#!/bin/bash
# Note - if you change that path to bash, then you should also change it in the configuration section below

VERSION="1.3.128 (2015-05-25)"

# (c) David Anderson 2011-
#
# http://wordshell.net / contact@wordshell.net
#
# Licence: http://wordshell.net/support/manual/wordshell-licence/
#
# Please do share your patches with me. I prefer then in "diff -uNr" format (please also specify the version against which you are patching).

# * * * BEGIN CONFIGURATION * * * #

# Looking for a command that outputs a file modification time (output should be an integer)
# This next one hopefully "just works" : if it does not on your system, then please tell us a) a working command and b) the output of /bin/uname on your system
# BSD/Mac OS X style
STAT_MODTIME="stat -f %m"
# GNU style
UNAME=`uname`
[[ $UNAME = "Linux" || $UNAME =~ ^Cygwin || $UNAME =~ ^CYGWIN ]] && STAT_MODTIME="stat -c %Y"

# If diff or patch is not in your path, then change these locations to find them.
DIFF="diff"
PATCH="patch"

# If lftp is not in your path, then change this to the location to find it. Only required if you are modifying sites via FTP.
LFTP="lftp"
# Note that by default lftp uses the command 'ssh -a -x' by default for accessing SFTP or fish sites. So if you wish to use SFTP or fish, you need to have a working ssh binary installed as well.

# Curl is presently used only (if there is no lftp) for basic GET/POST HTTP operations (e.g. downloading API information, getting zips); in a future version it may also handle (S)FTP operations; but for now it is simply an alternative to wget.
CURL="curl"
# Here, you can set any curl options you wish/need to set (note that some SSL options are set each time by the code). Will be over-ridden by configuration file option curl-ftp-options. (You can also specify options in a default curl configuration file - see the curl man page).
# --insecure means that SSL certificate checks need not pass; it is common to access FTP servers under a variety of host names, and many do not have certificates signed by signers known to curl.
CURL_FTPOPTIONS="--insecure"

# wget is only used for fetching API information and downloading zips if lftp and curl not found. This is only useful if you are not maintaining any sites via ftp (wget cannot upload via FTP)
WGET="wget"

# We use rsync for local copying
RSYNC="rsync"

# Unzip is used for unpacking new plugins/themes
UNZIP="unzip"
# Zip is used for packaging up old plugins/themes
ZIP="zip"

# Takes you to the website for manual downloading if requested
W3M="w3m"

# Alternatives to w3m if you did not have that available
ELINKS="elinks"
LYNX="lynx"

# used to edit the configuration files. No special vi features are needed; any text editor will do (e.g. emacs, joe, pico, nano)
VI="vi"

# used to unserialize, and to make MD5 checksums if nothing else was found
PHP="php"

# used as a scrolling pager
LESS="less"

# used for more reliable re-invoking self internally. This should match line 1.
BASH="/bin/bash"

# If you have multiple versions of date available, then point this to GNU date (coreutils) for slightly increased functionality
DATE="date"

# Finally, we find a binary that can do an MD5 checksum and return the results as the first output parameter
# WordShell will run through a list of possibilities (including your choice for PHP); the one specified here may not be used, but if nothing is found automatically then you can specify one here
MD5CHECKSUM_TRY="md5sum"

# Default configuration file. Will be created if it does not exist.
# Format is that each line is like so (or comments begin with #):
# site:site-name:access-method:directory:username:[password, optional]
# or:
# config:key:value
WORKDIR="$HOME/.wordshell"
CONFIGFILE="$WORKDIR/rc"

# Initial default number of threads for lftp to use when mirroring (some FTP servers will limit the maximum connections)
# Can be over-ridden in the configuration file (e.g. --setconfig=ftpparallel:24) and on the command-line (--ftpparallel=<num>)
FTPPARALLEL=9

# Globs to exclude from local synchronisation of plugins/themes
# Separate each addition glob with spaces. The default value is a plugin you may not use - but if you do, it can save you hundreds of megabytes.
# Can be over-ridden in the configuration file (e.g. --setconfig=exclude-glob-ftp:<value> and --setconfig=exclude-glob-rsync:value)
EXCLUDE_GLOB_FTP="wponlinebackup/tmp/*"
# Note that if you do not have rsync installed then this next line is totally ignored
EXCLUDE_GLOB_RSYNC="wponlinebackup/tmp/*"

# Where to fetch a wp-wordshell-controller.php script of sufficiently high protocol from
REMOTE_MANAGER_MINIMUM_PROTOCOL=19
REMOTE_MANAGER_FROM="https://wordshellnet.s3.amazonaws.com/wp-wordshell-controller.php.$REMOTE_MANAGER_MINIMUM_PROTOCOL"

SELINUX=0
[[ $UNAME = "Linux" ]] && selinuxenabled 2>/dev/null && SELINUX=1

# sed -i is not part of POSIX; an -i option is present on BSDs but works differently to GNU.
# Must provide the filename as $2
function ws_sed_i() {
	if [[ $UNAME = "Linux" || $UNAME =~ ^Cygwin || $UNAME =~ ^CYGWIN ]]; then
		sed -i "$@"
	elif [[ $UNAME = "FreeBSD" || $UNAME = "Darwin" ]]; then
		sed -i "" "$@"
	else
		local SED_TMP=`mktemp`
		sed "$@" >$SED_TMP
		cat $SED_TMP >"$2"
		rm -f $SED_TMP
	fi
}

# Now a function to recursively set directory ownership, recursively, based upon the owner of a specified file. Hopefully again this will "just work", but if not please let us know and send us the output of /bin/uname

function setownership() {
# Input: $1 = the reference file
# Input: $2 = the directory to set ownership upon
# Note - where you specify a directory finishing with /, this routine will not touch that directory itself (or dotfiles inside it)
if [[ $UNAME = "Linux" || $UNAME =~ ^Cygwin || $UNAME =~ ^CYGWIN ]]; then
	# GNU style
	if [[ $2 =~ \/$ ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "setownership: GNU: contents: $2"
		chown -R --reference="$1" "$2"/*
		if [[ $SELINUX -eq 1 ]]; then
			if [[ $DEBUG -ge 1 ]]; then
				ws_event_debug "setownership: SELinux chcon: contents: $2"
				chcon -R --reference="$1" "$2"/*
			else
				chcon -R --reference="$1" "$2"/* 2>/dev/null
			fi
		fi
	else
		[[ $DEBUG -ge 1 ]] && ws_event_debug "setownership: GNU: $2"
		chown -R --reference="$1" "$2"
		if [[ $SELINUX -eq 1 ]]; then
			if [[ $DEBUG -ge 1 ]]; then
				ws_event_debug "setownership: SELinux chcon: $2"
				chcon -R --reference="$1" "$2"
			else
				chcon -R --reference="$1" "$2" 2>/dev/null
			fi
		fi
	fi
else
	# Should work on some BSDs (including Mac OS X)
	local REFOWNER=`stat -f %u "$1"`
	local REFGROUP=`stat -f %g "$1"`
	if [[ $2 =~ \/$ ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "setownership: BSD: contents: $2"
		chown -R $REFOWNER:$REFGROUP "$2"/*
	else
		[[ $DEBUG -ge 1 ]] && ws_event_debug "setownership: BSD: $2"
		chown -R $REFOWNER:$REFGROUP "$2"
	fi
fi
}

# We want to know if date will accept the --date switch (GNU coreutils), or if we can use php to do the same; this unlocks functionality for parsing user-supplied dates
CAN_STRTOTIME=0; GNU_DATE=0
$DATE --version 2>/dev/null | grep -q GNU && GNU_DATE=1
[[ $GNU_DATE -eq 1 || -n $PHP ]] && CAN_STRTOTIME=1

function ws_strtotime() {
	if [[ $GNU_DATE -eq 1 ]]; then
		date --date="$1" +%s
	elif [[ -n $PHP ]]; then
		$PHP -r "print strtotime(\"$1\");"
	else
		echo "error";
	fi
}

# The follow function converts UNIX (epoch) times into the given format. The reason for its existence is because --date=@ is not part of POSIX.
# Input: $1 = epoch time, $2 = output format (accepted by the system's date binary)
function ws_date_from_epoch() {
	if [[ ${BASH_VERSINFO[0]} -ge 4 && ${BASH_VERSINFO[1]} -ge 2 ]]; then
		printf "%($2)T" "$1"
	elif [[ $GNU_DATE -eq 1 ]]; then
		date --date=@"$1" +"$2"
	else
		date -r "$1" +"$2"
	fi
}

# The following is optional; it aims to obtain terminal codes to turn on and off bold output
BOLD=""
OFFBOLD=""
TPUTTEST=`tput cols 2>/dev/null || echo 0`
TPUT_BOLD="bold"
TPUT_OFFBOLD="sgr0"
if [[ $UNAME = "FreeBSD" ]]; then
	TPUT_BOLD="md"
	TPUT_OFFBOLD="me"
fi
if [[ $TPUTTEST -gt 0 && -n $TERM && $TERM != "dumb" ]]; then
       BOLD=`tput $TPUT_BOLD`
       OFFBOLD=`tput $TPUT_OFFBOLD`
fi

# Default location of the WordPress content directory. Can be over-ridden with --contentdir= or a site option
DEFAULT_CONTENTDIR=wp-content

# * * * END CONFIGURATION * * * #

WORDSHELL_PID=$$
CONTENTDIR=$DEFAULT_CONTENTDIR

# The next function (only) is under the MIT licence
# http://blog.yjl.im/2012/01/printing-out-call-stack-in-bash.html
function ws_callstack() {
  local i=0
  local FRAMES=${#BASH_LINENO[@]}
  # FRAMES-2 skips main, the last one in arrays
  for ((i=FRAMES-2; i>=0; i--)); do
    echo '  File' \"${BASH_SOURCE[i+1]}\", line ${BASH_LINENO[i]}, in ${FUNCNAME[i+1]}
    # Grab the source code of the line
    sed -n "${BASH_LINENO[i]}{s/^/    /;p}" "${BASH_SOURCE[i+1]}"
  done
}

function ws_logger() {

	# Code everywhere calls into here (eventually) to log an event.
	# The task here is to decide what to do with it. This can be outputting on the screen, logging, syslog, etc.

	# If/when adding syslog, note that whilst POSIX specifies no parameters for logger, Linux/Net/Open/FreeBSD/Solaris/Mac all accept -i -p and -t

	# Input:
	# $1 = log level
	# $2 = log message

	# Screen printing: all ERROR and WARNING level messages; and everything when in debug mode
	if [[ ( $1 = "ERROR" || $1 = "WARNING" ) || $DEBUG -ge 1 ]]; then
		# Use bold only with ERROR/WARNING
		[[ ( $1 = "ERROR" || $1 = "WARNING" ) ]] && echo -n "${BOLD}" >/dev/stderr
		echo -n "$1: " >/dev/stderr
		[[ ( $1 = "ERROR" || $1 = "WARNING" ) ]] && echo -n "${OFFBOLD}" >/dev/stderr
		echo "$2" >/dev/stderr
	fi
	
	# File logging: all ERROR, WARNING and NOTICE messages
	if [[ $1 = "ERROR" || $1 = "WARNING" || $1 = "NOTICE" ]]; then
		# Log if the working directory path is now known, and if the log file location is not a symlink
		[[ -n $WORKINGDIR_FULL && ! -L $WORKINGDIR_FULL/log ]] && echo "`$DATE +'%Y-%b-%d %T'` [$WORDSHELL_PID] $1: $2" >> "$WORKINGDIR_FULL/log"
	fi

}

function ws_event_error() {
	# "Non-urgent failures, these should be relayed to developers or admins; each item must be resolved within a given time."
	ws_logger ERROR "$1"
}

function ws_event_warning() {
	# "Warning messages, not an error, but indication that an error will occur if action is not taken, e.g. file system 85% full - each item must be resolved within a given time."
	ws_logger WARNING "$1"
}

function ws_event_notice() {
	# "Events that are unusual but not error conditions - might be summarized in an email to developers or admins to spot potential problems - no immediate action required."
	ws_logger NOTICE "$1"
}

function ws_event_info() {
	# "Normal operational messages - may be harvested for reporting, measuring throughput, etc. - no action required."
	# If $2 is 1, then also echo to the screen
	[[ $2 = "1" ]] && echo "$1"
	ws_logger INFO "$1"
}

function ws_event_debug() {
	# "Info useful to developers for debugging the application, not useful during operations."
	ws_logger DEBUG "$1"
}

if [ "$1" = "--help" -o "$1" = "-?" -o "$1" = "-h" ]; then

echo "WordShell: www.wordshell.net (full manual and ticket system available online)

Tool for managing WordPress via the command line. Can operate on a WP install on the local filesystem or via FTP or SFTP. Various binaries are needed for full functionality; lftp in particular for FTP/SFTP; run with --checkrequirements for more information.

Usage: wordshell [<site-name>|all] [<plugin|theme|file|all>] (options)

Site names are aliases for sites whose fuller details are stored in the configuration file. If you enter an unknown site name, you will be requested for the site details and these will be added to the configuration file. You can specify multiple sites, separating them with commas.

If you enter the site name 'all', then all sites that are in the configuration file will be processed (e.g. wordshell all --listupdates).

If you enter the plugin/theme as 'all', then all the plugins/themes on the indicated site are processed (e.g. wordshell mysite all --update --latest)

Backups are taken and versions are compared. If there any potential problems spotted then user interaction is required.

${BOLD}Meta-mode selection:${OFFBOLD}
--plugin            :	Work on a plugin (this is the default mode, and does not need to be manually specified)
--theme             :	Work on a theme (e.g. wordshell mysite twentyten --delete --theme)
--content           :	Work with WordPress file content (including uploaded media). Can be used with --list, --refreshcache, --login and --restore. Most useful for site backup (--refreshcache) and restoration (--restore). If you use --list, then the second parameter to WordShell is a regex to match, e.g. 'wordshell mysite index.php --list'.
--core              :	Work on WordPress core. Not all operations make sense in core mode.
--everything | -e   :	Precisely equivalent to running each of the above in sequence. Again, this does not make sense with every combination of options. It is most useful with --list or --listupdates.
--pluginsandthemes  :	Precisely equivalent to running with --plugin and --theme in sequence. Again, this does not make sense with every combination of options. It is most useful with --list or --listupdates.
--user              :	User management (incomplete)

${BOLD}Modes for performing plugin/theme/core operations (mostly mutually exclusive - you can only choose one mode at once):${OFFBOLD}

--activate          :	Activate the specified plugin/theme (can be combined with install/update/rollback/restore)
--deactivate        :	Deactivate the specified plugin/theme (can be combined with update/rollback/restore; is automatically implied with --delete). These two switches are not applicable in core mode.
--changelog         :	Show the changelog for the indicated entity (requires w3m). If you also specify a site then after showing the changelog, move forward to the delete/install/rollback/update (otherwise stop).
--description       :	Show the description for the indicated entity (requires w3m). If you also specify a site then after showing the description, move forward to the delete/install/rollback/update (otherwise stop).
--lastupdated       :	Show the last upstream updated date for the indicated entity (plugins/themes from wordpress.org only)
--downloadurl       :	Show the download URL for the indicated entity. If you also specify a site then after showing the description, move forward to the delete/install/rollback/update (otherwise stop).
--checkmodifications:	Check entity for modifications compared with pristine version. This check happens automatically when updating; this switch is only for when you wish to do no other actions. If you wish to view the modifications, then specify --checkmodifications=view. Add showall to show status of all entities, whether modified or not (e.g. --checkmodifications=showall or --checkmodifications=showall,view). Note that when working with --core, only core WordPress files are checked; any additional files in your WP directory will be ignored (which includes wp-config.php).
--delete            :	Delete mode: does not ask for or upload new plugins/themes, simply deletes the files of the old one (WordPress will display an error next time you log in). Implies --deactivate unless you specify --skipdeactivate
--downloadonly      :	Download the specified entity from wordpress.org (into our internal cache, inside the working directory); do not update anything
--editconfig        :	Opens up the WordShell configuration in the configured text editor
--install           :	Install mode (uploads plugin; add --activate to also activate it)
--list              :	List installed plugins on the site. If you specify a plugin name, then this is used as an extended regex for matching; use --listexact to require an exact match. When the list is shown, a (-) next to the plugin name implies that the plugin could not be found at wordpress.org (hence either removed, or was third-party).
--login             :	Drops you into a shell or (S)FTP prompt in the site's WordPress installation root 
--rollback          :	Roll back to the most recently replaced version. If you optionally specify a time, then this will instead then automatically select the version of the plugin installed at that time, as far as we know. If you have GNU date (coreutils) installed, then any string supported by the 'date' command can be used here; e.g. --time='last Tuesday', --time='10 days ago', --time='24 Feb'. Otherwise, you must supply an epoch time. Use --listrollbacks to see what is available.
--restore           :	Restores the current copy of the indicated entities. This differs from --rollback in that it restores the believed-to-be-current version from our local cache/backup (rather than any previously replaced version). This implies --cache --cache (as otherwise, if the site has been damaged, we would first replicate that damage to the local cache) and then you'd need to head to your backups). In fact, we assume that your site is damaged, and drop all sanity checks related to the currently installed entity and the backup you are replacing it from. With an undamaged site and up-to-date cache, --restore should result in no real changes. When operating upon core, this will restore whatever you backed up (see --justwp). If you wish to restore the backup to a different location (i.e. not the site's regular home), then supply a parameter, e.g. --restore=/var/www/newlocation (accepts both file paths and FTP/SFTP URLs - specify the path for the WordPress base; do not include wp-content/plugins etc.).
--update            :	Upgrade mode (this is the default if no other mode is specified; you only need to specify it manually if combining with --activate (--activate without --update does not perform a plugin update)). --upgrade is a synonym.

${BOLD}Database operations (--database)${OFFBOLD}:

--searchandreplace=<search>^<replacement> :	Search and replace all WordPress tables in the database (which is defined as all those matching your \$table_prefix in wp-config.php). Uses the code under licence from the popular searchreplacedb2.php (http://interconnectit.com/products/search-and-replace-for-wordpress-databases/). Example: --searchandreplace=http://localhost/test^http://example.com
--tables=<list>    :	A list of tables for --searchandreplace to apply to. Tables should be supplied *without* prefixies and be comma-separated, e.g. --tables=options,usermeta,postmeta

${BOLD}User management operations (--user)${OFFBOLD}
--add              :	Adds a user. You must then supply the parameter --email=<address> and optionally --role=<role> (e.g. --role=admin)
--delete           :	Deletes the specified user (may be specified by username or by email address). Add the optional paramater --reassign=<username|email|@admin> to reassign all the user's posts/comments/etc. to a specified user, or to the first admin found (or leave out this parameter to just delete them).
--list             :	Lists existing users. Add --detailed for more details
--passwordreset    :	The specified user will have their password reset to a new, random password. In this case you can also specify the user by email address (e.g. wordshell mysite bob@example.com --passwordreset)

${BOLD}Modes for performing internal management/site management/checks (mutually exclusive - you can only choose one mode at once):${OFFBOLD}
--checkrequirements:	Checks that all possible helpers are available (lftp, rsync, diff, patch, unzip, vi, w3m), then exits
--entermaintenance :	Enter maintenance mode (add a parameter to specify a number of minutes, e.g. --entermaintenance=10; otherwise is indefinite)
--exitmaintenance  :	Leave maintenance mode
--waitmaintenance  :	Wait until the site is no longer in maintenance mode (but do not clear it ourselves)
--listsites        :	Show information on configured sites
--showpass         :	When used with --listsites, shows the passwords for (S)FTP sites
--maintenancestate :	Show maintenance mode status
--addsite          :	Configure a new site (equivalent to specifying 'new' as the site and listing (--list))
--delsite          :	Permanently remove a site from the configuration file (but do not touch the site itself)
--disablesite      :	Disable a site in the configuration file (but do not permanently remove it)
--definegroup      :	Define a group of sites: syntax is --definegroup=<groupname>:<list> See the section on specifying multiple sites below. The list can be any list of sites or groups as described there. Therefore, the way to add a site to a pre-existing group is, for example, --definegroup=mygroup:@mygroup,newsite; and the way to remove it is --definegroup=mygroup:@mygroup,-newsite. Group lists are evaluated immediately (i.e. the definition you gave is not stored, only the result).
--delgroup         :	Delete a defined group (not the sites themselves): syntax is --delgroup=<groupname>. This differs from --definegroup=<groupname>:-@groupname, which empties but does not delete the group.
--listgroups       :	List all defined groups in the configuration file, together with their members.
--enablesite       :	Enable a previously-disabled site in the configuration file.
--showlog          :	Show the WordPress log (the file 'log' from the configuration directory)
--visit            :	Launch the site in a web browser

The following are also valid with --database:

--refreshcache     :	Ensure freshness of our local cached copy of the site, then exit. You could use this to prime all the caches for quicker subsequent operation (e.g. in a cron job before your working day starts). If the cache was recently updated, then this is a no-op; to enforce an update, add --sync.
--listrollbacks    :	Show possible rollbacks for a given site (and plugin/theme, if indicated)
--deleterollbacks  :	Deletes all stored rollbacks older than 90 days, or the specified number (e.g. deleterollbacks=45)

${BOLD}Mode-specific options:${OFFBOLD}

${BOLD}Order of operations when working with multiple sites:${OFFBOLD}
--groupbytype      :	If you choose to operate on all sites together with --everything or --pluginsandthemes, then this will order the operations/output by type (i.e. do the plugins on all sites, then the themes, then the core), instead of the default (which is to do all the plugins, then themes, then core on a single site, then move on to the next site, etc.)

${BOLD}Core operations:${OFFBOLD}
--justwp           :	By default, when working with WordPress core, WordShell will ensure it has a backup of any files in your WordPress directory. This guarantees safety for disaster recovery (though note that current versions of WordShell only back up plugins and themes from your content directory (usually wp-content), and nothing else from in there). However, it can be slow. If you know that you either have nothing else stored there, or that it does not need backing up, then you can supply this swtich. Note that this will NOT delete existing non-WP files from the local mirror (i.e. backups made when --justwp was not used). For that, add --justwpwipeothers.
--justwpwipeothers :	This flag means the same as --justwp, except that back-ups of existing files that are not part of WordPress core will be deleted from the local mirror.
--filemethod       :	When upgrading to the latest WordPress version, by default WordShell will try to use WordPress's built-in updating procedures, running on the remote website. Use this switch to instead upgrade via the filesystem. The built-in method is faster; files are more reliable if your site is broken and sometimes the only option if your web host has a very restrictive set-up. If you are not upgrading to the latest version, then this switch is redundant, as it is the only available method.

${BOLD}Install and update modes:${OFFBOLD}
--latest           :	Synonym for --new=latest
--new=<file|version>:	Either specify a particular version that can be downloaded from wordpress.org (e.g. --new=1.3.2), or a version of an already-known plugin/theme, or specify a path to a zip file to use (e.g. --new=myfolder/myplugin.1.9.zip). Only valid when a particular plugin/theme is specified. If you enter 'latest' then the latest version available from wordpress.org will be downloaded.
--trunk            :	When looking for the latest version, look in the development trunk, not at stable released versions (only relevant for core and for themes/plugins from wordpress.org). This will always require downloading from the trunk, so brings some slow-down.
--nolint           :	Skip PHP linting (checking of the syntax of PHP files with the -l option to PHP)

${BOLD}Update mode:${OFFBOLD}
--donotrequirenew  :	Do not abort the update if the chosen new plugin/theme's version number is not newer than that currently installed (manual confirmation will still be required)
--autopatch        :	If the installed and plain versions differ, then automatically attempt to patch the new version appropriately (without asking first).
--ignorenamechange :	Usually WordShell asks for user confirmation if the plugin's name has changed. This switch will skip the request.
--ignoremodifications:	Skip the step of checking for plugin modifications

${BOLD}Delete, install, update, rollback and deleterollbacks modes:${OFFBOLD}
--confirm          :	Ask an extra \"are you sure?\" question before going forward; this is useful if you want to use --changelog or --showchanges and perhaps back out if you do not like what you see.
--dryrun | -n      :	Skip the step of installing/deleting/updating/rolling back/(de)activating; only notify what would have been done
--thisoneonly      :	If the specified plugin/theme does not exist, then do not present a menu of existing plugins/themes; just finish
--skipdeactivate   :	In delete mode, skip the deactivation step

${BOLD}Update, rollback and restore modes:${OFFBOLD}
--showchanges       :	Show changes from the installed plugin/theme to the indicated version. If you want to be asked to confirm the update after seeing the changes, use --confirm.
--noconfirmpristine:	Skip requesting confirmation when no pristine zip was found to compare an installed version with

${BOLD}List mode:${OFFBOLD}
--listonlythirdparty:	List only plugins/themes which were not found at wordpress.org (hence either removed, or obtained from elsewhere) (implies --list)
--listonlyupdates  :	List only installed plugins/themes for which an update is known to be available (implies --list)
--warnmissing      :	Prints a warning if no plugin/theme was found
--listexact        :	Turns off regex matching when listing - only list plugins that match the name exactly

${BOLD}List, update, restore and delete modes:${OFFBOLD}
--active           :	Operate on plugins/themes only if they are active
--inactive         :	Operate on plugins/themes only if they are inactive
--currentversion=<ver>:	Operate on entities only if the installed version matches this one. You can use --cver= as a shorter alias. This switch is also available in rollback mode. Prefix the version with x to negate the test, e.g. --cver=x3.3 means \"not version 3.3\".
--fast             :	Decide which sites to work on based upon WordShell's internal cache of sites (the effect of this option is to cut out the sync-ing of all sites, if you have chosen to work upon all sites)

${BOLD}Activate and deactivate modes:${OFFBOLD}
--network          :	When used with --activate on a WP multisite installation, performs \"network activation\" of the plugin (see http://codex.wordpress.org/Multisite_Network_Administration#Plugins)
--blog=<blog>      :	On a WP multisite installation, operates upon the specified blog instead of upon the default blog.

${BOLD}Verbosity and logging options:${OFFBOLD}
--debug | -d       :	Print lots of internal information. Specify twice or thrice for even more verbosity.
--showdiskspace    :	Show disk usage message at the end (only valid for update/install/rollback/restore)
--novaliditywarnings:	Do not show warnings about plugin/theme sub-directories in which a plugin/theme could not be detected

${BOLD}General options:${OFFBOLD}
--workdir=<dir>    :	Working directory to use (internal data is stored here)
--contentdir=<path>:	Relative path to the installation's content directory. Defaults to: wp-content. If you have a site on which the content directory is elsewhere, then you will want to specify this as a site option.

${BOLD}Debugging options:${OFFBOLD}
--debug            :	Print lots of internal information. Specify twice for even more verbosity.
--disablecache     :	Disables relying on state of local caches (e.g. of WordPress API calls). Implies --sync.
--disableapi       :	Do not use WordPress's API (http://api.wordpress.org) for any operations. This is mainly useful for debugging.
--disableremotecli :	Miss out some (not guaranteed to be all) remote CLI calls
--disableftptls    :	For FTP sites, explicitly disables use of encryption (lftp option: ftp:ssl-allow no)
--requireftptls    :	For FTP sites, explicitly requires use of encryption (lftp option: ftp:ssl-force yes)
--ftpparallel=<num>:	Maximum number of parallel FTP connections to use (lftp switch: --mirror=)
--sync             :	For (S)FTP sites, force initial sync of plugins/themes directory (i.e. do not skip sync if it had been synced recently). Use this if you know your local cache is out of date (e.g. a manual change was recently made at the remote side). See also --refreshcache.
--cache            :	For (S)FTP sites, force skipping initial sync of plugins/themes directory; use with caution. If specified twice, then does so also for filesystem mode sites.
--lftpdryrun       :	Specify --dry-run when doing an LFTP mirror operation.
--no(lftp|wget|curl|w3m|elinks|rsync):	Behave as if the indicated binary does not exist on the system
--nosslverify      :	Do not verify SSL certificates
--nositetest       :	Do not check on whether the site is reachable without an HTTP error before/after installing/upgrading etc.
--phpinfo          :	Get the phpinfo() output from the remote side
--phpversion       :	Get the phpversion() output from the remote side
--mysqlversion     :	Get the MySQL server version (mysql_get_server_info()) output from the remote side
--skipmakerollback :	When deleting or updating, skip the creation of a rollback file (actually just skips some time-consuming step)
--testurl          :	Tests to see if a WordPress site exists
--remotecli        :	Drops into a CLI that allows you to run internal commands against the remote site. This mode is not officially supported; it is an internal interface which is not guaranteed between versions. Use --remotecli=<command> to run command non-interactively (can specify multiple times).
--workdir          :	Working directory to use (internal data is stored here)

${BOLD}Configuration management:${OFFBOLD}
--setconfig        :	Set global configuration parameters, e.g. --setconfig=key:value. To set multiple parameters, separate with a comma, e.g. --setconfig=key1:value1,key2:value2
--getconfig        :	Read global configuration parameters, e.g. --getconfig=key1,key2,key3. Leave blank to show all.

There are also per-site configuration options; these are configured in the configuration file using a key of 'siteopt', followed by the site name, followed by the option (only one per line).

${BOLD}Global variables that can be configured:${OFFBOLD}
ftpparallel        :	Default number of threads for lftp to use (lower this if you consistently find sites rejecting your connections for having too many at once). Can be over-ridden on a per-site basis if you add a per-site option in the configuration file.
postfilecommand    :	A command that is run after newly installing plugins/themes in the filesystem, after selecting the new plugin/theme directory. e.g. \"chmod 700 .\" Do not use to perform a chown operation - that is already done automatically.
exclude-glob-ftp   :	A glob to match for files that should never be synced locally (e.g. if some plugin/theme stores an enormous amount of useless temporary data). Specify in a form compatible with lftp's --exclude-glob option and separate multiple globs with spaces.
exclude-glob-rsync :	A glob to match for files that should never be synced locally (e.g. if some plugin/theme stores an enormous amount of useless temporary data). Specify in a form compatible with rsync's --exclude option and separate multiple globs with spaces.. If rsync is not installed, then this option has no effect (and thus such files will be synced).
curl-ftp-options   :	Command line options to add when curl is called for an FTP operation. Read the curl ftp man page for more information. Useful if you have some exotic authentication scheme. (To set lftp over-ride options, edit the file lftp/rc in your WordShell working directory).

${BOLD}Specifying multiple sites${OFFBOLD}
WordShell allows you to specify one site, a list of sites, or to pre-define groups of sites (see the --definegroup, --delgroup and --listgroups options). You can specify arbitrarily long lists, and include or exclude individual sites or groups at will. Lists are separated with commas. Groups are indicated by prefixing a @, and exclusions (whether of an individual site or group) are indicated with a prefixed minus sign. Lists are parsed from left to right, and a site is finally included if and only if was included at some point and not subsequently excluded. Disabled sites are also excluded, except if the chosen mode was --listsites or --enablesite. Group names must be alphanumerics only. You can always test out the effect of any list by using --listsites.

Example:
wordshell mysite,@mygroup,-site2,-@group2,site3 --listsites

The above command would include the site mysite, then the sites in group mygroup, then remove site2 and all sites in group2, and finally add in site3.

The default working directory is $WORKDIR and the default configuration file is $CONFIGFILE.
"
exit 0;
fi

MODE="normal"

ORIGINAL_PARAMS="$@"
ORIGINAL_PARAMS_COUNT=${#@}

if [[ $ORIGINAL_PARAMS_COUNT -eq 0 ]]; then
	MODE="addsite"
	PLUGIN=""
elif [[ ${1:0:1} != "-" ]]; then
	SITE=$1
	if [ -n "$SITE" ]; then
		shift
		if [ "${1:0:1}" != "-" ]; then
			PLUGIN=$1
			[[ -n $PLUGIN ]] && shift
		fi
	fi
fi

function abort_die() {
	local ERR_CODE=$1
	echo -n "${BOLD}ABORT:${OFFBOLD} " >/dev/stderr
	ws_event_error "$2"
	ws_event_debug "WordShell internal abort code: $ERR_CODE"
	exit $ERR_CODE
}

function options_abort() {
	abort_die 40 "$1"
}

function mode_switch() {
	if [ "$MODE" = "normal" ]; then
		MODE=$1
	elif [ "$MODE" != "$1" ]; then
		# Don't whinge if they just specified the same thing twice
		options_abort "Incompatible options; cannot specify both --$MODE and --$1"
	fi
}

function metamode_switch() {
	if [[ $METAMODE = "plugin-default" ]]; then
		METAMODE=$1
		METAMODE_DIR=${1}s
		if [[ $1 = "core" ]]; then
			METAMODE_DIR="core"
			# We use this flag to work out, when changing core, if the zip we've been given is a full one or simply a collection of changes
			CHOSEN_CORE_IS_OVERLAY=0
		elif [[ $1 = "content" || $1 = "database" ]]; then
			METAMODE_DIR=$1
		fi
	elif [[ $METAMODE != $1 ]]; then
		options_abort "Incompatible options; cannot specify both --$METAMODE and --$1"
	fi
	# Bash 3.2 does not have ^ substitutions
	METAMODE_CAP=`echo -n ${METAMODE:0:1} | tr '[:lower:]' '[:upper:]'; echo ${METAMODE:1}`
}

METAMODE="plugin-default"
METAMODE_CAP="Plugin"
METAMODE_DIR="plugins"
DEBUG=0
CACHE=0
DISABLECACHE=0
SYNC=0
DISABLEAPI=0
SHOWDISKSPACE=0
USEZIP=""
THISONEONLY=0
REQUIRENEWVERSION=1
CHECKREQUIREMENTS=0
LISTEXACT=0
VALIDITYWARNINGS=1
WARNMISSING=0
LISTONLYUPDATES=0
ONLYACTIVE=0
ONLYINACTIVE=0
IREALLYMEANIT=0
LISTONLYTHIRDPARTY=0
DRYRUN=0
DETAILED=0
SHOWCHANGELOG=0
SHOWDESCRIPTION=0
SHOWLASTUPDATED=0
SHOWDOWNLOADURL=0
SHOWCHANGES=0
AUTOPATCH=0
DEACTIVATE=0
SKIPDEACTIVATE=0
ACTIVATE=0
GROUPBYTYPE=0
GETCONFIG=""
JUSTWP=0
JUSTWPWIPEOTHERS=0
SHOWPASS=0
SETCONFIG=""
TESTURL=0
DISABLEFTPTLS=0
REQUIREFTPTLS=0
ROLLBACKTIME="x"
# By default, maintenance mode is indefinite
unset MAINTENANCE_MINUTES
DELETEROLLBACKDAYS=90
CHECKMODIFICATIONS_VIEW=0
CHECKMODIFICATIONS_SHOWALL=1
GETCONFIRM=0
USETRUNK=0
REMOTECLI_NONINTERACTIVE=()
# An internal switch that is merely used to prevent unnecessary duplicate operations (e.g. clearing up tmp)
SELFINVOCATION=0
FILEMETHOD=0
SKIPMAKEROLLBACK=0
LFTPDRYRUN=0
CURRENTVERSION=""
DISABLEREMOTECLI=0
DISABLESITEMODE="disable"
DOSITETEST=1
IGNORENAMECHANGE=0
CONFIRM_WHEN_NO_PRISTINE=1
RESTOREPATH=""
POSTS_REASSIGN=""
PLUGIN_MODE_EXPLICIT=0
GROUP_DEFINES=""
GROUP_DELETES=""
REMOTE_PHPVERSION=""
REMOTE_WPVERSION=""
USER_EMAIL=""
USER_ROLE=""
FAST=0
PHPLINT=1
ALREADY_LINTED=0
NETWORK_PLUGIN=0
NETWORK_BLOGID=-1
TABLELIST=""
SSLVERIFY=1
IGNOREMODIFICATIONS=0

function parse_option() {
	# Input: $1: option to parse
	local i=$1
	# Put this in a variable for bash 3.2 compatibility
	local SEARCHREPLACEREGEX="^--searchandreplace=(.*)\^(.*)$"
	if [[ $i = "--debug" || $i = "-d" ]]; then DEBUG=$((DEBUG+1))
	elif [[ $i = "--everything" || $i = "-e" ]]; then metamode_switch everything
	elif [[ $i = "--dryrun" || $i = "--dry-run" || $i = "-n" ]]; then DRYRUN=1
	elif [[ $i =~ ^-([a-zA-Z].*$) ]]; then options_abort "Unknown option: $i: Note that WordShell options generally use double-dashes (--). Perhaps you meant --${BASH_REMATCH[1]} instead."
	elif [ "$i" = "--plugin" ]; then metamode_switch plugin; PLUGIN_MODE_EXPLICIT=1
	elif [ "$i" = "--theme" ]; then metamode_switch theme
	elif [ "$i" = "--core" ]; then metamode_switch core
	elif [[ $i = "--database" || $i = "--db" ]]; then metamode_switch database
	elif [[ $i = "--pluginsandthemes" ]]; then metamode_switch pluginsandthemes
	elif [[ $i = "--user" ]]; then metamode_switch user
	elif [[ $i = "--content" ]]; then metamode_switch content
	elif [ "$i" = "--cache" ]; then CACHE=$((CACHE+1))
	elif [ "$i" = "--sync" ]; then SYNC=1
	elif [ "$i" = "--deactivate" ]; then DEACTIVATE=1
	elif [ "$i" = "--activate" ]; then ACTIVATE=1
	elif [ "$i" = "--active" ]; then ONLYACTIVE=1
	elif [ "$i" = "--fast" ]; then FAST=1
	elif [ "$i" = "--inactive" ]; then ONLYINACTIVE=1
	elif [ "$i" = "--version" ]; then echo $VERSION; exit
	elif [ "$i" = "--changelog" ]; then SHOWCHANGELOG=1
	elif [ "$i" = "--description" ]; then SHOWDESCRIPTION=1
	elif [ "$i" = "--lastupdated" ]; then SHOWLASTUPDATED=1
	elif [ "$i" = "--downloadurl" ]; then SHOWDOWNLOADURL=1
	elif [ "$i" = "--checkmodifications" -o "$i" = "--checkmod" ]; then mode_switch "checkmodifications"; CHECKMODIFICATIONS_SHOWALL=0
	elif [ "$i" = "--checkmodifications=view" -o "$i" = "--checkmod=view" ]; then mode_switch "checkmodifications"; CHECKMODIFICATIONS_VIEW=1; CHECKMODIFICATIONS_SHOWALL=0
	elif [ "$i" = "--checkmodifications=showall" -o "$i" = "--checkmod=showall" ]; then mode_switch "checkmodifications";
	elif [ "$i" = "--checkmodifications=view,showall" -o "$i" = "--checkmod=view,showall" -o "$i" = "--checkmodifications=showall,view" -o "$i" = "--checkmod=showall,view" ]; then mode_switch "checkmodifications"; CHECKMODIFICATIONS_VIEW=1;
	elif [ "$i" = "--showchanges" ]; then SHOWCHANGES=1
	elif [ "$i" = "--getconfig" ]; then GETCONFIG="all"
	elif [ "$i" = "--addsite" ]; then mode_switch "addsite";
	elif [ "$i" = "--enablesite" ]; then mode_switch "enablesite";
	elif [[ $i = "--add" ]]; then mode_switch "add"
	elif [[ $i =~ ^--entermaintenance=([0-9]+)$ ]]; then mode_switch "entermaintenance"; MAINTENANCE_MINUTES=${BASH_REMATCH[1]}
	elif [[ $i =~ ^--ftpparallel=([0-9]+)$ ]]; then FTPPARALLEL=${BASH_REMATCH[1]}
	elif [ "$i" = "--checkrequirements" ]; then CHECKREQUIREMENTS=1
	elif [ "$i" = "--install" ]; then mode_switch "install"
	elif [ "$i" = "--ireallymeanit" ]; then IREALLYMEANIT=1
	elif [ "$i" = "--thisoneonly" ]; then THISONEONLY=1
	elif [ "$i" = "--autopatch" ]; then AUTOPATCH=1
	elif [ "$i" = "--detailed" ]; then DETAILED=1
	elif [ "$i" = "--selfinvoked" ]; then SELFINVOCATION=1
	elif [ "$i" = "--selfinvoked=e" ]; then SELFINVOCATION=2
	elif [ "$i" = "--confirm" ]; then GETCONFIRM=1
	elif [ "$i" = "--nosslverify" ]; then SSLVERIFY=0
	elif [ "$i" = "--list" ]; then mode_switch "list"
	elif [ "$i" = "--listrollbacks" ]; then mode_switch "listrollbacks"
	elif [ "$i" = "--listsites" ]; then mode_switch "listsites"
	elif [ "$i" = "--showpass" ]; then SHOWPASS=1
	elif [ "$i" = "--rollback" ]; then mode_switch "rollback"; ROLLBACKTIME="most recent"; REQUIRENEWVERSION=0
	elif [ "${i:0:11}" = "--rollback=" ]; then mode_switch "rollback"; ROLLBACKTIME=${i:11}; REQUIRENEWVERSION=0
	elif [ "$i" = "--restore" ]; then mode_switch "restore"; CACHE=2;
	elif [ "${i:0:10}" = "--restore=" ]; then mode_switch "restore"; RESTOREPATH=${i:10}; CACHE=2; [[ $RESTOREPATH =~ ^/ || $RESTOREPATH =~ ^s?ftps?: ]] || options_abort "Restoration paths need to be absolute, not relative (i.e. must begin with /); you may want --restore=`pwd`/$RESTOREPATH"
	elif [ "$i" = "--listexact" ]; then LISTEXACT=1
	elif [ "$i" = "--listonlyupdates" -o "$i" = "--listupdates" -o "$i" = "--listupdatesonly" ]; then mode_switch "list"; LISTONLYUPDATES=1
	elif [ "$i" = "--listonlythirdparty" -o "$i" = "--listthirdpartyonly" ]; then mode_switch "list"; LISTONLYTHIRDPARTY=1
	# We switch back into normal mode later; this is just so that we know it was explicitly specified on the command line
	elif [[ $i = "--update" || $i = "--upgrade" ]]; then mode_switch "update"
	elif [ "$i" = "--login" ]; then mode_switch "login"
	# We do these instantly to allow multiple options
	elif [[ $i =~ ^--def(ine)?group=([A-Za-z0-9]+):(.*)$ ]]; then GROUP_DEFINES="$GROUP_DEFINES ${BASH_REMATCH[2]}:${BASH_REMATCH[3]}"
	elif [[ $i =~ ^--del(ete)?group=([A-Za-z0-9]+)$ ]]; then GROUP_DELETES="$GROUP_DELETES ${BASH_REMATCH[2]}"
	elif [ "$i" = "--entermaintenance" ]; then mode_switch "entermaintenance";
	elif [ "$i" = "--waitmaintenance" ]; then mode_switch "waitmaintenance";
	elif [ "$i" = "--exitmaintenance" ]; then mode_switch "exitmaintenance";
	elif [ "$i" = "--maintenancestate" ]; then mode_switch "maintenancestate";
	elif [[ $i =~ $SEARCHREPLACEREGEX ]]; then mode_switch "searchandreplace"; SEARCHANDREPLACE_SEARCH=${BASH_REMATCH[1]}; SEARCHANDREPLACE_REPLACE=${BASH_REMATCH[2]}
	elif [ "$i" = "--downloadonly" ]; then mode_switch "downloadonly";
	elif [ "$i" = "--deleterollbacks" ]; then mode_switch "deleterollbacks";
	elif [[ $i =~ "^--deleterollbacks=([0-9]+)$" ]]; then mode_switch "deleterollbacks"; DELETEROLLBACKDAYS=${BASH_REMATCH[1]};
	elif [[ $i =~ ^--email=(.*)$ ]]; then USER_EMAIL=${BASH_REMATCH[1]};
	elif [[ $i =~ ^--reassign=(.*)$ ]]; then POSTS_REASSIGN=${BASH_REMATCH[1]};
	elif [[ $i =~ ^--role=(.*)$ ]]; then USER_ROLE=${BASH_REMATCH[1]};
	elif [ "$i" = "--listgroups" ]; then mode_switch "listgroups"
	elif [ "$i" = "--novaliditywarnings" ]; then VALIDITYWARNINGS=0
	elif [[ $i = "--delete" || $i = "--del" ]]; then mode_switch "delete"
	elif [ "$i" = "--showdiskspace" ]; then SHOWDISKSPACE=1
	elif [ "$i" = "--passwordreset" ]; then mode_switch "passwordreset"
	elif [ "$i" = "--nocountdiskspace" ]; then SHOWDISKSPACE=0
	elif [ "$i" = "--donotrequirenew" ]; then REQUIRENEWVERSION=0
	elif [ "$i" = "--phpinfo" ]; then mode_switch "phpinfo"
	elif [ "$i" = "--phpversion" ]; then mode_switch "phpversion"
	elif [ "$i" = "--mysqlversion" ]; then mode_switch "mysqlversion"
	elif [ "$i" = "--remotecli" ]; then mode_switch "remotecli"
	elif [ "${i:0:12}" = "--remotecli=" ]; then mode_switch "remotecli"; REMOTECLI_NONINTERACTIVE+=("${i:12}")
	elif [ "$i" = "--trunk" ]; then USETRUNK=1
	elif [ "$i" = "--justwp" ]; then JUSTWP=1
	elif [ "$i" = "--justwpwipeothers" ]; then JUSTWP=1; JUSTWPWIPEOTHERS=1
	elif [ "$i" = "--testurl" ]; then TESTURL=1
	elif [ "$i" = "--refreshcache" ]; then mode_switch "refreshcache"
	elif [ "$i" = "--warnmissing" ]; then WARNMISSING=1
	elif [ "$i" = "--groupbytype" ]; then GROUPBYTYPE=1
	elif [ "$i" = "--filemethod" ]; then FILEMETHOD=1
	elif [ "$i" = "--visit" ]; then mode_switch "visit"
	elif [ "$i" = "--network" ]; then NETWORK_PLUGIN=1
	elif [ "$i" = "--noconfirmpristine" ]; then CONFIRM_WHEN_NO_PRISTINE=0
	elif [ "$i" = "--nolint" ]; then PHPLINT=0
	elif [ "$i" = "--skipmakerollback" ]; then SKIPMAKEROLLBACK=1
	elif [ "$i" = "--disableftptls" ]; then DISABLEFTPTLS=1
	elif [ "$i" = "--requireftptls" ]; then REQUIREFTPTLS=1
	elif [ "${i:0:7}" = "--blog=" ]; then NETWORK_BLOGID=${i:7}
	elif [ "${i:0:17}" = "--currentversion=" ]; then CURRENTVERSION=${i:17}
	elif [ "${i:0:7}" = "--cver=" ]; then CURRENTVERSION=${i:7}
	elif [ "${i:0:13}" = "--contentdir=" ]; then CONTENTDIR=${i:13}
	elif [ "${i:0:12}" = "--getconfig=" ]; then GETCONFIG=${i:12}
	elif [ "${i:0:12}" = "--setconfig=" ]; then SETCONFIG=${i:12}
	elif [ "${i:0:9}" = "--tables=" ]; then TABLELIST=${i:9}
	elif [ "$i" = "--disableremotecli" ]; then DISABLEREMOTECLI=1
	elif [ "$i" = "--disableapi" ]; then DISABLEAPI=1
	elif [ "$i" = "--disablecache" ]; then DISABLECACHE=1; SYNC=1
	elif [ "$i" = "--disablesite" ]; then mode_switch "disablesite"
	elif [ "$i" = "--delsite" -o "$i" = "--deletesite" ]; then mode_switch "disablesite"; DISABLESITEMODE="delete"
	elif [ "${i:0:9}" = "--config=" ]; then CONFIGFILE=${i:9}
	elif [ "${i:0:6}" = "--new=" ]; then if [ -n "$USEZIP" ]; then options_abort "--new has been specified twice (remember that --latest is a synonym for --new=latest)"; else USEZIP=${i:6}; fi
	elif [ "$i" = "--latest" ]; then if [ -n "$USEZIP" ]; then options_abort "--new has been specified twice (remember that --latest is a synonym for --new=latest)"; else USEZIP="latest"; fi
	elif [ "$i" = "--verbose" ]; then options_abort "There is no option --verbose; did you want --debug?"
	elif [ "${i:0:10}" = "--workdir=" ]; then WORKDIR=${i:10}
	elif [[ $i = "--editconfig" || $i = "--editrc" ]]; then mode_switch editconfig
	elif [ "$i" = "--showlog" ]; then mode_switch showlog
	elif [ "$i" = "--noelinks" ]; then ELINKS="false"
	elif [ "$i" = "--nolynx" ]; then LYNX="false"
	elif [ "$i" = "--now3m" ]; then W3M="false"
	elif [ "$i" = "--nocurl" ]; then CURL="false"
	elif [ "$i" = "--nolftp" ]; then LFTP="false"
	elif [ "$i" = "--norsync" ]; then RSYNC="false"
	elif [ "$i" = "--nowget" ]; then WGET="false"
	elif [ "$i" = "--nositetest" ]; then DOSITETEST=0
	elif [[ $i = "--ignorenamechange" ]]; then IGNORENAMECHANGE=1
	elif [[ $i = "--ignoremodifications" ]]; then IGNOREMODIFICATIONS=1
	elif [ "$i" = "--lftpdryrun" ]; then LFTPDRYRUN=1
	elif [ -n "$i" ]; then options_abort "Unknown option: $i"
	#else echo "???: $i"
	fi
}

for i in "$@"; do
	parse_option "$i"
done

[[ $METAMODE = "plugin-default" ]] && METAMODE="plugin"

[[ $DEBUG -ge 1 ]] && ws_event_info "Configuration file in use: $CONFIGFILE ; working directory: $WORKDIR"

# 0 means nothing missing; 1 means something missing; 2 means something missing that will affect functionality
CHECKREQ_RESULTS=0

[[ $DISABLEAPI -eq 1 && $DEBUG -ge 1 ]] && ws_event_debug "Was run with --disableapi; will do best-effort"

function set_debug_level() {
	# Input: $1 = debugging level
	DEBUG=$1
	LFTPVERB=""
	WGETVERB=""
	LFTPDEBUG=""
	CURLVERB="--silent"
	if [ $DEBUG -eq 1 ]; then
		CURLVERB="-#"
	elif [ $DEBUG -eq 2 ]; then
		WGETVERB="--server-response"
		LFTPVERB="-v"
		LFTPDEBUG="-d"
		CURLVERB="--verbose"
	elif [ $DEBUG -ge 3 ]; then
		LFTPVERB="-v"
		LFTPDEBUG="-d"
		WGETVERB="--server-response --debug"
		CURLVERB="--trace-ascii /dev/stderr"
	elif [ $DEBUG -eq 0 ]; then
		WGETVERB="-q"
	fi
	if [[ $SSLVERIFY -eq 0 ]]; then
		$CURLVERB="$CURLVERB --insecure"
		$WGETVERB="$WGETVERB --no-check-certificate"
	fi
}

# Initialise values
set_debug_level $DEBUG

# Avoid unpleasant surprises
[[ -z $WORKDIR || $WORKDIR = "/" || $WORKDIR = "//" ]] && abort_die 6 "Working directory must not be empty or /"

# Check that the working directory is not an already-existing non-directory
# We need to do this surprisingly early, as we will soon need lftp to be invoked using our configuration file
[[ -e $WORKDIR && ! -d $WORKDIR ]] && abort_die 24 "Given working directory ($WORKDIR) exists but is not a directory"

# Offer to create working directory if it does not exist
if [ ! -d "$WORKDIR" ]; then
	read -p "Given working directory ($WORKDIR) does not exist. This is normal if this is your first run and you should accept the option to create it now. Create? (y to create, other to abort): " -n 1 CWORKDIR
	echo
	if [[ $CWORKDIR = "y" || $CWORKDIR = "Y" ]]; then
		mkdir -p "$WORKDIR" || abort_die 45 "Could not successfully create directory"
	else
		abort_die 25 "User chose to abort"
	fi
fi

# These functions allow us to follow the flow more easily when debugging
function ws_cd() {
	[[ $DEBUG -ge 1 ]] && ws_event_debug "ws_cd: (`caller`): $1"
	cd "$1" || abort_die 71 "Failed to cd ($1), pwd=`pwd`, caller=`caller`"
}

function ws_pushd() {
	if [[ $DEBUG -ge 1 ]]; then
		ws_event_debug "ws_pushd: (`caller`): (pwd: `pwd`)"
		pushd "$1" >/dev/stderr || abort_die 71 "Failed to pushd ($1), pwd=`pwd`"
	else
		pushd "$1" >/dev/null || abort_die 71 "Failed to pushd ($1), pwd=`pwd`"
	fi
}

function ws_popd() {
	if [[ $DEBUG -ge 1 ]]; then
		ws_event_debug "ws_popd: (`caller`): (pwd: `pwd`)"
		popd >/dev/stderr || abort_die 71 "Failed to popd"
	else
		popd >/dev/null || abort_die 71 "Failed to popd"
	fi
}

# Normalise the location of the configuration file, and make absolute (so it can be accessed from any part of the code)
ws_pushd `dirname "$CONFIGFILE"`
CONFIGFILE=`pwd -P`/`basename "$CONFIGFILE"`
ws_popd

if [ ! -f "$CONFIGFILE" ]; then
	read -p "Given configuration file ($CONFIGFILE) does not exist. This is normal if this is your first run and you should accept the option to create it now. Create? (y to create, other to abort): " -n 1 CCONFIG
	echo
	if [[ $CCONFIG = "y" || $CCONFIG = "Y" ]]; then
		touch $CONFIGFILE || abort_die 45 "$CONFIGFILE: Could not successfully create file"
	else
		abort_die 25 "User chose to abort"
	fi
fi

# Enter working directory. All cds after this are relative, thus allowing the user to supply a relative path.
ORIGDIR=`pwd -P` || exit 71
ws_cd "$WORKDIR" || abort_die 26 "Could not enter working directory ($WORKDIR)"
WORKINGDIR_FULL=`pwd`

function show_more_less() {
	local DIFFTMP=$1
	local DIFFLINES=`(wc -l $DIFFTMP || echo 0) | awk '{print $1}'`
	if [[ -n $LESS && $DIFFLINES -ge 20 ]]; then
		$LESS "$DIFFTMP"
	else
		more "$DIFFTMP"
	fi
}

if [[ $MODE = "showlog" ]]; then
	if [[ -f log ]]; then
		show_more_less log
	else
		echo "No log file found - apparently nothing has yet been logged"
	fi
	exit
fi

# Check for presence of diff/patch; don't complain yet as they may not be needed
$DIFF -v >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working diff not found (looked for: $DIFF; path is: $PATH)"
	unset DIFF
	CHECKREQ_RESULTS=2
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working diff was found"
fi

$PATCH -v >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working patch not found (looked for: $PATCH; path is: $PATH) - will not be able to copy modifications (if any) you have made"
	unset PATCH
	CHECKREQ_RESULTS=2
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working patch was found"
fi
PATCHOPT="--quiet"
[[ $DEBUG -eq 1 ]] && PATCHOPT=""
[[ $DEBUG -ge 3 ]] && PATCHOPT="--verbose"

$PHP -v >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working php not found (looked for: $PHP; path is: $PATH) - will not be able to speak with api.wordpress.org and will have to make some guesses"
	unset PHP
	CHECKREQ_RESULTS=2
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working php was found"
fi

$LESS --version 2>/dev/null >/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working less not found (looked for: $LESS; path is: $PATH) - will instead use 'more' as a pager"
	unset LESS
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working less was found"
fi

$VI --version >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working vi not found (looked for: $VI; path is: $PATH) - needed for manual editing of the configuration file (rare)"
	unset VI
	[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=1
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working vi was found"
fi

if [[ $MODE = "editconfig" ]]; then
	if [[ -n $VI ]]; then
		$VI "$CONFIGFILE"
		exit
	else
		abort_die 82 "No working vi found; needed to edit the configuration file. Run with --checkrequirements for more information."
	fi
fi

export LFTP_HOME=$WORKINGDIR_FULL/lftp

# Do we have lftp?
$LFTP -v >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working lftp not found (looked for: $LFTP; path is: $PATH) - will require curl to operate on sites via ftp/sftp (though lftp is faster + recommended); will require wget or curl in order to access api.wordpress.org and avoid making guesses"
	unset LFTP
	CHECKREQ_RESULTS=1
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working lftp was found"
	# First try with quotes, then try without
	LFTP_WILL_USE_SSH=`$LFTP -c 'set -a' | grep "^set sftp:connect-program"`
	if [[ $LFTP_WILL_USE_SSH =~ \" ]]; then
		LFTP_WILL_USE_SSH=`echo $LFTP_WILL_USE_SSH | cut -d \" -f2 | cut -d" " -f1`
	else
		LFTP_WILL_USE_SSH=`echo $LFTP_WILL_USE_SSH | cut -d" " -f3`
	fi
	# Only run the test if our attempt to read the configuration worked
	if [[ -n $LFTP_WILL_USE_SSH ]]; then
		$LFTP_WILL_USE_SSH -V >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_warning "lftp is configured to use the following binary for SFTP sites: $LFTP_WILL_USE_SSH. However, when we tried to run that binary the operation failed; hence you may have trouble with SFTP sites. If you wish to use SFTP then either install ssh, or edit the lftp configuration ($LFTP_HOME/rc or /etc/lftp.conf) to point to the location of an ssh binary (use a line like 'set sftp:connect-program \"/path/to/ssh -a -x\")."
		else
			[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working $LFTP_WILL_USE_SSH was found (configured in lftp for use with SFTP sites)"
		fi
	elif [[ $DEBUG -ge 1 ]]; then
		ws_event_info "Attempt to read lftp configuration failed"
	fi
fi

# Do we have curl?
CURL_CAN_FTP=0
CURL_CAN_SFTP=0
CURL_CAN_FTPS=0
# This one is set later
CURL_CAN_ACCESSMETHOD=0
# Earlier versions of curl 7 returned 2 (same code as for non-understood parameters) with --version. curl 7 was in existence by the year 2000 so we don't need to bother about earlier versions.
CURLTEST=`$CURL --version 2>/dev/null`
if [[ $? -ne 0 && ! $CURLTEST =~ "curl 7" ]]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working curl not found (looked for: $CURL; path is: $PATH) - will not be able to perform certain operations unless wget or lftp is available"
	unset CURL
	[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=1
	[[ -z $LFTP ]] && CHECKREQ_RESULTS=2
else
	echo "$CURLTEST" | grep -q ' ftp ' && CURL_CAN_FTP=1
	echo "$CURLTEST" | grep -q ' sftp ' && CURL_CAN_SFTP=1
	echo "$CURLTEST" | grep -q ' ftps ' && CURL_CAN_FTPS=1
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working curl was found; capabilities: FTP:$CURL_CAN_FTP FTPS:$CURL_CAN_FTPS SFTP:$CURL_CAN_SFTP"
fi
# Do we have wget?
$WGET --version >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working wget not found (looked for: $WGET; path is: $PATH) - only needed if you have neither a working lftp nor curl"
	unset WGET
	[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=1
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working wget was found"
fi

# Set this variable to prevent having to check 3 variables every time
CAN_URLGET=0
[[ -n "${LFTP}${WGET}${CURL}" ]] && CAN_URLGET=1

$RSYNC --version >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working rsync not found (looked for: $RSYNC; path is: $PATH) - recommended (but not required) for working on local filesystem WordPress installations"
	unset RSYNC
	[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=1
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working rsync was found"
fi
RSYNCOPT=""
[[ $DEBUG -ge 1 ]] && RSYNCOPT="-v --stats"
[[ $DEBUG -ge 3 ]] && RSYNCOPT="-vv --stats"
# Also used for mv as well as cp
COPYOPT=""
[[ $DEBUG -ge 1 ]] && COPYOPT="-v"

$UNZIP -v >/dev/null 2>/dev/null
UNZIPRET=$?
# Some BSD zips have no -v switch, so we can't use that; but instead they return code 1 and a usage summary
[[ $UNZIPRET -eq 1 && $UNAME != "Linux" && ${UNAME:0:6} != "Cygwin" && ${UNAME:0:6} != "CYGWIN" ]] && UNZIPRET=0
if [[ $UNZIPRET -ne 0 ]]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working unzip not found (looked for: $UNZIP; path is: $PATH) - required to make new installations and check modifications to existing ones"
	unset UNZIP
	[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=2
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working unzip was found"
fi
UNZIPOPT="-q"
[[ $DEBUG -ge 3 ]] && UNZIPOPT=""

$ZIP -v >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working zip not found (looked for: $ZIP; path is: $PATH) - needed to compress backups of old entities"
	unset ZIP
	[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=2
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working zip was found"
fi
ZIPOPT="-q"
[[ $DEBUG -ge 3 ]] && ZIPOPT=""

$W3M -version >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working w3m not found (looked for: $W3M; path is: $PATH) - needed for viewing changelogs, unless you have elinks or lynx available"
	unset W3M
	[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=1
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working w3m was found"
fi

$ELINKS -version >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	# Don't bother troubling the user with this if it won't be needed
	if [[ -z $W3M ]]; then
		[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working elinks not found (looked for: $ELINKS; path is: $PATH) - needed for viewing changelogs, unless you have w3m or lynx available"
		unset ELINKS
		[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=1
	fi
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working elinks was found"
fi

$LYNX -version >/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
	# Don't bother troubling the user with this if it won't be needed
	if [[ -z $W3M && -z $ELINKS ]]; then
		[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working lynx not found (looked for: $LYNX; path is: $PATH) - needed for viewing changelogs, unless you have w3m or elinks available"
		unset LYNX
		[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=1
		[[ -z $W3M && -z $ELINKS ]] && CHECKREQ_RESULTS=2
	fi
else
	[[ $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working lynx was found"
fi

# Spare ourselves from having to check 3 variables each time
CAN_BROWSE=0
[[ -n "${LYNX}${ELINKS}${W3M}" ]] && CAN_BROWSE=1

# Find an MD5 checksumming binary
CHECKSUM=""
if [[ "`echo X | md5sum 2>/dev/null| cut -f1 -d' '`" = "253bcac7dd806bb7cf57dc19f71f2fa0" ]]; then
	CHECKSUM="md5sum"
elif [[ "`echo X | openssl dgst -md5 -r 2>/dev/null | cut -f1 -d' '`" = "253bcac7dd806bb7cf57dc19f71f2fa0" ]]; then
	CHECKSUM="openssl dgst -md5 -r"
elif [[ "`echo X | md5 -r 2>/dev/null| cut -f1 -d' '`" = "253bcac7dd806bb7cf57dc19f71f2fa0" ]]; then
	CHECKSUM="md5 -r"
else
	[[ ! -s "$WORKINGDIR_FULL/md5.php" ]] && echo '<?php echo md5_file("php://stdin"); ?>' >"$WORKINGDIR_FULL/md5.php"
	if [[ -n $PHP && "`echo X | $PHP "$WORKINGDIR_FULL/md5.php" 2>/dev/null| cut -f1 -d' '`" = "253bcac7dd806bb7cf57dc19f71f2fa0" ]]; then
		CHECKSUM="$PHP $WORKINGDIR_FULL/md5.php"
	elif [[ -n $MD5CHECKSUM_TRY ]]; then
		CK_OUTPUT=`echo | $MD5CHECKSUM_TRY 2>/dev/null`
		if [ $? -eq 0 && -n $CK_OUTPUT ]; then
			CHECKSUM="$MD5CHECKSUM_TRY"
		fi
	fi
	if [[ -z $CHECKSUM ]]; then
		[[ $DEBUG -ge 1 || $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working MD5 checksum binary not found (looked for: md5sum, openssl, md5, php, $MDCHECKSUM_TRY; path is: $PATH) - useful to produce hashes (some cacheing operations will be disabled without it)"
		unset CHECKSUM
		[[ $CHECKREQ_RESULTS -eq 0 ]] && CHECKREQ_RESULTS=2
	fi
fi
[[ -n $CHECKSUM && $CHECKREQUIREMENTS -eq 1 ]] && ws_event_info "Working MD5 checksum binary ($CHECKSUM) was found"

if [[ $CHECKREQUIREMENTS -eq 1 ]]; then
	if [ $CHECKREQ_RESULTS -eq 0 ]; then
		echo "${BOLD}All is well${OFFBOLD} - you can run WordShell with 100% of available features"
	elif [ $CHECKREQ_RESULTS -eq 1 ]; then
		echo -n "${BOLD}All is well${OFFBOLD} - you did not have every tool we looked for, but you had enough to run WordShell with 100% of available features. You do not need to install any missing tools"
		[[ -z $LFTP ]] && echo " (though if you install lftp then your access to ftp/sftp sites will be faster)"
		echo "."
	else
		echo "${BOLD}Some requirements were not found${OFFBOLD} - you may find that some operations fail or some functionality is reduced"
	fi
	exit $CHECKREQ_RESULTS
fi

# Get this once rather than call potentially many times (especially comparing stat times)
NOWDATE=`date +%s`
# Reset this
REMOTEMANAGER_UPLOADTIME=0

# Unset because it is consulted by mktemp
unset TMPDIR

# $1 = prompt
# $2 = optional file to delete if user aborts
function check_continue() {
	read -p "$1" -n 1 DOCONT
	echo >/dev/stderr
	if [[ $DOCONT != "c" && $DOCONT != "C" ]]; then
		[[ -n $2 ]] && rm -f "$2"
		abort_die 27 "User chose to abort"
	fi
}

# Check reasonable free disk space. df -k -P is POSIX-compatible and has standardised output
FREESPACE=`(df -k -P . 2>/dev/null || echo 0 0 0 0) | tail -1 | awk '{print $4}'`
if [[ $FREESPACE =~ ^[0-9]+$ ]]; then
	if [[ $FREESPACE -lt 102400 && $FREESPACE -ne 0 ]]; then
		ws_event_notice "Disk space is low on WordShell's partition: df -k -P . returned: $FREESPACE Kb free"
		check_continue "There is less than 100Mb free on the local filesystem (in $WORKDIR; space: $FREESPACE Kb) - do you want to continue (c to continue, other to abort) : "
	fi
else
	[[ $DEBUG -ge 1 ]] && ws_event_info "The output of 'df -k -P' could not be parsed. Please send a bug report."
fi

ws_event_notice "Invoked: $ORIGINAL_PARAMS"
[[ $DEBUG -ge 1 ]] && ws_event_debug "WordShell: $VERSION Uname: $UNAME"

function reinvokeself() {
	# Purpose - re-invoke self, replacing any instances of --everything or --pluginsandthemes with another
	# $1 : Replacement parameter
	local LINE
	for i in $ORIGINAL_PARAMS; do
		if [[ $i = "--everything" || $i = "-e" || $i = "--pluginsandthemes" ]]; then
			LINE="$LINE $1"
		elif [[ ( $i != "--selfinvoked" && $i != "--selfinvoked=e" ) && $i != "--nocountdiskspace" && $i != "--groupbytype" && ( ( $1 != "--plugin" && $1 != "--theme" && $1 != "--content" && $1 != "--database" ) || ( $i != "--justwp" && $i != "--justwpwipeothers" ) ) ]]; then
			LINE="$LINE $i"
		fi
	done
	ws_pushd "$ORIGDIR"
	[[ $METAMODE = "everything" ]] && $BASH $0 $LINE --selfinvoked=e --nocountdiskspace
	[[ $METAMODE != "everything" ]] && $BASH $0 $LINE --selfinvoked --nocountdiskspace
	ws_popd
}

DO_MULTIPLE_METAMODE=0
[[ $METAMODE = "everything" || $METAMODE = "pluginsandthemes" ]] && DO_MULTIPLE_METAMODE=1

PLUGIN_OR_THEME_MODE=0
[[ $METAMODE = "plugin" || $METAMODE = "theme" ]] && PLUGIN_OR_THEME_MODE=1

# Sanity checks of options

# First, sanity checks that do not involve the non-multiple metamodes (--core, --theme, --plugin)

[[ $GROUPBYTYPE -eq 1 && $DO_MULTIPLE_METAMODE -eq 0 ]] && options_abort "--groupbytype only makes sense when given together with --everything or --pluginsandthemes"

[[ $DISABLEFTPTLS -eq 1 && $REQUIREFTPTLS -eq 1 ]] && options_abort "--disableftptls and --requireftptls are mutually incompatible options"

[[ $SYNC -eq 1 && $CACHE -ge 1 ]] && options_abort "--cache and --sync are mutually contradictory options"

[[ $ACTIVATE -eq 1 && $DEACTIVATE -eq 1 ]] && options_abort "You cannot both activate and de-activate at the same time"

[[ $ONLYACTIVE -eq 1 && $ONLYINACTIVE -eq 1 ]] && options_abort "Cannot specify both --active and --inactive"

[[ -n $CURRENTVERSION && $MODE != "normal" && $MODE != "update" && $MODE != "rollback" && $MODE != "delete" && $MODE != "list" ]] && options_abort "You can only use --currentversion/--cver in update, install, rollback, list and delete modes (not with --$MODE)"

[[ $SHOWCHANGES -ge 1 && $MODE != "normal" && $MODE != "update" && $MODE != "rollback" ]] && options_abort "You cannot use --showchanges in $MODE mode (--$MODE)"

[[ $SHOWCHANGES -ge 1 && -z $DIFF ]] && options_abort "--showchanges requires a working diff command (run again with --checkrequirements or --debug for more information)"

[[ $MODE = "checkmodifications" && -z $DIFF ]] && options_abort "--checkmodifications requires a working diff command (run again with --checkrequirements or --debug for more information)"

[[ $LISTONLYUPDATES -eq 1 && $LISTONLYTHIRDPARTY -eq 1 ]] && options_abort "--listonlyupdates and --listonlythirdparty are mututally exclusive options (because --listonlyupdates only works with wordpress.org code, not third-party)."

[[ $WARNMISSING -eq 1 && $MODE != "list" ]] && options_abort "--warnmissing can only be used in list mode"

[[ $LISTEXACT -eq 1 && $MODE != "list" ]] && options_abort "--listexact can only be specified in list mode (--list)"

[[ ( $LISTONLYTHIRDPARTY -eq 1 || $LISTONLYUPDATES -eq 1 ) && $MODE != "list" ]] && options_abort "--list* parameters can only be used in list mode (--list)"

[[ $REQUIRENEWVERSION -eq 0  && ( $MODE != "normal" && $MODE != "update" && $MODE != "rollback" && $MODE != "restore" ) ]] && options_abort "--donotrequirenew can only be used when upgrading (cannot use --$MODE)"

[[ $MODE = "refreshcache" && $CACHE -ge 1 ]] && options_abort "Cannot specify both --refreshcache and --cache"

[[ $FILEMETHOD -eq 1 && ( $METAMODE != "core" || ( $MODE != "normal" && $MODE != "update" ) ) ]] && options_abort "--filemethod can only be used when updating core"

[[ $METAMODE = "core" && $MODE = "delete" ]] && options_abort "WordShell does not yet support deleting core; but if you want to delete an installation then you can use --login and then delete all your files with one command from there."

[[ $MODE = "visit" && -z $SITE ]] && options_abort "You must specify a site with --visit"

# For .php plugins, only --list, --delete, --activate and --deactivate are allowed
[[ $METAMODE = "plugin" && ${PLUGIN%.php} != $PLUGIN && ( $MODE != "list" && $MODE != "delete" && $ACTIVATE -ne 1 && $DEACTIVATE -ne 1 ) ]] && options_abort "With single-file plugins, only --list, --delete, --activate and --deactivate modes are supported (feel free to contact us to tell us if you need more)"

[[ $NETWORK_PLUGIN -eq 1 && ( $METAMODE != "plugin" || ( $ACTIVATE -ne 1 && $DEACTIVATE -ne 1 && $MODE != "list" ) ) ]] && options_abort "--network only makes sense in plugin mode together with --list, --activate or --deactivate"

[[ $NETWORK_BLOGID != "-1" && ( $METAMODE != "plugin" || ( $ACTIVATE -ne 1 && $DEACTIVATE -ne 1 && $MODE != "list" ) ) ]] && options_abort "--blog only makes sense in plugin mode together with --list, --activate or --deactivate"

[[ $NETWORK_BLOGID != "-1" && $NETWORK_PLUGIN -eq 1 ]] && options_abort "You cannot specify both --network (i.e. network-wide) and --blog= (i.e. a particular site) at the same time"

# Now, sanity checks that depend upon the metamode, or which change supplied parameters
if [[ $METAMODE != "everything" && $METAMODE != "pluginsandthemes" ]]; then

	# This is good to put early
	[[ $METAMODE = "content" && $MODE != "restore" && $MODE != "refreshcache" && $MODE != "list" && $MODE != "login" ]] && options_abort "--content can only be used in one of the following modes: --restore, --list, --refreshcache, --login (not with --$MODE)"

	[[ $METAMODE = "database" && $MODE != "refreshcache" && $MODE != "listrollbacks" && $MODE != "deleterollbacks" && $MODE != "searchandreplace" ]] && options_abort "--database can only be used in --refreshcache/--listrollbacks/--deleterollbacks/--searchandreplace modes (not with --$MODE)"

	[[ $METAMODE != "database" && $MODE = "searchandreplace" ]] && options_abort "--searchandreplace can only be used in database mode (--database)"

	[[ -n $TABLELIST && $MODE != "searchandreplace" ]] && options_abort "--tables can only be specified with --searchandreplace (not with --$MODE)"

	[[ $METAMODE = "core" && $MODE = "install" && -n $SITE && $SITE != "new" ]] && options_abort "--core --install can only be used with a new site (specify no site, or 'new'), not an existing one"

	[[ $METAMODE != "core" && $JUSTWP -eq 1 ]] && options_abort "--justwp and --justwpwipeothers only make sense in --core mode (it instructs WordShell, when working with core, to only attempt to backup your WordPress installation (and not any extra files you have placed in the same directory))"

	[[ ( $METAMODE != "plugin" && $METAMODE != "theme" ) && ( $ONLYINACTIVE -eq 1 || $ONLYACTIVE -eq 1 ) ]] && options_abort "--onlyactive and --onlyinactive do not make sense in --$METAMODE mode (only themes and plugins have this concept)"

	[[ ( $METAMODE != "plugin" && $METAMODE != "theme" ) && ( $ACTIVATE -eq 1 || $DEACTIVATE -eq 1 ) ]] && options_abort "--activate and --deactivate do not make sense in --$METAMODE mode (only themes and plugins have this concept)"

	# --user
	[[ $METAMODE = "user" && $MODE != "add" && $MODE != "delete" && $MODE != "list" && "$MODE" != "passwordreset" ]] && options_abort "--user must be used with --add, --delete or --list (not with --$MODE)"
	[[ $MODE = "add" && $METAMODE != "user" ]] && options_abort "--add can only be used with --user (not with --$METAMODE)"
	[[ $MODE = "passwordreset" && $METAMODE != "user" ]] && options_abort "--passwordreset can only be used with --user (not with --$METAMODE)"
	[[ $METAMODE != "user" && -n $USER_ROLE ]] && options_abort "--role can only be used with --user (not with --$METAMODE)"
	[[ $METAMODE != "user" && -n $USER_EMAIL ]] && options_abort "--email can only be used with --user (not with --$METAMODE)"
	[[ ( $METAMODE != "user" || $MODE != "delete" ) && -n $POSTS_REASSIGN ]] && options_abort "--reassign can only be specified with --user --delete"

	[[ -n $USEZIP && $USEZIP != "latest" && $PLUGIN = "all" ]] && options_abort "Cannot specify a particular new ${METAMODE} zip (--new) together with ${METAMODE} 'all'"

	[[ $MODE = "login" && $PLUGIN = "all" ]] && options_abort "You cannot specify 'all' in login mode (--login)"

	[[ ( $MODE != "normal" && $MODE != "install" && $MODE != "update" ) && -n $USEZIP ]] && options_abort "Can only specify a zip or version to install when updating or installing (cannot use --usezip or --latest with --$MODE)"

	# In delete mode, also deactivate unless requested not to
	# In theme mode, deactivate has no meaning. WP will automatically switch to the default theme.
	[[ $MODE = "delete" && $SKIPDEACTIVATE -ne 1 && $METAMODE != "theme" ]] && DEACTIVATE=1

	# Specifying plugin "all" is redundant when listing, and in fact will invoke a different code path.
	[[ $MODE = "list" && $PLUGIN = "all" ]] && unset PLUGIN

	[[ ( $MODE = "definegroup" || $MODE = "delgroup" || $MODE = "listgroups" ) && -n $SITE ]] && options_abort "Do not specify a site with --$MODE"

	if [[ ( $MODE = "remotecli" || $MODE = "phpinfo" || $MODE = "phpversion" || $MODE = "mysqlversion" ) && -n $PLUGIN ]]; then
		ws_event_info "Do not specify a $METAMODE in --$MODE mode"
		unset PLUGIN
	fi

	# If self-invoked from an original --restore --everything without specifying a particular theme/plugin, then do them all
	[[ $PLUGIN_OR_THEME_MODE -eq 1 && $SELFINVOCATION -eq 2 && $MODE = "restore" && -z $PLUGIN ]] && PLUGIN="all"
	[[ $PLUGIN_OR_THEME_MODE -eq 1 && $MODE = "restore" && -z $PLUGIN ]] && options_abort "You must specify both a site and a $METAMODE with --restore (or specify \"all\")"

	[[ $DEACTIVATE -eq 1 && $METAMODE = "theme" ]] && options_abort "You cannot use --deactivate with a theme; rather, you must use --activate on the new theme that you wish to use"

	[[ $PLUGIN_OR_THEME_MODE -eq 1 && $MODE = "checkmodifications" && -z $PLUGIN ]] && PLUGIN="all"

	# --delete followed by --active or --inactive implies all plugins
	[[ $MODE = "delete" && -z $PLUGIN && ($ONLYACTIVE -eq 1 || $ONLYINACTIVE -eq 1 ) ]] && PLUGIN="all"

	[[ $METAMODE = "core" && -n $PLUGIN && $PLUGIN != "wordpress" && $PLUGIN != "WordPress" ]] && options_abort "$PLUGIN: You cannot specify this parameter in --core mode"
	# This value is used in a few places
	[[ $METAMODE = "core" ]] && PLUGIN="wordpress"

	[[ $SHOWCHANGES -ge 1 && -z $PLUGIN ]] && options_abort "You must specify both a site and a $METAMODE with --showchanges"

	# If we asked to list updates without specifying a site, then do them all
	[[ $LISTONLYUPDATES -eq 1 && -z $SITE ]] && SITE="all"

	[[ ( $MODE = "listrollbacks" || $MODE = "deleterollbacks" ) && -z $SITE ]] && SITE="all"

	[[ $MODE = "rollback" && -n $USEZIP ]] && options_abort "Cannot specify --new or --latest in rollback mode (--rollback)"

	[[ $METAMODE = "core" && $LISTONLYTHIRDPARTY -eq 1 ]] && options_abort "--listonlythirdparty makes no sense with --core"

	[[ $MODE = "install" && $PLUGIN = "all" ]] && options_abort "Incompatible options specified: cannot specify $METAMODE as 'all' when in install mode (--install)"

	[[ ( $MODE = "entermaintenance" || $MODE = "waitmaintenance" || $MODE = "exitmaintenance" || $MODE = "maintenancestate" ) && -n $PLUGIN  ]] && options_abort "Cannot specify a particular $METAMODE in this mode (--$MODE)"

	[[ $MODE = "refreshcache" && -n $PLUGIN && $PLUGIN != "all" && $PLUGIN_OR_THEME_MODE -eq 1 ]] && options_abort "Cannot specify a $METAMODE in refresh cache mode (--refreshcache)"

	# Was --update explicitly passed on the command line? (needed sometimes when using --activate / --deactivate, to make intention clear)
	if [[ ( $ACTIVATE -eq 1 || $DEACTIVATE -eq 1 ) && $MODE = "update" ]]; then
		MODE="normal"
	elif [[ $ACTIVATE -eq 1 && $MODE = "normal" ]]; then
		MODE="activate"
	elif [[ $DEACTIVATE -eq 1 && $MODE = "normal" ]]; then
		MODE="deactivate"
	elif [[ $MODE = "update" ]]; then
		MODE="normal"
	fi

	[[ ( $ONLYACTIVE -eq 1 || $ONLYINACTIVE -eq 1 || $FAST -eq 1 ) && ( $MODE != "list" && $MODE != "normal" && $MODE != "delete" ) ]] && options_abort "Can only specify --fast, --active or --inactive in list, delete, restore and update modes (not with --$MODE)"

	if [[ $MODE = "addsite" ]]; then
		if [[ -n $SITE && $SITE != "new" ]]; then
			options_abort "Cannot specify a site when adding a new site"
		elif [[ -n $PLUGIN ]]; then
			options_abort "Cannot specify a $METAMODE when adding a new site"
		fi
		# --addsite, after adding the site, comes out to --list
		SITE="new"
		MODE="list"
	fi

	[[ $ACTIVATE -ge 1 && $MODE != "activate" && $MODE != "normal" && $MODE != "install" && $MODE != "rollback" && $MODE != "restore" ]] && options_abort "--activate can only be specified on its own or in install/update/rollback/restore modes (not with --$MODE)"

	[[ $DEACTIVATE -ge 1 && $MODE != "deactivate" && $MODE != "normal" && $MODE != "delete" && $MODE != "rollback" && $MODE != "restore" ]] && options_abort "--deactivate can only be specified on its own or in delete/update/rollback/restore modes (not with --$MODE)"

	[[ $MODE != "normal" && $AUTOPATCH -eq 1 ]] && options_abort "--autopatch can only be specified in update mode (cannot use --$MODE)"

	[[ $DETAILED -eq 1 && ( $METAMODE != "user" || $MODE != "list" ) ]] && options_abort "--detailed can only be specified with --user --list"

	[[ $MODE = "delete" && $SITE = "all" && ( -z $PLUGIN || $PLUGIN = "all" ) && $IREALLYMEANIT -ne 1 ]] && options_abort "Deleting everything requires that you also specify --ireallymeanit"

	[[ $THISONEONLY -eq 1 && $MODE != "normal" && $MODE != "delete" && $MODE != "restore" && $MODE != "rollback" ]] && options_abort "--thisoneonly can only be used in update/delete/restore modes (cannot use --$MODE)"

	[[ $THISONEONLY -eq 1 && -z $PLUGIN ]] && options_abort "You must specify both a site and a $METAMODE when using --thisoneonly"

	[[ ( $MODE = "listrollbacks" || $MODE = "deleterollbacks" ) && $PLUGIN = "all" ]] && PLUGIN=""

# End of the sanity checks that depend somehow upon the meta-mode
fi

function url_detectredirection {
	# Input: $1=URI
	# Output: returns 0 if no redirection detected, 1 if found; and if so, sets URL_REDIRECTEDURL

	if [[ -n $CURL ]]; then
		local CURLOPTS=""
		local CURL_URL=$1
		if [[ $1 =~ ^(https?)://([^/]+):([^/]+)\@(.*)$ ]]; then
			CURLUSER="user = \"${BASH_REMATCH[2]}:${BASH_REMATCH[3]}\"
"
			CURL_URL="${BASH_REMATCH[1]}://${BASH_REMATCH[4]}"
			CURLOPTS="$CURLOPTS --config - --fail --anyauth --netrc-optional"
		fi
		local RTMP=`mktemp "$WORKINGDIR_FULL/tmp/URLREDIRECT.XXXXX"`
		echo $CURLUSER | $CURL $CURLVERB --head $CURLOPTS -o $RTMP "$CURL_URL"
		CURLRET=$?
		if [[ $CURLRET -eq 47 ]]; then
			rm -f $RTMP
			# Maximum redirections exceeded - try to find the URL
			return 1
		fi
		rm -f $RTMP
		if [[ $CURLRET -eq 0 ]]; then
			return 0
		else
			[[ $DEBUG -ge 1 ]] && ws_event_info "Curl returned code $CURLRET when trying to detect redirections at $CURL_URL"
			return 0
		fi
	fi

	# TODO - wget / lftp; then use this function in the intended places
	true
	cat <<-ENDHERE

$ wget --max-redirect=0 --spider -S http://www.homeedsuccess.co.uk -q
  HTTP/1.0 301 Moved Permanently
  Location: http://www.homeedsuccess.co.uk/he
  Connection: keep-alive
  Date: Tue, 15 May 2012 10:20:31 GMT
  Server: lighttpd

$ lftp -c "set xfer:max-redirections 0; open http://www.homeedsuccess.co.uk"
cd: File moved: 301 Moved Permanently (/ -> http://www.homeedsuccess.co.uk/he)
Or with -d:
<--- HTTP/1.1 301 Moved Permanently
<--- Location: http://www.homeedsuccess.co.uk/he
<--- Date: Tue, 15 May 2012 10:26:17 GMT
<--- Server: lighttpd
<--- 
cd: File moved: 301 Moved Permanently (/ -> http://www.homeedsuccess.co.uk/he)

curl --head http://www.homeedsuccess.co.uk
HTTP/1.1 301 Moved Permanently
Location: http://www.homeedsuccess.co.uk/he
Date: Tue, 15 May 2012 10:14:14 GMT
Server: lighttpd
	ENDHERE
}

function url_get() {
# Input: $1=URI If $2=stdout then output on terminal, else (if set) indicates output filename
# We assume one of LFTP and WGET and CURL is there (caller should check first)
# FTP requires you to set tryonlycurl
# $3: Other parameters:
#   e.g. tryonlylftp, tryonlywget, tryonlycurl
#   passwarning (if password will be put on command line)
#   testonly - informs url_get that we wish to test if the server returns an error code. You would likely then also specify $2=stdout and redirect to /dev/null. Note that without this switch, the return code from url_get may be zero in the case of failure; curl does this, returning the error document and suppressing the HTTP error.
# Returns URLGET_RETURNCODE as the return code, in case you were piping the output somewhere

# Set the command to get the desire output concerning the output selection ($2)
if [[ $2 = "stdout" ]]; then
	local LFTP_COM="cat"
	local URL_GOT="-"
	local CURL_OUTPUT=""
elif [[ -n $2 ]]; then
	local LFTP_COM="get1 -o \"$2\""
	local URL_GOT=$2
	local CURL_OUTPUT="-o $2"
else
	local LFTP_COM="get1"
	local URL_GOT=`basename "$1" 2>/dev/null`
	local CURL_OUTPUT="-O"
fi

if [[ -n $LFTP && ( -z $3 || $3 = "passwarning" || $3 = "testonly" || $3 =~ "tryonlylftp" ) ]]; then
	if [[ -n $LFTP ]]; then
		if [[ $DEBUG -ge 1 ]]; then
			ws_event_info "url_get: lftp: $1"
			# We don't put the URL on the command-line in case it contains passwords
			$LFTP $LFTPDEBUG <<-ENDHERE
			set xfer:max-redirections 16
			set ssl:verify-certificate $SSLVERIFY
			$LFTP_COM "$1"
			ENDHERE
		else
			$LFTP $LFTPDEBUG 2>/dev/null <<-ENDHERE
			set xfer:max-redirections 16
			set ssl:verify-certificate $SSLVERIFY
			$LFTP_COM "$1"
			ENDHERE
		fi
		URLGET_RETURNCODE=$?
	else
		URLGET_RETURNCODE=3
	fi
elif [[ -n $CURL && ( -z $3 || $3 = "passwarning" || $3 = "testonly" || $3 =~ "tryonlycurl" ) ]]; then
	if [[ -n $CURL ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "url_get: curl: $1"
		local CURLOPTS=""
		local CURL_URL=$1
		local CURLUSER=""
		local CURLRET
		[[ $1 =~ ^s?ftp ]] && CURLOPTS="$CURL_FTPOPTIONS "
		# --location forces curl to follow any Location: headers; otherwise the test may fail (a redirect code comes successfully back, though the site you'd get if you followed it may be down)
		[[ $3 =~ testonly ]] && CURLOPTS="$CURLOPTS --fail --location"
		if [[ $1 =~ ^(https?|s?ftps?)://([^/]+):([^/]+)\@(.*)$ ]]; then
			CURLUSER="user = \"${BASH_REMATCH[2]}:${BASH_REMATCH[3]}\"
"
			CURL_URL="${BASH_REMATCH[1]}://${BASH_REMATCH[4]}"
			CURLOPTS="$CURLOPTS --config -"
			[[ $1 =~ ^http ]] && CURLOPTS="$CURLOPTS --fail --anyauth --netrc-optional"
		fi
		if [[ $DEBUG -ge 2 ]]; then
			echo 
			echo $CURLUSER | $CURL $CURLVERB --show-error $CURLOPTS $CURL_OUTPUT "$CURL_URL"
			CURLRET=$?
		else
			if [[ "$MODE" = "downloadonly" || $DEBUG -eq 1 ]]; then
				echo $CURLUSER | $CURL $CURL_OUTPUT $CURLOPTS -# "$CURL_URL"
				CURLRET=$?
			else
				echo $CURLUSER | $CURL $CURL_OUTPUT $CURLOPTS --silent "$CURL_URL"
				CURLRET=$?
			fi
		fi
		URLGET_RETURNCODE=$CURLRET
	else
		URLGET_RETURNCODE=3
	fi
# We try wget last because it is harder to hide username/passwords in the URL with
elif [[ -n $WGET && ( -z $3 || $3 = "passwarning" || $3 = "testonly" || $3 =~ "tryonlywget" ) ]]; then
	if [[ -n $WGET ]]; then
		local WGET_URL=$1
		if [[ $3 =~ passwarning && $WGET_URL =~ ^(https?|s?ftps?)://([^/]+):([^/]+)\@(.*)$ ]]; then
			check_continue "${BOLD}Warning:${OFFBOLD} Your system does not have lftp or curl installed, so we are using wget to fetch URLs. However, wget has no easy way to hide passwords contained in URLs. This is not a problem unless your system is multi-user; someone then may be able to spot the password in the system's process table (by running the 'ps' command). To avoid this, you should (if you cannot install lftp or curl) add a line to your .netrc file in your home directory (see 'man netrc' for more information on how to do so; a typical line is 'machine www.example.com<tab>login myusername<tab>password mypassword'). After doing that, you can tell WordShell the URL without needing to include a username or password; wget will pick up the username/password automatically without WordShell needing to pass it. Do you want to continue? (c to continue if this does not matter, e.g. you are on a single user system, or if the entry is already in your .netrc; or any other key to abort): "
		fi
		if [[ $DEBUG -ge 1 ]]; then
			ws_event_info "url_get: wget: $1"
			$WGET $WGETVERB -O $URL_GOT "$WGET_URL"
		else
			if [[ $MODE = "downloadonly" ]]; then
				$WGET -O $URL_GOT -nv "$WGET_URL"
			else
				$WGET -O $URL_GOT -q "$WGET_URL"
			fi
		fi
	else
		URLGET_RETURNCODE=3
	fi
else
	ws_event_error "No suitable program to fetch the URL was found"
	URLGET_RETURNCODE=254
fi
return $URLGET_RETURNCODE
}

function url_post() {
	# Input: $1 = URI, $2 = path, $3 = params
	# $4 is options (comma-separated):
	# ignoreexisting: do not use an existing cache file
	# nocache: do not cache the results (implies ignoreexisting)
	# preferwget to prefer wget (or preferlftp to not do so - presently default, but you never know...). Or prefercurl
	# returnfile to return the full file path (not the contents); setvar to put the contents in URLPOST_RESULTS
	# We assume either lftp or wget or curl is available
	# Output: sets RETCODE_URLPOST
	local POST_OPTS=$4
	# This is needed to use STAT_MODTIME correctly (the spaces in it need recognising as parameter separators)
	local OLDIFS=$IFS
	IFS=" 	
"
	if [[ -z $CHECKSUM ]]; then
		# If no checksum binary, then cannot store predictable cache file name, so just use temp file
		REQHASH_FILE=`mktemp "$WORKINGDIR_FULL/tmp/url-post.XXXXX"`
		# Since the temp file name was not predictable, do not cache the file (unless the caller requested it)
		[[ ! $POST_OPTS =~ returnfile ]] && POST_OPTS="$4,nocache"
	else
		REQHASH_FILE="$WORKINGDIR_FULL/tmp/post-`echo $1 $2 $3 | $CHECKSUM | cut -d' ' -f1`"
	fi
	# Do the download if not cacheing, or if told to ignore existing cache, or cache disabled, or no cache file exists, or if cache file is old

	if [[ $POST_OPTS =~ nocache || $POST_OPTS =~ ignoreexisting || $DISABLECACHE -eq 1 || ! -f $REQHASH_FILE || $((NOWDATE - `$STAT_MODTIME $REQHASH_FILE 2>/dev/null|| echo 0`)) -ge 3600 ]]; then

		if [[ ( $POST_OPTS =~ preferwget && -n $WGET ) || ( -z $CURL && -z $LFTP)  ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "url_post: wget_post: options=$4: $1 $2 $3"
			$WGET $WGETVERB --post-data="$3" -O $REQHASH_FILE $1$2
			RETCODE_URLPOST=$?
		elif [[ ( $POST_OPTS =~ prefercurl && -n $CURL ) || -z $LFTP ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "url_post: curl_post: options=$4: $1 $2 $3"
			CURL_URL=$1
			CURLUSER=""
			CURLOPTS=""
			if [[ $1 =~ ^(https?)://([^/]+):([^/]+)\@(.*)$ ]]; then
				CURLUSER="user = \"${BASH_REMATCH[2]}:${BASH_REMATCH[3]}\"
"
				CURL_URL="${BASH_REMATCH[1]}://${BASH_REMATCH[4]}"
				CURLOPTS="$CURLOPTS --config -"
				[[ $1 =~ ^http ]] && CURLOPTS="$CURLOPTS --fail --anyauth --netrc-optional"
			fi
			echo $CURLUSER | $CURL $CURLVERB $CURLOPTS --output $REQHASH_FILE --data "$3" --url "${CURL_URL}$2"
			RETCODE_URLPOST=$?
		else
			[[ $DEBUG -ge 1 ]] && ws_event_info "url_post: lftp_post: options=$4: $1 $2 $3"
# 			if [[ $1 =~ ^(https?)://([^/]+):([^/]+)\@(.*)$ ]]; then
				# Don't put the URL on the command-line, in case it contains passwords
				$LFTP $LFTPDEBUG  >"$REQHASH_FILE" <<-ENDHERE
				set ssl:verify-certificate $SSLVERIFY
				open $1$2
				quote post '$2' '$3'"
				ENDHERE
				RETCODE_URLPOST=$?
# 			else
# 				# http://api.wordpress.org/themes/info/1.0/ returns a 500 error if HEAD is used, as happens with lftp's open command above. So, avoid that if possible by using this method.
# 				$LFTP $LFTPDEBUG "$1" >"$REQHASH_FILE" <<-ENDHERE
# 				quote post '$2' '$3'"
# 				ENDHERE
# 				RETCODE_URLPOST=$?
# 			fi
		fi
		[[ $DEBUG -ge 1 ]] && ws_event_info "url_post: wrote to file: $REQHASH_FILE"
	else
		[[ $DEBUG -ge 1 ]] && ws_event_info "HTTP POST: options=$4: $1 $2 $3: Found valid cache file: $REQHASH_FILE"
	fi
	if [[ $POST_OPTS =~ returnfile ]]; then
		echo $REQHASH_FILE
	elif [[ $POST_OPTS =~ setvar ]]; then
		URLPOST_RESULTS=`cat $REQHASH_FILE`
		rm -f $REQHASH_FILE
	else
		cat $REQHASH_FILE
		[[ $POST_OPTS =~ nocache ]] && rm -f $REQHASH_FILE
	fi
	IFS=$OLDIFS
}

# Deal with --setconfig
if [ -n "$SETCONFIG" ]; then
	OLDIFS="$IFS"
	IFS=","
	for CVAR in $SETCONFIG; do
		if [[ $CVAR =~ ^([^:]+):(.*)$ ]]; then
			CKEY=${BASH_REMATCH[1]}
			CVAL=${BASH_REMATCH[2]}
			grep -q "^config#$CKEY#" $CONFIGFILE
			if [ $? -eq 0 ]; then
				ws_sed_i "s/^config#$CKEY#.*$/config#$CKEY#$CVAL/" $CONFIGFILE
			else
				echo "config#${CKEY}#${CVAL}" >>"$CONFIGFILE"
			fi
		else
			abort_die 56 "illegitimate setconfig: $CVAR"
		fi
	done
	IFS="$OLDIFS"
fi

# Deal with --getconfig
if [ -n "$GETCONFIG" ]; then
	[[ -n $SITE ]] && options_abort "--getconfig takes no other parameters"
	OLDIFS="$IFS"
	IFS=","
	if [ "$GETCONFIG" = "all" ]; then
		grep "^config#" $CONFIGFILE | cut -d\# -f2,3
	else
		for CVAR in $GETCONFIG; do
			grep "^config#$CVAR#" $CONFIGFILE | cut -d\# -f2,3
		done
		IFS="$OLDIFS"
	fi
fi

function group_mod() {

	local GMODE=$1
	local ADDTHIS=$2

	if [[ $GMODE = "add" ]]; then
		grep -q "^d*site#$ADDTHIS#" $CONFIGFILE || abort_die 97 "Adding $ADDTHIS: this site was not found in the configuration file"
	fi

	if [[ $GROUPRESULT_COUNT -eq 0 && $GMODE = "add" ]]; then
		GROUPRESULT_COUNT=1
		GROUPRESULT[1]=$ADDTHIS
	elif [[ $GROUPRESULT_COUNT -gt 0 || $GMODE = "add" ]]; then
		local FOUNDIT=0
		local OLDIFS=$IFS
		IFS=" 
"
		for k in `seq 1 $GROUPRESULT_COUNT`; do
			if [[ "${GROUPRESULT[$k]}" = "$ADDTHIS" ]]; then
				# Is already there
				FOUNDIT=1
				[[ $GMODE = "del" ]] && GROUPRESULT[$k]=""
			fi
		done
		IFS=$OLDIFS
		if [[ $FOUNDIT -eq 0 && $GMODE = "add" ]]; then
			GROUPRESULT_COUNT=$((GROUPRESULT_COUNT+1))
			GROUPRESULT[$GROUPRESULT_COUNT]=$ADDTHIS
		fi
	fi

}

declare -a GROUPRESULT

function process_group_define() {
	# This function processes the input ($1 - a group definition) and sets $GROUPRESULT and $GROUPRESULT_COUNT accordingly (note that GROUPRESULT_COUNT is an upper limit; the highest used index in the array, not an exact result, as some array entries may be empty; others beyond it may be used but should be ignored)
	# $1 - a group definition
	local GROUPDEF=$1
	OLDIFS=$IFS
	IFS=","
	# When we write out the group, we write this many members (rest of the array should be discarded)
	GROUPRESULT_COUNT=0
	for GPART in $GROUPDEF; do
		if [[ $GPART = "all" ]]; then
			SITELIST=`grep "^site#" "$CONFIGFILE" | cut -d\# -f2` 
			IFS="
"
			for ADD_THIS in $SITELIST; do
				group_mod add "$ADD_THIS"
			done
			IFS=","
		elif [[ $GPART = "-all" ]]; then
			GROUPRESULT_COUNT=0
		elif [[ ${GPART:0:2} = "-@" && ${#GPART} -gt 2 && $GROUPRESULT_COUNT -gt 0 ]]; then
			# Delete group
			GROUP_TO_DEL=${GPART:2}
			DEL_THESE=`grep "^group#$GROUP_TO_DEL#" "$CONFIGFILE" | cut -d\# -f3`
			if [[ -n $DEL_THESE ]]; then
				# IFS is already ,
				for DEL_THIS in $DEL_THESE; do
					group_mod del "$DEL_THIS"
				done
			else
				abort_die 97 "$GROUP_TO_DEL: Unknown group"
			fi
		elif [[ ${GPART:0:1} = "-" &&  ${#GPART} -gt 1 && $GROUPRESULT_COUNT -gt 0 ]]; then
			# Delete site
			group_mod del "${GPART:1}"
		elif [[ ${GPART:0:1} = "@" && ${#GPART} -gt 1 ]]; then
			# Add a group: loop over, adding its members
			GROUP_TO_ADD=${GPART:1}
			ADD_THESE=`grep "^group#$GROUP_TO_ADD#" "$CONFIGFILE" | cut -d\# -f3`
			if [[ -n $ADD_THESE ]]; then
				# IFS is already ,
				for ADD_THIS in $ADD_THESE; do
					group_mod add "$ADD_THIS"
				done
			else
				abort_die 97 "$GROUP_TO_ADD: Unknown or empty group"
			fi
		elif [[ $GPART =~ ^[\-\.a-zA-Z0-9]+$ ]]; then
			# Add an item
			group_mod add "$GPART"
		else
			[[ $GROUPRESULT_COUNT -gt 0 || ${GPART:0:1} != "-" ]] && ws_event_warning "$GPART: this item could not be parsed"
		fi
	done
	IFS=$OLDIFS
}

# Deal with --definegroup, --delgroup, --listgroups
if [[ $MODE = "listgroups" ]]; then
	grep "^group#" $CONFIGFILE | while read LINE; do
		if [[ $LINE =~ ^group#([A-Za-z0-9]+)#(.*)$ ]]; then
			echo "${BOLD}${BASH_REMATCH[1]}:${OFFBOLD} ${BASH_REMATCH[2]}"
		else
			[[ $DEBUG -ge 1 ]] && ws_event_warning "Corrupt line in configuration file: $LINE"
		fi
	done
	exit
else
	if [[ -n $GROUP_DEFINES ]]; then
		for GROUPLINE in $GROUP_DEFINES; do
			# Each line is of format ([A-Za-z0-9]+):(.*)
			# Second part is a comma separarated list
			# When we're done, we need to either replace or add the relevant config line
			if [[ $GROUPLINE =~ ^([^:]+):(.*)$ ]]; then
				GROUPNAME=${BASH_REMATCH[1]}
				GROUPDEF=${BASH_REMATCH[2]}
				process_group_define "$GROUPDEF"
				# Now write it to the config file
				GROUP_RAW=""
				if [[ $GROUPRESULT_COUNT -gt 0 ]]; then
					for i in `seq 1 $GROUPRESULT_COUNT`; do
						if [[ -n ${GROUPRESULT[$i]} ]]; then
							[[ -n $GROUP_RAW ]] && GROUP_RAW="${GROUP_RAW},"
							GROUP_RAW="${GROUP_RAW}${GROUPRESULT[$i]}"
						fi
					done
				fi
				# Delete the line if it is present
				grep -q "^group#$GROUPNAME#" $CONFIGFILE && ws_sed_i "/^group#$GROUPNAME#/d" "$CONFIGFILE"
				# Now add it
				echo "group#$GROUPNAME#$GROUP_RAW" >>"$CONFIGFILE"
			fi
		done
	fi
	if [[ -n $GROUP_DELETES ]]; then
		for GROUPNAME in $GROUP_DELETES; do
			# Each line is of format ([A-Za-z0-9]+)
			# Just delete the relevant line from the configuration file
			# Delete the line if it is present
			[[ -n $GROUPNAME ]] && grep -q "^group#$GROUPNAME#" $CONFIGFILE && ws_sed_i "/^group#$GROUPNAME#/d" $CONFIGFILE
		done
	fi
	# Exit unless they explicitly requested to do something else
	[[ ( -n $GROUP_DEFINES || -n $GROUP_DELETES ) && $MODE = "normal" ]] && exit
fi

# Read in configuration variables
grep -q "^config#ftpparallel#" $CONFIGFILE && FTPPARALLEL=`grep "^config#ftpparallel#" $CONFIGFILE | cut -d\# -f3`
grep -q "^config#exclude-glob-ftp#" $CONFIGFILE && EXCLUDE_GLOB_FTP=`grep "^config#exclude-glob-ftp#" $CONFIGFILE | cut -d\# -f3`
grep -q "^config#exclude-glob-rsync#" $CONFIGFILE && EXCLUDE_GLOB_RSYNC=`grep "^config#exclude-glob-rsync#" $CONFIGFILE | cut -d\# -f3`
grep -q "^config#curl-ftp-options#" $CONFIGFILE && CURL_FTPOPTIONS=`grep "^config#curl-ftp-options#" $CONFIGFILE | cut -d\# -f3`

# If all that was specified was get/setconfig, then finish
[[ ( -n $GETCONFIG || -n $SETCONFIG ) && -z $SITE ]] && exit

function download_version() {
	# Core-friendly: yes
	# Input: $1 = plugin/theme name (if in appropriate mode), $2 = version
	# Assumes we are in working directory
	# Returns code to indicate success or failure
	local PLUGIN=$1
	local USEZIP=$2
	[[ -s "fromwporg.$METAMODE/$PLUGIN.$USEZIP.zip" ]] && return 0
	if [ $CAN_URLGET -eq 1 ]; then
		ws_pushd fromwporg.$METAMODE
		local FETCH_THIS
		local FETCH_AS=""
		if [[ $METAMODE = "plugin" ]]; then
			FETCH_THIS="https://downloads.wordpress.org/plugin/$PLUGIN.$USEZIP.zip"
			FETCH_AS="$PLUGIN.$USEZIP.zip"
		elif [[ $METAMODE = "theme" ]]; then
			FETCH_THIS="https://wordpress.org/themes/download/$PLUGIN.$USEZIP.zip"
			FETCH_AS="$PLUGIN.$USEZIP.zip"
		elif [[ $METAMODE = "core" ]]; then
			FETCH_THIS="https://wordpress.org/wordpress-$USEZIP.zip"
			FETCH_AS="wordpress.$USEZIP.zip"
		fi
		[[ -n $FETCH_THIS ]] && url_get "$FETCH_THIS" "$FETCH_AS"
		ws_popd
		if [[ ! -s "fromwporg.$METAMODE/$FETCH_AS" ]]; then
			ws_event_error "$USEZIP: Failed to successfully download this version (of $PLUGIN) from wordpress.org"
			return 1
		fi
		# In core mode, checksums are available
		# MD5 is broken for cryptographic verification purposes; however, since both files come from the same server, we are only checking the download success and not having cryptographic security (if you trojan the zip, you could trojan the checksum file)
		if [[ $METAMODE = "core" ]]; then
			[[ -s "fromwporg.core/$FETCH_AS.md5" ]] || url_get "$FETCH_THIS.md5" stdout >fromwporg.core/$FETCH_AS.md5
			DOWNLOADEDCORE_CHECKSUM_SHOULDBE=`cat fromwporg.core/$FETCH_AS.md5`
			if [[ ! $DOWNLOADEDCORE_CHECKSUM_SHOULDBE =~ ^[a-f0-9]+$ ]]; then
				ws_event_error "${BOLD}FAILED:${OFFBOLD} Could not successfully download the WordPress core checksum (output: $DOWNLOADEDCORE_CHECKSUM_SHOULDBE)"
				return 3
			fi
			DOWNLOADEDCORE_CHECKSUM=`$CHECKSUM "fromwporg.$METAMODE/$FETCH_AS" | cut -d' ' -f1`
			if [[ $DOWNLOADEDCORE_CHECKSUM = $DOWNLOADEDCORE_CHECKSUM_SHOULDBE ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "Download good: Checksum of downloaded WordPress zip matched what was expected ($DOWNLOADEDCORE_CHECKSUM)"
			else
				ws_event_error "${BOLD}FAILED:${OFFBOLD} Checksum of downloaded WordPress zip ($DOWNLOADEDCORE_CHECKSUM) did not match the expected value ($DOWNLOADEDCORE_CHECKSUM_SHOULDBE)"
				return 4
			fi
		fi
		return 0
	else
		ws_event_error "Could not find a working lftp or wget or curl. Run with --checkrequirements or --debug for more information"
		return 2
	fi
}

# This is checked for later
APPARENT_NEW_VERSION=""

function make_and_enter() {
	[[ $DEBUG -ge 2 ]] && ws_event_debug "make_and_enter: (`caller`): $1"	
	[[ -d "$1" ]] || mkdir -p "$1"
	ws_cd "$1"
}

function make_and_pushd() {
	[[ $DEBUG -ge 2 ]] && ws_event_debug "make_and_pushd: (`caller`): $1"	
	[[ -d "$1" ]] || mkdir -p "$1"
	ws_pushd "$1"
}

function managerollbacks() {
# Core-friendly: yes. Database-friendly: yes
# Input: $SITE will be set
# Input: $PLUGIN may be blank
# Input: $1 = list | time (then $2 = time) - returns $LISTPLUG_USEFILE, $LISTPLUG_USETIME } | delete (then $2 = time)
# We need to be in working directory
make_and_enter old.$METAMODE

if [[ $METAMODE = "database" ]]; then
	FINDPLUGREGEX="database"
elif [[ -n $PLUGIN ]]; then
	FINDPLUGREGEX="$PLUGIN"
else
	FINDPLUGREGEX=".*"
fi

LISTPLUG_USEFILE=""
LISTPLUG_USETIME=0
LISTPLUG_USEDATE=0
LISTPLUG_USEVERSION=""

local LISTROLLDAYS=""
[[ $1 = "delete" ]] && LISTROLLDAYS="-mtime +$2"

# Files have names like this:
# <site>-<plugslug>-<unixtime>-<version>.zip
for LISTPLUGLINE in `find . -regex "./$SITE-.*" $LISTROLLDAYS | cut -c3- |sort`; do
	if [[ $LISTPLUGLINE =~ ^$SITE-($FINDPLUGREGEX)-([0-9]{6,})-(.*)\.zip$ ]]; then
		LISTPLUG_NAME=${BASH_REMATCH[1]}
		LISTPLUG_TIME=${BASH_REMATCH[2]}
		LISTPLUG_VERSION=${BASH_REMATCH[3]}
		[[ $METAMODE = "database" ]] && LISTPLUG_VERSION=${LISTPLUG_VERSION%%\.sql}
		# The following line is Bash >= 4.2 only
		#printf -v LISTPLUG_DATE '%(%c)T' $LISTPLUG_TIME
		LISTPLUG_DATE=`ws_date_from_epoch $LISTPLUG_TIME "%c"`
		[[ $CAN_STRTOTIME -eq 0 ]] && LISTPLUG_DATE="$LISTPLUG_DATE ($LISTPLUG_TIME)"
		if [[ $1 = "list" ]]; then
			printf "${BOLD}%-14s${OFFBOLD} %-26s ${BOLD}%-14s${OFFBOLD} %s\n" "$SITE" "$LISTPLUG_NAME" "${LISTPLUG_VERSION}" "$LISTPLUG_DATE"
		elif [[ $1 = "delete" ]]; then
			if [ $DRYRUN -eq 1 ]; then
				echo "$SITE: Dry run mode: skipped deletion of rollback file: $LISTPLUGLINE"
				ws_event_info "$SITE: Dry run mode: skipped deletion of rollback file: $LISTPLUGLINE"
			else
				echo "$SITE: Deleting rollback file: $LISTPLUGLINE"
				ws_event_info "$SITE: Deleting rollback file: $LISTPLUGLINE"
				rm -f "$LISTPLUGLINE"
			fi
		elif [ "$1" = "time" ]; then
			# The one we are looking for satisfies these criteria:
			# 1) Its date is on or after the specified date
			# 2) It is earlier than any others matching 1)
			# Unless the specified date is "most recent" in which case we do just that.
			if [[ $2 = "most recent" ]]; then
				if [[ $LISTPLUG_TIME -gt $LISTPLUG_USETIME ]]; then
					LISTPLUG_USEFILE=$LISTPLUGLINE
					LISTPLUG_USETIME=$LISTPLUG_TIME
					LISTPLUG_USEDATE=$LISTPLUG_DATE
					LISTPLUG_USEVERSION=$LISTPLUG_VERSION
				fi
			elif [[ $LISTPLUG_TIME -ge $2 && ( -z "$LISTPLUG_USEFILE" || $LISTPLUG_TIME -lt $LISTPLUG_USETIME ) ]]; then
				LISTPLUG_USEFILE=$LISTPLUGLINE
				LISTPLUG_USETIME=$LISTPLUG_TIME
				LISTPLUG_USEDATE=$LISTPLUG_DATE
				LISTPLUG_USEVERSION=$LISTPLUG_VERSION
			fi
		fi
	fi
done

# Return to working directory
ws_cd ..

}

function choose_rollback() {
# Core-friendly: yes
# Input:
# Assume we are in working directory
# Output:
# If one was chosen, then set NEWZIPSOURCE and USEZIP accordingly
# If one was not chosen, then unset USEZIP

	# Before, USEZIP="rollback"
	USEZIP=""
	while [ -z "$USEZIP" ]; do
		echo "Available rollbacks:"
		managerollbacks list
		local DATE_EXPLAIN="many formats accepted"
		[[ $CAN_STRTOTIME -eq 0 ]] && DATE_EXPLAIN="which in this environment means, enter the number of seconds since the epoch (or install either PHP or the GNU/coreutils version of 'date' and then enter almost anything)"
		read -p "Enter a valid date ($DATE_EXPLAIN), or back to return to previous menu: " WHICHROLLBACK
		if [ "$WHICHROLLBACK" = "back" ]; then
			USEZIP="breakout"
		else
			[[ $DEBUG -ge 1 ]] && ws_event_info "Looking for installed version from time: $WHICHROLLBACK"
			SAVE_WHICHROLLBACK=$WHICHROLLBACK
			if [ "$WHICHROLLBACK" != "most recent" ]; then
				# Convert what is typed in into a UNIX time
				if [[ $CAN_STRTOTIME -eq 1 ]]; then 
					WHICHROLLBACK=`ws_strtotime "$WHICHROLLBACK"`
					[[ $? -ne 0 ]] && WHICHROLLBACK="error"
				fi
				if [[ ! $WHICHROLLBACK =~ ^[0-9]+$ ]]; then
					ws_event_error "Could not process rollback time: $SAVE_WHICHROLLBACK"
				else
					[[ $DEBUG -ge 1 ]] && ws_event_info "Rollback time in epoch time: $WHICHROLLBACK"
					managerollbacks time "$WHICHROLLBACK"
					if [ -z "$LISTPLUG_USEFILE" ]; then
						ws_event_error "Could not find any old version for time: $SAVE_WHICHROLLBACK (possibly the same version was installed then as now)"
					else
						ROLLBACKTIME=$WHICHROLLBACK
						USEZIP=$LISTPLUG_USEFILE
						NEWZIPSOURCE="old.$METAMODE"
						REQUIRENEWVERSION=0
						# When we save a rollback, we only save the changes
						CHOSEN_CORE_IS_OVERLAY=1
						APPARENT_NEW_VERSION=$LISTPLUG_USEVERSION
					fi
				fi
			fi
		fi
	done

	[[ $USEZIP = "breakout" ]] && unset USEZIP

}

# This function recursively lints (php -l) files in the current directory
# The parameter ($1) is a key to use for cacheing, and nothing else
function lint_dir() {
	[[ $DEBUG -ge 1 ]] && ws_event_debug "lint_dir: pwd=`pwd`, key=$1"
	if [[ $PHPLINT -eq 0 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "PHP linting has been disabled: skipping"
		return
	fi
	if [[ $ALREADY_LINTED -eq 1 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "We have already linted during this program run: skipping"
		return
	fi
	if [[ -z $PHP ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Cannot lint the contents of this directory, since no working PHP binary was found (run with --checkrequirements or --debug for more information)"
		return
	fi
	local CACHE_KEY=$1
	local END_ALL_LINTING=0
	# Look for existing cache
	local KEYCK=`echo "$CACHE_KEY" | $CHECKSUM | cut -d' ' -f1`
	local CACHEFILE=$WORKINGDIR_FULL/tmp/cache-lint-$KEYCK
	if [[ $DISABLECACHE -eq 0 && -f $CACHEFILE && $((NOWDATE - `$STAT_MODTIME $CACHEFILE 2>/dev/null|| echo 0`)) -lt 3600 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Successful lint result was cached ($CACHEFILE) - will skip linting process"
	else
		local ERRORS=0
		TMPLINT=`mktemp "$WORKINGDIR_FULL/tmp/LINT.XXXXX"`
		find . -name '*.php' -type f >$TMPLINT
		OLDIFS=$IFS
		IFS="
"
		for LINTIT in `cat $TMPLINT`; do
			LINTOUT=`$PHP -l "$LINTIT"`
			if [[ $? -eq 0 ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_debug "Lint: $LINTIT: PHP Syntax OK ($LINTOUT)"
			else
				ERRORS=1
				echo  "$LINTIT: This file in the entity you have chosen to upload is apparently invalid PHP. The PHP syntax check returned: $LINTOUT."
				check_continue "Are you sure you wish to continue (press c to continue, any other key to abort) ? " $TMPLINT
			fi
		done
		IFS=$OLDIFS
		rm -f $TMPLINT
		if [[ $ERRORS -eq 0 ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_debug "No errors were found during linting, so will save the successful result to the cache ($CACHEFILE)"
			touch "$CACHEFILE"
		fi
	fi
	ALREADY_LINTED=1
}

function extract_prospective_zip() {
	# Works with: plugins / themes / core
	# Input: Be inside tmp directory
	# Input: $1 = path to zip
	# $2 = extra unzip parameter, if any
	# $3 = further options: currently, "nolint" to prevent linting
	# Output: either exits with error, or cds you into a temporary copy of the unzipped plugin/theme/core
	# Sets USETMP as the name of the directory to be deleted (by caller) when he has finished
	# Also (if in plugin/theme meta-mode) lints the included .php files
	PROSPECTIVE_PLUG=$1
	ws_event_debug "extract_prospective_zip: zip=$PROSPECTIVE_PLUG, pwd=`pwd`, caller=`caller`"
	local EXTRA_UNZIP_OPT=$2
	local OUR_OPTS=$3
	if [[ ! -f "$PROSPECTIVE_PLUG" ]]; then
		ws_event_error "No such zip file ($PROSPECTIVE_PLUG) (`pwd`)"
		return 24
	elif [[ ! -s "$PROSPECTIVE_PLUG" ]]; then
		ws_event_error "Zero-sized zip file ($PROSPECTIVE_PLUG) (`pwd`)"
		return 24
	fi
	USETMP=`mktemp -d tmp-PRISTINE.XXXXX`
	ws_cd $USETMP
	[[ -z $UNZIP ]] && abort_die 20 "required unzip command not found (re-run with --checkrequirements or --debug for more information)"
	if [[ $PROSPECTIVE_PLUG =~ ^/ ]]; then
		$UNZIP $UNZIPOPT "$PROSPECTIVE_PLUG" $EXTRA_UNZIP_OPT
	else
		$UNZIP $UNZIPOPT "../$PROSPECTIVE_PLUG" $EXTRA_UNZIP_OPT
	fi
	local RETCODE=$?
	[[ $RETCODE -ne 0 ]] && abort_die 21 "Unzip command returned error (code: $RETCODE)"
	local HOWMANY=`find . -maxdepth 1 -type d | wc -l | awk '{print $1}'`
	# Should be two - . and the plugin/theme/core
	[[ $HOWMANY -ne 2 ]] && abort_die 22 "Did not find exactly one expected directory in $WORKDIR/tmp/$USETMP"
	# cd into the one that has no dot in it
	if [[ $METAMODE = "core" ]]; then
		ws_cd wordpress
		[[ $? -ne 0 ]] && abort_die 23 "Could not enter unzipped directory under $WORKDIR/tmp/$USETMP"
	else
		ws_cd "`find . -maxdepth 1 -type d | grep -v '^\.$'`"
		[[ $? -ne 0 ]] && abort_die 23 "Could not enter unzipped directory under $WORKDIR/tmp/$USETMP"
		[[ $PLUGIN_OR_THEME_MODE -eq 1 && $OUR_OPTS != "nolint" ]] && lint_dir "$PROSPECTIVE_PLUG"
	fi
}

# This function is just used by get_entity_version. It is abstracted out because it is used in two different places
function get_entity_version_frompluginfile() {
	# Input: $1 = the file to get the information from
	local PLUG=$1
	XPNAME=`head -47 $PLUG | grep -Ei "Plugin Name:" | head -1 | cut -d: -f2- | sed 's/[^-\/0-9a-zA-Z\. ]//g' | sed 's/^ //'`
	XPVER=`head -47 $PLUG | grep -Ei "Version:" | head -1 | cut -d: -f2- | awk '{print $1}' | sed 's/[^-0-9a-zA-Z\.]//g'`
	if [[ -n $XPNAME && -n $XPVER ]]; then
		FOUNDPLUG=1
		PPARENT=""
		PNAME=$XPNAME
		PVER=$XPVER
		# This is a special flag which should be used with caution to avoid confusion - we brought it in after seeing a version string "beta 1 (0.6)" which led to a fail of the "expected version = actual version" check. It should be used when you really need to know the full original version. PVER should be used instead for our rough-and-ready (but parsed and sane) version. Normally they are identical.
		PVER_ORIG_FULL=`head -47 $PLUG | grep -Ei "Version:" | head -1 | cut -d: -f2- | sed 's/^[[:space:]]*//g' | sed 's/\r//g'`
		if [[ $PLUG =~ ^\./ ]]; then
			# Plugin file: the last directory we are in, plus the file name, which we assume to being with ./ (and cut that bit off)
			PFILE="`basename $(pwd)`/`echo $PLUG | cut -c3-`"
		else
			PFILE=$PLUG
		fi
	fi
}

function get_entity_version() {
# Core-friendly: yes
# Input: Usually none. Just cd into the directory of the plugin/theme/core to be analysed.
# Special case: in plugin mode for a single-file plugin, specify the file name of the plugin (in the current directory)
# Output: sets FOUNDPLUG=0|1, PNAME, PVER, PVER_ORIG_FULL, PFILE (including/or directory name as relevant), PPARENT (themes)
	local EFILE=$1
	FOUNDPLUG=0
	if [[ $METAMODE = "core" ]]; then
		if [[ -f wp-includes/version.php ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Found wp-includes/version.php whilst checking version"
			XPVER=$(grep -E 'wp_version[[:space:]]*=' wp-includes/version.php  | head -1 | cut -d\' -f2)
			if [[ $XPVER =~ ^[0-9]+\. ]]; then
				FOUNDPLUG=1
				PVER=$XPVER
				PVER_ORIG_FULL=$XPVER
				PNAME="WordPress Core"
				PPARENT=""
				PFILE=wp-includes/version.php
			fi
		else
			ws_event_error "Did not find wp-includes/version.php whilst checking version"
		fi
	elif [[ $METAMODE = "plugin" ]]; then
		if [[ -n $EFILE ]]; then
			get_entity_version_frompluginfile "$EFILE"
		else
			# Look through all the files
			for PLUG in `find . -maxdepth 1 -type f -iregex '.*\.php$'`; do
				get_entity_version_frompluginfile "$PLUG"
			done
		fi
	elif [[ $METAMODE = "theme" && -f style.css ]]; then
		XPNAME=`head -45 style.css | grep -Ei "Theme Name:" | head -1 | cut -d: -f2- | sed 's/[^-\/0-9a-zA-Z\. ]//g' | sed 's/^ //'`
		XPVER=`head -45 style.css | grep -Ei "Version:" | head -1 | cut -d: -f2- | sed 's/[^-0-9a-zA-Z\.]//g'`
		PFILE="`basename $(pwd)`"
		PPARENT=`head -45 style.css | grep -Ei "Template:" | head -1 | cut -d: -f2- | sed 's/[^-\/0-9a-zA-Z\. ]//g' | sed 's/^ //'`
		if [[ -n $XPNAME && -n $XPVER ]]; then
			FOUNDPLUG=1
			PNAME=$XPNAME
			PVER=$XPVER
			PVER_ORIG_FULL=`head -45 style.css | grep -Ei "Version:" | head -1 | cut -d: -f2- | sed 's/^[[:space:]]*//g' | sed 's/\r$//g'`
		elif [[ -n $XPNAME && -z $XPVER ]]; then
			ws_event_warning "$XPNAME: Could not detect theme version: could not find tag in stylesheet: will set as 0"
			FOUNDPLUG=1
			PNAME=$XPNAME
			PVER=0
			PVER_ORIG_FULL=0
		fi
	elif [[ $METAMODE = "theme" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_warning "Could not detect theme information: stylesheet (style.css) not found (`pwd`)"
	elif [[ $METAMODE != "theme" ]]; then
		abort_die 74 "$METAMODE: Unknown metamode in get_entity_version"
	fi
}

if [[ $METAMODE = "core" || $METAMODE = "plugin" || $METAMODE = "theme" ]]; then
	# In zip selection code below we look in and download to these locations
	make_and_enter fromwporg.$METAMODE
	ws_cd ..
	make_and_enter customimports.$METAMODE
	ws_cd ..
fi

function unpack_wordpress() {
	# Unpacks a WordPress zip in current directory, and returns the version
	# Input: $1 = zip file
	# Output: Sets UNPACKED_VER to the version found in the unpacked zip
	$UNZIP $UNZIPOPT "$1" || abort_die 21 "Unzip command returned an error"
	[[ ! -f wordpress/wp-includes/version.php ]] && abort_die 21 "The zip file (`basename "$1"`) was unzipped; but did not appear to be a copy of WordPress"
	UNPACKED_VER=`grep -E 'wp_version[[:space:]]+=' wordpress/wp-includes/version.php | head -1 | cut -d\' -f2`
}

function ensure_unpacked_core_exists() {
	# $1 = version
	# You can be anywhere in the directory structure when you call this

	local THEVERSION=$1

	if [[ -f "$WORKINGDIR_FULL/fromwporg.core/$THEVERSION/wordpress/wp-includes/version.php" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "WordPress $THEVERSION: we already have this unpacked (fromwporg.core/$THEVERSION)"
	else
		[[ $DEBUG -ge 1 ]] && ws_event_info "WordPress $THEVERSION: requested to get one; we do not yet have an unpacked copy"

		[[ -z $UNZIP ]] && abort_die 20 "No unzip command found (needed to unpack WordPress zip) - run again with --checkrequirements or --debug for more information"

		if [[ -f "$WORKINGDIR_FULL/customimports.core/wordpress.$THEVERSION.zip" ]]; then
			COREFILE="wordpress.$THEVERSION.zip"
			make_and_pushd "$WORKINGDIR_FULL/customimports.core/$THEVERSION"
		elif [[ -f "$WORKINGDIR_FULL/fromwporg.core/wordpress.$THEVERSION.zip" ]]; then
			COREFILE="wordpress.$THEVERSION.zip"
			make_and_pushd "$WORKINGDIR_FULL/fromwporg.core/$THEVERSION"
		else
			[[ $DEBUG -ge 1 ]] && ws_event_info "Could not find a local WordPress $THEVERSION; going to download"
			# download_version assumes we are in working directory
			ws_pushd "$WORKINGDIR_FULL"
			download_version wordpress "$THEVERSION"
			[[ $? -ne 0 ]] && abort_die 89 "Failed to find version $THEVERSION of WordPress core"
			ws_popd
			make_and_pushd "$WORKINGDIR_FULL/fromwporg.core/$THEVERSION"
			# If we are still here, then it is in fromwporg.core/wordpress.$THEVERSION.zip
			COREFILE="wordpress.$THEVERSION.zip"
		fi
		[[ $DEBUG -ge 1 ]] && ws_event_info "WordPress core $THEVERSION downloaded ($COREFILE)"

		# Unpacks (or aborts upon failure) and sets UNPACKED_VER
		unpack_wordpress "../$COREFILE"

		# Sanity checks
		if [[ $UNPACKED_VER = $THEVERSION ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_debug "Unpackaged WordPress zip was the correct version ($THEVERSION)"
		else
			abort_die 83 "The zip file ($COREFILE) had a different WordPress version ($UNPACKED_VER) than expected ($THEVERSION)"
		fi

		# If the zip had a wp-content, then get rid of it
		rm -rf wordpress/wp-content 2>/dev/null

		# Return to where we were
		ws_popd

	fi

}

# This is put in a function, as there is another code path than the one immediately below which can call it
# Expects to be in working directory

function process_rollbacktime() {
	# The info that we wanted a rollback is found in $ROLLBACKTIME = x(=no rollback)/n(=show menu)/time string - 
	MODE="normal"
	if [[ $ROLLBACKTIME != "x" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Looking for installed version from time: $ROLLBACKTIME"
		local SAVEROLLBACKTIME=$ROLLBACKTIME
		if [[ $ROLLBACKTIME != "most recent" ]]; then
			if [[ $CAN_STRTOTIME -eq 1 ]]; then
				ROLLBACKTIME=`ws_strtotime "$ROLLBACKTIME"`
				[[ $? -ne 0 ]] && ROLLBACKTIME="error"
			fi
			[[ ! $ROLLBACKTIME =~ ^[0-9]+$ ]] && abort_die 59 "Could not process rollback time: $SAVEROLLBACKTIME"
		fi
		managerollbacks time "$ROLLBACKTIME"
		[[ -z $LISTPLUG_USEFILE ]] && abort_die 60 "Could not find any rollback version for time: $SAVEROLLBACKTIME (possibly the same version was installed then as now)"
		local EXTRABLURB=""
		[[ -L old.$METAMODE/$LISTPLUG_USEFILE ]] && EXTRABLURB=" (unmodified)"
		echo "${BOLD}Available rollback is:${OFFBOLD} ${LISTPLUG_USEVERSION}${EXTRABLURB}, replaced at: $LISTPLUG_USEDATE"
		[[ $DEBUG -ge 1 ]] && ws_event_info "Rollback file: ${LISTPLUG_USEFILE}${EXTRABLURB}"
		NEWZIPSOURCE="old.$METAMODE"
		USEZIP=$LISTPLUG_USEFILE
		APPARENT_NEW_VERSION=$LISTPLUG_USEVERSION
		CHOSEN_CORE_IS_OVERLAY=1
		[[ $METAMODE = "core" ]] && ensure_unpacked_core_exists "$LISTPLUG_USEVERSION"
	fi
}

# Identify where is the zip that we will use
# Rollback mode is the same as update mode internally; except we fetch the file from somewhere else
if [[ $MODE = "rollback" && $DO_MULTIPLE_METAMODE -eq 0 ]]; then
	if [[ -n $SITE && ( $SITE =~ , || $SITE =~ \@ || $SITE =~ \- ) ]]; then
		# Processing is deferred until later (either on re-invocation, or when we discover there really was only one site)
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Processing of the --rollback parameter is deferred until we know we are working on a single site"
	else
		process_rollbacktime
	fi
elif [[ $DO_MULTIPLE_METAMODE -eq 0 ]]; then
	NEWZIPSOURCE="fromwporg.$METAMODE"
	# If they specify a file/version, then act appropriately
	# customimports should override fromwporg
	if [[ -n $USEZIP && $USEZIP != "latest" ]]; then
		if [ -s "customimports.$METAMODE/$USEZIP" ]; then
			if [[ -s "$ORIGDIR/$USEZIP" && -n $CHECKSUM ]]; then
				FOUND_CUST_CKSUM=`$CHECKSUM "customimports.$METAMODE/$USEZIP" | cut -d' ' -f1`
				FOUND_NEW_CKSUM=`$CHECKSUM "$ORIGDIR/$USEZIP" | cut -d' ' -f1`
				[[ $FOUND_CUST_CKSUM != $FOUND_NEW_CKSUM ]] && abort_die 65 "Ambiguous file specification - named file exists, and so does an identically-named (but different contents) file that is already imported. To resolve this conflict, either rename the the file your are trying to import, or delete the existing file ($WORKDIR/customimports.$METAMODE/$USEZIP)"
			elif [[ -s "$ORIGDIR/$USEZIP" ]]; then
				abort_die 65 "Needed to perform a checksum operation, but no checksumming binary could be found (run again with --checkrequirements for more information"
			fi
			NEWZIPSOURCE="customimports.$METAMODE"
		elif [[ -s "customimports.$METAMODE/$PLUGIN.$USEZIP.zip" ]]; then
			NEWZIPSOURCE="customimports.$METAMODE"
			APPARENT_NEW_VERSION=$USEZIP
			USEZIP="$PLUGIN.$USEZIP.zip"
		elif [[ -s "$ORIGDIR/$USEZIP" || -s "$USEZIP" || $USEZIP =~ ^(https?|s?ftps?):// ]]; then
			if [[ $USEZIP =~ ^(https?|s?ftps?):// ]]; then
				# Download it
				[[ $DEBUG -ge 1 ]] && ws_event_info "Requested to pull new zip from remote URL: $USEZIP"
				if [[ $CAN_URLGET -eq 1 ]]; then
					make_and_enter tmp
					DOWNLOAD_TMP=`mktemp downloaded.XXXXX`
					url_get "$USEZIP" stdout >$DOWNLOAD_TMP
					if [[ -s $DOWNLOAD_TMP ]]; then
						# Parameter to extract_prospective_zip is relative to inside tmp
						NEWONE_FINDDIR="./"
						USEZIP=$DOWNLOAD_TMP
					else
						abort_die 65 "$USEZIP: Download failed"
					fi
					
				else
					abort_die 65 "Cannot download URL: $USEZIP: You need to install one of lftp, curl or wget (run again with --checkrequirements for more information"
				fi
				# Reverse earlier cd tmp
				ws_cd ..
			elif [[ -s "$ORIGDIR/$USEZIP" ]]; then
				NEWONE_FINDDIR="$ORIGDIR/"
			else
				NEWONE_FINDDIR=""
			fi
			# Check that this is a valid entity. Sets USETMP
			make_and_enter tmp
			EXTRA_ZIP_OPT=""
			[[ $METAMODE = "core" ]] && EXTRA_ZIP_OPT="wordpress/wp-includes/version.php"
			# This sets USETMP and enters us into an unzipped directory
			extract_prospective_zip "${NEWONE_FINDDIR}${USEZIP}" $EXTRA_ZIP_OPT
			# Check it is a valid plugin/theme/core
			get_entity_version
			EXTRACTED_SLUG=`basename $(pwd)`
			# Return to tmp
			ws_cd ../..
			# Remove the extracted plugin
			rm -rf $USETMP
			if [ $FOUNDPLUG -eq 0 ]; then
				[[ $NEWONE_FINDDIR = "./" ]] && rm -f $USEZIP
				abort_die 63 "Could not find a valid $METAMODE inside this zip file ($USEZIP)"
			fi
			[[ $DEBUG -ge 1 ]] && ws_event_info "Found valid $METAMODE in $USEZIP: name=$PNAME, version=$PVER, slug=$EXTRACTED_SLUG)"
			if [[ -n $PLUGIN && $PLUGIN != $EXTRACTED_SLUG ]]; then
				[[ $NEWONE_FINDDIR = "./" ]] && rm -f $USEZIP
				abort_die 64 "$METAMODE slug of given zip ($EXTRACTED_SLUG) does not match that given on the command line ($PLUGIN)"
			fi
			# Return to working directory
			ws_cd ..
			# Rename it to the proper filename scheme; also reduce $USEZIP to that new name
			if [[ $NEWONE_FINDDIR = "./" ]]; then
				mv -f $COPYOPT "tmp/$USEZIP" "customimports.$METAMODE/$EXTRACTED_SLUG.$PVER.zip" || exit $?
			else
				cp -f $COPYOPT "${NEWONE_FINDDIR}${USEZIP}" "customimports.$METAMODE/$EXTRACTED_SLUG.$PVER.zip" || exit $?
			fi
			USEZIP="$EXTRACTED_SLUG.$PVER.zip"
			NEWZIPSOURCE="customimports.$METAMODE"
		elif [[ -s "fromwporg.$METAMODE/$USEZIP" ]]; then
			# Note - this may actually be a directory when specifying a version with core; we deal with that later
			true
		elif [[ -s "fromwporg.$METAMODE/$PLUGIN.$USEZIP.zip" ]]; then
			APPARENT_NEW_VERSION=$USEZIP
			USEZIP="$PLUGIN.$USEZIP.zip"
		elif [[ ! $USEZIP =~ \.zip$ && ( ( $METAMODE = "core" && $USEZIP =~ ^([0-9][0-9a-z\.]+)(-(alpha|beta)[0-9])?$ ) || ( -n $PLUGIN && $USEZIP =~ ^([0-9][0-9a-z\.]+)$ ) ) ]]; then
			# Attempt to download this version from WordPress.Org...
			download_version "$PLUGIN" $USEZIP || exit 44
			APPARENT_NEW_VERSION=$USEZIP
			USEZIP=$PLUGIN.$USEZIP.zip
		else
			ws_event_error "site:${SITE}, ${METAMODE}:${PLUGIN}, --new=$USEZIP: Could not find a suitable zip file (either specify a version of an already-known $METAMODE, or to retrieve afresh from wordpress.org (e.g. --new=1.3.2), or a path or URL to a zip file (e.g. --new=myfolder/my${METAMODE}.1.5.zip))"
			exit 44
		fi
	fi
fi

ACCESSMETHOD=""
FILEDIR=""
FTPHOST=""
FTPPASS=""

# Setup now finished - into the actions

# This next section ensures existence of tmp
if [[ $SELFINVOCATION -eq 0 ]] ; then
	# This is required for caching url_post output
	mkdir -p lftp
	# Default lftp configuration - allow (but not force) TLS, plus a few other useful ones
	[[ ! -f lftp/rc && -n $LFTP ]] && echo "set ftp:list-options -a
set net:reconnect-interval-base 3
set net:reconnect-interval-multiplier 2
set net:reconnect-interval-max 300
set net:max-retries 9
set ftp:ssl-protect-data yes
set ftp:ssl-protect-list yes
# Note that the ftp:ssl-allow and ftp:ssl-force options are over-written afresh at run-time; changing them here will have no effect (the combination depends on site options and upon --disableftptls and --requireftptls)
set ftp:ssl-allow yes
set ftp:ssl-force no" >lftp/rc
	make_and_enter tmp
	# Clean up
	[[ $DEBUG -ge 1 ]] && ws_event_info "Cleaning up tmp directory"
	find . -maxdepth 1 -mtime +1 -type d -regex './[A-Za-z0-9].*' -exec rm -rf {} \;
	find . -maxdepth 1 -mtime +1 -type f -exec rm -f {} \;
	ws_cd ..
fi

function version_sort() {
# Return values:
# 0 = first was bigger
# 1 = equal
# 2 = second was bigger
# Handles numbers, periods, and <num>(-)<rc|alpha|beta><num>

	local FIRST=$1
	local SECOND=$2

	[[ $FIRST = $SECOND ]] && return 1

	local NEXTFIRST="0"
	local NEXTSECOND="0"
	local REMFIRST=""
	local REMSECOND=""

	# Discard anything after a space (3rd Dec 2012)
	local MATCHSREGEX='^([^ ]+) '
	[[ $FIRST =~ $MATCHSREGEX ]] && FIRST=${BASH_REMATCH[1]}
	[[ $SECOND =~ $MATCHSREGEX ]] && SECOND=${BASH_REMATCH[1]}

	# Deal with starting with a period (3rd Dec 2012): treat it as zero
	[[ ${FIRST:0:1} = "." ]] && FIRST="0$FIRST"
	[[ ${SECOND:0:1} = "." ]] && SECOND="0$SECOND"

	# Remove any leading v - seen 14th January 2012
	[[ ${FIRST:0:1} = "v" ]] && FIRST=${FIRST:1}
	[[ ${SECOND:0:1} = "v" ]] && SECOND=${SECOND:1}

	# Split off before the period - get this segment
	# Strip leading zeroes (added 24th Sep 2012)
	local MATCHREGEX='^([0-9]+)\.(.*)$'
	if [[ $FIRST =~ $MATCHREGEX ]]; then
		FIRST=${BASH_REMATCH[1]}
		NEXTFIRST=${BASH_REMATCH[2]}
	fi
	if [[ $SECOND =~ $MATCHREGEX ]]; then
		SECOND=${BASH_REMATCH[1]}
		NEXTSECOND=${BASH_REMATCH[2]}
	fi

	# Ignore anything after the numbers in pattern (number)(letter)(anything)
	local MATCHREGEX2='^([0-9]+)([-A-Za-z][-A-Za-z0-9]*)$'
	if [[ $FIRST =~ $MATCHREGEX2 ]]; then FIRST=${BASH_REMATCH[1]}; REMFIRST=${BASH_REMATCH[2]}; fi
	if [[ $SECOND =~ $MATCHREGEX2 ]]; then SECOND=${BASH_REMATCH[1]}; REMSECOND=${BASH_REMATCH[2]}; fi

	[[ $FIRST -gt $SECOND ]] && return 0
	[[ $FIRST -lt $SECOND ]] && return 2

	# Now have to deal with the fact that something like 0.2rc1 is less than 0.2

	local FIRST_RC=0
	if [[ $FIRST = $SECOND ]]; then
		if [[ $REMFIRST =~ ^-?[rR][cC](.*)$ ]]; then
			NEXTFIRST="2.${BASH_REMATCH[1]}"
			FIRST_RC=3
		elif [[ $REMFIRST =~ ^-?[aA][lL][pP][hH][aA]-?(.*)$ ]]; then
			NEXTFIRST="0.${BASH_REMATCH[1]}"
			FIRST_RC=2
		elif [[ $REMFIRST =~ ^-?[bB][eE][tT][aA]-?(.*)$ ]]; then
			NEXTFIRST="1.${BASH_REMATCH[1]}"
			FIRST_RC=1
		fi
		# Is the second an rc? 
		if [[ $REMSECOND =~ ^-?[rR][cC](.*)$ ]]; then
			# Is an RC. If first part was not, then first is greater
			[[ $FIRST_RC -eq 0 ]] && return 0
			NEXTSECOND="2.${BASH_REMATCH[1]}"
		elif [[ $REMSECOND =~ ^-?[aA][lL][pP][hH][aA](.*)$ ]]; then
			# Is an alpha
			[[ $FIRST_RC -eq 0 ]] && return 0
			NEXTSECOND="0.${BASH_REMATCH[1]}"
		elif [[ $REMSECOND =~ ^-?[bB][eE][tT][aA](.*)$ ]]; then
			# Is a beta
			[[ $FIRST_RC -eq 0 ]] && return 0
			NEXTSECOND="1.${BASH_REMATCH[1]}"
		elif [ $FIRST_RC -ge 1 ]; then
			# First was an RC/alpha/beta, this is not. So this is later.
			return 2
		fi
	fi

	[[ $NEXTFIRST =~ ^0[0-9] ]] && NEXTFIRST=${NEXTFIRST:1}
	[[ $NEXTSECOND =~ ^0[0-9] ]] && NEXTSECOND=${NEXTSECOND:1}

	version_sort $NEXTFIRST $NEXTSECOND

}


function url_browser() {
# Input: $1=URL
# We assume a browser is available
	if [[ -n $W3M ]]; then
		$W3M "$1"
	elif [[ -n $ELINKS ]]; then
		$ELINKS "$1"
	else
		$LYNX "$1"
	fi
}

function get_api_changelog() {
	# Core-friendly: only if calling with "changelog" (not description/download_link)
	# Input: $1 = plugin slug
	# $2 = changelog | description | download_link | last_updated

	if [[ $CAN_BROWSE -ne 1 ]]; then
		ws_event_error "Cannot find a working w3m, elinks or lynx, needed to display output (run with --checkrequirements or --debug for more information)"
		return 5
	elif [[ $CAN_URLGET -eq 0 ]]; then
		ws_event_error "Cannot find a working lftp, wget or curl, needed to get API info (run with --checkrequirements or --debug for more information)"
		return 5
	fi

	local CHANGELOG_PLUGIN=$1
	local SHOW_WHAT=$2
	if [[ $DISABLEAPI -eq 1 || -z $PHP || $METAMODE = "core" ]]; then
		if [[ $DISABLEAPI -eq 1 ]]; then ws_event_info "API was disabled via --disableapi; so will use text browser instead"
		elif [[ -z $PHP ]]; then ws_event_info "No php binary found (run with --debug for more information); so will use text browser instead"
		fi
		if [[ $SHOW_WHAT = "changelog" ]]; then
			if [[ $METAMODE = "core" ]]; then
				url_browser http://codex.wordpress.org/Category:Changelogs
			else
				url_browser https://wordpress.org/${METAMODE}s/$CHANGELOG_PLUGIN/changelog
			fi
		else
			url_browser https://wordpress.org/${METAMODE}s/$CHANGELOG_PLUGIN
		fi
		return
	fi

	SERIALTMP=`mktemp TMP-WPAPI.XXXXX` || exit 67

	SLUG=$1
	SLUGLEN=${#SLUG}

	URL_STRING="action=${METAMODE}_information&request=O:8:\"stdClass\":2:{s:4:\"slug\";s:$SLUGLEN:\"$SLUG\";s:8:\"per_page\";i:24;}"

	# Don't prefer lftp, because of its extraneous HEAD requests which cause 500s on /themes/info/1.0/
	url_post http://api.wordpress.org /${METAMODE}s/info/1.0/ "$URL_STRING" preferwget,prefercurl >$SERIALTMP

	if [[ -s "$SERIALTMP" ]]; then
		grep -q $SHOW_WHAT $SERIALTMP
		if [ $? -ne 0 ]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "API call did not result in file in expected format"
			echo "$SLUG: Could not find a $SHOW_WHAT for this ${METAMODE}" >/dev/stderr
			ws_event_notice "$SLUG: Could not find a $SHOW_WHAT for this ${METAMODE}"
			rm -f $SERIALTMP
			return 3
		fi

		if [[ $SHOW_WHAT = "changelog" ]]; then
			if [[ -n $W3M ]]; then
				( echo "<h1>Changelog for ${METAMODE}: $CHANGELOG_PLUGIN (Q to quit)</h1>" ; $PHP -r "\$o=unserialize(file_get_contents(\"$SERIALTMP\"));\$a=\$o->sections;print \$a['changelog'].\"\n\";" ) | $W3M -T text/html
			elif [[ -n $ELINKS ]]; then
				( echo "<h1>Changelog for ${METAMODE}: $CHANGELOG_PLUGIN (Q to quit)</h1>" ; $PHP -r "\$o=unserialize(file_get_contents(\"$SERIALTMP\"));\$a=\$o->sections;print \$a['changelog'].\"\n\";" ) | $ELINKS -force-html
			else
				( echo "<h1>Changelog for ${METAMODE}: $CHANGELOG_PLUGIN (Q to quit)</h1>" ; $PHP -r "\$o=unserialize(file_get_contents(\"$SERIALTMP\"));\$a=\$o->sections;print \$a['changelog'].\"\n\";" ) | $LYNX -force_html -stdin
			fi
		elif [[ $SHOW_WHAT = "description" ]]; then
			if [[ -n $W3M ]]; then
				( echo "<h1>Description for ${METAMODE}: $CHANGELOG_PLUGIN (Q to quit)</h1>" ; $PHP -r "\$o=unserialize(file_get_contents(\"$SERIALTMP\"));\$a=\$o->sections;print \$a['description'].\"\n\";" ) | $W3M -T text/html
			elif [[ -n $ELINKS ]]; then
				( echo "<h1>Description for ${METAMODE}: $CHANGELOG_PLUGIN (Q to quit)</h1>" ; $PHP -r "\$o=unserialize(file_get_contents(\"$SERIALTMP\"));\$a=\$o->sections;print \$a['description'].\"\n\";" ) | $ELINKS -force-html
			else
				( echo "<h1>Description for ${METAMODE}: $CHANGELOG_PLUGIN (Q to quit)</h1>" ; $PHP -r "\$o=unserialize(file_get_contents(\"$SERIALTMP\"));\$a=\$o->sections;print \$a['description'].\"\n\";" ) | $LYNX -force_html -stdin
			fi
		elif [[ $SHOW_WHAT = "download_link" || $SHOW_WHAT = "last_updated" ]]; then
			$PHP -r "\$o=unserialize(file_get_contents(\"$SERIALTMP\"));\$a=\$o->${SHOW_WHAT};print \$a.\"\n\";"
		fi
	else
		rm -f $SERIALTMP
		echo "$SLUG: Could not find a $SHOW_WHAT for this ${METAMODE}" >/dev/stderr
		ws_event_notice "$SLUG: Could not find a $SHOW_WHAT for this ${METAMODE}"
		return 2
	fi

	rm -f $SERIALTMP
	return 0

}

function get_api_entity_info() {
# Core-friendly: yes
# Input: $1 = entity slug
# Optional: $2 = plugin file, if known : will then use faster plugins/update-check API call instead of plugins/info
# If $2 specified, then must also specify $3 = plugin version and $4 = plugin name
# Output: Exit code = 0 success / else failure - 6 indicates that we got a reply back, which was null (indicates no such plugin)
# If success, sets API_PLUGIN_URL and API_PLUGIN_VER and API_PLUGIN_NAME

	local SLUG=$1

	unset API_PLUGIN_URL API_PLUGIN_VER API_PLUGIN_NAME API_PLUGIN_NOTICE

	# First, look in the cache
	API_INFO_CACHEFILE="$WORKINGDIR_FULL/tmp/cache-info-$METAMODE-$SLUG"
	if [[ $DISABLECACHE -eq 0 && -s $API_INFO_CACHEFILE && $((NOWDATE - `$STAT_MODTIME $API_INFO_CACHEFILE 2>/dev/null || echo 0`)) -lt 3600 ]]; then
		if [[ $METAMODE = "core" ]]; then
			head -1 $API_INFO_CACHEFILE | read API_PLUGIN_VER MINIMUM_PHP_VERSION API_PLUGIN_URL API_PLUGIN_NAME MINIMUM_MYSQL_VERSION
		else
			head -1 $API_INFO_CACHEFILE | read API_PLUGIN_VER API_PLUGIN_URL API_PLUGIN_NAME MINIMUM_WP_VERSION
		fi
		API_PLUGIN_NOTICE=`tail -n +2 $API_INFO_CACHEFILE`
		# If cache had valid data
		if [[ -n $API_PLUGIN_NAME && -n $API_PLUGIN_URL && -n $API_PLUGIN_VER ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Found valid API cache file: $API_INFO_CACHEFILE"
			return 0
		fi
		if [ "$API_PLUGIN_VER" = "N;" ]; then
			unset API_PLUGIN_VER
			return 6
		fi
		
	fi
	
	if [ $DISABLEAPI -eq 1 ]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "API was disabled via --disableapi"
		return 5
	fi

	if [[ $METAMODE = "core" ]]; then
		# From version 1.6 onwards, it sends serialized (and richer) data
		# If we ever switch to using that, we need to change callers of this function to check for $PHP
		local CACHE_CVCFILE="$WORKINGDIR_FULL/tmp/cache-info-core-version-check"
		if [[ $DISABLECACHE -eq 1 || ! -s $CACHE_CVCFILE || $((NOWDATE - `$STAT_MODTIME "$CACHE_CVCFILE" 2>/dev/null || echo 0`)) -ge 3600 ]]; then
			url_get http://api.wordpress.org/core/version-check/1.5/ stdout >"$CACHE_CVCFILE.tmp"
			if [[ -s "$CACHE_CVCFILE.tmp" ]]; then
				mv "$CACHE_CVCFILE.tmp" "$CACHE_CVCFILE"
			else
				rm -f "$CACHE_CVCFILE.tmp"
			fi
		else
			[[ $DEBUG -ge 1 ]] && ws_event_info "Version check was cached within last hour; using that ($CACHE_CVCFILE)"
		fi
		if [[ -s $CACHE_CVCFILE ]]; then
			local TESTIT=`head -1 $CACHE_CVCFILE`
			local TESTVER=`head -4 $CACHE_CVCFILE | tail -1`
			local API_RET=10
			if [[ $TESTIT = "upgrade" && $TESTVER =~ ^[0-9]+\. ]]; then
				MINIMUM_MYSQL_VERSION=`head -7 $CACHE_CVCFILE | tail -1`
				MINIMUM_PHP_VERSION=`head -6 $CACHE_CVCFILE | tail -1`
				API_PLUGIN_VER=$TESTVER
				API_PLUGIN_URL=`head -3 $CACHE_CVCFILE | tail -1`
				API_PLUGIN_NAME="WordPress Core"
				API_PLUGIN_NOTICE=""
				echo "$API_PLUGIN_VER $MINIMUM_PHP_VERSION $API_PLUGIN_URL $API_PLUGIN_NAME $MINIMUM_MYSQL_VERSION" >"$API_INFO_CACHEFILE"
				API_RET=0
			else
				[[ $DEBUG -ge 1 ]] && ws_event_notice "Core version check: Did not get the expected response from api.wordpress.org (response was: `cat $CACHE_CVCFILE`)"
			fi
		else
			ws_event_error "Unable to discern the latest WordPress core version by querying api.wordpress.org"
			API_RET=10
		fi
		return $API_RET
	fi

	# Core meta-mode has returned; now we know we are in plugin/theme meta-mode
	[[ -z $PHP ]] && return 1

	SERIALTMP=`mktemp TMP-WPAPI2.XXXXX` || exit 67

	SLUGLEN=${#SLUG}

	# Were we advised a file name?
	if [[ -n $2 && -n $3 && -n $4 ]]; then
		local PLUGVER=$3
		local PLUGVERLEN=${#PLUGVER}
		local PLUGNAME=$4
		local PLUGNAMELEN=${#PLUGNAME}
		local PLUGFILE=$2
		local PLUGFILELEN=${#PLUGFILE}

		# plugins=O:8:"stdClass":2:{s:7:"plugins";a:1:{s:51:"simple-social-bookmarks/simple-social-bookmarks;a:2:{s:4:"Name";s:23:"Simple Social Bookmarks";s:7:"Version";s:5:"3.2.2";}}s:6:"active";a:1:{i:0;s:51:"simple-social-bookmarks/simple-social-bookmarks.php";}}
		# We don't send our current version, but rather send 0 because we want a definite reply
		local METAMODE_LEN=$((${#METAMODE}+1))
		if [[ $METAMODE = "plugin" ]]; then
			local URL_STRING="${METAMODE}s=O:8:\"stdClass\":2:{s:${METAMODE_LEN}:\"${METAMODE}s\";a:1:{s:$PLUGFILELEN:\"$PLUGFILE\";a:2:{s:4:\"Name\";s:$PLUGNAMELEN:\"$PLUGNAME\";s:7:\"Version\";s:1:\"0\";}}s:6:\"active\";a:1:{i:0;s:$PLUGFILELEN:\"$PLUGFILE\";}}"
		else
			# themes=a:1:{s:10:"responsive";a:6:{s:4:"Name";s:10:"Responsive";s:7:"Version";s:5:"1.4.7";s:5:"Title";s:10:"Responsive";s:8:"Template";s:10:"responsive";s:10:"Stylesheet";s:10:"responsive";s:12:"Parent Theme";s:0:"";}}
			local URL_STRING="${METAMODE}s=a:1:{s:$PLUGFILELEN:\"$PLUGFILE\";a:6:{s:4:\"Name\";s:$PLUGNAMELEN:\"$PLUGNAME\";s:7:\"Version\";s:$PLUGVERLEN:\"$PLUGVER\";s:5:\"Title\";s:$PLUGNAMELEN:\"$PLUGNAME\";s:8:\"Template\";s:$PLUGFILELEN:\"$PLUGNAME\";s:10:\"Stylesheet\";s:$PLUGFILELEN:\"$PLUGFILE\";s:12:\"Parent Theme\";s:0:\"\";}}"
		fi
		if [[ $CAN_URLGET -eq 1 ]]; then
			url_post http://api.wordpress.org /${METAMODE}s/update-check/1.0/ "$URL_STRING" >$SERIALTMP
		else
			ws_event_error "No working lftp, wget or curl was found; could not get ${METAMODE} API info"
		fi
		if [[ -s $SERIALTMP ]]; then
			FIRSTL_OF_RESULT="`head -1 $SERIALTMP`"
			if [[ $FIRSTL_OF_RESULT  = "N;" ]]; then
				rm -f $SERIALTMP
				[[ $DEBUG -ge 1 ]] && ws_event_info "$SLUG: This ${METAMODE} is unknown at api.wordpress.org"
				echo "N;" >"$API_INFO_CACHEFILE"
				return 6
			fi
			if [[ $FIRSTL_OF_RESULT =~ stdClass ]]; then
				local OLDIFS="$IFS"
				# Newline
				IFS="
"
				for LINE in $($PHP -r "\$obj=unserialize(file_get_contents(\"$SERIALTMP\")); if (isset(\$obj[\"$PLUGFILE\"]->upgrade_notice)) {print \"Notice:\".\$obj[\"$PLUGFILE\"]->upgrade_notice.\"\n\";};  print \"Version:\".\$obj[\"$PLUGFILE\"]->new_version; print \"\nDownload:\".\$obj[\"$PLUGFILE\"]->package.\"\n\"; if (isset(\$obj[\"$PLUGFILE\"]->requires)) { print \"MinWP:\".\$obj[\"$PLUGFILE\"]->requires.\"\n\"; }"); do
					if [[ $LINE =~ Version:(.*)$ ]]; then API_PLUGIN_VER=${BASH_REMATCH[1]}
					elif [[ $LINE =~ Notice:(.*)$ ]]; then API_PLUGIN_NOTICE=${BASH_REMATCH[1]};
					elif [[ $LINE =~ Download:(.*)$ ]]; then API_PLUGIN_URL=${BASH_REMATCH[1]};
					elif [[ $LINE =~ MinWP:(.*)$ ]]; then MINIMUM_WP_VERSION=${BASH_REMATCH[1]};
					fi
					# As this is not returned, we just assume it is unchanged
					API_PLUGIN_NAME="$PLUGNAME"
				done
				IFS="$OLDIFS"
			fi
		fi
		# Truncate, as later the file is used + tested again
		echo -n >$SERIALTMP
	fi

	# Try the other way
		if [[ -z $API_PLUGIN_NAME || -z $API_PLUGIN_VER || -z $API_PLUGIN_URL ]]; then
		URL_STRING="action=${METAMODE}_information&request=O:8:\"stdClass\":2:{s:4:\"slug\";s:$SLUGLEN:\"$SLUG\";s:8:\"per_page\";i:24;}"
		# Prefer wget or curl, because lftp uses HEAD which results in a 500 and (harmless) error output on /themes/info/1.0/
		[[ $CAN_URLGET -eq 1 ]] && url_post http://api.wordpress.org /${METAMODE}s/info/1.0/ "$URL_STRING" preferwget,prefercurl >$SERIALTMP
		if [[ -s $SERIALTMP ]]; then
			FIRSTL_OF_RESULT="`head -1 $SERIALTMP`"
			if [[ $FIRSTL_OF_RESULT  = "N;" ]]; then
				rm -f $SERIALTMP
				[[ $DEBUG -ge 1 ]] && ws_event_info "$SLUG: This ${METAMODE} is unknown at api.wordpress.org"
				echo "N;" >"$API_INFO_CACHEFILE"
				return 6
			fi
			if [[ ! $FIRSTL_OF_RESULT =~ stdClass ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "API call did not result in file in expected format ($SERIALTMP)"
				rm -f $SERIALTMP
				return 3
			fi
			local OLDIFS2="$IFS"
			# Newline
			IFS="
"
			for LINE in $($PHP -r "\$obj=unserialize(file_get_contents(\"$SERIALTMP\")); print \"Version:\".\$obj->version.\"\nDownload:\".\$obj->download_link.\"\nName:\".\$obj->name.\"\n\"; if (isset(\$obj->requires)) print \"MinWP:\".\$obj->requires.\"\n\";"); do
				if [[ $LINE =~ Version:(.*)$ ]]; then API_PLUGIN_VER=${BASH_REMATCH[1]}
				elif [[ $LINE =~ Download:(.*)$ ]]; then API_PLUGIN_URL=${BASH_REMATCH[1]};
				elif [[ $LINE =~ Name:(.*)$ ]]; then API_PLUGIN_NAME=${BASH_REMATCH[1]};
				elif [[ $LINE =~ MinWP:(.*)$ ]]; then MINIMUM_WP_VERSION=${BASH_REMATCH[1]};
				fi
			done
			IFS="$OLDIFS2"
		else
			rm -f $SERIALTMP
			return 2
		fi
	fi

	# Tidy up and either write out results to cache or return error
	rm -f $SERIALTMP
	[[ -z "$API_PLUGIN_VER" || -z "$API_PLUGIN_URL" || -z "$API_PLUGIN_NAME" ]] && return 4
	echo "$API_PLUGIN_VER $API_PLUGIN_URL $API_PLUGIN_NAME $MINIMUM_WP_VERSION" >"$API_INFO_CACHEFILE"
	[[ -n $API_PLUGIN_NOTICE ]] && echo $API_PLUGIN_NOTICE >>"$API_INFO_CACHEFILE"
	return 0
}

function download_latest() {
# Core-friendly: yes
# Compatible with --trunk ($USETRUNK): yes
# Input: set variables:
# 1) $PLUGIN
# 2) $1 = allowed sources (wp = download.wordpress.org; any = anywhere we have access to - for now, customimports)
# 3) be in working directory;
# 4) Also: USETRUNK and METAMODE are consulted
# Output: $PVER $FOUNDPLUG Also if sources = wp then $PNAME is set (otherwise may be corrupted)
# Also if USEZIP="latest" then we update NEWZIPSOURCE if it was found in customimports
# Requires unzip, as we want to unzip and interrogate the version number
# Return code non-zero indicates error; return code of 6 indicates entity not known at wordpress.org
local ALLOWED_SOURCES=$1
DOWNLOAD_LATEST_RETCODE=0
unset PNAME PVER FOUNDPLUG

[[ $DEBUG -ge 1 ]] && ws_event_debug "download_latest: entity=$PLUGIN, sources=$1, caller=`caller`"

# We download into a temporary directory inside tmp
make_and_enter tmp
DOWNTMP=`mktemp -d TMP-DLATEST.XXXXX`
ws_cd $DOWNTMP

if [ $CAN_URLGET -eq 1 ]; then
	local TRY_URL=""
	# This next variable is only going to differ from `basename $TRY_URL` if the Version: and Stable: tags differ, which is a bad thing, but we have seen it once (Nov 2012) in the wordpress.org directory
	local DOWNLOADED_BASE_OVERRIDE=""
	API_SUCCESS=0
	NOT_KNOWN_AT_WP=0 # Only if we get a definite response to confirm that it is not known
	BE_SILENT_ON_DOWNLOAD_FAIL=0
	# First, see if we can get the version number from an api.wordpress.org call
	# API cannot tell us the latest trunk version
	# PHP is not needed in core mode, as there is still an older non-serialized API output available
	if [[ ( -n $PHP || $METAMODE = "core" ) && $USETRUNK -eq 0 ]]; then
		# Sets: API_PLUGIN_URL API_PLUGIN_VER API_PLUGIN_NAME
		get_api_entity_info "$PLUGIN"
		API_RET=$?
		if [ $API_RET -eq 0 ]; then
			API_SUCCESS=1
			# Do we have it cached already?
			if [[ -s "../../fromwporg.$METAMODE/$PLUGIN.$API_PLUGIN_VER.zip" ]]; then
				# When we test this later, we will find we already have it; no download will occur
				if [[ $METAMODE = "plugin" ]]; then
					TRY_URL="https://downloads.wordpress.org/plugin/$PLUGIN.$API_PLUGIN_VER.zip"
					DOWNLOADED_BASE_OVERRIDE="$PLUGIN.$API_PLUGIN_VER.zip"
				elif [[ $METAMODE = "theme" ]]; then
					TRY_URL="https://wordpress.org/themes/download/$PLUGIN.$API_PLUGIN_VER.zip"
					DOWNLOADED_BASE_OVERRIDE="$PLUGIN.$API_PLUGIN_VER.zip"
				else
					TRY_URL="https://wordpress.org/wordpress-$API_PLUGIN_VER.zip"
				fi
			else
				TRY_URL=$API_PLUGIN_URL
			fi
		elif [ $API_RET -eq 6 ]; then
			NOT_KNOWN_AT_WP=1
			BE_SILENT_ON_DOWNLOAD_FAIL=1
		else
			[[ $DEBUG -ge 1 ]] && ws_event_notice "API call returned failure code: $API_RET"
		fi
	fi
	# Special case; here is as good a place as any to put it
	if [[ $METAMODE = "core" && $USETRUNK -eq 1 ]]; then
		TRY_URL="http://core.trac.wordpress.org/changeset/latest/trunk?old_path=/&format=zip"
	elif [[ $NOT_KNOWN_AT_WP -eq 0 && ( -z $TRY_URL || $API_SUCCESS -eq 0 ) ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_warning "$PLUGIN: Could not get $METAMODE info from wordpress.org API; $METAMODE probably not available from wordpress.org"
		# Only worth trying this if the API is down
		# Note that this gets the latest trunk version, which can be different to the latest stable version
		BE_SILENT_ON_DOWNLOAD_FAIL=1
		if [[ $METAMODE = "plugin" ]]; then
			TRY_URL=https://downloads.wordpress.org/plugin/$PLUGIN.zip
		elif [[ $METAMODE = "theme" ]]; then
			TRY_URL=https://wordpress.org/themes/download/$PLUGIN.zip
		else
			# Note that https://wordpress.org/latest.zip.md5 does exist, so this is OK with the below
			TRY_URL=https://wordpress.org/latest.zip
		fi
	fi
	[[ $DEBUG -ge 1 && -n $TRY_URL ]] && ws_event_info "URL chosen to download: $TRY_URL"
	if [[ $METAMODE = "core" && $TRY_URL != "https://wordpress.org/latest.zip" ]]; then
		if [[ $USETRUNK -eq 0 ]]; then
			DOWNLOADED="wordpress.$API_PLUGIN_VER.zip"
		else
			# Remove the cached file when using --core --trunk if it is 30 minutes old
			DOWNLOADED="wordpress.trunk.zip"
			local WHEN_DOWNLOADED=../../fromwporg.core/$DOWNLOADED
			if [[ $DISABLECACHE -eq 1 || ( -f $WHEN_DOWNLOADED && $((NOWDATE - `$STAT_MODTIME $WHEN_DOWNLOADED 2>/dev/null|| echo 0`)) -ge 1800 ) ]]; then
				ws_event_debug "Cached file fromwporg.core/$DOWNLOADED exists, but either --disablecache was specified or the file is older than 30 minutes - will delete"
				rm -f $WHEN_DOWNLOADED
			fi
		fi
	else
		# This used to take the file name from the basename of TRY_URL (basename $TRY_URL) - then (Nov 2012) we encountered a plugin with differing Version: and Stable: fields.
		# The Version: was 'beta 1 (0.6)', whereas Stable:, which filtered into TRY_URL, was just 0.6
		if [[ -n $DOWNLOADED_BASE_OVERRIDE ]]; then
			DOWNLOADED=$DOWNLOADED_BASE_OVERRIDE
		else
			DOWNLOADED=`basename $TRY_URL 2>/dev/null`
		fi
	fi
	if [[ $NOT_KNOWN_AT_WP -eq 0 && -s "../../fromwporg.$METAMODE/$DOWNLOADED" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Found existing version already in fromwporg cache (fromwporg.$METAMODE/$DOWNLOADED); will copy"
		cp $COPYOPT "../../fromwporg.$METAMODE/$DOWNLOADED" .
	elif [[ $NOT_KNOWN_AT_WP -eq 0 ]]; then
		[[ -n $TRY_URL ]] && url_get "$TRY_URL" "$DOWNLOADED"
		# In core mode, we can checksum the download (unless it was a --trunk fetch)
		if [[ $METAMODE = "core" && $USETRUNK -eq 0 ]]; then
			[[ ! -s "../../fromwporg.$METAMODE/$DOWNLOADED.md5" ]] && url_get "$TRY_URL.md5" stdout >../../fromwporg.$METAMODE/$DOWNLOADED.md5
			local DOWNLOADED_MD5_DESIRED=`cat "../../fromwporg.$METAMODE/$DOWNLOADED.md5"`
			local DOWNLOADED_MD5_ACTUAL=`$CHECKSUM "$DOWNLOADED" | cut -d' ' -f1`
			if [[ -z $DOWNLOADED_MD5_DESIRED ]]; then
				echo "${BOLD}FAILED:${OFFBOLD} Could not successfully download the WordPress core checksum" >/dev/stderr
				ws_event_warning "Could not successfully download the WordPress core checksum"
				DOWNLOAD_LATEST_RETCODE=7
			else
				if [[ $DOWNLOADED_MD5_ACTUAL = $DOWNLOADED_MD5_DESIRED ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "Download good: Checksum of downloaded WordPress zip matched what was expected ($DOWNLOADED_MD5_DESIRED)"
				else
					echo "${BOLD}FAILED:${OFFBOLD} Checksum of downloaded WordPress zip ($DOWNLOADED_MD5_ACTUAL) did not match the expected value ($DOWNLOADED_MD5_DESIRED)" >/dev/stderr
					ws_event_warning "Checksum of downloaded WordPress zip ($DOWNLOADED_MD5_ACTUAL) did not match the expected value ($DOWNLOADED_MD5_DESIRED)"
					rm -f "$DOWNLOADED"
					DOWNLOADED=""
					DOWNLOAD_LATEST_RETCODE=8
				fi
			fi
		fi
	fi
	if [[ $NOT_KNOWN_AT_WP -eq 0 && -n $DOWNLOADED && -s $DOWNLOADED ]]; then
		if [ $API_SUCCESS -eq 1 ]; then
			# Save time - no need to unzip
			[[ $DEBUG -ge 1 ]] && ws_event_info "API found latest version as: $API_PLUGIN_VER"
			APPARENT_NEW_VERSION=$API_PLUGIN_VER
			FOUNDPLUG=1
			PVER=$API_PLUGIN_VER
			PNAME=$API_PLUGIN_NAME
			if [[ ! -e ../../fromwporg.$METAMODE/$PLUGIN.$PVER.zip ]]; then
				mv "$DOWNLOADED" "../../fromwporg.$METAMODE/$PLUGIN.$PVER.zip"
			fi
		else
			# API was not success
			if [[ -z $UNZIP ]]; then
				ws_event_info "could not unpack $METAMODE - unzip command not found (re-run with --debug for more information)"
				DOWNLOAD_LATEST_RETCODE=5
			else
				local EXTRAZIP_OPT=""
				if [[ $METAMODE = "core" ]]; then
					if [[ $USETRUNK -eq 1 ]]; then
						EXTRAZIP_OPT="trunk/wp-includes/version.php"
					else
						EXTRAZIP_OPT="wordpress/wp-includes/version.php"
					fi
				fi
				ws_event_info "Unpacking: $DOWNLOADED"
				$UNZIP $UNZIPOPT "$DOWNLOADED" $EXTRAZIP_OPT
				RETCODE=$?
				# The --trunk download is packed in a directory called "trunk"; move it
				[[ $USETRUNK -eq 1 && $METAMODE = "core" ]] && mv trunk $PLUGIN
				if [ $RETCODE -ne 0 ]; then
					ws_event_error "Unzip command returned error (code: $RETCODE)"
					DOWNLOAD_LATEST_RETCODE=4
				elif [ -d $PLUGIN ]; then
					ws_cd $PLUGIN
					# Sets FOUNDPLUG, PVER, PNAME
					get_entity_version
					[[ $DEBUG -ge 1 ]] && ws_event_info "Downloaded $METAMODE is: $PNAME: $PVER"
					ws_cd ..
					rm -rf $PLUGIN
					if [[ $METAMODE = "core" && $USETRUNK -eq 1 ]]; then
						mv "$DOWNLOADED" "../../fromwporg.core/wordpress.trunk.zip"
					else
						if [[ ! -e ../../fromwporg.$METAMODE/$PLUGIN.$PVER.zip ]]; then
							mv "$DOWNLOADED" "../../fromwporg.$METAMODE/$PLUGIN.$PVER.zip"
						fi
					fi
				else
					ws_event_error "Expected directory $PLUGIN not found (in $WORKDIR/tmp/$DOWNTMP)"
					DOWNLOAD_LATEST_RETCODE=3
				fi
			fi
		fi
	else
		# This code indicates, that the entity was not found on WordPress.Org (and that we tried - not just some other failure)
		DOWNLOAD_LATEST_RETCODE=2
		[[ $NOT_KNOWN_AT_WP -eq 1 ]] && DOWNLOAD_LATEST_RETCODE=6
		[[ $BE_SILENT_ON_DOWNLOAD_FAIL -eq 0 ]] && ws_event_info "$PLUGIN: Could not find latest version of $METAMODE ($PLUGIN.zip)"
	fi

else

	ws_event_info "$PLUGIN: Could not download/check latest version of $METAMODE at wordpress.org: lftp and wget and curl not found (run with --debug or --checkrequirements for more information)"
	DOWNLOAD_LATEST_RETCODE=1

fi

# Back into tmp
ws_cd ..
# Remove the temporary directory (by now any downloaded entity has been moved into the proper cache directory)
rm -rf $DOWNTMP

# Back into working directory
ws_cd ..

# Look in customimports for a later version, unless it was --core --trunk
if [[ $ALLOWED_SOURCES = "any" && ( $METAMODE != "core" || $USETRUNK -eq 0 ) ]]; then
	# If there is and if USEZIP=latest, re-set NEWZIPSOURCE
	# Also, re-set DOWNLOAD_LATEST_RETCODE if we manage to find a plugin successfully
	local REGEXF="customimports.$METAMODE/$PLUGIN\.[0-9a-z\.]+\.zip"
	for KNOWNNEW in `find customimports.$METAMODE -maxdepth 1 -regex $REGEXF`; do
		# We assume that plugins in this directory are accurately named (since we name then when we copy in)
		if [[ $KNOWNNEW =~ customimports.$METAMODE/$PLUGIN\.([0-9a-z\.]+)\.zip$ ]]; then
			local THIS_VERSION=${BASH_REMATCH[1]}
			[[ -n $PVER ]] && version_sort $PVER $THIS_VERSION
			if [ $? -eq 2 -o -z "$PVER" ]; then
				APPARENT_NEW_VERSION=$THIS_VERSION
				PVER=$THIS_VERSION
				FOUNDPLUG=1
				DOWNLOAD_LATEST_RETCODE=0
				[[ $USEZIP = "latest" ]] && NEWZIPSOURCE="customimports.$METAMODE"
			fi
		fi
	done
fi

return $DOWNLOAD_LATEST_RETCODE

}

function choose_new_zip() {
# Core-friendly: yes
# Input: Looks at variable $PLUGIN (may be empty in install mode)
# Output: Function sets return code and places the name of the zip file chosen in $USEZIP (except in restore mode)
EXTRABLURB="same-name "
[[ -z "$PLUGIN" ]] && EXTRABLURB=""
echo -n "${BOLD}Already downloaded ${EXTRABLURB}versions: ${OFFBOLD}"
make_and_enter customimports.$METAMODE
make_and_enter ../fromwporg.$METAMODE
USEZIP=""
FIRSTSHOW=1
while [ -z "$USEZIP" ]; do
	ANY=`find . ../customimports.$METAMODE -regex ".*/$PLUGIN\.[0-9][-0-9a-zA-Z\.]*\.zip$" | cut -c3-`
	if [ -n "$ANY" ]; then
		# Only query the ones from fromwporg (wanting to get info on latest version)
		if [[ $DISABLEAPI -eq 0 && -n "$PLUGIN" && ${ANY:0:1} != "/" ]]; then
			get_api_entity_info $PLUGIN
			API_RETSHOW=$?
		else
			API_RETSHOW=-1
		fi
		for POTZIP in `find . ../customimports.$METAMODE -regex ".*/$PLUGIN\.[0-9][-0-9a-zA-Z\.]*\.zip$" | sort | cut -c3-`; do
			if [[ $POTZIP =~ ^(/customimports.$METAMODE/)?$PLUGIN\.([0-9][-0-9a-zA-Z\.]+)\.zip$ ]]; then
				FOUNDTHISVER=${BASH_REMATCH[2]}
				if [ $DISABLEAPI -eq 0 -a "$FOUNDTHISVER" = "$API_PLUGIN_VER" -a "$API_RETSHOW" -eq 0 ]; then
					echo -n "$FOUNDTHISVER(=latest) "
				else
					if [[ $BASH_REMATCH = "/customimports.$METAMODE/" ]]; then
						echo -n "$FOUNDTHISVER(custom) "
					else
						echo -n "$FOUNDTHISVER "
					fi
				fi
			fi
		done
		echo
	elif [ $FIRSTSHOW -eq 1 ]; then
		echo "(none)"
		FIRSTSHOW=0
	fi
	EXTRABLURB2="or a new version number to download from wordpress.org, or latest to download latest,"
	# This next line cannot trigger with --core --install
	local ALLOW_RESTORE=0
	if [[ -n $PLUGIN && ( ( $METAMODE != "core" && -d "../current/$SITE/{$METAMODE}s/$PLUGIN" ) || ( $METAMODE = "core" && -d "../current/$SITE/core/wp-includes" ) ) ]]; then
		EXTRABLURB2="$EXTRABLURB2 or restore to install the present backup,"
		ALLOW_RESTORE=1
	fi
	local ALLOW_ROLLBACK
	if [[ $METAMODE != "core" || $MODE != "install" ]]; then
		ALLOW_ROLLBACK=1
		EXTRABLURB2="$EXTRABLURB2 or rollback to show old versions "
	fi
	EXTRABLURB2="$EXTRABLURB2 or changelog/description, or all to show more zips, "
	[[ -z $PLUGIN ]] && EXTRABLURB2=""
	read -p "${BOLD}Version to use (${EXTRABLURB2}or w3m to try download page):${OFFBOLD} " USEZIP
	if [ "$USEZIP" = "all" -a -n "$PLUGIN" ]; then
		echo "(Enter the full file name to select a zip to use)"
		ls [a-z0-9]*zip
		unset USEZIP
	elif [[ ( "$USEZIP" = "changelog" || "$USEZIP" = "ch" || "$USEZIP" = "c" ) && -n "$PLUGIN" ]]; then
		get_api_changelog $PLUGIN changelog
		unset USEZIP
	elif [[ ( "$USEZIP" = "description" || "$USEZIP" = "de" || "$USEZIP" = "d" ) && -n "$PLUGIN" ]]; then
		if [[ $METAMODE = "core" ]]; then
			echo "WordPress core"
		else
			get_api_changelog $PLUGIN description
		fi
		unset USEZIP
	elif [[ $USEZIP = "restore" && $ALLOW_RESTORE -eq 1 ]]; then
		if [[ ( $METAMODE != "core" && -d "../current/$SITE/${METAMODE_DIR}s/$PLUGIN" ) || ( $METAMODE = "core" && -d "../current/$SITE/core/wp-includes" ) ]]; then
			[[ $DEBUG -ge 1 && $PLUGIN_OR_THEME_MODE -eq 1 ]] && ws_event_info "Selected current backup to restore ($WORKINGDIR_FULL/current/$SITE/${METAMODE}s/$PLUGIN)"
			[[ $DEBUG -ge 1 && $METAMODE = "core" ]] && ws_event_info "Selected current backup to restore ($WORKINGDIR_FULL/current/$SITE/core)"
			MODE="restore"; CACHE=2;
			# This is just to get us out of the loop - gets reset later
			USEZIP="restore"
		else
			[[ $PLUGIN_OR_THEME_MODE -eq 1 ]] && ws_event_error "Could not find a current backup to restore ($WORKINGDIR_FULL/current/$SITE/${METAMODE}s/$PLUGIN)"
			[[ $METAMODE = "core" ]] && ws_event_error "Could not find a current backup to restore ($WORKINGDIR_FULL/current/$SITE/core)"
			unset USEZIP
		fi
	elif [[  ( $USEZIP = "rollback" || $USEZIP = "ro" || $USEZIP = "r" ) && -n $PLUGIN && $ALLOW_ROLLBACK -eq 1 ]]; then
		ws_pushd ..
		choose_rollback
		ws_popd
	elif [[ ( "$USEZIP" = "latest" || "$USEZIP" = "la" || "$USEZIP" = "l" ) && -n $PLUGIN ]]; then
		ws_cd ..
		download_latest any
		ws_cd $NEWZIPSOURCE
		if [ "$FOUNDPLUG" = "1" ]; then
			[[ $DEBUG -eq 1 || $MODE = "downloadonly" ]] && echo "${BOLD}Downloaded version:${OFFBOLD} $PVER"
			if [[ -s "$PLUGIN.$PVER.zip" ]]; then
				USEZIP="$PLUGIN.$PVER.zip"
			else
				ws_event_error "Could not find expected file: $USEZIP (in $WORKDIR/$NEWZIPSOURCE)"
				unset USEZIP
			fi
		else
			ws_event_error "Download failed"
			unset USEZIP
		fi
	elif [[ $USEZIP =~ ^([0-9][-0-9A-Za-z\.]*)$ && ! $USEZIP =~ \.zip$ && -n $PLUGIN ]]; then
		if [ -f ../customimports.$METAMODE/$PLUGIN.$USEZIP.zip ]; then
			USEZIP="$PLUGIN.$USEZIP.zip"
			NEWZIPSOURCE="customimports.$METAMODE"
		elif [ -f $PLUGIN.$USEZIP.zip ]; then
			USEZIP="$PLUGIN.$USEZIP.zip"
			NEWZIPSOURCE="fromwporg.$METAMODE"
		else
			ws_pushd ..
			download_version "$PLUGIN" $USEZIP
			ws_popd
			if [ $? -eq 0 ]; then
				USEZIP="$PLUGIN.$USEZIP.zip"
			else
				ws_event_error "Download failed"
				unset USEZIP
			fi
		fi
	elif [ "$USEZIP" = "w3m" ]; then
		if [ $CAN_BROWSE -eq 1 ]; then
			if [[ $METAMODE = "core" ]]; then
				url_browser https://wordpress.org/download
			else
				if [ -n "$PLUGIN" ]; then
					url_browser https://wordpress.org/${METAMODE}s/$PLUGIN/download
				else
					url_browser https://wordpress.org/${METAMODE}s
				fi
			fi
		else
			ws_event_error "Cannot find a working w3m, elinks or lynx (run with --checkrequirements or --debug for more information)"
		fi
		USEZIP=""
	elif [ -f "../customimports.$METAMODE/$USEZIP" ]; then
		NEWZIPSOURCE="customimports.$METAMODE"
	elif [ ! -f "$USEZIP" ]; then
		ws_event_error "$USEZIP: Specified file not found"
		USEZIP=""
	fi
done
# Return to working directory
ws_cd ..
[[ $MODE = "restore" ]] && unset USEZIP
return 0
}

# --changelog, --description and --downloadurl
if [[ ( $METAMODE = "core" || $METAMODE = "plugin" || $METAMODE = "theme" ) && ( $SHOWCHANGELOG -eq 1 || $SHOWDESCRIPTION -eq 1 || $SHOWDOWNLOADURL -eq 1 || $SHOWLASTUPDATED -eq 1 ) ]]; then
	if [[ -z $PLUGIN && $PLUGIN_OR_THEME_MODE -eq 1 ]]; then
		if [ -n "$SITE" ]; then
			PLUGIN=$SITE
			unset SITE
		else
			abort_die 49 "Requested changelog or description or download URL, but no $METAMODE indicated"
		fi
	fi
	if [[ $CAN_BROWSE -eq 0 ]]; then
		ws_event_error "Operation cannot be carried out; no working browser (w3m, elinks or lynx) is available - run again with --checkrequirements for more information"
		false
	else
		if [[ $METAMODE = "core" ]]; then
			[[ $SHOWCHANGELOG -eq 1 ]] && url_browser http://codex.wordpress.org/Category:Changelogs
			[[ $SHOWDESCRIPTION -eq 1 ]] && url_browser https://wordpress.org/about/
			[[ $SHOWDOWNLOADURL -eq 1 ]] && echo "https://wordpress.org/latest.zip"
		else
			[[ $SHOWCHANGELOG -eq 1 ]] && get_api_changelog $PLUGIN changelog
			[[ $SHOWLASTUPDATED -eq 1 ]] && get_api_changelog $PLUGIN last_updated
			[[ $SHOWDESCRIPTION -eq 1 ]] && get_api_changelog $PLUGIN description
			[[ $SHOWDOWNLOADURL -eq 1 ]] && get_api_changelog $PLUGIN download_link
		fi
	fi
	GET_CHANGELOG_RET=$?
	# If no site specified, then we're done
	[[ -z $SITE ]] && exit $GET_CHANGELOG_RET
fi

# Download only mode - no need to specify both site and plugin
if [[ $MODE = "downloadonly" && ( $METAMODE = "core" || $METAMODE = "plugin" || $METAMODE = "theme" ) ]]; then
	# If no second parameter was specified but a first was, then assume it was a plugin
	if [[ -z $PLUGIN && $PLUGIN_OR_THEME_MODE -eq 1 ]]; then
		if [[ -n $SITE ]]; then
			PLUGIN=$SITE
		else
			abort_die 59 "Requested download, but no $METAMODE indicated"
		fi
	fi
	if [[ $USEZIP = "latest" || -z $USEZIP ]]; then
		[[ -z $USEZIP && $DEBUG -ge 1 ]] && ws_event_info "No version specified; will download latest"
		download_latest wp
	else
		download_version "$PLUGIN" $USEZIP
	fi
	exit $?
fi

function download_remote_manager() {
	# Purpose: make sure remote manager script is in place at the required minimum protocol version
	# Input: $1: Minimum protocol version
	local NEED_TO_DOWNLOAD=0
	local NEEDED_REMOTEPROTO=$1

	if [[ ! -s "wp-wordshell-controller.php" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "wp-wordshell-controller.php not found; will try to download"
		NEED_TO_DOWNLOAD=1
	else
		local REMOTE_PROTOVER=`grep -E 'proto_version[[:space:]]*=' wp-wordshell-controller.php | head -1 | cut -d\" -f2`
		if [[ -z $REMOTE_PROTOVER || ! $REMOTE_PROTOVER -ge $NEEDED_REMOTEPROTO ]]; then 
			NEED_TO_DOWNLOAD=1
			[[ $DEBUG -ge 1 ]] && ws_event_info "wp-wordshell-controller.php found, but insufficiently high protocol version (found:$REMOTE_PROTOVER needed:$NEEDED_REMOTEPROTO); will try to download updated version"
		fi
	fi

	if [[ $NEED_TO_DOWNLOAD -eq 1 ]]; then
		[[ -f "wp-wordshell-controller.php" ]] && rm -f "wp-wordshell-controller.php"
		# Download it - try all three methods in case one has a problem with the SSL certificate
		url_get $REMOTE_MANAGER_FROM wp-wordshell-controller.php tryonlylftp
		[[ ! -s "wp-wordshell-controller.php" ]] && url_get $REMOTE_MANAGER_FROM wp-wordshell-controller.php tryonlycurl
		[[ ! -s "wp-wordshell-controller.php" ]] && url_get $REMOTE_MANAGER_FROM wp-wordshell-controller.php tryonlywget
		[[ ! -s "wp-wordshell-controller.php" ]] && GET_MANAGER_DOWNLOAD_RET=2
	fi

	local REMOTE_PROTOVER=`grep -E 'proto_version[[:space:]]*=' wp-wordshell-controller.php | head -1 | cut -d\" -f2`
	if [[ -z $REMOTE_PROTOVER ]]; then
		abort_die 85 "wp-wordshell-controller.php found, but could not detect the protocol version (perhaps the file is corrupt)"
	elif [[ ! $REMOTE_PROTOVER -ge $NEEDED_REMOTEPROTO ]]; then 
		abort_die 85 "wp-wordshell-controller.php found, but insufficiently high protocol version (found:$REMOTE_PROTOVER needed:$NEEDED_REMOTEPROTO)"
	fi


}

function setup_remote_manager() {
	# Purpose: Makes sure remote manager script is uploaded to site, and sets our return variables, including the nonce
	# You must call this before _every_ remote manager call (otherwise your nonce will be wrong)
	# Input: $1 = minimum acceptable version
	# $2 = flags:
	#   nononce means do not return a nonce (no call is going to be made); simply make sure we are set up
	#   earlyping means to use the 'earlyping' RPC instead of ping; does not require WordPress to be alive; you should also always specify nononce with this since the remote end will not be able to update its own nonces
	# Returns 0 upon success, othersize non-zero; also sets the next valid REMOTEMANAGER_NONCE (this is the one to put in wpm-a), REMOTEMANAGER_KEY, SITEURL_HOST and SITEURL_LOCAL and otthers used internally: REMOTEMANAGER_COUNTER, REMOTEMANAGER_UPLOADTIME
	# Sets GET_REMOTE_MESSAGE if there was a problem
	local SETUP_RM_FLAGS=$2
	if [[ $((`date +%s` - $REMOTEMANAGER_UPLOADTIME)) -lt 175 ]]; then
		if [[ ! $SETUP_RM_FLAGS =~ nononce ]]; then
			# Just increase the nonce then exit; no need to re-upload
			REMOTEMANAGER_COUNTER=$((REMOTEMANAGER_COUNTER+1))
			REMOTEMANAGER_NONCE=`echo -n ${REMOTEMANAGER_KEY}${REMOTEMANAGER_COUNTER} | $CHECKSUM | cut -d' ' -f1`
			[[ $DEBUG -ge 2 ]] && ws_event_debug "Remote manager counter (1) key=$REMOTEMANAGER_KEY, counter=$REMOTEMANAGER_COUNTER"
		fi
		return 0
	fi
	local REMOTE_MINVER=$1
	GET_REMOTE_MESSAGE=""
	if [[ -z $SITEURL ]]; then
		GET_REMOTE_MESSAGE="ERROR: No URL has been provided for this site - cannot make contact with it"
		return 1
	fi
	ws_pushd "$WORKINGDIR_FULL"
	# Get our helper PHP
	local GET_MANAGER_DOWNLOAD_RET=0
	# Try to ensure that the script (at sufficient protocol level) we need to upload is available to do so
	download_remote_manager $REMOTE_MINVER
	# Check if it we got it
	if [[ ! -s "wp-wordshell-controller.php" ]]; then
		GET_REMOTE_MESSAGE="ERROR: Could not get the needed file for the remote helper (if you can get it manually, copy it into $WORKINGDIR_FULL/wp-wordshell-controller.php - was trying to get it from: $REMOTE_MANAGER_FROM)"
		return 2
	fi
	make_and_enter tmp
	local CONTROL_TMP=`mktemp ctrl-tmp-php.XXXXX` || return 5
	REMOTEMANAGER_KEY="${RANDOM}${RANDOM}${RANDOM}"
	echo "<?php \$our_auth = \"$REMOTEMANAGER_KEY\"; ?>" >$CONTROL_TMP
	if [[ $ACCESSMETHOD =~ ftp ]]; then
		echo "<?php define('WORDSHELL_FTP_USER', '$FTPUSER');" >>$CONTROL_TMP
		local QUOTPASS=$(echo $FTPPASS | sed "s/'/\\\'/g")
		echo "define('WORDSHELL_FTP_PASS', '$QUOTPASS');" >>$CONTROL_TMP
		echo "define('WORDSHELL_FTP_HOST', '$FTPHOST'); ?>" >>$CONTROL_TMP
	fi
	cat ../wp-wordshell-controller.php >>$CONTROL_TMP
	if [[ $ACCESSMETHOD = "file" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Copy across remote controller (filesystem)"
		cp $COPYOPT $CONTROL_TMP "$FILEDIR/wp-wordshell-controller.php"
		chmod +r,+x "$FILEDIR/wp-wordshell-controller.php"
		if [[ -f "$FILEDIR/index.php" ]]; then
			setownership "$FILEDIR/index.php" "$FILEDIR/wp-wordshell-controller.php"
		else
			# In --install --core, index.php will (should) not yet exist
			setownership "$FILEDIR/" "$FILEDIR/wp-wordshell-controller.php"
		fi
		rm -f $CONTROL_TMP
		# Back to working directory
		ws_cd ..
		if [[ ! -s "$FILEDIR/wp-wordshell-controller.php" ]]; then
			GET_REMOTE_MESSAGE="ERROR: File copy of remote helper failed"
			ws_popd
			return 3
		fi
	else
		# (s)ftp
		[[ $DEBUG -ge 1 ]] && ws_event_info "Copy across remote controller ($ACCESSMETHOD)"
		ftp_putfile $CONTROL_TMP wp-wordshell-controller.php
		local FTP_RETURN=$?
		rm -f $CONTROL_TMP
		# Back to working directory
		ws_cd ..
		if [ $FTP_RETURN -ne 0 ]; then
			GET_REMOTE_MESSAGE="ERROR: $ACCESSMETHOD put of remote helper failed"
			ws_popd
			return 4
		fi
	fi
	REMOTEMANAGER_UPLOADTIME=`date +%s`
	ws_popd
	# Now test it
	if [[ ! $SITEURL =~ ^(https?://[^/]+)(/.*)?/?$ ]]; then
		GET_REMOTE_MESSAGE="ERROR: Could not parse URL ($SITEURL) into components"
		return 7
	fi
	SITEURL_HOST=${BASH_REMATCH[1]}
	SITEURL_LOCAL=${BASH_REMATCH[2]}
	REMOTEMANAGER_COUNTER=0
	REMOTEMANAGER_NONCE=`echo -n ${REMOTEMANAGER_KEY}${REMOTEMANAGER_COUNTER} | $CHECKSUM | cut -d' ' -f1`
	[[ $DEBUG -ge 2 ]] && ws_event_debug "Remote manager counter (2) key=$REMOTEMANAGER_KEY, counter=$REMOTEMANAGER_COUNTER"
	REMOTE_DEBUG=""
	[[ $DEBUG -ge 1 ]] && REMOTE_DEBUG="&wpm-d=1"
	local PING_COM=ping
	[[ $SETUP_RM_FLAGS =~ earlyping ]] && PING_COM=earlyping
	url_post $SITEURL_HOST $SITEURL_LOCAL/wp-wordshell-controller.php "wpm-a=${REMOTEMANAGER_NONCE}${REMOTE_DEBUG}&wpm-c=$PING_COM" nocache,setvar
	[[ $DEBUG -ge 1 ]] && ws_event_info "String returned when testing remote controller: $URLPOST_RESULTS"
	REMOTE_CONTENTDIR=""
	if [[ $URLPOST_RESULTS =~ AUTHOK:PONG:([0-9]+): ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "OK: That was the desired result to find a remote controller"
		local REMOTE_FOUNDVER=${BASH_REMATCH[1]}
		if [ $REMOTE_FOUNDVER -ge $REMOTE_MINVER ]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "The remote protocol version ($REMOTE_FOUNDVER) was high enough (at least $REMOTE_MINVER)"
		else
			GET_REMOTE_MESSAGE="ERROR: The remote protocol version ($REMOTE_FOUNDVER) was NOT high enough (at least $REMOTE_MINVER)"
			return 9
		fi
		[[ $URLPOST_RESULTS =~ AUTHOK:PONG:[0-9]+:([\.0-9]+): ]] && REMOTE_PHPVERSION=${BASH_REMATCH[1]}
		[[ $URLPOST_RESULTS =~ AUTHOK:PONG:[0-9]+:[\.0-9]+:w([\.0-9]+)[,:] ]] && REMOTE_WPVERSION=${BASH_REMATCH[1]}
		[[ $URLPOST_RESULTS =~ AUTHOK:PONG:[0-9]+:[\.0-9]+:w[\.0-9]+,m([\.0-9]+): ]] && REMOTE_MYSQLVERSION=${BASH_REMATCH[1]}
		[[ $URLPOST_RESULTS =~ AUTHOK:PONG:[0-9]+:[\.0-9]+:[^:]+,wpcd=([-_a-zA-Z0-9]+): ]] && REMOTE_CONTENTDIR=${BASH_REMATCH[1]}

	else
		GET_REMOTE_MESSAGE="ERROR: Remote controller returned unexpected result ($URLPOST_RESULTS) - try --debug or --debug --debug for more information"
		return 8
	fi
	# Increase counter
	if [[ ! $SETUP_RM_FLAGS =~ nononce ]]; then
		# Just increase the nonce then exit; no need to re-upload
		REMOTEMANAGER_COUNTER=$((REMOTEMANAGER_COUNTER+1))
		REMOTEMANAGER_NONCE=`echo -n ${REMOTEMANAGER_KEY}${REMOTEMANAGER_COUNTER} | $CHECKSUM | cut -d' ' -f1`
		[[ $DEBUG -ge 2 ]] && ws_event_debug "Remote manager counter (3) key=$REMOTEMANAGER_KEY, counter=$REMOTEMANAGER_COUNTER"
	fi
	return 0
}

# Remote CLI mode
function remotecli_process() {
# This function ensures that the remote manager is set up, and then it calls it.
# Do not call in a subshell, as needs to set global variables
# Input: $1 is command to run
# $2 = what to do with output: tellfile=sets REMOTECLI_OUTPUT to file; setvar=sets REMOTECLI_OUTPUT variable; otherwise, cat it
# $3 = options: noquit returns an error instead of aborting on error ; silentfail does the same silently
	local USE_OUTPUT=$2
	local RCLI_OPTIONS=$3
	[[ $DEBUG -ge 1 ]] && ws_event_info "remotecli_process: $1 (caller: `caller`)"
	if [[ -z $SITEURL ]] ; then
		if [[ $RCLI_OPTIONS =~ noquit ]]; then
			ws_event_error "$SITE: Cannot perform this operation; the site URL has not been set up for this site"
			return 79
		elif [[ $RCLI_OPTIONS =~ silentfail ]]; then
			return 79
		else
			abort_die 79 "$SITE: Cannot perform this operation; the site URL has not been set up for this site"
		fi
	fi
	REMOTECLI_COM=$1
	[[ $REMOTECLI_COM = "exit" ]] && exit
	local DEBUG_REGEX="^debug ([0123])$"
	local RDEBUG_REGEX="^rdebug ([01])$"
	if [[ $REMOTECLI_COM =~ $DEBUG_REGEX ]]; then
		set_debug_level ${BASH_REMATCH[1]}
		echo "LOCAL: change debugging level to: $DEBUG" >/dev/stderr
	elif [[ $REMOTECLI_COM =~ $RDEBUG_REGEX ]]; then
		RDEBUG=${BASH_REMATCH[1]}
		echo "LOCAL: change requested remote debugging level to: $RDEBUG" >/dev/stderr
	elif [[ $REMOTECLI_COM = "login" ]]; then
		ws_pushd "$ORIGDIR"
		REMOTECLI_LOGIN_PARAMS=""
		[[ $DEBUG -eq 1 ]] && REMOTECLI_LOGIN_PARAMS="--debug "
		[[ $DEBUG -eq 2 ]] && REMOTECLI_LOGIN_PARAMS="--debug --debug"
		[[ $DEBUG -eq 3 ]] && REMOTECLI_LOGIN_PARAMS="--debug --debug --debug"
		[[ $DEBUG -ge 1 ]] && ws_event_info "Invoking with parameters: \"$SITE\" --selfinvoked --nocountdiskspace --login $REMOTECLI_LOGIN_PARAMS"
		$BASH $0 "$SITE" --login --selfinvoked --nocountdiskspace $REMOTECLI_LOGIN_PARAMS
		ws_popd
	elif [[ -n $REMOTECLI_COM ]]; then
		# Variables set upon return: REMOTEMANAGER_NONCE, SITEURL_HOST and SITEURL_LOCAL, GET_REMOTE_MESSAGE
		# Prevent an unnecessary double ping
		if [[ ( $METAMODE = "core" || $METAMODE = "plugin" ) && $MODE = "normal" && $REMOTECLI_COM = "ping" ]]; then
			setup_remote_manager $REMOTE_MANAGER_MINIMUM_PROTOCOL nononce
		else
			setup_remote_manager $REMOTE_MANAGER_MINIMUM_PROTOCOL
		fi
		local SETUP_REMOTE_RETURN=$?
		if [ $SETUP_REMOTE_RETURN -ne 0 ]; then
			if [[ $RCLI_OPTIONS =~ noquit ]]; then
				ws_event_error "Setup of remote end returned an error ($SETUP_REMOTE_RETURN): ${GET_REMOTE_MESSAGE:0:1000}"
				return $SETUP_REMOTE_RETURN
			elif [[ $RCLI_OPTIONS =~ silentfail ]]; then
				return $SETUP_REMOTE_RETURN
			else
				abort_die 79 "Setup of remote end returned an error ($SETUP_REMOTE_RETURN): ${GET_REMOTE_MESSAGE:0:1000}"
			fi
		fi

		[[ ( $METAMODE = "core" || $METAMODE = "plugin" ) && $MODE = "normal" && $REMOTECLI_COM = "ping" ]] && return
		
		REMOTE_DEBUG=""
		[[ $RDEBUG -ge 1 ]] && REMOTE_DEBUG="&wpm-d=1"

		REMOTE_OUTPUTFILE=`url_post $SITEURL_HOST $SITEURL_LOCAL/wp-wordshell-controller.php "wpm-a=$REMOTEMANAGER_NONCE&wpm-c=${REMOTECLI_COM}${REMOTE_DEBUG}" returnfile,nocache,preferlftp`
		[[ $RETCODE_URLPOST -ne 0 && ! $RCLI_OPTIONS =~ silentfail ]] && ws_event_error "Returned code from HTTP post was: $RETCODE_URLPOST"
		if [ -f $REMOTE_OUTPUTFILE ]; then
			if [[ $USE_OUTPUT = "tellfile" ]]; then
				REMOTECLI_OUTPUT="$REMOTE_OUTPUTFILE"
			elif [[ $USE_OUTPUT = "setvar" ]]; then
				REMOTECLI_OUTPUT="`cat $REMOTE_OUTPUTFILE`"
				[[ $DEBUG -ge 1 ]] && ws_event_debug "Remote CLI output: $REMOTECLI_OUTPUT"
				rm -f $REMOTE_OUTPUTFILE
			else
				cat $REMOTE_OUTPUTFILE
				rm -f $REMOTE_OUTPUTFILE
			fi
		else
			[[ ! $RCLI_OPTIONS =~ silentfail ]] && ws_event_error "url_post did not return a file (returned: $REMOTE_OUTPUTFILE)"
		fi
	fi
}

function ftp_putfile() {
	# Input: $1 = filename, $2 = filename to place as (or if empty, same as $1)
	local PUTFILE=$2
	[[ -z $PUTFILE ]] && PUTFILE=$1
	if [[ -n $LFTP ]]; then
		local FILEBASE=`dirname $PUTFILE`
		local CDTO="$FTPDIR"
		[[ $FILEBASE != "." ]] && $CDTO="$CDTO/$FILEBASE"
		[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_putfile lftp $1 -> $ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$PUTFILE"
		$LFTP $LFTPDEBUG <<-ENDHERE
		open $ACCESSMETHOD://$FTPHOST
		user "$FTPUSER" "$FTPPASS"
		cd "$CDTO"
		put "$1" -o "`basename $PUTFILE`"
		ENDHERE
	else
		[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_putfile curl $1 -> $ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$PUTFILE"
		$CURL $CURLVERB $CURL_FTPOPTIONS --config - --url "$ACCESSMETHOD://$FTPHOST/$FTPDIR/$PUTFILE" --ftp-create-dirs --upload-file "$1" <<-ENDHERE
		user  = "$FTPUSER:$FTPPASS"
		ENDHERE
		if [ $? -eq 0 ]; then
			return 0
		elif [ $? -eq 25 ]; then
			ws_event_error "Curl FTP returned an error when uploading file $PUTFILE (STOR command failed)"
			return 25
		else
			ws_event_warning "Unexpected curl FTP error returned when uploading file $PUTFILE (code; $? - see curl man page)"
			return 1
		fi
	fi
}

function rpc_mirror_get() {
	# Function to use remotecli to sync a remote directory with a local one
	# Syncing is based on MD5 sums only - we do not care about timestamps

	# Sets the return status to indicate success or failure
	# $1 = the remote directory to first cd into
	# $2 = the remote directory or file (if it matches *.php) to then fetch (after the cd)
	# $3 = the local directory (or file, if $2 matched *.php) to sync to
	# Note: support for $2 matching *.php was not finished, as we decided it was better to go another route elsewhere
	# $4 = if set, the local directory to first check (a read-only directory; think of the dir in $3 as an overlay on top of $4)
	# Internally, $4 (read-only underlay) is only used for syncing WordPress core; in which case we:
	# - exclude wp-content
	# - only create directories when saving a file
	# - Always get wp-includes/version.php
	# - Ignore .svn directories
	# - Ignore _notes/dwsync.xml (DropBox)
	# So, if you wish to use an overlay for a different purpose and if the above behaviour is undesirable, then amend the code below
	# Furthermore, in metamode "content", we exclude the plugins and themes and cache directories

	local RDIR=$1
	local RMIRROR_DIR=$2
	local LMIRROR_DIR=$3
	local LMIRROR_RODIR=$4

	# By default, find all files
	local FINDDEPTH=0
	[[ -n $4 ]] && FINDDEPTH=-2
	local FINDDIR="$RDIR/$RMIRROR_DIR"
	[[ $RDIR = "." ]] && FINDDIR="$RMIRROR_DIR"

	remotecli_process "findfiles5:$FINDDEPTH:$FINDDIR" tellfile
	FINDEM=$REMOTECLI_OUTPUT
	local REM_ANS=`head -1 $FINDEM`
	if [[ $REM_ANS = "AUTHOK:OK" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Remote side confirms existence of $FINDDIR"
		# Starts below zero because will be bumped up to zero by the ignored first line
		local FILE_COUNTER=-1
		local FILE_COUNTER_TOTAL=-1
		# "-t 1" means, "if file descriptor 1 (stdout) is a terminal"
		[[ $DEBUG -le 1 && -t 1 ]] && echo -n "Syncing: "
		local OLDIFS="$IFS"
		local PROC_FIRSTLINE=1
		IFS="
"
		while read LINE; do
			IFS=$OLDIFS
			FILE_COUNTER=$((FILE_COUNTER+1))
			FILE_COUNTER_TOTAL=$((FILE_COUNTER_TOTAL+1))
			if [[ $FILE_COUNTER -ge 15 ]]; then
				FILE_COUNTER=0
				# Only output arrows when on a terminal
				[[ $DEBUG -le 1 && -t 1 ]] && echo -n ">"
			fi
			if [[ $PROC_FIRSTLINE -eq 1 ]]; then
				# First line has the protocol header on. Ignore.
				PROC_FIRSTLINE=0
			elif [[ $METAMODE = "content" && $LINE =~ ^[dfl].*:$FINDDIR/(plugins|themes|cache
			updraft|upgrade) ]]; then
				# We don't want to fetch these
				[[ $DEBUG -ge 3 ]] && ws_event_info "Content meta-mode: Skipped: $LINE"
				true
			elif [[ $LINE =~ ^f:.*/.svn/ || $LINE =~ ^f:.*_notes/dwsync\.xml$ ]]; then
				# file in an .svn directory / Dropbox file - we ignore these
				true
			elif [[ $LINE =~ ^d:$FINDDIR/?(.*)$ ]]; then
				[[ -z $LMIRROR_RODIR ]] && mkdir -p "$LMIRROR_DIR/${BASH_REMATCH[1]}"
			elif [[ $LINE =~ ^f:CANNOTREAD:(.*)$ ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_notice "Remote side could not read file: ${BASH_REMATCH[1]}"
			elif [[ $LINE =~ ^l:$FINDDIR/?(.*):(.*)$ ]]; then
				# Link: copy them; probably takes just as much time to wipe/copy as to check current state
				local LFILE_NAME=${BASH_REMATCH[1]}
				local LFILE_TARGET=${BASH_REMATCH[2]}
				rm -f "$LMIRROR_DIR/$LFILE_NAME"
				ln -s "$LFILE_TARGET" "$LMIRROR_DIR/$LFILE_NAME"
			elif [[ $LINE =~ ^f:([a-f0-9]+):$FINDDIR/(.*)$ || ( $FINDDIR =~ \.php$ && $LINE =~ ^f:([a-f0-9]+):$FINDDIR$ ) ]]; then
				local LFILE_MD5=${BASH_REMATCH[1]}
				local LFILE_NAME=${BASH_REMATCH[2]}
				local LFILE_EXISTING_CKSUM=""
				local DO_COPY=1
				local UNDERLAY_CKSUM=""
				# Remember the special case - we always want wp-config.php; it is not in the WP distribution, but it is "core"
				# The check for the underlay here is just to check that we are working upon WP core
				if [[ -n $LMIRROR_RODIR && $LFILE_NAME = "wp-config.php" ]]; then
					[[ -f $LMIRROR_DIR/wp-config.php ]] && LFILE_EXISTING_CKSUM=`$CHECKSUM "$LMIRROR_DIR/wp-config.php" | cut -d' ' -f1`
				# Now, check for an overlaid file; if not there, look for one in the base
				elif [[ -f "$LMIRROR_DIR/$LFILE_NAME" ]]; then
					# Exists in overlay, but not necessarily (we've not yet checked) in potential underlay. If not in the underlay, then take appropriate action.
					if [[ -n $LMIRROR_RODIR && ! -f "$LMIRROR_RODIR/$LFILE_NAME" && $JUSTWPWIPEOTHERS -eq 1 ]]; then
						[[ $LFILE_NAME != "wp-config.php" && $DEBUG -ge 1 ]] && ws_event_info "Delete: $LFILE_NAME is not in WP base, and --justwpwipeothers was set"
						# In overlay, but not in underlay, and not we are wiping such
						[[ $LFILE_NAME != "wp-config.php" ]] && rm -f "$LMIRROR_DIR/$LFILE_NAME"
						[[ $LFILE_NAME != "wp-config.php" ]] && DO_COPY=0
					elif [[ -n $LMIRROR_RODIR && ! -f "$LMIRROR_RODIR/$LFILE_NAME" && $JUSTWP -eq 1 ]]; then
						[[ $DEBUG -ge 1 ]] && ws_event_info "$LFILE_NAME: is not in WP base; will ignore since --justwp was specified"
						DO_COPY=0
						# In overlay, but not in underlay, and not we are not backing up such, though we are not wiping them
					elif [[ -n $LMIRROR_RODIR && ! -f "$LMIRROR_RODIR/$LFILE_NAME" && $JUSTWP -eq 0 ]]; then
						# In overlay but not in underlay, and we are backing up such files
						LFILE_EXISTING_CKSUM=`$CHECKSUM "$LMIRROR_DIR/$LFILE_NAME" | cut -d' ' -f1`
						# That exhausts all possibilities of (in overlay, not in underlay).
						# Henceforth we know that it is in the overlay and the underlay (if there is one), or that there is no underlay
					elif [[ -n $LMIRROR_RODIR ]]; then
						# In both underlay and overlay; a changed core file (always backed up)
						LFILE_EXISTING_CKSUM=`$CHECKSUM "$LMIRROR_DIR/$LFILE_NAME" | cut -d' ' -f1`
						# This extra check because sometimes the one further down seems not to work
						if [[ 1 -eq 0 ]] ; then
							DO_COPY=0
						else
							[[ $DEBUG -ge 1 && $LFILE_NAME != "wp-includes/version.php" ]] && ws_event_notice "$LFILE_NAME: This core WP file has been changed. Changing WP core is not recommended; you should try to use plugins instead."
						fi
						# Henceforth we know that there is no underlay. This is a plain mirror. File is in it locally.
						# Potentially, this file in both underlay and overlay is about to become identical in both, in which case it should be removed from the overlay
						[[ $LFILE_NAME != "wp-includes/version.php" ]] && UNDERLAY_CKSUM=`$CHECKSUM "$LMIRROR_RODIR/$LFILE_NAME" | cut -d' ' -f1`
					else
						LFILE_EXISTING_CKSUM=`$CHECKSUM "$LMIRROR_DIR/$LFILE_NAME" | cut -d' ' -f1`
					fi
					# Henceforth we know that the file does not exist in the overlay
				elif [[ -n $LMIRROR_RODIR && -f "$LMIRROR_RODIR/$LFILE_NAME" ]]; then
					# Exists in underlay, though not in overlay. Therefore, an unchanged file previously (though may now have changed)
					LFILE_EXISTING_CKSUM=`$CHECKSUM "$LMIRROR_RODIR/$LFILE_NAME" | cut -d' ' -f1`
				elif [[ -n $LMIRROR_RODIR && ! -f "$LMIRROR_RODIR/$LFILE_NAME" ]]; then
					# There is an underlay, but this file is not in it (or in the overlay). Therefore, a new non-core file.
					[[ $JUSTWP -eq 1 ]] && DO_COPY=0
					# Henceforth, we know that there is no underlay - this is a plain mirror (and this file is not in the mirror - hence, a new file). (Hence following elif statement should always be true).
				elif [[ ! -f "$LMIRROR_DIR/$LFILE_NAME" ]]; then
					# Not in overlay; not in underlay - a new file
					true
				fi
				# In file mode, we just copied this across using the filesystem already
				if [[ $LFILE_EXISTING_CKSUM = $LFILE_MD5 && -n $UNDERLAY_CKSUM && $UNDERLAY_CKSUM = $LFILE_MD5 ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "$LMIRROR_DIR/$LFILE_NAME: is now the same as in the underlay, so will delete from the overlay"
					rm -f "$LMIRROR_DIR/$LFILE_NAME"
				elif [[ $LFILE_EXISTING_CKSUM = $LFILE_MD5 && ( $ACCESSMETHOD = "file" || $LFILE_NAME != "wp-includes/version.php" ) ]]; then
					# File is up to date
					[[ $DEBUG -ge 2 ]] && ws_event_debug "$LMIRROR_DIR/$LFILE_NAME is up to date"
				elif [[ $DO_COPY -eq 1 ]]; then
					# Copy the file if we worked out that we needed to
					[[ $DEBUG -ge 1 ]] && ws_event_info "$LMIRROR_DIR/$LFILE_NAME out of date: will fetch"
					remotecli_process "getfile:$LFILE_NAME" tellfile
					local LDIR_TMP=$REMOTECLI_OUTPUT
					local GET_ANS="`dd if=$LDIR_TMP bs=15 count=1 of=/dev/stdout 2>/dev/null`"
					if [[ $GET_ANS = "AUTHOK:CANTREAD" ]]; then
						ws_event_warning "$SITE: $LINE: Could not download file (error: file not readable)"
						rm -f $LDIR_TMP
					elif [[ $GET_ANS = "AUTHOK:NOTAFILE" ]]; then
						ws_event_warning "$SITE: $LINE: Could not download file (error: not a file)"
						rm -f $LDIR_TMP
					else
						# We assume directory does not need creating; the controller lists directories first
						local CKSUM=`$CHECKSUM $LDIR_TMP | cut -d' ' -f1`
						if [[ $CKSUM == $LFILE_MD5 ]]; then
							local LDEST=`dirname "$LMIRROR_DIR/$LFILE_NAME"`
							[[ -n $LMIRROR_RODIR ]] && mkdir -p "$LDEST"
							mv $LDIR_TMP "$LMIRROR_DIR/$LFILE_NAME"
							[[ $DEBUG -ge 1 ]] && ws_event_info "Received remote file $FINDDIR/$LFILE_NAME, wrote to $LMIRROR_DIR/$LFILE_NAME"
						else
							ws_event_warning "$SITE: $LINE: Could not download file (unknown error; file checksum wrong - was $CKSUM)"
							if [[ $DEBUG -ge 1 ]]; then
								ws_event_debug "DEBUG MODE: Not deleted: $LDIR_TMP"
							else
								rm -f $LDIR_TMP
							fi
						fi
					fi
				# The next segment is only reached if DO_COPY has been explicitly set to 0
				elif [[ $JUSTWP -eq 1 && $JUSTWPWIPEOTHERS -eq 0 ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "$LFILE_NAME: Skipping: is not part of WP core, and --justwp is set"
				fi
			elif [[ -n $LINE && $LINE != "x:END" ]]; then
				ws_event_warning "Unrecognised line when processing mirror listing: $LINE"
			fi
			IFS="
"
		done <$FINDEM
		IFS="$OLDIFS"
		# Empty the line on the terminal if needed
		[[ $DEBUG -le 1 && -t 1 ]] && echo -en "\r                                                                                                                                               \r"
		grep -q ^x:END$ $FINDEM
		if [[ $? -eq 0 ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Sync completed: will now look for local files to delete"
			# $FINDEM is a file with a list of files that we were sent from the remote end
			ws_pushd "$LMIRROR_DIR"
			# See what files are available locally that should not be
			# Note: we won't delete files from the read-only base directory, even if they were deleted remotely
			find . -type f | cut -c3- | while read EXISTING_FILE; do
				# Was that file in the remote list?
				grep -E -q "^f:[0-9a-fA-F]+:$FINDDIR/$EXISTING_FILE$" $FINDEM
				if [ $? -eq 0 ]; then
					[[ $DEBUG -ge 3 ]] && ws_event_info "Keep in cache: $EXISTING_FILE"
				else
					[[ $DEBUG -ge 1 ]] && ws_event_info "Deleting from cache: $EXISTING_FILE"
					rm -f "$EXISTING_FILE"
				fi
			done
			ws_popd
		else
			ws_event_warning "Sync did not complete; the file list sent ended unexpectedly."
			rm -f $FINDEM
			return 4
		fi
		rm -f $FINDEM
	elif [[ $REM_ANS = "AUTHOK:NOTFOUND" ]]; then
		rm -f $FINDEM
		ws_event_error "$SITE: $2/$3: Directory not found"
		return 3
	else
		rm -f $FINDEM
		ws_event_error "$SITE: $2/$3: Could not list remote files (returned: $REM_ANS)"
		return 2
	fi

}

function ftp_mirror() {
	# This is used for four things: 1) Recursive fetch 2) Recursive put (put/putnodelete) 3) Recursive delete 4) Recursive put with recursive delete.
	# Some special magic - in meta-mode "content" with get, certain exclusions are applied

	[[ $DEBUG -ge 1 ]] && ws_event_debug "ftp_mirror: $1: $2 $3 $4"

	local MIRRORMODE=$1
	local REMOTE_CD=$2
	local REMOTE_DIR=$3
	local LOCAL_DIR=$4

	# For recursive fetch:
	local LFTPADD=""
	[[ $METAMODE = "content" && $MIRRORMODE = "get" ]] && LFTPADD="--exclude plugins/ --exclude themes/ --exclude cache/ --exclude updraft/ --exclude=upgrade/"
	for XGLOB in $EXCLUDE_GLOB_FTP; do
		local LFTPADD="$LFTPADD --exclude-glob $XGLOB"
	done

	# Input:
	# $1 = mode: get | get-delsource | delete | put | putnodelete
	# $2 = directory to cd to first on remote side
	# $3 = remote directory. If empty, then no mirror takes place (though other commands can still run)
	# $4 = local directory (if relevant)
	# $5 = extra command to run before, if using lftp in get/put/get-delsource mode

	if [[ $MIRRORMODE = "get" || $MIRRORMODE = "put" || $MIRRORMODE = "putnodelete" ]]; then
		if [[ -n $LFTP ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_mirror $MIRRORMODE lftp: $2 $3 $4"
			local EXTRACOM=$5
			if [[ $MIRRORMODE = "get" ]]; then
				LFTPADD="$LFTPADD --delete"
			elif [[ $MIRRORMODE = "put" ]]; then
				LFTPADD="--reverse $LFTPADD --delete"
			elif [[ $MIRRORMODE = "putnodelete" ]]; then
				LFTPADD="--reverse $LFTPADD"
			fi
			[[ $LFTPDRYRUN -eq 1 ]] && LFTPADD="--dry-run $LFTPADD"
			$LFTP $LFTPDEBUG <<-ENDHERE
			open $ACCESSMETHOD://$FTPHOST
			user "$FTPUSER" "$FTPPASS"
			cd "$FTPDIR"
			set xfer:clobber yes
			$EXTRACOM
			cd "$REMOTE_CD"
			mirror $LFTPVERB $LFTPADD --parallel=$FTPPARALLEL "$REMOTE_DIR" "$LOCAL_DIR"
			ENDHERE
		elif [[ $MIRRORMODE = "put" || $MIRRORMODE = "putnodelete" ]]; then
			# curl recursive put
			# If we have no special access, could do it this way: slow (logs in for every file); also does not delete gone files (so you'd have to begin with a recursive delete)
			# echo "user = \"$FTPUSER:$FTPPASS\"" | find -type f -exec $CURL $CURL_FTPOPTIONS $CURLVERB --ftp-create-dirs --upload-file {} --config - --url \"$ACCESSMETHOD://$FTPHOST/$FTPDIR/{}\" \;
			[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_mirror $MIRRORMODE curl: $2 $3 $4"
			[[ -z $ZIP ]] && abort_die 80 "This operation requires a working zip (run again with --checkrequirements for more information"
			local REMOTE_PATH=$2
			[[ $REMOTE_DIR != "." ]] && $REMOTE_PATH="$2/$3"
			# First, empty (not delete) the target directory
			[[ $MIRROR_MODE != "putnodelete" ]] && ftp_mirror delete "$REMOTE_CD" "$REMOTE_DIR" empty
			# Next, zip up our local directory
			local SENDZIP=`mktemp -u $WORKINGDIR_FULL/tmp/sendzip.XXXXX`
			ws_pushd "$LOCAL_DIR"
			[[ $? -ne 0 ]] && abort_die 80 "Could not enter local directory to be mirrored ($LOCAL_DIR)"
			find . -type f | $ZIP $ZIPOPT -@ $SENDZIP
			if [ $? -ne 0 ]; then
				ws_popd
				rm -f $SENDZIP
				abort_die 80 "Mirror: Create zip operation failed (error code: $?)"
			fi
			ws_popd
			ftp_putfile $SENDZIP "$REMOTE_PATH/`basename $SENDZIP`.zip"
			local FTPPUT_RET=$?
			rm -f $SENDZIP
			[[ $FTPPUT_RET -ne 0 ]] && abort_die 80 "Mirror operation: Could not send file to remote end (error code: $FTPPUT_RET)"
			remotecli_process "unzipd:$REMOTE_PATH/`basename $SENDZIP`.zip:$REMOTE_PATH" setvar
			if [[ $REMOTECLI_OUTPUT = "AUTHOK:UNZIPPED" ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "$SENDZIP.zip: Unzip operation success; mirror operation success"
				return 0
			else
				abort_die 80 "Mirror: Unzip operation failed (error code: $?; output: $REMOTECLI_OUTPUT)"
			fi
		elif [[ $MIRRORMODE = "get" ]]; then
			# curl recursive get
			# Use findfiles and getfile
			local RDIR=$2
			local RMIRROR_DIR=$3
			local LMIRROR_DIR=$4
			if [[ $RMIRROR_DIR =~ \.php$ ]]; then
				remotecli_process "getfile:$RDIR/$RMIRROR_DIR" >$LMIRROR_DIR/$RMIRROR_DIR
			else
				if [[ ! -d "$LMIRROR_DIR" ]]; then
					mkdir -p "$LMIRROR_DIR"+
				fi
				rpc_mirror_get "$RDIR" "$RMIRROR_DIR" "$LMIRROR_DIR"
			fi
		fi
	elif [[ $MIRRORMODE = "get-delsource" ]]; then
		if [[ -n $LFTP ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_mirror get-delsource lftp: $2 $3 $4 $5"
			# We don't take notice of --lftpdryrun here; that switch was not designed for this case
			if [[ $3 =~ \.php$ ]]; then
				# Single file
				$LFTP $LFTPDEBUG <<-ENDHERE
				open $ACCESSMETHOD://$FTPHOST
				user "$FTPUSER" "$FTPPASS"
				cd "$FTPDIR"
				$5
				cd "$2"
				get1 -o "$4" "$3"
				rm -f "$3"
				ENDHERE
			else
				# Directory
				$LFTP $LFTPDEBUG <<-ENDHERE
				open $ACCESSMETHOD://$FTPHOST
				user "$FTPUSER" "$FTPPASS"
				cd "$FTPDIR"
				$5
				cd "$2"
				mirror $LFTPVERB $LFTPADD --delete --parallel=$FTPPARALLEL "$3" "$4"
				mrm -rf "$3"
				rmdir -f "$3"
				ENDHERE
			fi
		else
			[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_mirror get-delsource curl: $2 $3 $4"
			local DO_CD=$2
			local DO_REMOTEDIR=$3
			local DO_LOCALDIR=$4
			# Curl recursive get-then-delete
			[[ ! -d "$DO_LOCALDIR" ]] && mkdir -p "$DO_LOCALDIR"
			ftp_mirror get "$DO_CD" "$DO_REMOTEDIR" "$DO_LOCALDIR"
			ftp_mirror delete "$DO_CD" "$DO_REMOTEDIR"
		fi
	elif [[ $MIRRORMODE = "delete" ]]; then
		if [[ -n $LFTP ]]; then
			$LFTP $LFTPDEBUG <<-ENDHERE
			open $ACCESSMETHOD://$FTPHOST
			user "$FTPUSER" "$FTPPASS"
			cd "$FTPDIR"
			cd "$2"
			mrm -rf "$3"
			rmdir -f "$3"
			ENDHERE
		else
			local DELACTION="deldir"
			[[ $4 = "empty" ]] && DELACTION="emptydir"
			# Curl recursive delete
			local TODEL=$2
			[[ $3 != "." ]] && TODEL="$2/$3"
			# Single file
			[[ $TODEL =~ \.php$ ]] && DELACTION="delfile"
			remotecli_process "$DELACTION:$TODEL" setvar noquit
			CURLDEL=$REMOTECLI_OUTPUT
			CURLDEL_RET=$?
			if [[ ${CURLDEL:0:14} = "AUTHOK:DELETED" ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "$TODEL: Successfully deleted on the remote side"
				return 0
			elif [[ $CURLDEL = "AUTHOK:NOSUCHDIR" ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "$TODEL: Could not delete on the remote side; no such file/directory"
				return 1
			else
				[[ $DEBUG -ge 1 ]] && ws_event_warning "Unexpected result returned from remotecli $DELACTION operation: $CURLDEL"
			fi
			return $CURLDEL_RET
		fi
	else
		abort_die 79 "$1: Unknown ftp_mirror mode"
	fi
	
}

function ftp_checkfileexistence() {
# Input: $1: file to list; if ends in / then it is a directory (this prior knowledge matters)
# $2: Options. Options: makedir = attempt to make directory, suppress = suppress stderr output
# Return 1 on success, otherwise 0
# Secret knowledge/assumptions: this is called only for .maintenance and then directories within wp-content

local ISDIR=0
local FILE=$1
# Strip slash for consistency
if [[ $1 =~ ^(.*)/$ ]]; then
	ISDIR=1
	FILE=${BASH_REMATCH[1]}
fi

if [[ -n $LFTP ]]; then
	local EXTRACOMM=""
	[[ $2 =~ makedir ]] && EXTRACOMM="mkdir $FILE"
	[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_checkfileexistence lftp $ACCESSMETHOD://$FTPHOST/$FTPDIR/$FILE $EXTRACOMM"
	# I think cls is always best - on vsftpd -d seems to take no effect on regular ls
	local LFTPOUTPUT=`mktemp "$WORKINGDIR_FULL/tmp/LFTP_OUT.XXXXX"`
	# The redirection to /dev/null suppress some debug output, but is needed to also suppress messages like "Access failed: 550 Can't change directory to /web/.maintenance: No such file or directory". To work around this problem, we have these two almost-identical blocks here, plus the option.
	if [[ $DEBUG -eq 0 && $2 =~ suppress ]]; then
		$LFTP $LFTPDEBUG 2>/dev/null >$LFTPOUTPUT <<-ENDHERE
		open $ACCESSMETHOD://$FTPHOST
		user "$FTPUSER" "$FTPPASS"
		cd "$FTPDIR"
		$EXTRACOMM
		cls -d "$FILE""
		ENDHERE
	else
		$LFTP $LFTPDEBUG >$LFTPOUTPUT <<-ENDHERE
		open $ACCESSMETHOD://$FTPHOST
		user "$FTPUSER" "$FTPPASS"
		cd "$FTPDIR"
		$EXTRACOMM
		cls -d "$FILE""
		ENDHERE
	fi
	CLS_OUTPUT=`cat $LFTPOUTPUT`
	rm -f $LFTPOUTPUT
	[[ $DEBUG -ge 1 ]] && ws_event_debug "Output=$CLS_OUTPUT when looking for file=$FILE"
	# Allow extra trailing slash if sent back (perhaps different servers do different things, though I think lftp standardises the output)
	[[ $CLS_OUTPUT =~ ^$FILE/? ]] && return 1
	return 0
else
	# Curl
	[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_checkfileexistence curl $ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$FILE"
	local OURCURLVERB=$CURLVERB
	[[ $OURCURLVERB = "--silent --show-error" ]] && OURCURLVERB="--silent"
	if [[ $ISDIR -eq 1 ]]; then
		# Curl appears to behave as follows:
		# - Specify a directory; make explicit by putting / on the end
		# If no other operation, then it just tries to cd; the success/failure code is then set
		# Give --ftp-create-dirs to try to create if the cd fails
		if [[ $2 =~ makedir ]]; then
			OURCURLVERB="$OURCURLVERB --ftp-create-dirs"
		fi
		local CURLOUTFILE=`mktemp "$WORKINGDIR_FULL/tmp/curlout.XXXXX"`
		echo -e "user = \"$FTPUSER:$FTPPASS\"\n" | $CURL $OURCURLVERB $CURL_FTPOPTIONS --config - --url "$ACCESSMETHOD://$FTPHOST/$FTPDIR/$FILE/" >"$CURLOUTFILE"
		local CURL_RET=$?
		if [ $CURL_RET -eq 19 -o $CURL_RET -eq 87 ]; then
			# Curl error: RETR failed / unable to parse list
			rm -f "$CURLOUTFILE"
			abort_die 78 "curl FTP operation failed, code $?; run again with --debug or --debug --debug for more information"
		elif [ $CURL_RET -eq 67 ]; then
			# Login failed
			ws_event_error "FTP login failed (login details were not accepted)"
			return 0
		elif [ $CURL_RET -eq 9 ]; then
			# Wouldn't let us cd, so probably does not exist
			return 0
		elif [ $CURL_RET -eq 0 ]; then
			# Success
			return 1
		else
			# This code not likely to be invoked, and likely wrong too
			[[ $DEBUG -ge 1 ]] && ws_event_debug "Contents of curl output file: `cat $CURLOUTFILE`"
			local SEEKFILE=`basename $FILE`
			grep -q ^$SEEKFILE$ "$CURLOUTFILE"
			local CURLOUTGREP=$?
			rm -f "$CURLOUTFILE"
			[[ $CURLOUTGREP -eq 0 ]] && return 1
			return 0
		fi
	else
		# File
		echo -e "user = \"$FTPUSER:$FTPPASS\"" | $CURL $OURCURLVERB $CURL_FTPOPTIONS --config - --url "$ACCESSMETHOD://$FTPHOST/$FTPDIR/$FILE" --output /dev/null
		local CURLRET=$?
		if [[ $CURLRET -eq 19 || $CURLRET -eq 78 ]]; then
			return 0
		elif [ $CURLRET -eq 67 ]; then
			# Login failed
			ws_event_error "FTP login failed (login details were not accepted)"
			return 0
		elif [ $CURLRET -eq 0 ]; then
			return 1
		else
			# Curl error: RETR failed / unable to parse list
			abort_die 78 "curl FTP operation failed, code $CURLRET; run again with --debug or --debug --debug for more information"
		fi
	fi
fi

}

function ftp_deletefile() {
	# Input: $1 file to delete; assumed to be directly deletable
	local FILE=$1
	if [[ -n $LFTP ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_deletefile lftp $ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$FILE"
		$LFTP $LFTPDEBUG <<-ENDHERE
		open $ACCESSMETHOD://$FTPHOST
		user "$FTPUSER" "$FTPPASS"
		cd "$FTPDIR"
		rm -f "$FILE"
		ENDHERE
	else
		[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_deletefile curl $ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$FILE"
		# + means to go into the indicated directory first
		if [[ $ACCESSMETHOD = "sftp" ]]; then
			$CURL $CURLVERB $CURL_FTPOPTIONS --config - --url "$ACCESSMETHOD://$FTPHOST" --quote "rm $FTPDIR/$FILE" --output /dev/null <<-ENDHERE
			user  = "$FTPUSER:$FTPPASS"
			ENDHERE
		else
			$CURL $CURLVERB $CURL_FTPOPTIONS --config - --url "$ACCESSMETHOD://$FTPHOST" --quote "CWD $FTPDIR" --quote "DELE `basename $FILE`" --output /dev/null <<-ENDHERE
			user  = "$FTPUSER:$FTPPASS"
			ENDHERE
		fi
	fi
}

function ftp_deletefiles() {
	# Input: $1 - a list of files to delete
	# We don't quit upon an error
	# We may change the file's contents
	# The advantage over repeatedly calling ftp_deletefile is that if possible this routine will try to do it in one go
	local LISTOFFILES=$1
	[[ $DEBUG -ge 1 ]] && ws_event_info "ftp_deletefiles: $LISTOFFILES"
	if [[ -n $LFTP ]]; then
		[[ $DEBUG -ge 1 ]] && ws_sed_i "s/^/rm /" $LISTOFFILES
		[[ $DEBUG -ge 1 ]] || ws_sed_i "s/^/rm -f /" $LISTOFFILES
		[[ $DEBUG -ge 2 ]] && ws_event_info "List of lftp commands to be executed: `cat $LISTOFFILES`"
		$LFTP $LFTPDEBUG <<-ENDHERE
		open $ACCESSMETHOD://$FTPHOST
		user "$FTPUSER" "$FTPPASS"
		cd "$FTPDIR"
		`cat $LISTOFFILES`
		ENDHERE
	elif [[ -n $CURL ]]; then
		while read DELTHISFILE; do
			[[ -n $DELTHISFILE ]] && ftp_deletefile "$DELTHISFILE"
		done <$LISTOFFILES
	else
		# RPC call delfile
		while read DELTHISFILE; do
			if [[ -n $DELTHISFILE ]]; then
				remotecli_process "delfile:$DELTHISFILE" setvar
				if [[ $REMOTECLI_OUTPUT =~ :DELETED: ]]; then
					[[ $DEBUG -ge 2 ]] && ws_event_info "Successfully deleted file: $DELTHISFILE"
				else
					[[ $DEBUG -ge 1 ]] && ws_event_warning "Tried to delete file $DELTHISFILE, but failed (output was: $REMOTECLI_OUTPUT)"
				fi
			fi
		done <$LISTOFFILES
	fi
}

function maintenance_mode() {
# Input: $1 = enter|enterwait|exit|state
# The variable MAINTENANCE_MINUTES is consulted for the number of minutes (or -1 for indefinite)
	if [ "$1" = "enter" -o "$1" = "enterwait" -o "$1" = "state" -o "$1" = "waitclear" ]; then
		# Sanity check - are we already in maintenance mode? And then enter it.
		local INMAINTENANCEMODE=1
		local MAINTENANCE_TIME="time();"
		if [[ -n $MAINTENANCE_MINUTES ]]; then
			# WP wants to know the time 10 minutes before you exit maintenance mode
			MAINTENANCE_TIME=$((NOWDATE-600+60*$MAINTENANCE_MINUTES))
		fi
		while [ $INMAINTENANCEMODE -eq 1 ]; do
			local REMOTECLI_GOTANSWER=0
			[[ $DISABLEREMOTECLI -eq 0 ]] && remotecli_process maintenancestate setvar silentfail || false
			if [ $? -eq 0 ]; then
				if [[ $REMOTECLI_OUTPUT = "AUTHOK:YES" ]]; then
					REMOTECLI_GOTANSWER=1
				elif [[ $REMOTECLI_OUTPUT = "AUTHOK:NONOFILE" ]]; then
					REMOTECLI_GOTANSWER=2
				elif [[ $REMOTECLI_OUTPUT = "AUTHOK:NOBUTFILE" ]]; then
					REMOTECLI_GOTANSWER=3
				else
					[[ $DEBUG -ge 1 ]] && ws_event_debug "Unknown response returned from remote end when checking maintenance state: $REMOTECLI_OUTPUT"
				fi
			fi
			# If we got a definitive answer
			if [[ $REMOTECLI_GOTANSWER -ge 1 && ( ( ( $1 = "enterwait" || $1 = "waitclear" ) && $REMOTECLI_GOTANSWER -eq 1 ) || $1 = "state" ) ]]; then
				if [[ $ACCESSMETHOD = "file" ]]; then
					local MAINT_FILE="$FILEDIR"
				else
					local MAINT_FILE="$ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR"
				fi
				if [[ $1 = "state" && $REMOTECLI_GOTANSWER -eq 1 ]]; then
					echo "${BOLD}$SITE:${OFFBOLD} In maintenance mode"
					INMAINTENANCEMODE=0
				elif [[ $1 = "state" && $REMOTECLI_GOTANSWER -eq 2 ]]; then
					echo "${BOLD}$SITE:${OFFBOLD} Not in maintenance mode"
					INMAINTENANCEMODE=0
				elif [[ $1 = "state" && $REMOTECLI_GOTANSWER -eq 3 ]]; then
					echo "${BOLD}$SITE:${OFFBOLD} Not in maintenance mode (but a .maintenance file remains - $MAINT_FILE/.maintenance)"
					INMAINTENANCEMODE=0
				elif [[ $1 = "enterwait" && $REMOTECLI_GOTANSWER -eq 1 ]]; then
					echo "Site already in maintenance mode ($MAINT_FILE/.maintenance) - sleeping for 30s (or press a key)"
					read -t 30 -n 1 -s
				elif [[ $1 = "waitclear" && $REMOTECLI_GOTANSWER -eq 1 ]]; then
					echo "Site presently in maintenance mode ($MAINT_FILE/.maintenance) - sleeping for 30s (or press a key)"
					read -t 30 -n 1 -s
				fi
			elif [[ $ACCESSMETHOD = "file" ]]; then
				# File
				if [[ $1 = "enterwait" && -f "$FILEDIR/.maintenance" ]]; then
					echo "Site already in maintenance mode ($FILEDIR/.maintenance) - sleeping for 30s (or press a key)"
					read -t 30 -n 1 -s
				elif [[ $1 = "waitclear" && -f "$FILEDIR/.maintenance" ]]; then
					echo "Site presently in maintenance mode ($FILEDIR/.maintenance) - sleeping for 30s (or press a key)"
					read -t 30 -n 1 -s
				elif [[ $1 = "waitclear" ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_debug "OK: Not in maintenance mode"
					INMAINTENANCEMODE=0
				elif [[ $1 = "state" && -f "$FILEDIR/.maintenance" ]]; then
					echo "${BOLD}$SITE:${OFFBOLD} In maintenance mode"
					INMAINTENANCEMODE=0
				elif [[ $1 = "state" ]]; then
					echo "${BOLD}$SITE:${OFFBOLD} Not in maintenance mode"
					INMAINTENANCEMODE=0
				elif [ "${1:0:5}" = "enter" ]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "Entering maintenance mode ($FILEDIR/.maintenance)"
					touch "$FILEDIR/.maintenance"
					# chown so that it can be deleted by an FTP user if needed
					setownership "$FILEDIR/index.php" "$FILEDIR/.maintenance"
					# Got this from http://sivel.net/2009/06/wordpress-maintenance-mode-without-a-plugin/
					# WordPress maintains maintenance mode for 10 minutes after the specified time
					echo "<?php global \$wordshell_maintenance; \$upgrading = (\$wordshell_maintenance === true ) ? 0 : $MAINTENANCE_TIME; ?>" >"$FILEDIR/.maintenance"
					INMAINTENANCEMODE=0
					ws_event_notice "$SITE: Entered maintenance mode"
				fi
			elif [[ $ACCESSMETHOD =~ ftp ]]; then
				# (S)FTP
				if [[ $1 = "enterwait" || $1 = "state" || $1 = "waitclear" ]]; then
					# Find out if we are already in maintenance mode
					if [[ -n $LFTP || $CURL_CAN_ACCESSMETHOD -eq 1 ]]; then
						ftp_checkfileexistence .maintenance suppress
						local FTP_MAINTENANCEEXISTS=$?
					else
						abort_die 72 "Needed a working and compatible lftp or curl to perform this operation (run again with --checkrequirements or --debug for more information"
					fi
				fi
				if [[ $1 = "enterwait" && $FTP_MAINTENANCEEXISTS -eq 1 ]]; then
					echo "Site already in maintenance mode ($ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/.maintenance) - sleeping for 30s (or press a key)"
					read -t 30 -n 1 -s
				elif [[ $1 = "waitclear" && $FTP_MAINTENANCEEXISTS -eq 1 ]]; then
					echo "Site presently in maintenance mode ($ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/.maintenance) - sleeping for 30s (or press a key)"
					read -t 30 -n 1 -s
				elif [[ $1 = "waitclear" ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_debug "OK: Not in maintenance mode"
					INMAINTENANCEMODE=0
				elif [[ $1 = "state"  && $FTP_MAINTENANCEEXISTS -eq 1 ]]; then
					echo "${BOLD}$SITE:${OFFBOLD} In maintenance mode"
					INMAINTENANCEMODE=0
				elif [[ $1 = "state" ]]; then
					echo "${BOLD}$SITE:${OFFBOLD} Not in maintenance mode"
					INMAINTENANCEMODE=0
				else
					echo "<?php global \$wordshell_maintenance; \$upgrading = (\$wordshell_maintenance === true ) ? 0 : $MAINTENANCE_TIME; ?>" >.maintenance
					[[ $DEBUG -ge 1 ]] && ws_event_info "Entering maintenance mode ($ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/.maintenance)"
					
					if [[ -n $LFTP || $CURL_CAN_ACCESSMETHOD -eq 1 ]]; then
						ftp_putfile .maintenance
					else
						ws_event_error "No working lftp or curl found for access method $ACCESSMETHOD (run with --checkrequirements for more information)"
						false
					fi
					[[ $? -ne 0 ]] && abort_die 73 "Failed to enter maintenance mode (run with --debug or --debug --debug for more information"
					INMAINTENANCEMODE=0
					ws_event_notice "$SITE: Entered maintenance mode"
				fi
			fi
		done
	elif [ "$1" = "exit" ]; then
		if [[ $ACCESSMETHOD = "file" ]]; then
			# File
			[[ $DEBUG -ge 1 ]] && ws_event_info "Leaving maintenance mode ($FILEDIR/.maintenance)"
			rm -f "$FILEDIR/.maintenance"
			ws_event_notice "$SITE: Left maintenance mode"
		else
			# (S)FTP
			[[ $DEBUG -ge 1 ]] && ws_event_info "Leaving maintenance mode ($ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/.maintenance)"
			if [[ -n $LFTP || $CURL_CAN_ACCESSMETHOD -eq 1 ]]; then
				ftp_deletefile .maintenance
			else
				ws_event_error "No working lftp or curl found for access method $ACCESSMETHOD (run with --checkrequirements for more information)"
				false
			fi
			local MAINTAIN_RET=$?
			if [[ $MAINTAIN_RET -ne 0 ]]; then
				ws_event_error "$SITE: Failed to leave maintenance mode (code: $MAINTAIN_RET)"
			else
				ws_event_notice "$SITE: Left maintenance mode"
			fi
		fi
		
	fi

}

# Parse $SITE. Afterwards, we detect different situations as follows:
# First, check for $SITE=all
# Second, if $SITECOUNT is greater or equal to 2, then loop over the array $SITES from 1 to $SITECOUNT
# Otherwise, $SITE is a simple site
# Checking whether SITECOUNT is greater or equal to 2 will also indicate whether there are (potentially) multiple sites - including the case where SITE is "all" and there is only one (or even none) in the configuration file
SITECOUNT=0
# Only bother doing anything if it's not a simple site name or "all"
if [[ -n $SITE && ( $SITE =~ , || $SITE =~ \@ || $SITE =~ \- ) ]]; then
# 	# This sets up GROUPRESULT and GROUPRESULT_COUNT, which then need normalising
	process_group_define "$SITE"
	if [[ $GROUPRESULT_COUNT -lt 1 ]]; then
		abort_die 98 "When processed, the site list was empty"
	else
		# Normalise
		for i in `seq 1 $GROUPRESULT_COUNT`; do
			if [[ -n ${GROUPRESULT[$i]} ]]; then
				# Site might be disabled - in which case, exclude
				REGEX="^site#${GROUPRESULT[$i]}#"
				[[ $MODE = "enablesite" || $MODE = "listsites" ]] && REGEX="^d*site#${GROUPRESULT[$i]}#"
				grep -q "$REGEX" $CONFIGFILE
				if [ $? -eq 0 ]; then
					SITECOUNT=$((SITECOUNT+1))
					SITES[$SITECOUNT]=${GROUPRESULT[$i]}
				fi
			fi
		done
	fi
	# It's possible that after normalising we still ended up with something empty
	[[ $SITECOUNT -lt 1 ]] && abort_die 98 "When processed, the site list was empty"
	# If there was exactly one, then put the result in the right place
	if [[ $SITECOUNT -eq 1 ]]; then
		SITE=${SITES[1]}
		# This processing was earlier deferred, as it did not work with multiple sites
		[[ $MODE = "rollback" && $DO_MULTIPLE_METAMODE -eq 0 ]] && process_rollbacktime
	fi
elif [[ $SITE = "all" ]]; then
	# Just something bigger than one
	SITECOUNT=2
elif [[ -n $SITE ]]; then
	SITECOUNT=1
fi

function list_site() {
	# Input: $1 = the regex to use when searching for matching sites in the config file
	local FREGEX=$1
	grep -E "$FREGEX" "$CONFIGFILE" | sort | while read LINE; do
		if [[ $LINE =~ ^(d)?site#([^#]+)#([^#]+)#([a-z]+)#(.+)$ ]]; then
			if [[ ${BASH_REMATCH[1]} = "d" ]]; then SITEENABLE="Disabled"; else SITEENABLE="Enabled"; fi
			SITEKEY=${BASH_REMATCH[2]}
			SITEURL=${BASH_REMATCH[3]}
			SITEMETHOD=${BASH_REMATCH[4]}
			SITEEXTRA=${BASH_REMATCH[5]}
			if [[ $SITEMETHOD = "file" ]]; then
				EXTRAPRINT="file://$SITEEXTRA"
			elif [[ $SITEMETHOD =~ ftp ]]; then
				if [[ $SITEEXTRA =~ ^([^#]+)#([^#]*)#([^#]+)#(.+)$ ]]; then
					FTPHOST="`echo ${BASH_REMATCH[1]} | cut -d/ -f1`"
					if [ $SHOWPASS -eq 1 ]; then
						EXTRAPRINT="$SITEMETHOD://${BASH_REMATCH[3]}:${BASH_REMATCH[4]}@$FTPHOST/${BASH_REMATCH[2]}"
					else
						EXTRAPRINT="$SITEMETHOD://${BASH_REMATCH[3]}@$FTPHOST/${BASH_REMATCH[2]}"
					fi
				else
					EXTRAPRINT="$SITEMETHOD; but could not parse the details"
				fi
			else
				EXTRAPRINT="$SITEMETHOD"
			fi
			printf "${BOLD}%-14s${OFFBOLD} %-14s %s\n" "$SITEKEY" "$SITEENABLE" "$EXTRAPRINT | $SITEURL"
		fi
	done
}

# List sites mode
if [[ $MODE = "listsites" ]]; then
	if [[ $SITE = "all" || -z $SITE ]]; then
		list_site "^d?site#"
	elif [[ $SITECOUNT -ge 2 ]]; then
		for i in `seq 1 $SITECOUNT`; do
			list_site "^d?site#${SITES[$i]}#" 
		done
	else
		list_site "^d?site#$SITE#"
	fi
	exit
fi

function show_disk_space() {
	echo -n "${BOLD}Disk space in use ($WORKDIR):${OFFBOLD} "
	# -h is not in POSIX, but is in GNU, Net/FreeBSD and Max OS X at least
	du -shx "$WORKDIR" 2>/dev/null | awk '{print $1}'
}

function site_reinvoke() {
	# Input: $1 = regex to use to locate the lists of sites from the configuration file
	local FREGEX=$1
	[[ $DEBUG -ge 1 ]] && ws_event_info "Intending to reinvoke for sites found in configuration using regex: $FREGEX"
	for SITE2 in `grep "$FREGEX" $CONFIGFILE | cut -d\# -f2 | sort`; do

		[[ "$MODE" != "list" && "$MODE" != "listrollbacks" && "$MODE" != "deleterollbacks" && $MODE != "maintenancestate" && ( $METAMODE != "core" || $MODE != "checkmodifications" ) ]] && echo "${BOLD}Site:${OFFBOLD} $SITE2"
		# Invoke whether or not a zip presently exists in the cache - the cache may be out of date
		EXTRAPARAMS=""
		# Pass on given parameters when re-invoking
		[[ $REQUIRENEWVERSION -eq 0 ]] && EXTRAPARAMS="--donotrequirenew"
		[[ $LISTEXACT -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --listexact"
		[[ $CACHE -ge 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --cache"
		[[ $DEBUG -ge 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --debug"
		[[ $DEBUG -ge 2 ]] && EXTRAPARAMS="$EXTRAPARAMS --debug"
		[[ $DEBUG -ge 3 ]] && EXTRAPARAMS="$EXTRAPARAMS --debug"
		[[ $VALIDITYWARNINGS -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --novaliditywarnings"
		if [ "$MODE" = "delete" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --delete --thisoneonly"
		elif [[ $MODE = "login" ]]; then
			EXTRAPARAMS="$EXTRAPARAMS --login"
		elif [[ $METAMODE = "user" ]]; then
			EXTRAPARAMS="$EXTRAPARAMS --$MODE"
			[[ -n $POSTS_REASSIGN ]] && EXTRAPARAMS="$EXTRAPARAMS --reassign=$POSTS_REASSIGN"
		elif [ "$MODE" = "refreshcache" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --refreshcache"
		elif [ "$MODE" = "activate" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --activate"
		elif [ "$MODE" = "visit" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --visit"
		elif [ "$MODE" = "deactivate" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --deactivate"
		elif [ "$MODE" = "restore" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --restore"
			[[ -n $RESTOREPATH ]] && EXTRAPARAMS="$EXTRAPARAMS=$RESTOREPATH"
		elif [[ $MODE = "phpinfo" || $MODE = "phpversion" || $MODE = "mysqlversion" ]]; then
			EXTRAPARAMS="$EXTRAPARAMS --$MODE"
		elif [ "$MODE" = "remotecli" ]; then
			if [[ ${#REMOTECLI_NONINTERACTIVE[@]} -gt 0 ]]; then
				for (( i = 0 ; i < ${#REMOTECLI_NONINTERACTIVE[@]} ; i++ )) do
					EXTRAPARAMS="$EXTRAPARAMS --remotecli=${REMOTECLI_NONINTERACTIVE[$i]}"
				done
# 				OLDIFS="$IFS"
# 				IFS="
# "
# 				for REMOTECLI_LINE in $REMOTECLI_NONINTERACTIVE; do
# 					EXTRAPARAMS="$EXTRAPARAMS --remotecli=$REMOTECLI_LINE"
# 				done
# 				IFS="$OLDIFS"
			else
				EXTRAPARAMS="$EXTRAPARAMS --remotecli"
			fi
		elif [ "$MODE" = "install" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --install"
		elif [ "$MODE" = "checkmodifications" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --checkmodifications"
			if [ $CHECKMODIFICATIONS_VIEW -eq 1 ]; then
				EXTRAPARAMS="${EXTRAPARAMS}=view"
				[[ $CHECKMODIFICATIONS_SHOWALL -eq 1 ]] && EXTRAPARAMS="${EXTRAPARAMS},showall"
			elif [ $CHECKMODIFICATIONS_SHOWALL -eq 1 ]; then EXTRAPARAMS="${EXTRAPARAMS}=showall"
			fi
		elif [ "$MODE" = "entermaintenance" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --entermaintenance"
		elif [ "$MODE" = "waitmaintenance" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --waitmaintenance"
		elif [ "$MODE" = "exitmaintenance" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --exitmaintenance"
		elif [ "$MODE" = "maintenancestate" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --maintenancestate"
		elif [[ $MODE = "searchandreplace" ]]; then
			EXTRAPARAMS="$EXTRAPARAMS --searchandreplace=$SEARCHANDREPLACE_SEARCH^$SEARCHANDREPLACE_REPLACE"
			[[ -n $TABLELIST ]] && EXTRAPARAMS="$EXTRAPARAMS --tablelist=$TABLELIST"
		elif [ "$MODE" = "listrollbacks" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --listrollbacks"
		elif [ "$MODE" = "deleterollbacks" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --deleterollbacks=$DELETEROLLBACKDAYS"
		elif [ "$MODE" = "disablesite" ]; then
			if [[ $DISABLESITEMODE = "disable" ]]; then
				EXTRAPARAMS="$EXTRAPARAMS --disablesite"
			else
				EXTRAPARAMS="$EXTRAPARAMS --delsite"
			fi
		elif [ "$MODE" = "enablesite" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --enablesite"
		elif [ "$MODE" = "passwordreset" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --passwordreset"
		elif [ "$MODE" = "list" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --list"
			[[ $WARNMISSING -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --warnmissing"
			[[ $LISTONLYUPDATES -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --listonlyupdates"
			[[ $LISTONLYTHIRDPARTY -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --listonlythirdparty"
		elif [[ ( $MODE = "normal" || $MODE = "rollback" ) && $ROLLBACKTIME != "x" ]]; then
			if [[ $ROLLBACKTIME = "most recent" ]]; then
				EXTRAPARAMS="$EXTRAPARAMS --thisoneonly --rollback"
			else
				EXTRAPARAMS="$EXTRAPARAMS --thisoneonly --rollback=\"$ROLLBACKTIME\""
			fi
		elif [ "$MODE" = "normal" ]; then
			EXTRAPARAMS="$EXTRAPARAMS --thisoneonly"
			[[ $AUTOPATCH -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --autopatch"
		else
			abort_die 42 "Do not know how to operate on all sites in mode: $MODE"
		fi
		[[ $DRYRUN -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --dryrun"
		# Meta modes
		EXTRAPARAMS="$EXTRAPARAMS --$METAMODE"
		# Already covered case of activate mode above, so don't specify twice
		[[ $METAMODE != "user" && $ACTIVATE -eq 1 && $MODE != "activate" ]] && EXTRAPARAMS="$EXTRAPARAMS --activate"
		[[ $METAMODE != "user" && $DEACTIVATE -eq 1 && $MODE != "deactivate" ]] && EXTRAPARAMS="$EXTRAPARAMS --deactivate"
		# In update mode with --activate, --update needs explicitly specifying
		[[ $ACTIVATE -eq 1 && $MODE = "normal" ]] && EXTRAPARAMS="$EXTRAPARAMS --update"
		[[ $DEACTIVATE -eq 1 && $MODE = "normal" ]] && EXTRAPARAMS="$EXTRAPARAMS --update"
		[[ $ONLYACTIVE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --active"
		[[ $ONLYINACTIVE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --inactive"
		[[ $FAST -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --fast"
		[[ $SHOWCHANGELOG -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --changelog"
		[[ $SHOWDESCRIPTION -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --description"
		[[ $SHOWLASTUPDATED -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --lastupdated"
		[[ $SHOWDOWNLOADURL -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --downloadurl"
		[[ $DISABLECACHE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --disablecache"
		[[ $USETRUNK -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --trunk"
		[[ $DETAILED -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --detailed"
		[[ $IGNORENAMECHANGE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --ignorenamechange"
		[[ $IGNOREMODIFICATIONS -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --ignoremodifications"
		if [[ $JUSTWP -eq 1 ]]; then
			EXTRAPARAMS="$EXTRAPARAMS --justwp"
			[[ $JUSTWPWIPEOTHERS -eq 1 ]] && EXTRAPARAMS="${EXTRAPARAMS}wipeothers"
		fi
		[[ $SSLVERIFY -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --nosslverify"
		[[ -z $LFTP ]] && EXTRAPARAMS="$EXTRAPARAMS --nolftp"
		[[ -z $WGET ]] && EXTRAPARAMS="$EXTRAPARAMS --nowget"
		[[ -z $CURL ]] && EXTRAPARAMS="$EXTRAPARAMS --nocurl"
		[[ -z $LYNX ]] && EXTRAPARAMS="$EXTRAPARAMS --nolynx"
		[[ -z $ELINKS ]] && EXTRAPARAMS="$EXTRAPARAMS --noelinks"
		[[ -z $RSYNC ]] && EXTRAPARAMS="$EXTRAPARAMS --norsync"
		[[ -n $USER_EMAIL ]] && EXTRAPARAMS="$EXTRAPARAMS --email=$USER_EMAIL"
		[[ -n $USER_ROLE ]] && EXTRAPARAMS="$EXTRAPARAMS --role=$USER_ROLE"
		[[ $DOSITETEST -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --nositetest"
		[[ $SKIPMAKEROLLBACK -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --skipmakerollback"
		[[ $GETCONFIRM -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --confirm"
		[[ $FILEMETHOD -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --filemethod"
		[[ $NETWORK_PLUGIN -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --network"
		[[ $NETWORK_BLOGID != "-1" ]] && EXTRAPARAMS="$EXTRAPARAMS --blog=$NETWORK_BLOGID"
		[[ $REQUIREFTPTLS -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --requireftptls"
		[[ $DISABLEFTPTLS -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --disableftptls"
		[[ $PHPLINT -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --nolint"
		[[ $CONFIRM_WHEN_NO_PRISTINE -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --noconfirmpristine"
		ws_cd "$ORIGDIR"
		[[ -n $CURRENTVERSION ]] && EXTRAPARAMS="$EXTRAPARAMS --cver=$CURRENTVERSION"
		[[ -n $USEZIP ]] && EXTRAPARAMS="$EXTRAPARAMS --new=$USEZIP"
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Invoking with parameters: \"$SITE2\" \"$PLUGIN\" --selfinvoked --nocountdiskspace $EXTRAPARAMS"
		$BASH $0 "$SITE2" "$PLUGIN" $EXTRAPARAMS --selfinvoked --nocountdiskspace
		ws_cd "$WORKDIR"
	done
}

# All sites/multiple sites mode - recursively self-invokes then exits
# If we are doing --everything/--pluginsandthemes together with all, then --groupbytype uses a different path, further down
if [[ $SITECOUNT -ge 2 && ( $DO_MULTIPLE_METAMODE -eq 0 || $GROUPBYTYPE -eq 0 ) ]]; then
	[[ $DEBUG -ge 1 ]] && ws_event_info "Multiple sites indicated - will iterate over each indicated site"
	# Multiple sites mode without a specified plugin does not allow delete, login or update (only list)
	if [[ -z $PLUGIN && ( $MODE != "list" && $MODE != "listrollbacks" && $MODE != "deleterollbacks" && $MODE != "maintenancestate" && $MODE != "exitmaintenance" && $MODE != "entermaintenance" && $MODE != "waitmaintenance" && $MODE != "remotecli" && $MODE != "phpinfo" && $MODE != "phpversion" && $MODE != "mysqlversion" && $MODE != "refreshcache" ) ]]; then
		abort_die 32 "When specifying multiple sites, you must specify a $METAMODE when in '$MODE' mode (--$MODE)"
	fi
	# Don't need to do anything special for 'latest' as we are just passing it on
	[[ $MODE = "normal" && ( -z "$USEZIP" && "$PLUGIN" != "all" ) ]] && choose_new_zip

	if [[ $SITE = "all" ]]; then
		site_reinvoke "^site#"
	else
		for i in `seq 1 $SITECOUNT`; do
			site_reinvoke "^site#${SITES[$i]}#" 
		done
	fi

	# Finish here - all actions are performed by re-invocation
	[[ $SHOWDISKSPACE -eq 1 ]] && show_disk_space
	exit
fi

# Now, deal with --everything and --pluginsandthemes
# This comes after "all sites" mode, so that by default for any one site all goes together, and we do not reach here
# However if --groupbytype was used then we will arrive here and be re-invoking with site "all"
if [[ $DO_MULTIPLE_METAMODE -eq 1 ]]; then

	reinvokeself --plugin
	reinvokeself --theme

	# We do not invoke with --content unless the mode was relevant (rather than throw an annoying error)
	# We don't re-invoke for --list as this produces confusing output (filenames)
	if [[ $METAMODE = "everything" && ( $MODE = "refreshcache" || $MODE = "restore" || $MODE = "login" ) ]]; then
		reinvokeself --content
	elif [[ $DEBUG -ge 1 ]]; then
		ws_event_info "Mode '$MODE' is not relevant with --content, so will not invoke --content --$MODE"
	fi

	# --database
	if [[ $METAMODE = "everything" && ( $MODE = "refreshcache" || $MODE = "listrollbacks" || $MODE = "deleterollbacks" ) ]]; then
		reinvokeself --database
	elif [[ $DEBUG -ge 1 ]]; then
		ws_event_info "Mode '$MODE' is not relevant with --database, so will not invoke --database --$MODE"
	fi

	# --core
	[[ $METAMODE = "everything" ]] && reinvokeself --core
	exit
fi

# Get the site name, confirm access
if [ -z "$SITE" ]; then
	# Format:
	# site:url:access-method:directory:username:[password, optional]
	# list available sites
	grep -q "^site#" $CONFIGFILE
	if [ $? -eq 0 ]; then
		echo -n "Known sites: "
		grep "^site#" $CONFIGFILE | cut -d\# -f2 | sort | while read SITE; do
			echo -n "$SITE "
		done
		echo
		GOTSITE=0
		while [ $GOTSITE -eq 0 ]; do
			read -p "Enter site name (or new/edit): " SITENAME
			if [ "$SITENAME" = "edit" ]; then
				if [ -n "$VI" ]; then
					$VI $CONFIGFILE
					SITENAME=""
				else
					ws_event_error "No working vi found (tried: $VI, path: $PATH)"
				fi
			fi
			REGEX='^(\S+) login$'
			if [[ $SITENAME =~ $REGEX ]]; then
				SITENAME=${BASH_REMATCH[1]}
				MODE="login"
			fi
			grep -q "^site#$SITENAME#" $CONFIGFILE
			if [[ $? -eq 0 || $SITENAME = "new" ]]; then
				GOTSITE=1
				SITE="$SITENAME"
			fi
		done
	fi
fi

# Disable site mode
if [[ $MODE = "disablesite" ]]; then
	if [[ $DISABLESITEMODE = "disable" ]]; then
		ws_sed_i "s/^site#$SITE#/dsite#$SITE#/g" $CONFIGFILE
	elif [[ $DISABLESITEMODE = "delete" ]]; then
		ws_sed_i "/^d*site#$SITE#/d" $CONFIGFILE
		# Remove the site from any groups it appears in
		ws_sed_i "s/^group#\(.*\)#$SITE$/group#\1#/" $CONFIGFILE
		ws_sed_i "s/^group#\(.*\)#$SITE,\(.*\)$/group#\1#\2/" $CONFIGFILE
		ws_sed_i "s/^group#\(.*\)#\(.*\),$SITE$/group#\1#\2/" $CONFIGFILE
		ws_sed_i "s/^group#\(.*\)#\(.*\),$SITE,\(.*\)$/group#\1#\2,\3/" $CONFIGFILE
		# Remove any siteopts
		ws_sed_i "/^siteopt#$SITE#/d" $CONFIGFILE
	fi
	exit $?
fi

# Enable site mode
if [[ $MODE = "enablesite" ]]; then
	ws_sed_i "s/^dsite#$SITE#/site#$SITE#/g" $CONFIGFILE
	exit $?
fi

# Indicate we don't yet know the precise access method for FTP sites (will be found later)
FTP_SUBACCESS=0

# Get access details for specified site from configuration file
if [[ $SITE != "new" ]]; then
	grep -q "^site#$SITE#" $CONFIGFILE || abort_die 7 "Site '$SITE' not found in configuration file"

	# Found - get parameters
	SITEURL=`grep "^site#$SITE#" $CONFIGFILE | head -1 | cut -d\# -f3`

	if [[ -z $RESTOREPATH ]]; then
		ACCESSMET=`grep "^site#$SITE#" $CONFIGFILE | head -1 | cut -d\# -f4`
		# site:site-name:access-method:directory:username:[password, optional]
		if [[ $ACCESSMET =~ ftp ]]; then
			ACCESSMETHOD=$ACCESSMET
			# Indicate we know the precise FTP method
			FTP_SUBACCESS=1
			FTPHOST=`grep "^site#$SITE#" $CONFIGFILE | head -1 | cut -d\# -f5`
			if [[ $FTPHOST =~ ^([^/]+)/([0-9]+)$ ]]; then
				FTPHOST=${BASH_REMATCH[1]}
				FTPPARALLEL=${BASH_REMATCH[2]}
				# TODO: Remove after a suitable time period (first added 9th August 2012)
				ws_event_info "Specifying a particular value for the maximum connections by adding /(number) in the configuration file is a deprecated configuration method, and will be removed in future. Please instead use a site option - add a line to the configuration file (run: wordshell --editconfig) like so: siteopt#$SITE#--ftpparallel=$FTPPARALLEL"
				[[ $DEBUG -ge 1 ]] && ws_event_info "Server: $FTPHOST: Configuration override (deprecated method): use maximum $FTPPARALLEL connections"
			fi
			FTPUSER=`grep "^site#$SITE#" $CONFIGFILE | head -1 | cut -d\# -f7`
			FTPPASS=`grep "^site#$SITE#" $CONFIGFILE | head -1 | cut -d\# -f8-`
			# A blank FTP password is legitimate if it's an sftp site with key-based login. Set flag to use later.
			# A regular FTP password could also be blank if they use Kerberos, but we will wait for a user to request that feature.
			[[ $ACCESSMETHOD = "sftp" && -z $FTPPASS ]] && SFTPPASS_BLANKCONFIG=1
			FTPDIR=`grep "^site#$SITE#" $CONFIGFILE | head -1 | cut -d\# -f6`
			# If this was blank (which was legitimate), then mark it for future
			[[ -z $FTPDIR ]] && FTPDIR_BLANKCONFIG=1
		else
			ACCESSMETHOD="file"
			FILEDIR=`grep "^site#$SITE#" $CONFIGFILE | head -1 | cut -d\# -f5`
		fi
	fi

	# Read in per-site options (configuration file key: siteopt)
	OLDIFS=$IFS
	IFS="
"
	for OPT in `grep "^siteopt#$SITE#" $CONFIGFILE | cut -d\# -f3`; do
		[[ $DEBUG -ge 1 ]] && ws_event_info "Site option: $OPT"
		IFS=$OLDIFS
		parse_option "$OPT"
		IFS="
"
	done
	IFS=$OLDIFS
fi

function accessmethod_warnings() {
	if [[ $ACCESSMETHOD = "sftp" && -z $LFTP && -n $CURL && $CURL_CAN_SFTP -eq 0 ]]; then
		ws_event_warning "This is an sftp site, but you do not have lftp installed, and your installed curl does not support SFTP. Therefore, many operations will fail. Either install lftp or upgrade your curl to support sftp."
	elif [[ ( $ACCESSMETHOD = "sftp" || $ACCESSMETHOD = "ftp" ) && -z $LFTP && -z $CURL ]]; then
		ws_event_warning "This is an $ACCESSMETHOD site, but you do not have lftp or curl installed. Therefore, most operations will fail. Please install either lftp or curl (run again with --checkrequirements for more details)"
	elif [[ $ACCESSMETHOD = "sftp" && ( -n $LFTP || $CURL_CAN_SFTP -eq 0 ) ]]; then
		ssh -V >/dev/null 2>/dev/null
		if [ $? -ne 0 ]; then
			ws_event_warning "Since you do not have an sftp-enabled curl installed, therefore SFTP sites are accessed using the lftp program which in turn uses the 'ssh' binary by default; however ssh was not found by default in your path. So, if you have problems and if ssh is installed in a non-default location on your system, then if you have not done so already you should edit one of the lftp configuration files ($WORKINGDIR_FULL/lftp/rc or /etc/lftp.conf) and add a line like 'set sftp:connect-program \"/path/to/ssh -a -x\"' (use 'man lftp' for more help). Alternatively if ssh is not installed at all then you will need to install it before you can use SFTP sites."
		fi
	fi
	if [[ $ACCESSMETHOD =~ ftp && -z $LFTP && -n $CURL ]]; then
		ws_event_info "This is an $ACCESSMETHOD site, but you do not have lftp installed. This makes the first sync of the site much slower (one file at a time, whereas lftp can sync many in parallel). Later sync operations are fast."
	fi
}

# If in restore mode, with path specified, then adjust
if [[ $MODE = "restore" && -n $RESTOREPATH ]]; then
	# Disable remote cli calls, since the file location is no longer linked to the URL
	if [[ $RESTOREPATH =~ ^s?ftps?:// ]]; then
		if [[ $RESTOREPATH =~ ^sftp: ]]; then
			ACCESSMETHOD="sftp"
		elif [[ $RESTOREPATH =~ ^ftps: ]]; then
			ACCESSMETHOD="ftps"
			# Indicate that we know the particular type of FTP access required
			FTP_SUBACCESS=1
		elif [[ $RESTOREPATH =~ ^ftp: ]]; then
			ACCESSMETHOD=ftp
		else
			abort_die 38 "$RESTOREPATH: Could not parse this restoration path"
		fi
		# Warn if we are missing any helper programs
		accessmethod_warnings
		# Now we need to get the other details
		# We only put this in a string because otherwise kate's syntax highlighting gets confused
		RESTOREREGEX='^s?ftps?://(([^:]*)(:([^@]*))?\@)?([^/]+)/(.*)$'
		if [[ $RESTOREPATH =~ $RESTOREREGEX ]]; then
			if [[ $DEBUG -ge 1 ]]; then
				ws_event_info "Parsed FTP user: ${BASH_REMATCH[2]}"
				ws_event_info "Parsed FTP password: ${BASH_REMATCH[4]}"
				ws_event_info "Parsed FTP host: ${BASH_REMATCH[5]}"
				ws_event_info "Parsed FTP path: ${BASH_REMATCH[6]}"
			fi
			ws_event_info "Will use restoration path: $RESTOREPATH"
			DISABLEREMOTECLI=1
			[[ $DEBUG -ge 1 ]] && ws_event_info "--restore=<path> implies --disableremotecli"
			FTPHOST=${BASH_REMATCH[5]}
			FTPDIR=${BASH_REMATCH[6]}
			FTPPASS=${BASH_REMATCH[4]}
			FTPUSER=${BASH_REMATCH[2]}
			# When restoring to a new directory, make the base plugin/theme directory for them. Needs to be done one directory at a time.
			[[ $METAMODE = "content" || $PLUGIN_OR_THEME_MODE -eq 1 ]] && ftp_checkfileexistence $CONTENTDIR/ makedir
			[[ $PLUGIN_OR_THEME_MODE -eq 1 ]] && ftp_checkfileexistence "$CONTENTDIR/$METAMODE_DIR/" makedir
		else
			abort_die 38 "$RESTOREPATH: Failed to parse this FTP/SFTP restoration path"
		fi
	else
		if [[ -d $RESTOREPATH ]]; then
			ws_event_info "Will use restoration path: $RESTOREPATH"
			ACCESSMETHOD="file"
			if [[ $FILEDIR != $RESTOREPATH ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "--restore=<path> implies --disableremotecli"
				DISABLEREMOTECLI=1
				FILEDIR=$RESTOREPATH
				# When restoring to a new directory, make the base plugin/theme directory for them
				[[ $PLUGIN_OR_THEME_MODE -eq 1 ]] && mkdir -p "$FILEDIR/$CONTENTDIR/$METAMODE_DIR"
				[[ $METAMODE = "content" ]] && mkdir -p "$FILEDIR/$CONTENTDIR"
			fi
		else
			abort_die 38 "$RESTOREPATH: Restoration path does not exist (if it was correct, then please create it)"
		fi
	fi
fi

function siteurl_test() {
# Input: be in working directory
# $SITEURL = prospective URL
# Returns as empty if not found
	# Input: $1 = quiet means, don't report the result to the user (just return the code)
	# Returns: 0 if site found, 1 otherwise
	local BEQUIET=$1
	make_and_enter tmp
	TMPTEST=`mktemp TMP-TEST.XXXXX`
	[[ $DEBUG -ge 1 ]] && ws_event_debug "Testing presence of WP site by looking for $SITEURL/readme.html"
	# Password warning (only happens if relevant and with wget) first time, only
	url_get "$SITEURL/readme.html" stdout passwarning >$TMPTEST
	SITEURL_FOUND=0
	if [[ $? -eq 0 && -s $TMPTEST ]]; then
		head -10 $TMPTEST | grep -qi 'WordPress' && SITEURL_FOUND=1
	fi
	if [ $SITEURL_FOUND -eq 0 ]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Testing presence of WP site by looking for $SITEURL/license.txt"
		url_get "$SITEURL/license.txt" stdout >$TMPTEST
		if [[ $? -eq 0 && -s $TMPTEST ]]; then
			head -1 $TMPTEST | grep -qi "WordPress" && SITEURL_FOUND=1
		fi
	fi
	if [ $SITEURL_FOUND -eq 0 ]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Testing presence of WP site by looking for $SITEURL/wp-trackback.php"
		url_get "$SITEURL/wp-trackback.php" stdout >$TMPTEST
		if [[ $? -eq 0 && -s $TMPTEST ]]; then
			head -10 $TMPTEST | grep -qi "<message>" && SITEURL_FOUND=1
		fi
	fi
	if [ $SITEURL_FOUND -eq 0 ]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Testing presence of WP site by looking for $SITEURL/wp-login.php"
		url_get "$SITEURL/wp-login.php" stdout >$TMPTEST
		if [[ $? -eq 0 && -s $TMPTEST ]]; then
			head -10 $TMPTEST | grep -qi "/wp-admin" && SITEURL_FOUND=1
		fi
	fi
	rm -f $TMPTEST
	ws_cd ..
	if [[ $SITEURL_FOUND -eq 1 ]]; then
		[[ $BEQUIET != "quiet" && $DEBUG -lt 1 ]] && echo "${BOLD}OK:${OFFBOLD} Found WordPress site at that location" >/dev/stderr
		return 0
	else
		[[ $BEQUIET != "quiet" ]] && echo -n "${BOLD}ERROR:${OFFBOLD} " >/dev/stderr
		[[ $BEQUIET != "quiet" && $DEBUG -lt 1 ]] && echo -n "Could not find any WordPress site at that location" >/dev/stderr >/dev/stderr
		if [[ $BEQUIET != "quiet" ]]; then
			echo " (you must enter the canonical WordPress URL, not any other URL that forwards to it. If your website is password protected, then specify the URL in this form: http://username:password@www.example.com/mysite (or make an entry in your .netrc file - see 'man netrc')). You can rerun with --debug (once, twice or thrice) for more information on what is going on.)" >/dev/stderr
		fi
		SITEURL=""
		return 1
	fi
}

# Ask for and test validity of site URL
# With --install --core, we want it to NOT exist; otherwise we want it to exist
while [[ ( $METAMODE != "core" || $MODE != "restore" ) && -z $SITEURL ]]; do
	read -p "New site: enter site URL, e.g. http://www.example.com : " SITEURL
	# Remove trailing / or /index.php
	[[ $SITEURL =~ index\.php$ ]] && SITEURL=${SITEURL%index.php}
	[[ $SITEURL =~ /$ ]] && SITEURL=${SITEURL%/}
	[[ $SITEURL =~ ^www\. ]] && SITEURL="http://$SITEURL"
	if [[ $SITEURL =~ ^https?:\/\/$ ]]; then
		ws_event_error "URL not recognised; needs to begin with http:// or https://"
		SITEURL=""
	fi
	if [[ $SITEURL != "none" ]]; then
		if [[ $CAN_URLGET -eq 0 ]]; then
			ws_event_warning "You do not have a working lftp, wget or curl available; many site management features will be unavailable (run again with --checkrequirements or --debug for more information)"
		else
			if [[ $METAMODE = "core" && $MODE = "install" ]]; then
				SAVE_SITEURL=$SITEURL
				siteurl_test quiet && abort_die 102 "Cannot install: a site already appears to exist at that location"
				SITEURL=$SAVE_SITEURL
			else
				siteurl_test
			fi
		fi
	fi
done

# Process --testurl
if [[ $TESTURL -eq 1 ]]; then
	if [[ $CAN_URLGET -eq 1 ]]; then
		# Preserving the variable only makes a difference for --core --install, which is somewhat absurd anyway, but whatever the user wants...
		SAVE_SITEURL=$SITEURL
		siteurl_test
		SITEURL=$SAVE_SITEURL
	else
		abort_die 101 "No working w3m, lynx or elinks available; cannot test the URL (--testurl) - run again with --checkrequirements for more information"
	fi
fi

# Request to know the access method, if not already known
while [ "$ACCESSMETHOD" != "ftp" -a "$ACCESSMETHOD" != "ftpes" -a "$ACCESSMETHOD" != "ftpp" -a "$ACCESSMETHOD" != "ftps" -a "$ACCESSMETHOD" != "sftp" -a "$ACCESSMETHOD" != "file" ]; do
	read -p "Access by FTP, SFTP or filesystem? [1=FTP, 2=SFTP, 3=Filesystem]: " -n 1 ACCESSMETHOD
	echo
	[[ $ACCESSMETHOD = "1" ]] && ACCESSMETHOD="ftp"
	[[ $ACCESSMETHOD = "2" ]] && ACCESSMETHOD="sftp"
	[[ $ACCESSMETHOD = "3" ]] && ACCESSMETHOD="file"
	accessmethod_warnings
done

# For FTP access, request to know the specific encryption method to be used, if not already known
# The first two of these are standard (and can be passed to lftp as-is), the second our own internal use
# ftps = implicit SSL (usually port 990)
# ftp = (explicit) encryption allowed but not mandated
# ftpes = explicit encryption, required
# ftpp = no encryption allowed (to cope with broken servers that advertise TLS but do not work)
while [[ $ACCESSMETHOD = "ftp" && $FTP_SUBACCESS != "1" ]]; do
	read -p "Choose FTP encryption method [1=use encryption when available (a.k.a. explicit encryption) - recommended choice if you are unsure, 2=require explicit encryption (TLS), 3=never use encryption (recommended only for broken or local servers), 4=use FTPS (a.k.a. implicit encryption, usually port 990, becoming obsolete): " -n 1 FTP_SUBACCESS
	if [[ $FTP_SUBACCESS -eq 1 ]]; then ACCESSMETHOD="ftp"; FTP_SUBACCESS=1;
	elif [[ $FTP_SUBACCESS -eq 2 ]]; then ACCESSMETHOD="ftpes"; FTP_SUBACCESS=1
	elif [[ $FTP_SUBACCESS -eq 3 ]]; then ACCESSMETHOD="ftpp"; FTP_SUBACCESS=1
	elif [[ $FTP_SUBACCESS -eq 4 ]]; then ACCESSMETHOD="ftps"; FTP_SUBACCESS=1
	fi
	echo
done

# Now set CURL_CAN_ACCESSMETHOD
if [[ ( ( $ACCESSMETHOD = "ftp" || $ACCESSMETHOD = "ftpp" ) && $CURL_CAN_FTP -eq 1 ) || ( $ACCESSMETHOD = "sftp" && $CURL_CAN_SFTP -eq 1 ) || ( $ACCESSMETHOD = "ftpes" && $CURL_CAN_FTPS -eq 1 ) ]]; then
	CURL_CAN_ACCESSMETHOD=1
fi

if [[ -z $LFTP && -n $CURL && $CURL_CAN_ACCESSMETHOD -eq 0 && $ACCESSMETHOD != "file" ]]; then
	ws_event_warning "The version of curl you have installed does not support the access method used by this site ($ACCESSMETHOD). You need to either install lftp (recommended), or update your version of curl, otherwise most operations will fail. Run again with --checkrequirements for more information."
elif [[ -z $LFTP && -n $CURL && $DEBUG -ge 1 && $ACCESSMETHOD != "file" ]]; then
	ws_event_debug "Access method $ACCESSMETHOD is supported by our installed curl"
fi

function ftp_login_mode() {
	# Return them to where they were; so they are uploading/downloading from/to where they expect
	ws_cd "$ORIGDIR"
	local MAKE_A_NETRC=0
	if [[ -s "$HOME/.netrc" ]]; then
		grep -E -q "machine[[:space:]]+$FTPHOST[[:space:]]+login[[:space:]]+$FTPUSER[[:space:]]+" "$HOME/.netrc"
		[[ -n $FTPPASS && $? -ne 0 ]] && MAKE_A_NETRC=1
	else
		MAKE_A_NETRC=1
	fi
	if [[ $MAKE_A_NETRC -eq 1 ]]; then
		echo "machine $FTPHOST login $FTPUSER password $FTPPASS" >"$LFTP_HOME/.netrc"
		# Netkit ftp performs a file permissions check
		chmod 600 $LFTP_HOME/.netrc
		HOME=$LFTP_HOME
	fi
	local GODIR="$FTPDIR"
	if [[ $METAMODE = "theme" || $PLUGIN_MODE_EXPLICIT -eq 1 ]]; then
		GODIR="$FTPDIR/$CONTENTDIR/$METAMODE_DIR"
		[[ -n $PLUGIN ]] && GODIR="$GODIR/$PLUGIN"
	elif [[ $METAMODE = "content" ]]; then
		GODIR="$FTPDIR/$CONTENTDIR"
	fi
	if [[ -n $LFTP ]]; then
		echo "Entering login mode - invoking lftp (will quit when you exit)"
		# When looking for .netrc, lftp uses HOME and not LFTP_HOME
		# But, possibly the user has entered the password in the present $HOME/.netrc
		# Use $HOME/.netrc by preference, as there may not be one in our configuration file
		$LFTP $LFTPDEBUG $ACCESSMETHOD://$FTPUSER@$FTPHOST/$GODIR
		exit
	else
		# Netkit FTP has no --version switch; returns an error on stdout
		ftp --version >/dev/null 2>/dev/null
		# Bash returns 127 for undefined functions. Netkit FTP returns 1.
		if [[ $? -eq 1 || $? -eq 0 ]]; then
			echo "Entering login mode (no lftp; manual entry required) - invoking ftp (will quit when you exit)"
			echo "When prompted, enter this username & password: $FTPUSER $FTPPASS"
			echo "After login, to enter the WP directory type: cd $GODIR"
			FTPDEBUG=""
			[[ $DEBUG -eq 1 ]] && FTPDEBUG="-v"
			[[ $DEBUG -ge 2 ]] && FTPDEBUG="-v -d"
			ftp $FTPDEBUG $FTPHOST
			exit
		else
			abort_die 41 "Cannot enter login mode: you do not have a working lftp or ftp (run again with --checkrequirements for more information; path where plain ftp is searched for was $PATH)"
		fi
	fi
}

function set_ftp_encryption_options() {
	# This routine changes our irregular access methods (ftpp, ftpes) into canonical, and sets up the lftp and curl configurations, and aborts if conflicting options were set
	# Input: Assumes we are in working directory
	# Thus far, REQUIREFTPTLS and DISABLEFTPTLS can only be set if they were set on the command line. So check for conflicting options as well as setting them correctly going forward
	if [[ $ACCESSMETHOD = "ftpp" ]]; then
		# Forbid encryption
		if [ $REQUIREFTPTLS -eq 1 ]; then
			ws_event_notice "--requireftptls was specified on this run, over-riding the settings for this site (which has been set up to never use encryption"
			echo "Note: --requireftptls was specified on this run, over-riding the settings for this site (which has been set up to never use encryption" >/dev/stderr
		else
			DISABLEFTPTLS=1
		fi
		ACCESSMETHOD="ftp"
	elif [[ $ACCESSMETHOD = "ftpes" ]]; then
		# Absolutely require successful encryption upgrade
		if [ $DISABLEFTPTLS -eq 1 ]; then
			ws_event_notice "--disableftptls was specified on this run, over-riding the settings for this site (which has been set up to require encryption every time"
			echo "Note: --disableftptls was specified on this run, over-riding the settings for this site (which has been set up to require encryption every time" >/dev/stderr
		else
			REQUIREFTPTLS=1
		fi
		ACCESSMETHOD="ftp"
	fi

	# By this point, we have ascertained whether we are using encryption with FTP or not.
	# This next check should be redundant, as the code above already does not allow it.
	if [[ $DISABLEFTPTLS -eq 1 && $REQUIREFTPTLS -eq 1 ]]; then
		abort_die 78 "Conflicting options; options were detected to both mandate and forbid FTP encryption"
	fi
	# Now, write the LFTP configuration file accordingly and set the curl options properly
	LFTPCONF_TMP=`mktemp tmp/lftp-cfg.XXXXX`
	grep -v "set ftp:ssl-allow" lftp/rc | grep -v "set ftp:ssl-force" > $LFTPCONF_TMP
	# Three possibilities: encryption is 1) required 2) forbidden 3) optional; corresponding to the 3 non-aborted combinations remaining for $DISABLEFTPTLS and $REQUIREFTPTLS
	if [ $DISABLEFTPTLS -eq 1 ]; then
		echo -e "set ftp:ssl-allow no\nset ftp:ssl-force no" >> $LFTPCONF_TMP
		# See http://www.openssl.org/docs/apps/ciphers.html
		# From curl 7.20 onwards (Feb 2010) we could use --no-ssl
		# No option should be needed; my reading is that without --ftp-ssl it does not even try SSL, so it is disabled by default
		CURL_FTPOPTIONS="$CURL_FTPOPTIONS --ciphers NULL"
	elif [ $REQUIREFTPTLS -eq 1 ]; then
		echo -e "set ftp:ssl-allow yes\nset ftp:ssl-force yes" >> $LFTPCONF_TMP
		# Note: --ftp-ssl-reqd is still supported, but now deprecated by --ssl-reqd which entered in 7.20.0 (Feb 2010)
		# --ftp-ssl-reqd itself was added in August 2006 (7.15.5)
		CURL_FTPOPTIONS="$CURL_FTPOPTIONS --ftp-ssl-reqd"
	else
		echo -e "set ftp:ssl-allow yes\nset ftp:ssl-force no" >> $LFTPCONF_TMP
		# Note: --ftp-ssl is still supported, but now deprecated by --ssl which entered in 7.20.0 (Feb 2010)
		# Means, "try ssl; revert to plain if not supported"
		CURL_FTPOPTIONS="$CURL_FTPOPTIONS --ftp-ssl"
	fi
	mv $LFTPCONF_TMP lftp/rc
	[[ $DEBUG -ge 2 && -n $LFTP ]] && ws_event_debug "LFTP configuration file dump follows: `cat lftp/rc`"
	[[ $DEBUG -ge 2 && $CURL_CAN_ACCESSMETHOD ]] && ws_event_debug "Curl FTP command line options to use: $CURL_FTPOPTIONS"

}

function get_ftp_details() {
	# Input: set $1 to 1 to force collection of details even if they already seem to exist.
	# FTPDIR can be legitimately blank
	[[ -z $FTPHOST || $1 -eq 1 ]] && read -p "Enter host name (and optional port, e.g. ftp.example.com:2000) : " FTPHOST
	[[ -z $FTPUSER || $1 -eq 1 ]] && read -p "Enter username : " FTPUSER
	[[ ( -z $FTPDIR && "$FTPDIR_BLANKCONFIG" != "1" ) || $1 -eq 1 ]] && read -p "Enter directory : " FTPDIR
	# SFTPPASS_BLANKCONFIG may be 1, or may be unset
	if [[ ( -z $FTPPASS && "$SFTPPASS_BLANKCONFIG" != "1" ) || $1 -eq 1 ]]; then
		GETPASS_PROMPT_EXTRA=""
		[[ $ACCESSMETHOD = "sftp" ]] && GETPASS_PROMPT_EXTRA=" (leave blank if you already have a working key-based login)"
		read -p "Enter password${GETPASS_PROMPT_EXTRA} : " -s FTPPASS
		echo
	fi
}

# Get FTP access details
if [[ $ACCESSMETHOD =~ ftp ]]; then
	# Get host/user/directory/password if not already set (e.g. read from configuration file)
	get_ftp_details
	# Save variables that set_ftp_encryption_options over-writes in case we need to recover them
	ORIGINAL_ACCESSMETHOD=$ACCESSMETHOD
	ORIGINAL_REQUIREFTPTLS=$REQUIREFTPTLS
	ORIGINAL_DISABLEFTPTLS=$DISABLEFTPTLS
	set_ftp_encryption_options
fi

# This next block not only confirms site access, but also performs the sync and login operations

# Directory existence to test for
# Default that should work with any new meta-modes added in future
CHECK_SANITY="wp-includes"
[[ $METAMODE = "plugin" || $METAMODE = "theme" ]] && CHECK_SANITY="$CONTENTDIR/${METAMODE}s"
[[ $METAMODE = "content" ]] && CHECK_SANITY="$CONTENTDIR"

function core_install_consistency_check() {
	# --core --install: need to verify that this location is actually the same as that given in SITEURL (test an upload)
	# aborts if the check failed
	if [[ $METAMODE = "core" && $MODE = "install" ]]; then
		setup_remote_manager $REMOTE_MANAGER_MINIMUM_PROTOCOL earlyping
		if [ $? -eq 0 ]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Successfully accessed indicated webspace (HTTP test)"
		else
			abort_die 102 "Test via HTTP of given location failed - is it the correct location? Returned error message was: $GET_REMOTE_MESSAGE"
		fi
	fi
}

# With --restore if a restorepath is specified, then we do not need to consult these other details
if [[ ( $MODE != "restore" || -z $RESTOREPATH ) && $ACCESSMETHOD =~ ftp ]]; then
	FTP_FOUND=0
	while [[ ( $SITE = "new" || -z $SITE ) && $FTP_FOUND -ne 1 ]]; do
		if [[ $METAMODE = "core" && $MODE = "install" ]]; then
			LOOKING_FOR="directory"
			[[ $DEBUG -ge 1 ]] && ws_event_info "Looking to confirm presence of root directory"
			ftp_checkfileexistence ./
			FTP_FOUND=$?
			[[ $DEBUG -ge 1 ]] && ws_event_debug "Result (looking for ./): $FTP_FOUND"
		else
			LOOKING_FOR="WordPress install (directory: wp-includes)"
			[[ $DEBUG -ge 1 ]] && ws_event_info "Looking to confirm presence of wp-includes"
			ftp_checkfileexistence wp-includes/
			FTP_FOUND=$?
			[[ $DEBUG -ge 1 ]] && ws_event_debug "Result (looking for wp-includes): $FTP_FOUND"
		fi
		if [[ $FTP_FOUND -ne 1 ]]; then
			ws_event_error "Could not find a $LOOKING_FOR there. Please check the details and try again."
			get_ftp_details 1
			ORIGINAL_ACCESSMETHOD=$ACCESSMETHOD
			REQUIREFTPTLS=$ORIGINAL_REQUIREFTPTLS
			DISABLEFTPTLS=$ORIGINAL_DISABLEFTPTLS
			set_ftp_encryption_options
		else
			echo "${BOLD}OK:${OFFBOLD} Found a $LOOKING_FOR there" >/dev/stderr
			[[ $DEBUG -ge 1 ]] && ws_event_debug "OK: Found a $LOOKING_FOR there"
		fi
	done

	# Verify that this location is actually the same as that given in SITEURL (test an upload)
	[[ $METAMODE = "core" && $MODE = "install" ]] && core_install_consistency_check

	# Save the details as they are, before set_ftp_encryption_options changes them
	SITESAVE=""
	if [[ $SITE = "new" || -z $SITE ]]; then
		while [[ ! $SITESAVE =~ ^[\-\.a-zA-Z0-9]+$ || $SITESAVE = "all" ]]; do
			read -p "Enter a site name to save these details for later use: " SITESAVE
			[[ $SITESAVE = "all" ]] && echo "Name 'all' is not allowed" >/dev/stderr
			grep -q "^site#$SITESAVE#" $CONFIGFILE
			if [ $? -eq 0 ]; then
				echo "$SITESAVE: That site name is already in use - please choose again" >/dev/stderr
				SITESAVE=""
			fi
		done
		# We save the ftpp/ftpes internal indicators; but after doing so strip them away
		if [[ -n $SITESAVE ]]; then
			echo "site#$SITESAVE#$SITEURL#$ORIGINAL_ACCESSMETHOD#$FTPHOST#$FTPDIR#$FTPUSER#$FTPPASS" >>"$CONFIGFILE"
			SITE="$SITESAVE"
		fi
		TMP_ALLFILES=""
		while [[ ! $TMP_ALLFILES =~ [yYnN] ]]; do
			read -n 1 -p "When mirroring this site, do you wish to mirror all found files (regardless of whether they are part of this WordPress install or not) ? (Choose no if you have already another backup solution other than WordShell, or if there will never be files to backup that are added from outside of WordPress; otherwise choose yes (which makes things run a bit slower since WordShell will be managing more files)) (y/n): " TMP_ALLFILES
			echo
		done
		[[ $TMP_ALLFILES = "n" || $TMP_ALLFILES = "N" ]] && echo "siteopt#$SITESAVE#--justwp" >>"$CONFIGFILE"
	fi

	# Login mode - drop into this before doing anything else (we want to be able to drop in even (especially) if things are broken)
	# Script then terminates - login_mode does not return
	[[ $MODE = "login" ]] && ftp_login_mode

	if [[ $ACCESSMETHOD =~ ftp && $CACHE -eq 0 && -z $LFTP && $CURL_CAN_ACCESSMETHOD -eq 0 ]]; then
		ws_event_warning "No working lftp or curl with $ACCESSMETHOD found (run with --checkrequirements or --debug for more info); enforcing --cache and ignoring --sync"
 		CACHE=1
 		SYNC=0
	fi

	# Sanity check existence of remote site, if appropriate
	if [[ $FTP_FOUND -eq 1 ]]; then
		# We already sanity checked and found it earlier (happens with newly created sites).
		true
	elif [[ $CACHE -ge 1 && -d "current/$SITE/$METAMODE_DIR" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Running in cache mode, and current/$SITE/$METAMODE_DIR exists: skipping sanity check on remote $ACCESSMETHOD server"
	elif [[ -d "current/$SITE/$METAMODE_DIR" && $((NOWDATE - `$STAT_MODTIME current/$SITE/$METAMODE_DIR`)) -le 36000 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "current/$SITE/$METAMODE_DIR exists, and was synced in last 10 hours; skipping sanity check on remote $ACCESSMETHOD server"
	elif [[ $MODE != "listrollbacks" && $MODE != "deleterollbacks" && $METAMODE != "database" ]]; then
		# (S)FTP login, look for existence of relevant directory
		[[ $DEBUG -ge 1 ]] && ws_event_info "Looking to confirm presence of $CHECK_SANITY"
		ftp_checkfileexistence $CHECK_SANITY/
		FTP_FOUND=$?
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Result (looking for $CHECK_SANITY): $FTP_FOUND"
		if [[ $FTP_FOUND -ne 1 ]]; then
			[[ $MODE = "restore" ]] && ws_event_info "In restore mode, missing ${METAMODE}s can be replaced; but you must still re-create the base ($CHECK_SANITY) directory manually (re-run with --login to do this quickly). This is so that we can be sure we have the correct directory."
			abort_die 11 "Could not find $ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$CHECK_SANITY"
		fi
		[[ $DEBUG -ge 1 ]] && ws_event_debug "OK: Found $CHECK_SANITY in given location ($ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$CHECK_SANITY)"
	fi
elif [[ ( $MODE != "restore" || -z $RESTOREPATH ) ]]; then
	# Access method = file
	[[ $METAMODE = "core" && $MODE = "install" ]] && CHECK_SANITY=""
	while [[ -z $FILEDIR || ! -d "$FILEDIR/$CHECK_SANITY" ]]; do
		if [[ -n "$FILEDIR" && ! -d "$FILEDIR/$CHECK_SANITY" ]]; then
			if [[ ! -d $FILEDIR ]]; then
				ws_event_error "$FILEDIR: no such directory (or at least, not one accessible by your user)"
				if [[ $METAMODE = "core" && $MODE = "install" ]]; then
					read -p "Do you want to create this directory now? (y/n): " -n 1 TMP_CREATEDIR
					echo
					if [[ $TMP_CREATEDIR = "y" || $TMP_CREATEDIR = "Y" ]]; then
						mkdir -p "$FILEDIR"
					else
						[[ $DEBUG -ge 1 ]] && ws_event_info "User chose to not create directory"
						FILEDIR=""
					fi
				else
					FILEDIR=""
				fi
			else
				ws_event_error "Could not access WP installation in given directory (searched for: $FILEDIR/$CHECK_SANITY)"
				FILEDIR=""
			fi
		fi
		[[ -z $FILEDIR ]] && read -p "Enter directory: " FILEDIR
	done
	[[ $METAMODE = "core" && $MODE = "install" && -d "$FILEDIR/wp-includes" ]] && abort_die 103 "Cannot install: there appears to already be a WordPress installation in that directory"
	# Login mode - drop into this before doing anything else (we want to be able to drop in even (especially) if things are broken)
	if [[ $MODE = "login" ]]; then
		GODIR="$FILEDIR"
		if [[ $METAMODE = "theme" || $PLUGIN_MODE_EXPLICIT -eq 1 ]]; then
			GODIR="$FILEDIR/$CONTENTDIR/$METAMODE_DIR"
			[[ -n $PLUGIN ]] && GODIR="$GODIR/$PLUGIN"
		elif [[ $METAMODE = "content" ]]; then
			GODIR="$FILEDIR/$CONTENTDIR"
		fi
		ws_cd "$GODIR"
		echo "Entering login mode - invoking interactive bash (will quit when you exit)"
		$BASH -i
		exit
	fi

	[[ $METAMODE = "core" && $MODE = "install" ]] && core_install_consistency_check

	if [ "$SITENAME" = "new" -o "$SITE" = "new" -o "$SITE" = "new" -o -z "$SITE" ]; then
		SITESAVE=""
		while [[ ! $SITESAVE =~ ^[\-\.a-zA-Z0-9]+$ || $SITESAVE = "all" ]]; do
			read -p "Enter a site name to save these details for later use: " SITESAVE
			[[ $SITESAVE = "all" ]] && echo "Name 'all' is not allowed"
			grep -q "^site#$SITESAVE#" $CONFIGFILE
			if [ $? -eq 0 ]; then
				echo "$SITESAVE: That site name is already in use - please choose again" >/dev/stderr
				unset SITESAVE
			fi
		done
		SITE="$SITESAVE"
		[[ -n $SITESAVE ]] && echo "site#$SITESAVE#$SITEURL#file#$FILEDIR" >>"$CONFIGFILE"
		TMP_ALLFILES=""
		while [[ ! $TMP_ALLFILES =~ [yYnN] ]]; do
			read -n 1 -p "When mirroring this site, do you wish to mirror all found files (regardless of whether they are part of this WordPress install or not) ? (Choose no if you have already another backup solution other than WordShell, or if there will never be files to backup that are added from outside of WordPress; otherwise choose yes (which makes things run a bit slower since WordShell will need be managing more files)) (y/n): " TMP_ALLFILES
			echo
		done
		[[ $TMP_ALLFILES = "n" || $TMP_ALLFILES = "N" ]] && echo "siteopt#$SITESAVE#--justwp" >>"$CONFIGFILE"

	fi
fi

[[ -z $SITE ]] && abort_die 2 "No valid site specified"

# Setup finished: now we have the site and its access details, and they are sanity-checked; we can start processing most modes

# Apply the filters from --fast (exit if nothing to do) (these are never set with --core)
if [[ ( $MODE = "delete" || $MODE = "normal" || $MODE = "restore" || $MODE = "rollback" || $MODE = "list" ) && ( $FAST -eq 1 ) ]]; then
	if [[ ! -e "$WORKINGDIR_FULL/current/$SITE/$METAMODE_DIR/$PLUGIN" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "$SITE: $PLUGIN: Nothing to do: ${METAMODE} is not present in the local cache, and --fast was given"
		exit
	fi
fi

# Maintenance mode
if [[ $MODE = "entermaintenance" ]]; then
	maintenance_mode enter
	exit
elif [[ $MODE = "waitmaintenance" ]]; then
	maintenance_mode waitclear
	exit
elif [[ $MODE = "exitmaintenance" ]]; then
	maintenance_mode exit
	exit
elif [[ $MODE = "maintenancestate" ]]; then
	maintenance_mode state
	exit
fi

if [[ $MODE = "visit" ]]; then
	if [[ -z $SITEURL ]]; then
		abort_die 94 "Cannot visit this site: the site URL is not known"
	elif [[ $CAN_BROWSE -ne 1 ]]; then
		abort_die 94 "$SITEURL: Cannot visit the site, as we did not find a web browser (w3m, lynx or elinks - run again with --checkrequirements for more information"
	else
		[[ ${SITEURL: -1} != "/" ]] && SITEURL="${SITEURL}/"
		url_browser "$SITEURL"
		exit
	fi
fi

# --user metamode
if [[ $METAMODE = "user" ]]; then
	if [[ $MODE = "list" ]]; then
		[[ -n $PLUGIN ]] && options_abort "--list --user takes no other parameters"
		TMP_LISTCOM="userlist"
		[[ $DETAILED -eq 1 ]] && TMP_LISTCOM="userlistdetailed"
		remotecli_process $TMP_LISTCOM tellfile
		if [[ "`head -1 $REMOTECLI_OUTPUT`" =~ ^AUTHOK: ]]; then
			tail -n +2 $REMOTECLI_OUTPUT
			echo
		else
			if [[ $DEBUG -ge 1 ]]; then
				ws_event_debug "Output not understood; first 5 lines of output follow: `head -5 $REMOTECLI_OUTPUT`"
			fi
			abort_die 99 "The output from the remote side was not understood"
		fi
		rm -f $REMOTECLI_OUTPUT
	elif [[ $MODE = "passwordreset" ]]; then
		[[ -z $PLUGIN ]] && options_abort "With --list --password you need to specify a username or email address"
		remotecli_process "passwordreset:$PLUGIN" setvar
		if [[ $REMOTECLI_OUTPUT =~ ^AUTHOK:PWCHANGED:([^:]+) ]]; then
			ws_event_info "$SITE: $PLUGIN: User password changed successfully"
			ws_event_info "$SITE: $PLUGIN: Password: ${BASH_REMATCH[1]}" 1
		elif [[ $REMOTECLI_OUTPUT =~ ^(AUTHOK:)?ERROR:(.*)$ ]]; then
			abort_die 104 "User password reset failed: error message returned was: ${BASH_REMATCH[2]}"
		else
			abort_die 104 "User password reset failed; output could not be understood (output: $REMOTECLI_OUTPUT)"
		fi
# 		exit
	elif [[ $MODE = "add" ]]; then
		if [[ -z $PLUGIN ]]; then
			options_abort "You need to specify a username: syntax is: wordshell <site> <username> --user --add --email=<email address>"
		elif [[ -z $USER_EMAIL ]]; then
			options_abort "You need to specify an email address: syntax is: wordshell <site> <username> --user --add --email=<email address>"
		else
			if [[ -z $USER_ROLE ]]; then
				USER_ROLE="subscriber"
				ws_event_info "$PLUGIN: No user role was specified (--role=); defaulting to subscriber"
			elif [[ $USER_ROLE = "admin" ]]; then
				USER_ROLE="administrator"
			fi
			remotecli_process "useradd:$PLUGIN:$USER_ROLE:$USER_EMAIL" setvar
			if [[ $REMOTECLI_OUTPUT =~ ^AUTHOK:ADDED:([^:]+) ]]; then
				ws_event_info "$SITE: $PLUGIN: User created successfully"
				ws_event_info "Password: ${BASH_REMATCH[1]}" 1
			elif [[ $REMOTECLI_OUTPUT =~ ^(AUTHOK:)?ERROR:(.*)$ ]]; then
				abort_die 104 "User creation failed: error message returned was: ${BASH_REMATCH[2]}"
			else
				abort_die 104 "User creation failed; output could not be understood (output: $REMOTECLI_OUTPUT)"
			fi
		fi
	elif [[ $MODE = "delete" ]]; then
		[[ -z $PLUGIN ]] && options_abort "You need to specify a username (or email address): syntax is: wordshell <site> <username|email address> --user --delete [--reassign=<username|email address|@admin>]"
		RC_REASSIGN=""
		[[ -n $POSTS_REASSIGN ]] && RC_REASSIGN=",$POSTS_REASSIGN"
		remotecli_process "userdel:${PLUGIN}${RC_REASSIGN}" setvar
		if [[ $REMOTECLI_OUTPUT =~ ^AUTHOK:DELETED ]]; then
			ws_event_info "$SITE: $PLUGIN: User deleted successfully"
		elif [[ $REMOTECLI_OUTPUT =~ ^(AUTHOK:)?ERROR:NOSUCHUSER ]]; then
			abort_die 104 "User deletion failed: no such user found"
		elif [[ $REMOTECLI_OUTPUT =~ ^(AUTHOK:)?ERROR:NOSUCHAUSER ]]; then
			abort_die 104 "User deletion failed: the user for re-assignment was not found"
		elif [[ $REMOTECLI_OUTPUT =~ ^(AUTHOK:)?ERROR:NOSUCHRUSER ]]; then
			abort_die 104 "User deletion failed: no admin was found to re-assign to"
		else
			abort_die 104 "User deletion failed; output could not be understood (output: $REMOTECLI_OUTPUT)"
		fi
	else
		abort_die 99 "--user --$MODE: this operation is not supported"
	fi
	exit
fi

# --active and --inactive and --remotecli/--phpinfo/--phpversion/--mysqlversion : make sure we are able to proceed; and list all plugins/themes for later use
HTTP_LIST_OUTPUT=""
if [[ ( $PLUGIN_OR_THEME_MODE -eq 1 && ( $NETWORK_BLOGID != "-1" || $NETWORK_PLUGIN -eq 1 || $ONLYACTIVE -eq 1 || $ONLYINACTIVE -eq 1 || $MODE = "remotecli" || $MODE = "phpinfo" || $MODE = "phpversion" || $MODE = "mysqlversion" || ( $MODE = "list" && -n $SITEURL && $DISABLEREMOTECLI -eq 0 ) ) ) || $METAMODE = "database" ]]; then
	[[ -z $SITEURL ]] && abort_die 70 "--active, --inactive, --remotecli, --database, --phpinfo, --phpversion, --mysqlversion, --network or --blog was specified; but these rely on knowing the site URL, which we do not have"
	[[ $DISABLEREMOTECLI -eq 1 ]] && options_abort "Cannot perform this action with --disableremotecli"
	[[ $ACCESSMETHOD = "file" && $CAN_URLGET -eq 0 ]] && abort_die 70 "You need to have a working lftp, wget or curl installed to use this feature"
	[[ $ACCESSMETHOD =~ ftp && -z $LFTP && $CURL_CAN_ACCESSMETHOD -eq 0 ]] && abort_die 70 "You need to have a working lftp or curl that supports $ACCESSMETHOD installed to use this feature"
	setup_remote_manager $REMOTE_MANAGER_MINIMUM_PROTOCOL nononce
	GET_REMOTE_RETURN=$?

	if [[ ( -n $REMOTE_CONTENTDIR && $REMOTE_CONTENTDIR != $CONTENTDIR ) ]]; then
		TMP_CHANGECONTENTDIR=""
		while [[ ! $TMP_CHANGECONTENTDIR =~ [yYnN] ]]; do
			read -n 1 -p "The remote site reports that its content directory is not found at the default location ($CONTENTDIR), but at $REMOTE_CONTENTDIR - do you wish to note this in our local configuration (y is strongly recommended) (y/n): " TMP_CHANGECONTENTDIR
			echo
		done
		if [[ $IREALLYMEANIT -eq 0 && $TMP_CHANGECONTENTDIR = "y" || $TMP_CHANGECONTENTDIR = "Y" ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_notice "Setting site option: --contentdir=$REMOTE_CONTENTDIR"
			# First, remove any existing entry
			ws_sed_i "/^siteopt#--contentdir=.*$/d" $CONFIGFILE
			# Now, add the new entry
			echo "siteopt#$SITE#--contentdir=$REMOTE_CONTENTDIR" >>"$CONFIGFILE"
			CONTENTDIR=$REMOTE_CONTENTDIR
		fi
	fi

	if [ $GET_REMOTE_RETURN -ne 0 ]; then
		[[ $METAMODE = "database" || $ONLYACTIVE -eq 1 || $ONLYINACTIVE -eq 1 || $MODE = "remotecli" || $MODE = "phpinfo" || $MODE = "phpversion" || $MODE = "mysqlversion" ]] && abort_die 70 "$SITE: --active, --inactive, --remotecli, --database, --phpinfo, --phpversion, --mysqlversion, --network or --blog was specified; but these rely on being able to communicate with the remote site via HTTP; this failed (return code: $GET_REMOTE_RETURN; error message was: $GET_REMOTE_MESSAGE)"
	# Listing is not needed in remotecli mode
	elif [[ $METAMODE != "database" && $MODE != "remotecli" && $MODE != "phpinfo" && $MODE != "phpversion" && $MODE != "mysqlversion" ]]; then
		RPCLISTCOM=list
		[[ $METAMODE = "plugin" && $NETWORK_PLUGIN -eq 1 ]] && RPCLISTCOM="listnet"
		RPCLISTCOMMAND="${RPCLISTCOM}${METAMODE}s"
		[[ $METAMODE = "plugin" && $NETWORK_BLOGID != "-1" ]] && RPCLISTCOMMAND="listsite${METAMODE}s:${NETWORK_BLOGID}"
		remotecli_process $RPCLISTCOMMAND tellfile
		HTTP_LIST_OUTPUT=$REMOTECLI_OUTPUT
		if [[ -n $HTTP_LIST_OUTPUT && -s $HTTP_LIST_OUTPUT ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Remote manager: got back a response ($HTTP_LIST_OUTPUT)"
			LIST_HEADLINE=`head -1 $HTTP_LIST_OUTPUT`
			echo $LIST_HEADLINE | grep -q "^AUTHOK:OK:List"
			FIND_AUTH_RET=$?
			if [[ $FIND_AUTH_RET -ne 0 && $LIST_HEADLINE =~ ERROR:NotMulti ]]; then
				abort_die 70 "either --network or --blog was specified, but this is not a WordPress multi-site installation"
			elif [[ $FIND_AUTH_RET -ne 0 && ( $MODE = "remotecli" || $ONLYACTIVE -eq 1 || $ONLYINACTIVE -eq 1 ) ]]; then
				[[ $DEBUG -ge 1 ]] &&  ws_event_error "looked for AUTHOK:OK:List; got: `head -1 $HTTP_LIST_OUTPUT`)"
				abort_die 70 "--active or --inactive was specified; but these rely on being able to communicate with the remote site via HTTP; this failed"
			elif [[ $FIND_AUTH_RET -ne 0 ]]; then
				unset HTTP_LIST_OUTPUT
				[[ $DEBUG -ge 1 ]] && ws_event_debug "Did not find expected output in remote listing - will ignore what was received"
			fi
		elif [[ $ONLYACTIVE -eq 1 || $ONLYINACTIVE -eq 1 ]]; then
			abort_die 70 "--active or --inactive was specified; but these rely on being able to communicate with the remote site via HTTP; this failed (returned no valid information)"
		else
			unset HTTP_LIST_OUTPUT
		fi
	fi
fi

function sync_core() {
	# Input:
	# Be in current/$SITE
	# core/wp-includes directory must exist
	# This function does this:
	#
	# 1) Find out the version (use RPC, since we need that anyway)
	# 2) Make sure we've got and unpacked that WP version (without wp-content)
	# 3) Then sync (only copy different files) - uses an RPC findfiles5 call. Always make sure we have wp-includes/version.php

	# 1) Find out the version (use RPC, since we need that anyway)
	[[ $DEBUG -ge 1 ]] && ws_event_info "Finding out remote version"
	if [[ -n $REMOTE_WPVERSION ]]; then
		local THEVERSION=$REMOTE_WPVERSION
	else
		remotecli_process wpversion setvar
		[[ ! $REMOTECLI_OUTPUT =~ ^AUTHOK:WPVERSION:([0-9](\.[0-9]+)+(-(alpha|beta|RC[0-9]?(-[0-9]+)))?)$ ]] && ws_event_error "Could not find the remote version number (output was: $REMOTECLI_OUTPUT)"
		local THEVERSION=${BASH_REMATCH[1]}
	fi
	[[ $DEBUG -ge 1 ]] && ws_event_info "Remote version: $THEVERSION"

	# 2 Make sure we've got that WP version, unpacked
	ensure_unpacked_core_exists $THEVERSION

	# 3) Sync (only copy different files) - uses an RPC findfiles5 call
	# Sets the return status to indicate success or failure
	# $1 = the remote directory to first cd into
	# $2 = the remote directory to then fetch (after the cd)
	# $3 = the local directory to sync to
	# $4 = if set, the local directory to first check (a read-only directory; think of the dir in $3 as an overlay on top of $4)
	# Internally, $4 is only used for syncing WordPress core; in which case we exclude wp-content
	# So, if you wish to use an overlay for a different purpose, then amend the code below
	# Pre-populate using rsync; copy over everything that is not part of a standard WP install
	# Nothing to do if --justwp was used, since this sync is for the non-WP stuff
	if [[ $ACCESSMETHOD = "file" && -n $RSYNC && $JUSTWP -eq 0 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Trying to pre-populate local cache of WordPress core, using rsync"
		$RSYNC --exclude=/$CONTENTDIR --exclude=/wp-admin --exclude=/wp-includes --exclude=/wp-*.php --exclude=/index.php --exclude=/license.txt --exclude=/readme.html --exclude=/xmlrpc.php --exclude=.svn/ --delete $RSYNCOPT --perms --links --times --recursive "$FILEDIR"/ core/
		if [ $? -ne 0 ]; then
			[[ $DEBUG -ge 1 ]] && ws_event_notice "rsync returned an error (code: $?); is not fatal, but it may slow us down"
		fi
	elif [[ $ACCESSMETHOD = "file" && $JUSTWP -eq 0 ]]; then
		ws_event_info "The next step would be quicker if you installed rsync"
	elif [[ -n $LFTP && $JUSTWP -eq 0 ]]; then
		# Only LFTP has a multi-threaded mirror mode; if we are relying on curl then mirror simply falls through to rpc_mirror_get anyway, so now point doing it twice
		[[ $DEBUG -ge 1 ]] && ws_event_info "Trying to pre-populate local cache of WordPress core, using lftp mirror"
		local SAVE_EXCLUDE_GLOB_FTP=$EXCLUDE_GLOB_FTP
		EXCLUDE_GLOB_FTP="wp-admin/ wp-includes/ $CONTENTDIR/ .svn/ wp-*.php license.txt readme.html xmlrpc.php index.php"
		ftp_mirror get . . core
		EXCLUDE_GLOB_FTP=$SAVE_EXCLUDE_GLOB_FTP
	fi
	rpc_mirror_get . . core ../../fromwporg.core/$THEVERSION/wordpress
}

function move_old_database() {
	# $1 : file to move (must exist)
	# We must be in the directory current/<site>/database
	make_and_enter ../../../old.$METAMODE
	MOVETOLEAF="$SITE-database-$NOWDATE-$1"
	[[ $DEBUG -ge 1 ]] && ws_event_debug "Moving old version (current/site/database/$1) to: $WORKDIR/old.$METAMODE/$1"
	mv "../current/$SITE/database/$1" .
	# Return to where we were before
	ws_cd "../current/$SITE/database"
}

# This goes in a separate function so as to be usable from FTP or file code (since it does not depend on the method)
# Sets DATABASE_SYNCED_THIS_RUN
function sync_database() {
	if [[ $DATABASE_SYNCED_THIS_RUN -eq 1 ]]; then
		ws_event_debug "sync_database: database has already been synced this run, so nothing to do"
		return
	fi
	# Must be in current/<site> when calling this
	remotecli_process dbdump tellfile
	if [[ -s $REMOTECLI_OUTPUT ]]; then
		local DATALINES=`wc -l "$REMOTECLI_OUTPUT" | awk '{print $1}'`
		grep -qi '^drop table' $REMOTECLI_OUTPUT
		local GREPRES=$?
		if [[ $DATALINES -gt 50 && $GREPRES -eq 0 ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_debug "New database file has $DATALINES lines in the output - assuming it is a proper DB"
			make_and_enter database
			# Move previous database into old. directory
			for i in *.sql.zip *.sql ; do
				# -f test necessary in case there were no files
				[[ -f $i ]] && move_old_database $i
			done
			# This is chosen to match what is looked for in the managerollbacks function
			local SAVEAS="$SITE-database-$NOWDATE-0.sql"
			[[ -n $REMOTE_WPVERSION ]] && SAVEAS="$SITE-database-$NOWDATE-$REMOTE_WPVERSION.sql"
			mv "$REMOTECLI_OUTPUT" "$SAVEAS"
			DATABASE_SYNCED_THIS_RUN=1
			if [[ -n $ZIP ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_debug "Zipping up database file: `pwd`: $SAVEAS -> $SAVEAS.zip"
				$ZIP $ZIPOPT -m "$SAVEAS.zip" "$SAVEAS"
			fi
			ws_cd ..
		else
			ws_event_error "Failed to sync the WordPress database - the output was not as expected ($REMOTECLI_OUTPUT)"
			[[ $DEBUG -ge 1 ]] && ws_event_debug "Result (should be 0) when looking for expected SQL: $GREPERS; number of lines in output file (at least 50 wanted) ($REMOTECLI_OUTPUT): $DATALINES"
		fi
	else
		ws_event_error "Failed to sync the WordPress database - no output resulted"
	fi
}

# Now, take a local copy of the site's relevant directory
# In core mode, this needs to only download changed files, but also make sure we have a copy of the base version
FTP_SYNC_PASSED=0

if [[ ( $METAMODE != "core" || $MODE != "install" ) && ( $ACCESSMETHOD  = "ftp" || $ACCESSMETHOD = "sftp" || $ACCESSMETHOD = "ftps" ) && ( $MODE != "restore" && $MODE != "deleterollbacks" && $MODE != "listrollbacks" && $MODE != "remotecli" && $MODE != "phpinfo" && $MODE != "phpversion" && $MODE != "mysqlversion" ) ]]; then
	# (S)FTP
	make_and_enter "current/$SITE"
	# Skip sync if the directory exists and either we were told to cache or it's been synced in the last 3 hours
	if [[ -d $METAMODE_DIR && -f core/wp-includes/version.php && $CACHE -ge 1 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Skipping initial sync, as running in cache mode and cache exists"
	elif [[ -d $METAMODE_DIR && -f core/wp-includes/version.php && $SYNC -eq 0 && $((NOWDATE - `$STAT_MODTIME $METAMODE_DIR`)) -le 10800 ]]; then
		# Need to keep that 10800 seconds in sync with uses elsewhere
		[[ $DEBUG -ge 1 ]] && ws_event_info "Skipping initial sync, as we synced within the last three hours"
	else
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Synchronising entity ${METAMODE} from site ($ACCESSMETHOD) to $WORKDIR/current/$SITE"
		mkdir -p core/wp-includes
		if [[ $METAMODE = "core" ]]; then
			sync_core
			# Update time-stamp
			touch core
		else
			if [[ -z $LFTP && $CURL_CAN_ACCESSMETHOD -eq 1 ]]; then
				# Only lftp performs the extra get below. For curl we do it manually.
				url_get "$ACCESSMETHOD://$FTPUSER:$FTPPASS@$FTPHOST/$FTPDIR/wp-includes/version.php" stdout tryonlycurl >core/wp-includes/version.php
			fi
			if [[ $METAMODE = "content" ]]; then
				ftp_mirror get $CONTENTDIR . content "get -O core/wp-includes wp-includes/version.php"
			elif [[ $METAMODE = "database" ]]; then
				sync_database
			else
				ftp_mirror get $CONTENTDIR ${METAMODE}s ${METAMODE}s "get -O core/wp-includes wp-includes/version.php"
			fi
			[[ $? -ne 0 ]] && abort_die 72 "Sync failed ($?) (run with --debug or --debug --debug for more information)"
		fi
		FTP_SYNC_PASSED=1
	fi
	if [ $DEBUG -ge 1 ]; then
		ws_event_debug "Local copy now has (follows): "
		TMP_LOCAL_COPY=`ls "$METAMODE_DIR"`
		ws_event_debug $TMP_LOCAL_COPY
	fi
	# Touch, so that we can decide whether to sync again later
	[[ -d $METAMODE_DIR ]] && touch $METAMODE_DIR
	# Return to working directory
	ws_cd ../..
elif [[ ( $METAMODE != "core" || $MODE != "install" ) && $MODE != "restore" && $MODE != "deleterollbacks" && $MODE != "listrollbacks" && $MODE != "remotecli" && $MODE != "phpinfo" && $MODE != "phpversion" && $MODE != "mysqlversion" ]]; then
	# File method. Existence of plugin directory has already been verified.
	if [[ -d "current/$SITE/$METAMODE_DIR" && -f "current/$SITE/core/wp-includes/version.php" && ( $CACHE -ge 2 || ( $CACHE -ge 1 && $SELFINVOCATION -ge 1 ) ) ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Skipping initial sync, as running in cache mode and cache exists"
	else
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Synchronising entity (${METAMODE}) on site (file) to $WORKDIR/current/$SITE"
		[[ -z $RSYNC && $METAMODE != "database" && $DEBUG -ge 1 ]] && ws_event_info "Optimum operation needs a working copy of rsync; we recommend you install this; re-run with --checkrequirements or --debug for more help."
		make_and_enter "current/$SITE"
		# Get the version file; spares an RPC round-trip
		mkdir -p core/wp-includes
		[[ ! -f "$FILEDIR/wp-includes/version.php" && $MODE != "restore" ]] && abort_die 99 "Something is seriously amiss and we recommend you proceed cautiously and verify your installation manually: could not find the file wp-includes/version.php on the live site (looked for: $FILEDIR/wp-includes/version.php)"
		cp $COPYOPT "$FILEDIR/wp-includes/version.php" "core/wp-includes/"
		if [[ $METAMODE = "core" ]]; then
			# Do a further timestamp check, as this involves lots of HTTP calls
			if [[ $SYNC -eq 0 && $((NOWDATE - `$STAT_MODTIME core`)) -le 10800 ]]; then
				# The 10800 here needs keeping in sync with uses elsewhere
				[[ $DEBUG -ge 1 ]] && ws_event_info "Skipping initial sync, as we synced within the last three hours"
			else
				sync_core
				# Update time-stamp
				touch core
			fi
		elif [[ $METAMODE = "database" ]]; then
			sync_database
		else
			RSYNCADD=""
			for XGLOB in $EXCLUDE_GLOB_RSYNC; do
				RSYNCADD="$RSYNCADD --exclude $XGLOB"
			done
			[[ $METAMODE = "content" ]] && RSYNCADD="$RSYNCADD --exclude /themes/ --exclude /plugins/ --exclude /updraft/ --exclude /upgrade/"
			if [[ -n $RSYNC ]]; then
				# We do not add --owner --group, as this affects quota counting
				# Careful with the trailing slashes
				FROMDIR="$FILEDIR/$CONTENTDIR/$METAMODE_DIR"
				TODIR="./"
				if [[ $METAMODE = "content" ]]; then
					FROMDIR="$FILEDIR/$CONTENTDIR/"
					TODIR="content/"
					mkdir -p content
				fi
				[[ $DEBUG -ge 1 ]] && echo $RSYNC --delete $RSYNCOPT $RSYNCADD --perms --links --copy-unsafe-links --times --recursive "$FROMDIR" "$TODIR"
				$RSYNC --delete $RSYNCOPT $RSYNCADD --perms --links --copy-unsafe-links --times --recursive "$FROMDIR" "$TODIR"
				RETCODE=$?
			else
				# No rsync
				[[ $DEBUG -ge 1 ]] && ws_event_info "rsync not found: this operation may be significantly slower; we recommend you install it"
				rm -rf $METAMODE_DIR
				if [[ $METAMODE = "content" ]]; then
					cp $COPYOPT -R "$FILEDIR/$CONTENTDIR" $METAMODE_DIR
					RETCODE=$?
					rm -rf "$METAMODE_DIR/plugins" "$METAMODE_DIR/themes" "$METAMODE_DIR/updraft" "$METAMODE_DIR/upgrade"
				else
					cp $COPYOPT -R "$FILEDIR/$CONTENTDIR/${METAMODE}s" $METAMODE_DIR
					RETCODE=$?
				fi
			fi
			[[ $RETCODE -ne 0 ]] && abort_die 5 "Sync returned errors (code: $RETCODE)"
		fi
		# Touch, so that we can decide whether to sync again later
		[[ -d $METAMODE_DIR ]] && touch $METAMODE_DIR
		# Return to working directory
		ws_cd ../..
	fi
fi

[[ $METAMODE = "core" && $MODE = "install" ]] && mkdir -p "current/$SITE/core"

# Anything there?
if [[ $MODE != "remotecli" && $MODE != "phpinfo" && $MODE != "phpversion" && $MODE != "mysqlversion" && $MODE != "deleterollbacks" && $MODE != "listrollbacks" && ! -d "current/$SITE/${METAMODE_DIR}" ]]; then
	abort_die 4 "Could not find $WORKDIR/current/$SITE/${METAMODE_DIR} (apparently copy operation failed)"
fi

if [[ $MODE = "refreshcache" ]]; then
	[[ $DEBUG -ge 1 ]] && ws_event_info "Refresh cache mode: refresh completed: exiting"
	exit
fi

# Database activity can be done here, now that we have synced
if [[ $METAMODE = "database" && $MODE = "searchandreplace" ]]; then
	# Back up, as it is a dangerous operation; don't rely on the user doing so explicitly
	make_and_enter "current/$SITE"
	sync_database
	cd ../..
	echo -n "${BOLD}Search and replacing${OFFBOLD} (wait, do not abort): "
	if [[ -z $TABLELIST ]]; then
		remotecli_process "dbsearchreplace:$SEARCHANDREPLACE_SEARCH^$SEARCHANDREPLACE_REPLACE" setvar
	else
		remotecli_process "dbsearchreplace:$SEARCHANDREPLACE_SEARCH^$SEARCHANDREPLACE_REPLACE:$TABLELIST" setvar
	fi
	ws_event_debug "Remote searchandreplace operation results: $REMOTECLI_OUTPUT"
	if [[ $REMOTECLI_OUTPUT =~ DBSRDONE: ]]; then
		echo "Success"
		[[ $REMOTECLI_OUTPUT =~ :t([0-9]+): ]] && echo "Tables examined: ${BASH_REMATCH[1]}"
		[[ $REMOTECLI_OUTPUT =~ :r([0-9]+): ]] && echo "Rows examined: ${BASH_REMATCH[1]}"
		[[ $REMOTECLI_OUTPUT =~ :c([0-9]+): ]] && echo "Changes made: ${BASH_REMATCH[1]}"
		[[ $REMOTECLI_OUTPUT =~ :u([0-9]+): ]] && echo "SQL update commands run: ${BASH_REMATCH[1]}"
		[[ $REMOTECLI_OUTPUT =~ :d([0-9]+): ]] && echo "Time taken: ${BASH_REMATCH[1]}s"
	elif [[ $REMOTECLI_OUTPUT =~ ERR: ]]; then
		ws_event_error "Failed: output was: ${REMOTECLI_OUTPUT}"
	else
		ws_event_error "Failed: could not understand the response from the remote side: $REMOTECLI_OUTPUT"
	fi
	exit
fi

if [[ $MODE = "listrollbacks" ]]; then
	managerollbacks list
	exit
elif [[ $MODE = "deleterollbacks" ]]; then
	managerollbacks delete $DELETEROLLBACKDAYS
	exit
fi

if [[ $MODE = "phpversion" && -n $REMOTE_PHPVERSION ]]; then
	echo $REMOTE_PHPVERSION
	exit
elif [[ $MODE = "mysqlversion" && -n $REMOTE_MYSQLVERSION ]]; then
	echo $REMOTE_MYSQLVERSION
	exit
elif [[ $MODE = "phpinfo" || $MODE = "phpversion" || $MODE = "mysqlversion" ]]; then
	RDEBUG=$DEBUG
	remotecli_process $MODE tellfile
	PHPINFO_OUTFILE=$REMOTECLI_OUTPUT
	if [[ -f $PHPINFO_OUTFILE ]]; then
		CURLINE=1
		FIRSTLINE="`head -1 $PHPINFO_OUTFILE`"
		# Try to deal with extraneous whitespace
		while [[ ! $FIRSTLINE =~ AUTHOK: && $CURLINE -le 100 ]]; do
			CURLINE=$((CURLINE+1))
			FIRSTLINE="`head -$CURLINE $PHPINFO_OUTFILE | tail -1`"
		done
		if [[ $FIRSTLINE = "AUTHOK:PHPINFO:" ]]; then
			if [[ -n $W3M ]]; then
				tail -n +$((CURLINE+1)) "$PHPINFO_OUTFILE" | $W3M -T text/html
			elif [[ -n $ELINKS ]]; then
				tail -n +$((CURLINE+1)) "$PHPINFO_OUTFILE" | $ELINKS -force-html
			elif [[ -n $LYNX ]]; then
				tail -n +$((CURLINE+1)) "$PHPINFO_OUTFILE" | $LYNX -force_html -stdin
			else
				ws_event_error "Neither w3m, elinks nor lynx was available to display the output (re-run with --checkrequirements for more information)"
			fi
		elif [[ ${FIRSTLINE:0:18} = "AUTHOK:PHPVERSION:" ]]; then
			echo "${FIRSTLINE:18}"
		elif [[ ${FIRSTLINE:0:20} = "AUTHOK:MYSQLVERSION:" ]]; then
			echo "${FIRSTLINE:20}"
		else
			ws_event_error "Output was not in the expected format"
			[[ $DEBUG -ge 1 ]] && ws_event_info "First line of output was: $FIRSTLINE"
			if [[ $DEBUG -ge 2 ]]; then
				ws_event_debug "Whole output follows: "
				TMP_WHOLE_OUTPUT=`cat $PHPINFO_OUTFILE`
				ws_event_debug "$TMP_WHOLE_OUTPUT"
			fi
		fi
		rm -f "$PHPINFO_OUTFILE"
	else
		ws_event_error "No output found; something went wrong"
	fi
	exit
fi

if [[ $MODE = "remotecli" ]]; then
	if [[ ${#REMOTECLI_NONINTERACTIVE[@]} -eq 0 ]]; then
		echo "WARNING: Remote CLI mode is an unsupported interface, intended for experts and feature development."
		echo "Enter 'exit' to stop sending commands.
Enter 'debug <0|1|2|3>' to set verbosity.
Enter 'login' to drop into a shell to access the files directly.
Enter 'rdebug <0|1>' to toggle whether to request debugging information from the remote side.

All other commands are sent to the remote side (try 'help' for a list)." >/dev/stderr
	fi
	# Need to unset this on relevant commands: GET_REMOTE_ALREADY_DONE, and re-call setup_remote_manager
	# Change mode to prevent setup_remote_manager printing out the version info every time
	MODE="remotecli-active"
	RDEBUG=$DEBUG
	if [[ ${#REMOTECLI_NONINTERACTIVE[@]} -gt 0 ]]; then
		for (( i = 0 ; i < ${#REMOTECLI_NONINTERACTIVE[@]} ; i++ )) do
			EXTRAPARAMS="$EXTRAPARAMS --remotecli=${REMOTECLI_NONINTERACTIVE[$i]}"
			[[ $DEBUG -ge 1 ]] && ws_event_debug "$SITE: Running remotecli command from command line: ${REMOTECLI_NONINTERACTIVE[$i]}"
			remotecli_process "${REMOTECLI_NONINTERACTIVE[$i]}"
		done
		exit
	else
		while true; do
			read -e -p "> " REMOTECLI_COM
			remotecli_process "$REMOTECLI_COM"
			echo
		done
	fi
fi

[[ ! -d "current/$SITE/$METAMODE_DIR" && $MODE = "restore" ]] && abort_die 70 "In restore mode, but no local cache exists - nothing to restore from"

# Now, let's look at which entity to update: display the menu
ws_cd "current/$SITE/${METAMODE_DIR}"

function showentity_thisdir() {
	# Core-friendly: yes
	# Output: sets FOUNDWANTED
	# Input: $PLUGDIR needs to be set to the slug (the directory (or file name for single-file plugins))
	# $1 = show only this slug
	# $2 : if set to "file", then it is a plugin in a single file (not a directory)
	local SHOWONLY=$1
	local ISFILE=$2
	local REMOTE_FOUND_DETAILS=0
	[[ $DEBUG -ge 1 ]] && ws_event_debug "showentity_thisdir: showonly=$1, isfile=$2, PLUGDIR=$PLUGDIR, pwd=`pwd`, caller=`caller`"
	# PACTIVE: -1 means unknown; otherwise yes/no
	PACTIVE=-1
	# Did we manage to get (via remotecli) a list of plugins? If so, interrogate that.
	if [[ -n $HTTP_LIST_OUTPUT && -s $HTTP_LIST_OUTPUT ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "$PLUGDIR: Found remote list ($HTTP_LIST_OUTPUT); will look for details"
		if [[ $METAMODE = "plugin" ]]; then
			if [[ $ISFILE = "file" ]]; then
				local PLUGKEY="^$PLUGDIR:"
			else
				local PLUGKEY="^$PLUGDIR/"
			fi
		else
			local PLUGKEY="^$PLUGDIR:"
		fi
		grep -q $PLUGKEY $HTTP_LIST_OUTPUT
		if [ $? -eq 0 ]; then
			REMOTE_FOUND_DETAILS=1
			FOUNDPLUG=1
			# Plugin format: plugfile:yes|no(active):version:name
			# Theme format: themedir:yes|no(active):version:name:parent name
			PVER=`grep $PLUGKEY $HTTP_LIST_OUTPUT | head -1 | cut -d: -f3`
			PNAME=`grep $PLUGKEY $HTTP_LIST_OUTPUT | head -1 | cut -d: -f4`
			PFILE=`grep $PLUGKEY $HTTP_LIST_OUTPUT | head -1 | cut -d: -f1`
			PACTIVE=`grep $PLUGKEY $HTTP_LIST_OUTPUT | head -1 | cut -d: -f2`
			PPARENT=`grep $PLUGKEY $HTTP_LIST_OUTPUT | head -1 | cut -d: -f5`
		fi
	fi
	# Sets FOUNDPLUG, PVER, PNAME, PFILE
	if [[ $REMOTE_FOUND_DETAILS -eq 0 ]]; then
		if [[ $METAMODE = "plugin" && $ISFILE = "file" ]]; then
			get_entity_version $PLUGDIR
		else
			get_entity_version
		fi
	fi
	if [ $FOUNDPLUG -eq 1 ]; then
		# Print if we are showing all plugins, or if this is the requested one
		if [[ -z $SHOWONLY || $SHOWONLY = $PLUGDIR || $METAMODE = "core" || ($LISTEXACT -eq 0 && $PLUGDIR =~ $SHOWONLY) ]]; then
			PRINTTHISONE=0
			LATESTVER=""
			UNKNOWN_AT_WP=0
			# If no restrictions regarding third party / updates on listing, then list this one
			if [[ $LISTONLYUPDATES -eq 0 && $LISTONLYTHIRDPARTY -eq 0 && ( $ONLYACTIVE -eq 0 || $PACTIVE = "yes" ) && (( $ONLYINACTIVE -eq 0 || $PACTIVE = "no" )) ]]; then
				PRINTTHISONE=1
			fi
			NEWESTFOUND_FILE=""
			NEWESTFOUND_VERSION=""
			# First, try to use the API (to find the latest version)
			API_FETCHED_VERSION=0
			if [[ -z $PVER ]]; then
				ws_event_warning "$PLUGDIR: Apparently this theme has no version number"
				PVER=0
			fi
			# TODO: This won't work for single-file plugins (but isn't hello.php the only one of those that is also in the WP plugins directory? Seems a bit pointless to pay much attention to that). Could just hard-code in a check for hello.php.
			if [[ $DISABLEAPI -eq 0 && $USETRUNK -eq 0 ]]; then
				get_api_entity_info "$PLUGDIR" "$PFILE" "$PVER" "$PNAME"
				API_RETSHOW=$?
				if [ $API_RETSHOW -eq 0 ]; then
					API_FETCHED_VERSION=1
					version_sort $PVER $API_PLUGIN_VER
					if [ $? -eq 2 ]; then
						[[ $LISTONLYUPDATES -eq 1 && ( $ONLYACTIVE -eq 0 || $PACTIVE = "yes" ) && (( $ONLYINACTIVE -eq 0 || $PACTIVE = "no" )) ]] && PRINTTHISONE=1
						LATESTVER=$API_PLUGIN_VER
					fi
				elif [ $API_RETSHOW -eq 6 ]; then
					# Indicates not known at wordpress.org
					UNKNOWN_AT_WP=1
					[[ $LISTONLYTHIRDPARTY -eq 1 && ( $ONLYACTIVE -eq 0 || $PACTIVE = "yes" ) && (( $ONLYINACTIVE -eq 0 || $PACTIVE = "no" )) ]] && PRINTTHISONE=1
				fi
			fi
			# Set this now - it is used both in the next conditional block and in the following unconditional
			REGEXF="[a-z\.\/]*/$PLUGDIR\.[0-9a-z\.]+\.zip"
			# Didn't succeed through the API; try caches and downloading
			local HOWMANYDOTS="../../.."
			[[ $PLUGIN_OR_THEME_MODE -eq 1 && $ISFILE != "file" ]] && HOWMANYDOTS="../../../.."
			if [ $API_FETCHED_VERSION -eq 0 ]; then
				# See if there are any recent versions; if not, do download_latest first
				# This is to refresh the cache
				if [[ -z "`find $HOWMANYDOTS/fromwporg.$METAMODE -maxdepth 1 -regex $REGEXF -mtime -7 2>/dev/null ; find $HOWMANYDOTS/customimports.$METAMODE -maxdepth 1 -regex $REGEXF 2>/dev/null`" || $USETRUNK -eq 1 ]]; then
					[[ $DEBUG -ge 1 && $USETRUNK -eq 0 ]] && ws_event_info "No ${METAMODE} ($PLUGDIR) found in WP caches from last 7 days or in custom caches, so going to try to download latest"
					[[ $DEBUG -ge 1 && $USETRUNK -eq 1 ]] && ws_event_info "--trunk was specified, so will try to download latest version"
					SAVE_PNAME=$PNAME
					SAVE_PVER=$PVER
					SAVE_FOUNDPLUG=$FOUNDPLUG
					ws_pushd $HOWMANYDOTS
					PLUGIN=$PLUGDIR
					# This resets PNAME/PVER/FOUNDPLUG
					# Only need to check wp; we examine the cache unconditionally later, so don't waste time
					download_latest wp
					if [ "$PVER" = "$SAVE_PVER" ]; then
						# Touch to indicate that we already have the latest - prevent repeated downloads
						touch -c fromwporg.$METAMODE/$PLUGDIR.$PVER.zip 2>/dev/null
					fi
					PNAME=$SAVE_PNAME
					PVER=$SAVE_PVER
					FOUNDPLUG=$SAVE_FOUNDPLUG
					ws_popd
				else
					[[ $DEBUG -ge 1 ]] && ws_event_info "${METAMODE} ($PLUGDIR) was found in caches from last 7 days; will not look online for any later version"
				fi
			fi
			# Now look at the files in the cache
			# We know PVER is set
			# Note that we do this unconditionally (i.e. not dependent on what we got back from api.wordpress.org) - in case there are newer versions that we already have; e.g. someone testing a new version, or a custom import
			# TODO: single-file plugins - these might be in customimports (once we allow them to be installed)
			local FOUND_LATER_ONE=0
			local ORIG_PRINTTHISONE=$PRINTTHISONE
			for KNOWNNEW in `find $HOWMANYDOTS/fromwporg.$METAMODE $HOWMANYDOTS/customimports.$METAMODE -maxdepth 1 -regex $REGEXF`; do
				if [[ $KNOWNNEW =~ /(fromwporg.$METAMODE|customimports.$METAMODE)/$PLUGDIR\.([0-9a-z\.]+)\.zip$ ]]; then
					THIS_FOUND=${BASH_REMATCH[1]}
					THIS_VERSION=${BASH_REMATCH[2]}
					# Installed version = PVER
					# File in the cache version = THIS_VERSION
					# Latest that we've found so far = LATESTVER
					version_sort "$PVER" "$THIS_VERSION"
					if [ $? -eq 2 ]; then
						if [ -z "$LATESTVER" ]; then
							FOUND_LATER_ONE=1
							LATESTVER=$THIS_VERSION
						else
							version_sort "$THIS_VERSION" "$LATESTVER"
							if [ $? -eq 0 ]; then
								FOUND_LATER_ONE=1
								LATESTVER=$THIS_VERSION
							fi
						fi
						[[ $LISTONLYUPDATES -eq 1 && ( $ONLYACTIVE -eq 0 || $PACTIVE = "yes" ) && (( $ONLYINACTIVE -eq 0 || $PACTIVE = "no" ))  ]] && PRINTTHISONE=1
					fi
				fi
			done
			# The plugin is in fromwporg and it is more recent than a positive API result
			if [[ $FOUND_LATER_ONE -eq 1 && $API_FETCHED_VERSION -eq 1 ]]; then
				ws_event_warning "${i:2}: We have a cached version $LATESTVER from wordpress.org, but wordpress.org now claims the latest version is only $API_PLUGIN_VER. Unless you used --trunk to download this version from the development trunk, then this may mean that the later version was withdrawn (perhaps buggy or with security problems) - you are recommended to delete it from the cache (do: rm $WORKINGDIR_FULL/fromwporg.$METAMODE/${i:2}.$LATESTVER.zip) "
				# Revert to the api.wordpress.org canonical answer
				unset LATESTVER
				PRINTTHISONE=$ORIG_PRINTTHISONE
			fi
			# Implement --currentversion; do not print if not the specified version
			if [[ $PRINTTHISONE -eq 1 && -n $CURRENTVERSION && ( ( $CURRENTVERSION =~ ^x && "x$PVER" = $CURRENTVERSION ) || ( ! $CURRENTVERSION =~ ^x && $PVER != $CURRENTVERSION ) ) ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_debug "EXIT: $SITE: $METAMODE: $PLUGIN: installed version=$PVER; specified version=$CURRENTVERSION, so exiting"
				PRINTTHISONE=0
			fi
			# List mode
			if [[ $MODE = "list" && $PRINTTHISONE -eq 1 ]]; then
				# Print site header
				printf "${BOLD}%-14s${OFFBOLD}\t" "$SITE"
			fi
			if [ $PRINTTHISONE -eq 1 ]; then
				if [[ $METAMODE = "core" ]]; then
					SHOWNAMEAS="wordpress"
				else
					if [[ $METAMODE = "plugin" && $ISFILE = "file" ]]; then
						local SHOWNAMEAS=$PLUGDIR
					else
						local SHOWNAMEAS=$(basename `pwd`)
					fi
				fi
				[[ $UNKNOWN_AT_WP -eq 1 ]] && SHOWNAMEAS="$SHOWNAMEAS (-)"
 				[[ $PACTIVE = "no" ]] && SHOWNAMEAS="$SHOWNAMEAS (i)"
				[[ -n $PPARENT ]] && SHOWNAMEAS="$SHOWNAMEAS (c:$PPARENT)"
				if [[ -n $LATESTVER ]]; then
					printf "%-35s ${BOLD}%-23s${OFFBOLD} %s" "$SHOWNAMEAS" "$PVER ($LATESTVER)" "$PNAME"
					[[ -n $API_PLUGIN_NOTICE && $UNKNOWN_AT_WP -eq 0 ]] && echo -n "  ${BOLD}Update:${OFFBOLD} ${API_PLUGIN_NOTICE}"
				else
					printf "%-35s ${BOLD}%-23s${OFFBOLD} %s" "$SHOWNAMEAS" "$PVER" "$PNAME"
				fi
				echo
			fi
			FOUNDWANTED=1
		fi
	# Only show the warning if being verbose or if it's the one we cared about
	elif [[ $DEBUG -ge 1 || ( ( $SHOWONLY = $PLUGDIR || $PLUGDIR =~ $SHOWONLY ) && $VALIDITYWARNINGS -eq 1 ) ]]; then
		# Special case: index.php in the plugins/theme directory is not expected to be a plugin/theme file, so don't warn
		[[ $PLUGIN_OR_THEME_MODE -ne 1 || $ISFILE != "file" || $PLUGDIR != "index.php" ]] && ws_event_warning "$SITE: Did not detect a valid ${METAMODE} in directory: $i"
	fi
}

function show_theentities() {
	# Core-friendly: yes
	# List the chosen entities installed on this site
	# Input: make sure we are cd-ed into a directory of the appropriate (METAMODE) entities
	# $1 : slug to match - or if empty, show them all
	# At present, use of this parameter (i.e. non-empty) implies we are in list mode, so we can assume that
	local SHOWONLY=$1
	[[ $DEBUG -ge 1 ]] && ws_event_debug "show_theentities: $SHOWONLY (pwd: `pwd`, caller: `caller`)"
	FOUNDWANTED=0
	local LATESTVER
	if [[ $METAMODE = "core" ]]; then
		# We are already in the appropriate directory
		showentity_thisdir "$SHOWONLY"
	else
		local OLDIFS="$IFS"
		IFS="
	"
		# Find the plugins
		for i in `find . -maxdepth 1 -iregex './[a-z0-9].*' | sort`; do
			# This could match the directory name (e.g. "akismet" from plugin akismet/akismet.php) or the file name (e.g. hello.php for "Hello Dolly")
			PLUGDIR=`echo "$i" | cut -d/ -f2`
			# Plugins in directories
			if [[ -d $i ]]; then
				# Enter the plugin's directory
				ws_pushd "$i"
				# See what's in this directory
				showentity_thisdir "$SHOWONLY"
				ws_popd
			# Plugins in files
			elif [[ $METAMODE = "plugin" && $i =~ .*\.php$ ]]; then
				showentity_thisdir "$SHOWONLY" file
			else
				[[ $DEBUG -ge 1 ]] && ws_event_notice "$i: Unknown entity found in ${METAMODE}s directory"
			fi
		done
		if [[ $WARNMISSING -eq 1 && $FOUNDWANTED -eq 0 && $MODE = "list" ]]; then
			ws_event_warning "no ${METAMODE} found (site: $SITE)"
		fi
		IFS="$OLDIFS"
	fi
}

HAVESHOWNPLUGS=0

# All plugins
# Impossible to trigger this in core mode - where plugin is set to "wordpress"
if [[ $PLUGIN = "all" ]]; then
	# Iterate over installed plugins
	for i in `find . -maxdepth 1 -type d -iregex './[a-z0-9].*' | sort`; do
		ws_cd "$i"
		# Sets FOUNDPLUG, PVER, PNAME
		get_entity_version
		if [ $FOUNDPLUG -eq 1 ]; then
			EXTRAPARAMS=""
			[[ $REQUIRENEWVERSION -eq 0 ]] && EXTRAPARAMS="--donotrequirenew"
			# List and install modes and listrollbacks should not be possible in this code-path
			if [ "$MODE" = "delete" ]; then
				EXTRAPARAMS="$EXTRAPARAMS --delete --thisoneonly"
			elif [ "$MODE" = "restore" ]; then
				EXTRAPARAMS="$EXTRAPARAMS --thisoneonly --restore"
				[[ -n $RESTOREPATH ]] && EXTRAPARAMS="$EXTRAPARAMS=$RESTOREPATH"
			elif [ "$MODE" = "checkmodifications" ]; then
				EXTRAPARAMS="$EXTRAPARAMS --checkmodifications"
				if [ $CHECKMODIFICATIONS_VIEW -eq 1 ]; then
					EXTRAPARAMS="${EXTRAPARAMS}=view"
					[[ $CHECKMODIFICATIONS_SHOWALL -eq 1 ]] && EXTRAPARAMS="${EXTRAPARAMS},showall"
				elif [ $CHECKMODIFICATIONS_SHOWALL -eq 1 ]; then EXTRAPARAMS="${EXTRAPARAMS}=showall"
				fi
			elif [ "$MODE" = "normal" ]; then
				EXTRAPARAMS="$EXTRAPARAMS --thisoneonly"
				[[ $AUTOPATCH -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --autopatch"
			elif [[ $MODE = "activate" ]]; then
				EXTRAPARAMS="$EXTRAPARAMS --activate"
			elif [[ $MODE = "deactivate" ]]; then
				EXTRAPARAMS="$EXTRAPARAMS --deactivate"
			elif [[ $MODE = "passwordreset" ]]; then
				EXTRAPARAMS="$EXTRAPARAMS --passwordreset"
			fi
			[[ $LISTEXACT -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --listexact"
			[[ $DETAILED -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --detailed"
			[[ $SHOWCHANGELOG -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --changelog"
			[[ $IGNORENAMECHANGE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --ignorenamechange"
			[[ $IGNOREMODIFICATIONS -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --ignoremodifications"
			[[ $SHOWDESCRIPTION -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --description"
			[[ $SHOWLASTUPDATED -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --lastupdated"
			[[ $SHOWDOWNLOADURL -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --downloadurl"
			[[ $DISABLECACHE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --disablecache"
			[[ $ONLYACTIVE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --active"
			[[ $ONLYINACTIVE -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --inactive"
			[[ $FAST -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --fast"
			# Already covered case of activate mode above, so don't specify twice
			[[ $ACTIVATE -eq 1 && $MODE != "activate" ]] && EXTRAPARAMS="$EXTRAPARAMS --activate"
			[[ $DEACTIVATE -eq 1 && $MODE != "deactivate" ]] && EXTRAPARAMS="$EXTRAPARAMS --deactivate"
			# In update mode with --activate, --update needs explicitly specifying
			[[ $ACTIVATE -eq 1 && $MODE = "normal" ]] && EXTRAPARAMS="$EXTRAPARAMS --update"
			[[ $DEACTIVATE -eq 1 && $MODE = "normal" ]] && EXTRAPARAMS="$EXTRAPARAMS --update"
			[[ $DRYRUN -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --dryrun"
			[[ $USETRUNK -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --trunk"
			[[ $SSLVERIFY -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --nosslverify"
			[[ -z $LFTP ]] && EXTRAPARAMS="$EXTRAPARAMS --nolftp"
			[[ -z $WGET ]] && EXTRAPARAMS="$EXTRAPARAMS --nowget"
			[[ -z $CURL ]] && EXTRAPARAMS="$EXTRAPARAMS --nocurl"
			[[ -z $LYNX ]] && EXTRAPARAMS="$EXTRAPARAMS --nolynx"
			[[ $DOSITETEST -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --nositetest"
			[[ $CONTENTDIR != $DEFAULT_CONTENTDIR ]] && EXTRAPARAMS="$EXTRAPARAMS --contentdir=$CONTENTDIR"
			# --justwp makes no sense in this context
			[[ -n $CURRENTVERSION ]] && EXTRAPARAMS="$EXTRAPARAMS --cver=$CURRENTVERSION"
			[[ -z $ELINKS ]] && EXTRAPARAMS="$EXTRAPARAMS --noelinks"
			[[ -z $RSYNC ]] && EXTRAPARAMS="$EXTRAPARAMS --norsync"
			[[ $GETCONFIRM -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --confirm"
			[[ $NETWORK_PLUGIN -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --network"
			[[ $NETWORK_BLOGID != "-1" ]] && EXTRAPARAMS="$EXTRAPARAMS --blog=$NETWORK_BLOGID"
			[[ $SKIPMAKEROLLBACK -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --skipmakerollback"
			[[ $REQUIREFTPTLS -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --requireftptls"
			[[ $DISABLEFTPTLS -eq 1 ]] && EXTRAPARAMS="$EXTRAPARAMS --disableftptls"
			[[ $PHPLINT -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --nolint"
			[[ $CONFIRM_WHEN_NO_PRISTINE -eq 0 ]] && EXTRAPARAMS="$EXTRAPARAMS --noconfirmpristine"
			[[ $METAMODE = "theme" ]] && EXTRAPARAMS="$EXTRAPARAMS --theme"
			ws_cd "$ORIGDIR"
			if [[ $DEBUG -ge 1 ]]; then
				EXTRAPARAMS="$EXTRAPARAMS --debug"
				[[ $DEBUG -ge 2 ]] && EXTRAPARAMS="$EXTRAPARAMS --debug"
				[[ $DEBUG -ge 3 ]] && EXTRAPARAMS="$EXTRAPARAMS --debug"
				ws_event_debug "Invoking with parameters: \"$SITE\" \"${i:2}\" --new=$USEZIP $EXTRAPARAMS --nocountdiskspace --selfinvoked --cache"
			fi
			$BASH $0 "$SITE" "${i:2}" --new=$USEZIP $EXTRAPARAMS --nocountdiskspace --selfinvoked --cache
			ws_cd "$WORKINGDIR_FULL/current/$SITE/${METAMODE}s"
		elif [[ $DEBUG -ge 1 || $VALIDITYWARNINGS -eq 1 ]]; then
			ws_event_warning "Did not detect a valid ${METAMODE} in directory: ${i:2} (`pwd`)"
			ws_cd ..
		fi
	done
exit
fi

# Implement list mode; show plugins and exit
if [[ $MODE = "list" ]]; then
	if [[ $METAMODE = "content" && $LISTONLYTHIRDPARTY -eq 0 && $LISTONLYUPDATES -eq 0 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Files being listed can be found in: `pwd -P`"
		if [[ -z $PLUGIN || $PLUGIN = "all" ]]; then
			find . | grep -v '^\.$' | cut -c3-
		else
			find . -iregex ".*$PLUGIN.*" | grep -v '^\.$' | cut -c3-
		fi
	elif [[ $METAMODE != "content" ]]; then
		# $PLUGIN could of course be empty, which implies "list all"
		show_theentities "$PLUGIN"
	fi
	exit
fi

# In install mode, check plugin is not already there
[[ $PLUGIN_OR_THEME_MODE -eq 1 && $MODE = "install" && -d $PLUGIN ]] && abort_die 47 "Installation cancelled: ${METAMODE} $PLUGIN already exists on this site (--install is only for new ${METAMODE}s)"


# Apply the filters from --active and --inactive (exit if nothing to do) (these are never set with --core)
if [[ ( $MODE = "delete" || $MODE = "normal" || $MODE = "restore" || $MODE = "rollback" ) && ( $ONLYACTIVE -eq 1 || $ONLYINACTIVE -eq 1 ) ]]; then
	# Plugins are listed by path; themes not
	PACTIVE=`grep "^$PLUGIN[:/]" $HTTP_LIST_OUTPUT | cut -d: -f2`
	if [[ ( $ONLYACTIVE -eq 1 && $PACTIVE != "yes" ) || ( $ONLYINACTIVE -eq 1 && $PACTIVE != "no" ) ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "$SITE: $PLUGIN: Nothing to do: ${METAMODE} activation state=$PACTIVE, which contradicts selection options"
	exit
	fi
fi

# Now we are in install/update/rollback/activate; FTP sites require lftp/curl
[[ $ACCESSMETHOD  =~ ftp && -z $LFTP && $CURL_CAN_ACCESSMETHOD -eq 0 && $MODE != "checkmodifications" ]] && abort_die 52  "$ACCESSMETHOD site chosen, and no working lftp or curl with $ACCESSMETHOD support found - run again with --debug or --checkrequirements for more information"

# Restore/checkmodification/activate mode: verify that something to restore/check exists
if [[ $MODE = "checkmodifications" || $MODE = "restore" || $MODE = "activate" || $MODE = "deactivate" ]]; then
	if [[ $METAMODE = "core" && ! -f wp-includes/version.php ]]; then
		abort_die 47 "Operation cancelled: ${METAMODE} cache does not exist in our local cache on this site (looked for: `pwd`/wp-includes/version.php) - run again with --sync if you want to refresh the local cache."
	elif [[ $PLUGIN_OR_THEME_MODE -eq 1 && ! -e $PLUGIN ]]; then
		abort_die 47 "Operation cancelled: ${METAMODE} $PLUGIN does not exist in our local cache on this site (`pwd`/$PLUGIN) - run again with --sync if you want to refresh the local cache."
	fi
fi

# Ask them to make a choice (update / delete / restore / check modification / (de)activate modes; skip this in install mode)
# In core mode, there is nothing to chose: there is only one core
while [[ ( -z $PLUGIN || ! -e "$PLUGIN" ) && $MODE != "install" && $PLUGIN_OR_THEME_MODE -eq 1 ]]; do
	if [ $THISONEONLY -eq 1 ]; then
		[[ $SELFINVOCATION -eq 0 && -n $PLUGIN ]] && echo "${BOLD}$SITE:${OFFBOLD} $PLUGIN: ${METAMODE} not found on this site"
		exit 33
	elif [[ ( $MODE = "delete" || $MODE = "restore" || $MODE = "checkmodifications" || $MODE = "activate" || $MODE = "deactivate" ) && -n $PLUGIN ]]; then
		echo "${BOLD}$SITE:${OFFBOLD} $PLUGIN: ${METAMODE} not found on this site"
	fi
	if [ $HAVESHOWNPLUGS -eq 0 ]; then
		echo "${METAMODE_CAP}s in use on this site:"
		show_theentities
		HAVESHOWNPLUGS=1
	fi
	PLACTION="update"
	[[ $MODE = "delete" || $MODE = "restore" || $MODE = "activate" || $MODE = "deactivate" ]] && PLACTION=$MODE
	[[ $MODE = "checkmodifications" ]] && PLACTION="check"
	read -p "${METAMODE_CAP} to $PLACTION (prepend with changelog/description to show info; Ctrl-C to quit): " PLUGIN
	CREGEX="^c(hangelog)? (\S+)$"
	DREGEX="^d(escription)? (\S+)$"
	if [[ $PLUGIN =~ $CREGEX ]]; then
		get_api_changelog ${BASH_REMATCH[2]} changelog
		PLUGIN=""
	elif [[ $PLUGIN =~ $DREGEX ]]; then
		get_api_changelog ${BASH_REMATCH[2]} description
		PLUGIN=""
	elif [ ! -d "$PLUGIN" ]; then
		ws_event_error "${METAMODE_CAP} not found, please try again"
		PLUGIN=""
	fi
done

# PLUGIN is now set, and is valid (in the relevant modes)
if [[ $MODE != "install" && $METAMODE != "content" ]]; then
	if [[ $METAMODE != "core" ]]; then
		if [[ $METAMODE = "plugin" && ${PLUGIN%.php} != $PLUGIN && -f $PLUGIN ]]; then
			# File plugin; nothing to do
			# Get current version again. This function sets FOUNDPLUG, PNAME AND PVER. Core-friendly.
			get_entity_version "$PLUGIN"
		else
			ws_cd "$PLUGIN"
			# Get current version again. This function sets FOUNDPLUG, PNAME AND PVER. Core-friendly.
			get_entity_version
		fi
	else
		# Get current version again. This function sets FOUNDPLUG, PNAME AND PVER. Core-friendly.
		get_entity_version
	fi
	INSTALLED_PNAME="$PNAME"
	INSTALLED_PVER="$PVER"
	INSTALLED_PVER_ORIG_FULL="$PVER_ORIG_FULL"
	INSTALLED_PFILE="$PFILE"
	# Implement --currentversion: abort if the present install is not the right version
	if [[ -n $CURRENTVERSION && ( ( $CURRENTVERSION =~ ^x && "x$INSTALLED_PVER" = $CURRENTVERSION ) || ( ! $CURRENTVERSION =~ ^x && $INSTALLED_PVER != $CURRENTVERSION ) ) ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_debug "EXIT: $SITE: $METAMODE: $PLUGIN: installed version=$INSTALLED_PVER; specified version=$CURRENTVERSION, so exiting"
		exit 92
	fi
fi

DIFFACTION=""
ENTITY_UNMODIFIED=-1

# Get a copy of the pristine version for comparison
# Not necessary in rollback or restore modes, as we then know exactly the code we want to use (and not relevant in install/activate modes)
# Rollbacktime="x" is the internal default; means that no value was specified; which in turn means that we are not in rollback mode. Thus the line below means "if updating or checking modifications"
if [[ $FOUNDPLUG -eq 1 && ( ( $MODE = "normal" && $ROLLBACKTIME = "x" && $IGNOREMODIFICATIONS -eq 0 ) || $MODE = "checkmodifications" ) ]]; then
	EXTRAINSTMSG=""
	[[ $CACHE -ge 1 ]] && EXTRAINSTMSG=" (using cache)"
	PRISTINE_FILENAME="$PLUGIN.$PVER_ORIG_FULL.zip"
	# Plugins/themes: we are in current/<site>/plugins/<plugin> (we cd'd a few lines up from here)
	# Core: we are in current/<site>/core
	[[ $METAMODE = "core" ]] && make_and_enter ../../../customimports.$METAMODE
	[[ $METAMODE != "core" ]] && make_and_enter ../../../../customimports.$METAMODE
	make_and_enter ../fromwporg.$METAMODE
	THE_PRISTINE_ZIP=""
	if [[ -s ../customimports.$METAMODE/$PRISTINE_FILENAME ]]; then
		THE_PRISTINE_ZIP="customimports.$METAMODE/$PRISTINE_FILENAME"
		[[ $DEBUG -ge 1 ]] && ws_event_info "Copy of pristine zip found in customimports ($THE_PRISTINE_ZIP)"
	elif [[ ! -s "$PRISTINE_FILENAME" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Copy of pristine zip not found in custom imports or in wordpress.org cache (fromwporg.$METAMODE/$PRISTINE_FILENAME)"
		if [ $CAN_URLGET -eq 1 ]; then
			# Try and download one
			echo -n "${BOLD}Trying to download pristine version:${OFFBOLD} $TRY_PRISTINE_GET"
			if [[ $METAMODE = "plugin" ]]; then
				TRY_PRISTINE_GET="https://downloads.wordpress.org/plugin/$PRISTINE_FILENAME"
				url_get $TRY_PRISTINE_GET
			elif [[ $METAMODE = "theme" ]]; then
				TRY_PRISTINE_GET="https://wordpress.org/themes/download/$PRISTINE_FILENAME"
				url_get $TRY_PRISTINE_GET
			elif [[ $METAMODE = "core" ]]; then
				ws_pushd ..
				# download_version also checks the MD5 sum for us
				download_version wordpress "$PVER"
				ws_popd
			fi
		else
			ws_event_info "No working lftp/wget/curl found: cannot fetch pristine version automatically"
			if [[ $CAN_BROWSE -eq 1 ]]; then
				echo "Going to the download page with web browser - please download manually (press y)"
				read -n 1 -s CONFIRM
				if [ "$CONFIRM" = "y" -o "$CONFIRM" = "Y" ]; then
					if [[ $PLUGIN_OR_THEME_MODE -eq 1 ]]; then
						url_browser "https://wordpress.org/${METAMODE}s/$PLUGIN/download"
					else
						url_browser "https://wordpress.org/download"
					fi
				else
					echo "Cancelled web browser: user declined" 
				fi
			else
				ws_event_error "Could not find a working w3m, elinks or lynx to use (run with --checkrequirements or --debug for more information)"
			fi
		fi
		THE_PRISTINE_ZIP="fromwporg.$METAMODE/$PRISTINE_FILENAME"
	else
		THE_PRISTINE_ZIP="fromwporg.$METAMODE/$PRISTINE_FILENAME"
		[[ $DEBUG -ge 1 ]] && ws_event_debug "Found already-downloaded pristine version from wordpress.org ($THE_PRISTINE_ZIP)"
	fi
	# Back into working directory (THE_PRISTINE_ZIP is given relative to here)
	ws_cd ..
	if [[ -s "$THE_PRISTINE_ZIP" ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Proceeding with comparison using found file: $THE_PRISTINE_ZIP"
		# With WordPress core, we keep around an unzipped version, rather than doing a new unzip every time we want to use one
		if [[ $METAMODE = "core" ]]; then
			# Could be fromwporg.core or customimports.core
			PRISTDIR=`dirname $THE_PRISTINE_ZIP`
			if [[ -d "$PRISTDIR/$PVER" ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "Unzipped version, $PRISTDIR/$PVER, already exists"
				ws_cd "$PRISTDIR/$PVER" || exit 71
			else
				[[ $DEBUG -ge 1 ]] && ws_event_info "Will attempt to unzip as: $PRISTDIR/$PVER"
				# We are currently in the working directory
				ws_cd "$PRISTDIR" || exit 71
				make_and_enter "$PVER"
				unpack_wordpress "../`basename $THE_PRISTINE_ZIP`"
				# Our underlays do not have the wp-content directory in them
				rm -rf wordpress/wp-content 2>/dev/null
			fi
			ws_cd wordpress || exit 71
			# That should leave us in fromwporg|customimports.core/<version>/wordpress
		else
			make_and_enter tmp
			extract_prospective_zip "../$THE_PRISTINE_ZIP" "" nolint
			# That then leaves us in tmp/<tmpdir>/<zipdir>
		fi
		# Plugin/themes modes: Compare this present directory with ../../../current/<site>/plugins/<plugin>
		# Core mode: Compare this present directory with ../../../current/<site>/<core> - with any files missing in there assumed to be in ../../../fromwporg.core/<version>/wordpress
		if [[ -z $DIFF ]]; then
			printf "${BOLD}%-40s${OFFBOLD}  Installed${EXTRAINSTMSG}: ${BOLD}%-10s${OFFBOLD} %s\n" "$SITE : $PNAME" "$PVER"
			# This question makes no sense in --checkmodifications mode, but in that case we already aborted earlier
			check_continue "No working diff binary found - cannot compare the installed $METAMODE with an unmodified version. Press c to continue or any other to abort (continue recommended only if you are sure your $METAMODE was not modified): "
		else
			# We have a diff binary and can do the comparison
			# In non-core mode, the below line has some redundancy, since we are already in a sub-directory of tmp
			# Note: if the format of DIFFTMP changes, then there is a usage further down which needs amending to keep in sync because it assumes the format
			# -b (--ignore-space-change) is needed to not flag up DOS->UNIX line ending changes
			if [[ $METAMODE = "core" ]]; then
				DIFFTMP=`mktemp -u ../../../tmp/TMP-DIFF.XXXXX` || exit 71
				# Thinking about it, our overlay is precisely a repository of changed files. That fact is something we could/should use? (Though note: it can also contain non-core files).
				# Do this: diff every core file we have, but ignore the additions
				# cwd is the pristine version
				# http://lists.gnu.org/archive/html/bug-gnu-utils/2005-11/msg00046.html - diff has no option, but grep works.
				# Remove -N (--new-file - treats absent files as empty)
				# I think this all means this diff can't be used strictly as a patch; it will not repeat the removal of removed files. But why would you want to remove files from WP core? Seems an unlikely use case.
				LOCAL_COPY_TO_EXAMINE="../../../current/$SITE/core"
				# Only -b -r are POSIX. But -u and -N are in Mac OS X, FreeBSD and GNU and OpenSolaris (2009). -B -d and are in MacOSX/FreeBSD/GNU
				DIFF_OPTIONS="-Bburd"
				$DIFF -Bburd . "$LOCAL_COPY_TO_EXAMINE" | grep -v "^Only in " >$DIFFTMP
				# Diff will return 1 if there are differences (including 'Only in...'); grep will return 0 if there was output, or 1 if there was (we don't expect any other code)
				DIFF_RET=$((1-$?))
				AUTOPATCH_STRIP=6
			else
				# Back to working directory. The moving around is because it seemed to silence a patch warning.
				MYBASE=$(basename `pwd`)
				ws_pushd ../../..
				DIFFTMP=`mktemp -u tmp/TMP-DIFF.XXXXX` || exit 71
				# The new one is now in tmp/$USETMP/$MYBASE
				NEW_TO_EXAMINE="tmp/$USETMP/$MYBASE"
				LOCAL_COPY_TO_EXAMINE="current/$SITE/${METAMODE}s/$PLUGIN"
				DIFF_OPTIONS="-BbuNr"
				[[ $DEBUG -ge 1 ]] && ws_event_debug "diff command: $DIFF -BbuNr $NEW_TO_EXAMINE $LOCAL_COPY_TO_EXAMINE >$DIFFTMP"
				$DIFF -BbuNr "$NEW_TO_EXAMINE" "$LOCAL_COPY_TO_EXAMINE" >$DIFFTMP
				DIFF_RET=$?
				ws_popd
				AUTOPATCH_STRIP=3
			fi
			if [ $DIFF_RET -eq 0 ]; then
				# The same
				ENTITY_UNMODIFIED=1
				SHOWVER="$PVER (unmodified)"
				[[ $CHECKMODIFICATIONS_SHOWALL -eq 1 ]] && printf "${BOLD}%-40s${OFFBOLD}  Installed${EXTRAINSTMSG}: ${BOLD}%-10s${OFFBOLD}  %s\n" "$SITE : $PNAME" "$SHOWVER"
			elif [ $DIFF_RET -eq 1 ]; then
				# Different
				SHOWVER="$PVER (modified)"
				printf "${BOLD}%-40s${OFFBOLD}  Installed${EXTRAINSTMSG}: ${BOLD}%-10s${OFFBOLD} %s\n" "$SITE : $PNAME" "$SHOWVER"
				[[ $MODE != "checkmodifications" ]] && echo -n "${BOLD}WARNING:${OFFBOLD} "
				[[ $MODE != "checkmodifications" || $DEBUG -ge 1 ]] && echo "$SITE: $PLUGIN: The $METAMODE has apparently been modified from its original state."
				# $DIFFACTION is emptied above
				[[ $DEBUG -ge 1 ]] && ws_event_debug "Diff command was: $DIFF $DIFF_OPTIONS . $LOCAL_COPY_TO_EXAMINE ; cd = `pwd`"
				unset DIFFACTION
				if [ $AUTOPATCH -eq 1 ]; then
					DIFFACTION="p"
					if [[ $DEBUG -eq 1 ]]; then
						echo "--autopatch specified; will attempt to patch the new version automatically" >/dev/stderr
						ws_event_debug "--autopatch specified; will attempt to patch the new version automatically" >/dev/stderr
					fi
				fi
				if [[ $MODE = "checkmodifications" ]]; then
					if [ $CHECKMODIFICATIONS_VIEW -eq 1 ]; then
						read -n 1 -p "Press any key to view the modifications..."
						echo
						[[ $METAMODE != "core" ]] && ws_pushd ../../..
						show_more_less "$DIFFTMP"
						[[ $METAMODE != "core" ]] && ws_popd
						# This is just set to ensure the deletion of the temporary file below
						DIFFACTION="v"
					fi
				else
					while [[ $DIFFACTION != "p" && $DIFFACTION != "c" ]]; do
						read -p "Choose an action: a=abort, v=view differences (less), p=apply patch to new version, c=continue with new version as is: " -n 1 VIEWDIFF
						echo
						if [ "$VIEWDIFF" = "v" -o "$VIEWDIFF" = "Y" ]; then
							[[ $METAMODE != "core" ]] &&  ws_pushd ../../..
							show_more_less "$DIFFTMP"
							[[ $METAMODE != "core" ]] &&  ws_popd
						elif [ "$VIEWDIFF" = "a" -o "$VIEWDIFF" = "A" ]; then
							abort_die 29 "User aborted"
						else
							DIFFACTION=$VIEWDIFF
						fi
					done
				fi
			else
				printf "${BOLD}%-40s${OFFBOLD}  Installed${EXTRAINSTMSG}: ${BOLD}%-10s${OFFBOLD} %-12s %s\n" "$SITE : $PNAME" "" "$PVER"
				# Unknown problem
				if [[ $MODE = "checkmodifications" ]]; then
					echo "Comparison between installed and pristine versions failed (code $DIFF_RET)" >/dev/stderr
					ws_event_notice "Comparison between installed and pristine versions failed (code $DIFF_RET)"
				else
					DOCONT=""
					while [[ $DOCONT != "c" && $DOCONT != "C" ]]; do
						read -p "Comparison between installed and pristine versions failed (code $DIFF_RET) - what do you wish to do (c to continue, v to view diff output, a to abort): " -n 1 DOCONT
						echo >/dev/stderr
						if [[ $DOCONT = "v" || $DOCONT = "V" ]]; then
							[[ $METAMODE != "core" ]] &&  ws_pushd ../../..
							show_more_less "$DIFFTMP"
							[[ $METAMODE != "core" ]] &&  ws_popd
						fi
						[[ $DOCONT = "a" || $DOCONT = "A" ]] && abort_die 95 "User aborted"
					done
				fi
			fi
			[[ $DIFFACTION != "p" ]] && rm -f "$DIFFTMP"
		fi
		# Return to tmp directory
		ws_cd ../../../tmp
		# Delete pristine version
		[[ $DIFFACTION != "p" ]] && rm -rf $USETMP

		# Return to working directory
		ws_cd ..
	elif [[ $MODE = "checkmodifications" ]]; then
		ws_event_error "Download failed ($TRY_PRISTINE_GET)"
		echo "$PLUGIN: No pristine zip found either in the wordpress.org cache or locally ($PRISTINE_FILENAME), so could not compare the installed version to a pristine version to review any customisations" >/dev/stderr
	else
		printf "${BOLD}%-40s${OFFBOLD}  Installed${EXTRAINSTMSG}: ${BOLD}%-10s${OFFBOLD} %-12s %s\n" "$SITE : $PNAME" "" "$PVER"
		ws_event_warning "Download failed ($TRY_PRISTINE_GET)"
		[[ $CONFIRM_WHEN_NO_PRISTINE -eq 1 ]] && check_continue "No pristine zip found either in the wordpress.org cache or locally ($PRISTINE_FILENAME), so cannot compare the installed version to a pristine version to review any customisations: press c if you want to continue (only advised if you are sure there are no customisations), otherwise will abort: "
	fi
elif [ "$MODE" = "normal" ]; then
	# Plugins/themes: we are in current/<site>/plugins/<plugin>
	# Core: we are in current/<site>/core

	if [[ $IGNOREMODIFICATIONS -eq 0 ]]; then
		# Do not ask in install/delete modes
		# Note that "normal" covers both update and rollback modes
		[[ $ROLLBACKTIME = "x" ]] && check_continue "Could not detect the current version (so cannot compare the installed version to a pristine version to review any customisations): press c if you want to continue (only advised if you are sure there are no customisations), otherwise will abort: "
	else
		ws_event_debug "--ignoremodifications: No modification checks will be made"
	fi

	# Leave us back in working directory where expected
	ws_cd ../../..
	[[ $METAMODE != "core" ]] && ws_cd ..
elif [[ $MODE = "delete" ]]; then
	# Leave us back in working directory where expected
	if [[ $METAMODE = "plugin" && ${PLUGIN%.php} != $PLUGIN && -f $PLUGIN ]]; then
		ws_cd ../..
	else
		ws_cd ../../..
	fi
	[[ $METAMODE != "core" ]] && ws_cd ..
elif [[ $MODE = "activate" || $MODE = "deactivate" ]]; then
	# Leave us back in working directory where expected
	if [[ $METAMODE = "plugin" && ${PLUGIN%.php} != $PLUGIN && -f $PLUGIN ]]; then
		ws_cd ../..
	else
		ws_cd ../../..
	fi
	[[ $METAMODE != "core" ]] && ws_cd ..
elif [ "$MODE" = "install" ]; then
	# Leave us back in working directory where expected
	ws_cd ../../..
elif [[ $MODE = "checkmodifications" ]]; then
	ws_event_error "Could not detect the current version (which means the current cache of the $METAMODE seems to be corrupt), so could not carry out any version comparison"
	exit 89
elif [[ $MODE = "restore" && $METAMODE != "content" ]]; then
	[[ $FOUNDPLUG -ne 1 ]] && check_continue "Could not detect the current version (which means the current cache of the $METAMODE seems to be corrupt): press c if you want to continue (only advised if you are sure the current cached version is what you want), otherwise will abort: "
	ws_cd ../../..
	[[ $METAMODE != "core" ]] && ws_cd ..
elif [[ $MODE = "restore" && $METAMODE = "content" ]]; then
	ws_cd ../../..
fi

# In check modifications mode, the task is now complete
[[ $MODE = "checkmodifications" ]] && exit

# Unzip and sanity check versions (if not in delete mode)
if [[ $MODE = "normal" || $MODE = "install" ]]; then
	if [[ -z $USEZIP ]]; then
		choose_new_zip
	elif [[ $USEZIP = "latest" ]]; then
		download_latest any
		# In this use case (USEZIP=latest), NEWZIPSOURCE is set in download_latest
		if [[ $METAMODE = "core" && $USETRUNK -eq 1 ]]; then
			USEZIP="wordpress.trunk.zip"
		elif [[ -s "$NEWZIPSOURCE/$PLUGIN.$PVER.zip" ]]; then
			USEZIP="$PLUGIN.$PVER.zip"
		else
			if [[ -z $PVER ]]; then
				abort_die 38 "$PLUGIN: No suitable zip file could be found - such a $METAMODE appears not to exist"
			else
				abort_die 38 "Expected zip file not found ($PLUGIN.$PVER.zip in $WORKDIR/$NEWZIPSOURCE)"
			fi
		fi
	fi
fi

# Do not combine this with the above block, as choose_new_zip there can flip us into restore mode
if [[ $MODE = "normal" || $MODE = "install" ]]; then
	# Extract the selected file
	make_and_enter tmp
	NEWPLUGDIR=`mktemp -d NEW-$PLUGIN.XXXXX`
	ws_cd $NEWPLUGDIR

	if [[ $METAMODE = "core" && -d "../../$NEWZIPSOURCE/$USEZIP/wordpress" ]]; then
		# In case of core, we already have an unzipped version (depending on the mode), so we can save time by adapting accordingly
		# Potential speed-up: it may not always be necessary to copy; sometimes we could use the directory as-is
		# The unzip command we would have used leaves us with a directory "wordpress"
		cp -R "../../$NEWZIPSOURCE/$USEZIP/wordpress" .
	else
		[[ -z $UNZIP ]] && abort_die 8 "Required unzip command not found when extracting new $METAMODE (re-run with --debug or --checkrequirements for more information)"
		$UNZIP $UNZIPOPT "../../$NEWZIPSOURCE/$USEZIP"
		RETCODE=$?
		# The core trunk zip sometimes gives a return code 2 with 'mapname:  conversion of  failed', but appears harmless
		[[ $RETCODE -ne 0 && ( $METAMODE != "core" || $USETRUNK -ne 1 || $RETCODE -ne 2 ) ]] && abort_die 29 "unzip command returned an error code when extracting new $METAMODE (code: $RETCODE, pwd: `pwd`)"
		[[ $PLUGIN_OR_THEME_MODE -eq 1 ]] && lint_dir "$NEWZIPSOURCE/$USEZIP"
	fi

	# This makes things easier because $PLUGIN is "wordpress", and/or assumed to be in various places
	[[ $METAMODE = "core" && $USETRUNK -eq 1 ]] && mv trunk wordpress

	NEWDIRNAME="`ls -1 | head -1`"
	ws_cd "$NEWDIRNAME" || exit 71

	get_entity_version

	# Cannot compare versions in install mode, only update
	if [ $FOUNDPLUG -eq 1 ]; then
		if [ "$ROLLBACKTIME" != "x" ]; then
			# Rollback mode - slug will be something else
			# With symlinked-to-pristine ones, the directory is just the slug, not our specialised backup
			if [[ -L ../../../$NEWZIPSOURCE/$USEZIP && $USEZIP =~ ^${SITE}[\.-](.*)-[0-9]{6,}[\.-]$PVER\.zip$ ]]; then
				NEW_COMPARE_SLUG=${BASH_REMATCH[1]}
			elif [[ $NEWDIRNAME =~ ^$SITE-(.*)+-[0-9]{6,}$ ]]; then
				NEW_COMPARE_SLUG=${BASH_REMATCH[1]}
			else
				abort_die 62 "Rollback ${METAMODE}'s directory name ($NEWDIRNAME) has an unrecognised format"
			fi
		else
			NEW_COMPARE_SLUG=$NEWDIRNAME
		fi
		[[ $MODE = "normal" && $NEW_COMPARE_SLUG != "$PLUGIN" ]] && abort_die 61 "New $METAMODE slug ($NEW_COMPARE_SLUG) does not match old ($PLUGIN) - apparently not the same $METAMODE"

		# Bash 3.2 does not have ^ substitutions
		TMP_PNAME=`echo -n $PNAME | tr '[:lower:]' '[:upper:]'`
		TMP_INSTALLED_PNAME=`echo -n "$INSTALLED_PNAME" | tr '[:lower:]' '[:upper:]'`

		if [[ $MODE = "normal" && $TMP_PNAME != $TMP_INSTALLED_PNAME && $PNAME != $INSTALLED_PNAME ]]; then
			if [[ $IGNORENAMECHANGE -eq 1 ]]; then
				[[ $DEBUG -ge 1 ]] && ws_event_info "Name changed (but --ignorenamechange specified): New ${METAMODE}'s name matches old ($PNAME)"
			else
				check_continue "The new ${METAMODE}'s name ($PNAME) does not equal the installed ${METAMODE}'s name ($INSTALLED_PNAME) - are you sure you want to continue? (c to continue, other to abort): "
			fi
		else
			[[ $DEBUG -ge 1 && $MODE = "normal" ]] && ws_event_info "OK: New ${METAMODE}'s name matches old ($PNAME)"
		fi
		echo "${BOLD}New $METAMODE version:${OFFBOLD} $PVER"
		# Check for consistency (these are not enforced at wordpress.org - we have seen mismatches)
		# And something new, November 2012 - a plugin with a Stable: tag that differs from its Version: header, by having extra junk in, hence the extra PVER_ORIG_FULL check
		if [[ -n $APPARENT_NEW_VERSION && $APPARENT_NEW_VERSION != $PVER && ( -z $PVER_ORIG_FULL || $PVER_ORIG_FULL != $APPARENT_NEW_VERSION ) ]]; then
			abort_die 67 "$PLUGIN: Version mismatch: Was expecting version '$APPARENT_NEW_VERSION', but in fact the $METAMODE is version '$PVER' (this usually means either that the $METAMODE was wrongly packaged, or that two releases were made very close together and our cache is out of date (try running with --disablecache))"
		fi
		# Only check that the new version is newer in upgrade mode (not for restore/rollback)
		if [ "$PVER" = "$INSTALLED_PVER" -a "$MODE" = "normal" ]; then
			# In rollback mode, --donotrequirenew is autonmatically specified
			if [ $REQUIRENEWVERSION -eq 0 ]; then
				ws_event_info "The new ${METAMODE}'s version ($PVER) exactly equals the installed ${METAMODE}'s version, but --donotrequirenew was specified, so will continue"
			else
				abort_die 34 "${BOLD}Will not upgrade:${OFFBOLD} installed $METAMODE is already at this version ($INSTALLED_PVER) - use --donotrequirenew to over-ride"
			fi
		elif [ "$MODE" = "normal" ]; then
			# Versions are different
			version_sort $PVER $INSTALLED_PVER
			RET=$?
			if [ $RET -eq 2 ]; then
				if [ $REQUIRENEWVERSION -eq 0 ]; then
					[[ $ROLLBACKTIME = "x" ]] && ws_event_info "The new ${METAMODE}'s version ($PVER) appears to be lower than the installed ${METAMODE}'s version ($INSTALLED_PVER), but --donotrequirenew was specified, so will continue."
				else
					abort_die 35 "Will not upgrade: installed $METAMODE is newer ($INSTALLED_PVER) than this version ($PVER) - use --donotrequirenew to over-ride"
				fi
			fi
		fi
	else
		check_continue "No valid $METAMODE header was found in the new $METAMODE directory - are you sure you want to continue? (c to continue, other to abort): "
	fi
	ws_cd ..

	# There should only be one directory present

	# Returning to working directory
	ws_cd ../..

	# If the current plugin is not equal to the pristine version, and a patch was required
	# Not possible to get into this state except in upgrade mode
	if [[ $DIFFACTION = "p" ]]; then
		# Contents of DIFFTMP is the diff from the pristine plugin to currently installed one (cache version)
		# DIFFTMP was created via: DIFFTMP=`mktemp -u ../../../tmp/TMP-DIFF.XXXXX`
		# tmp/$NEWPLUGDIR/$NEWDIRNAME is the extracted new version
		# $USETMP is the pristine version of the installed plugin
		#DIFFTMP=`echo $DIFFTMP | cut -d/ -f5`
		DIFFTMP=`basename "$DIFFTMP"`
		if [[ ! -s "tmp/$DIFFTMP" ]]; then
			[[ -n $USETMP ]] && rm -rf tmp/$USETMP
			abort_die 53 "Could not find the patch file ($DIFFTMP)"
		fi
		if [[ -z $PATCH ]]; then
			rm -f tmp/$DIFFTMP tmp/$USETMP
			check_continue "Could not find a working 'patch' command; run with --checkrequirements or --debug for more information (c to continue without patching, other to abort) : "
		else
			ws_cd "tmp/$NEWPLUGDIR/$NEWDIRNAME"
			echo -n "Testing applying patch from the pristine to installed version against the new version: "
			[[ $DEBUG -ge 1 ]] && ws_event_info "pwd=`pwd`; patch command being run: $PATCH $PATCHOPT -p$AUTOPATCH_STRIP --dry-run -V never --unified --ignore-whitespace <../../$DIFFTMP"
			$PATCH $PATCHOPT -p$AUTOPATCH_STRIP --dry-run -V never --unified --ignore-whitespace <../../$DIFFTMP
			PATCH_RET=$?
			# If that applies cleanly, then do it for real
			if [[ $PATCH_RET -eq 0 ]]; then
				echo OK
				$PATCH $PATCHOPT -p$AUTOPATCH_STRIP -V never --unified --ignore-whitespace <../../$DIFFTMP
				PATCH_RET2=$?
				rm -rf ../../$DIFFTMP ../../$USETMP
				if [ $PATCH_RET2 -eq 0 ]; then
					echo "OK: The patch applied successfully"
					ws_event_info "The patch applied successfully"
				else
					abort_die 66 "Unexpected error: patch did not apply successfully (despite a dry run being successful)"
				fi
			else
				# Did not apply cleanly. Now try the other way first to see if that can work (i.e. a patch from the pristine old version to the pristine new version - and apply that to the installed version).
				# Our current directory is the extracted new version (tmp/$NEWPLUGDIR/$NEWDIRNAME)
				# To make core mode work, we produce a combined directory, bringing in the underlay and the overlay together. Only that combined work can have the patch applied to it.
				# Back into tmp temporarily
				ws_pushd ../..
				DIFFTMP2=`mktemp TMP-DIFF2.XXXXX` || exit $?
				# Get a diff from the pristine old version to the pristine new version
				# This is core-friendly by its nature (overlays are not involved here)
				# We are supposed to delete $USETMP after usage
				$DIFF -BbuNr "$USETMP/$PLUGIN" "$NEWPLUGDIR/$NEWDIRNAME" >$DIFFTMP2
				DIFFRET=$?
				ws_popd
				PATCH_RET4=-1
				if [[ $DIFFRET -eq 0 && ( ( $METAMODE != "core" && -d "../../../current/$SITE/${METAMODE}s/$PLUGIN" ) || ( $METAMODE = "core" && -d "../../../current/$SITE/core/wp-includes" ) ) ]]; then
					# Now attempt to apply this patch against the installed version
					if [[ $METAMODE != "core" ]]; then
						ws_pushd ../../../current/$SITE/${METAMODE}s/$PLUGIN
						PATCHLOC="../../../../tmp/$DIFFTMP2"
					else
						# Current directory is tmp/$NEWPLUGDIR/$NEWDIRNAME
						ws_pushd ../../../current/$SITE/core
						# Copy over the overlay to make a genuine copy of the site
						# Of course, that pollutes the pristine copy in USETMP, but that was no longer needed
						cp -R . ../../../tmp/$USETMP/wordpress/
						PATCHLOC="../../../tmp/$DIFFTMP2"
					fi
					[[ $DEBUG -ge 1 ]] && ws_event_info "Now going to try apply a patch from the old to new versions, against the current version: $PATCH $PATCHOPT -p2 --dry-run -V never --unified --ignore-whitespace <$PATCHLOC (pwd: `pwd`)"
					echo -n "Testing applying patch between the pristine old and present versions against the installed version: "
					$PATCH $PATCHOPT -p2 --dry-run -V never --unified --ignore-whitespace <$PATCHLOC
					PATCH_RET3=$?
					# Move back to extracted new version
					ws_popd
					if [[ $PATCH_RET3 -eq 0 ]]; then
						echo OK
						[[ $DEBUG -ge 1 ]] && ws_event_info "Successfully created a patch of the old version to the new version that applies without errors to the currently installed (modified) version"
						# Back into tmp
						ws_cd ../..
						[[ $METAMODE != "core" ]] && NEWTMP=`mktemp -d "NEW-$PLUGIN.XXXXX"`
						[[ $METAMODE = "core" ]] && NEWTMP=$USETMP
						# Copy over the current install
						[[ $METAMODE != "core" ]] && cp $COPYOPT -R ../current/$SITE/${METAMODE}s/$PLUGIN $NEWTMP/
						# In core mode, we already have a copy of the existing site we made earlier; nothing to do
						ws_cd $NEWTMP/$PLUGIN
						$PATCH $PATCHOPT -p2 -V never --unified --ignore-whitespace <../../$DIFFTMP2
						PATCH_RET4=$?
						# Back into tmp
						ws_cd ../..
						if [ $PATCH_RET4 -ne 0 ]; then
							# USETMP and NEWTMP might actually be the same thing
							rm -rf $DIFFTMP2 $NEWTMP $USETMP
							abort_die 75 "Dry run succeeded applying patch, but real apply failed (tmp/$DIFFTMP2)"
						else
							ws_event_info "The patch applied successfully"
							# Make sure this version is actually now used
							# Get rid of the previous prospective new version
							rm -rf $NEWPLUGDIR/$NEWPLUGNAME
							[[ $METAMODE != "core" ]] && rm -rf "$USETMP"
							NEWPLUGDIR=`basename "$NEWTMP"`
							NEWPLUGNAME="$PLUGIN"
						fi
						ws_cd $NEWPLUGDIR/$NEWPLUGNAME
					else
						[[ $DEBUG -ge 1 ]] && ws_event_info "Tried to create a patch of the old version to the new version, but this did not apply to the currently installed (modified) version without errors"
					fi
				fi
				if [ $PATCH_RET4 -ne 0 ]; then
					read -p "The patch did not apply cleanly. Press b to continue with the 'best effort' of the pristine->current patch (the parts of the patch that could apply to the new version), or c for the 'best effort' of the previous->new version patch (applied to the current version); in both cases you can then edit the results; or any other key to abort: " -n 1 WHICHPATCH
					# Neither method worked
					# Our current directory is the extracted new version (tmp/$NEWPLUGDIR/$NEWDIRNAME)
					if [ "$WHICHPATCH" = "b" ]; then
						# Pristine -> current patch against new
						$PATCH $PATCHOPT -V never --unified --ignore-whitespace <../../$DIFFTMP
						PATCH_RET5=$?
					elif [ "$WHICHPATCH" = "c" ]; then
						# Prevous -> new patch against current
						# Back into tmp
						ws_cd ../..
						[[ $METAMODE != "core" ]] && NEWTMP=`mktemp -d "NEW-$PLUGIN.XXXXX"`
						[[ $METAMODE = "core" ]] && NEWTMP=$USETMP
						[[ $METAMODE != "core" ]] && cp $COPYOPT -Rp ../current/$SITE/${METAMODE}s/$PLUGIN $NEWTMP/
						ws_cd $NEWTMP/$PLUGIN
						$PATCH $PATCHOPT -p2 -V never --unified --ignore-whitespace <../../$DIFFTMP2
						PATCH_RET5=$?
						ws_cd ../..
						rm -rf $NEWPLUGDIR/$NEWPLUGNAME
						NEWPLUGDIR=`basename "$NEWTMP"`
						NEWPLUGNAME="$PLUGIN"
						ws_cd $NEWPLUGDIR/$NEWPLUGNAME
					else
						rm -f ../../$DIFFTMP2
						abort_die 106 "User chose to abort"
					fi
					check_continue "You can now edit the directory that is to be installed (`pwd`); when done, press c to continue with the install, or any other key to abort: "
				fi
				rm -f ../../$DIFFTMP2
			fi
			# Returning to working directory
			ws_cd ../../..
		fi
	fi
fi

# This speeds up things later on - we can populate kernel caches whilst doing other things and spare the user the wait
[[ $SHOWDISKSPACE -eq 1 ]] && (du -shx . &)>/dev/null 2>/dev/null

# Move in new entity
# First, see if we were requested to show changes
# --restore --showchanges = automatic no-op
if [[ $SHOWCHANGES -ge 1 && $MODE != "restore" ]]; then
	[[ $DEBUG -ge 1 ]] && ws_event_info "Going to attempt to show changes between new $METAMODE and our local copy of what is installed"
	DIFFTMP3=`mktemp tmp/SHOWCHANGES.XXXXX` || exit 64
	if [[ $METAMODE = "core" ]]; then
		# No -N tag: don't treat missing files as empty
		# grep out those only in one side or the other; missing on left means unmodified; on right means non-core
		# The question is to show the changes that *will* be made to the *existing* copy by the *new* one
		# Existing one is made up of an underlay and overlay; we need to combine them, or to do the diff file-by-file
		# New one is in tmp/$NEWPLUGDIR/$NEWDIRNAME (which may be pristine, or may be patched)
		[[ ! -d fromwporg.core/$INSTALLED_PVER/wordpress ]] && abort_die 93 "Could not find the pristine version of the current installation in fromwporg.core/$INSTALLED_PVER/wordpress"
		# Loop over all files in new installation (those removed will not show in this diff)
		ws_cd "tmp/$NEWPLUGDIR/$NEWDIRNAME" || exit 71
		find . -type f | while read NEWFILE; do
			# Only look at files that were in WordPress core previously
			if [[ -f "../../../fromwporg.core/$INSTALLED_PVER/wordpress/$NEWFILE" ]]; then
				# Work out which file is the one in use on the site (underlay or overlay)
				if [[ -f "../../../current/$SITE/core/$NEWFILE" ]]; then
					COMPFILE="../../../current/$SITE/core/$NEWFILE"
				else
					COMPFILE="../../../fromwporg.core/$INSTALLED_PVER/wordpress/$NEWFILE"
				fi
				# Compare the live file with the new one
				$DIFF -Bbdu "$COMPFILE" "$NEWFILE" >>../../../$DIFFTMP3
			else
				echo "Only in .: $NEWFILE" >>../../../$DIFFTMP3
			fi
		done
		# Back into working directory
		ws_cd ../../..
	else
		$DIFF -BbduNr current/$SITE/${METAMODE}s/$PLUGIN tmp/$NEWPLUGDIR/$NEWDIRNAME>$DIFFTMP3
	fi
	show_more_less $DIFFTMP3
	rm -f "$DIFFTMP3"
fi

if [[ $GETCONFIRM -eq 1 ]]; then
	GETCONFIRM_SHOWMODE=$MODE
	[[ $MODE = "normal" ]] && GETCONFIRM_SHOWMODE="update"
	check_continue "Do you want to go ahead with the $GETCONFIRM_SHOWMODE operation? (c to continue, any other to abort): "
fi

# In core update mode, we now need to work out whether to activate filemethod, if it was not explicitly chosen
if [[ $METAMODE = "core" && $MODE = "normal" && $FILEMETHOD -eq 0 ]]; then
	if [[ $USETRUNK -eq 1 ]]; then
		ws_event_info "--core --trunk implies --filemethod"
		FILEMETHOD=1
	else
		get_api_entity_info wordpress
		if [[ $? -ne 0 || -z $API_PLUGIN_VER ]]; then
			ws_event_warning "Failed to learn the latest WordPress version from api.wordpress.org"
			FILEMETHOD=1
		elif [[ $API_PLUGIN_VER != $PVER && $FILEMETHOD -eq 0 ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "This new version is not the latest; therefore, enforcing --filemethod"
			FILEMETHOD=1
		elif [[ $DISABLEREMOTECLI -eq 1 ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "--disableremotecli implies --filemethod"
			FILEMETHOD=1
		elif [[ $API_PLUGIN_VER = $PVER && $FILEMETHOD -eq 0 ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "This version is the latest and --filemethod was not specified; will update using remotecli mode. If the upgrade fails due to file permission errors, then try again, adding --filemethod."
		fi
	fi
fi

# When installing core, only file method is available
if [[ $METAMODE = "core" && $MODE = "install" && $FILEMETHOD -eq 0 ]]; then
	ws_event_info "--core --install implies --filemethod"
	FILEMETHOD=1
fi

# Try to set $REMOTE_PHPVERSION and/or $REMOTE_WPVERSION if we can/want it
[[ $DISABLEREMOTECLI -eq 0 && $MODE = "normal" && ( ( $METAMODE = "core" && -n $MINIMUM_PHP_VERSION && ( -z $REMOTE_PHPVERSION  || -z $REMOTE_MYSQLVERSION ) ) || ( $METAMODE = "plugin" && -n $MINIMUM_WP_VERSION && -z $REMOTE_WPVERSION ) ) ]] && remotecli_process ping

if [[ $DISABLEREMOTECLI -eq 0 && $METAMODE = "core" && ( $MODE = "normal" || $MODE = "install" ) ]]; then
	if [[ -n $MINIMUM_PHP_VERSION && -n $REMOTE_PHPVERSION ]]; then
		version_sort "$REMOTE_PHPVERSION" "$MINIMUM_PHP_VERSION"
		if [ $? -eq 0 -o $? -eq 1 ]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Remote PHP version ($REMOTE_PHPVERSION) is high enough to use the new WordPress version (required: $MINIMUM_PHP_VERSION)"
		else
			abort_die 100 "The PHP version on the server ($REMOTE_PHPVERSION) is not high enough to use the new WordPress version (required: $MINIMUM_PHP_VERSION)"
		fi
	fi
	if [[ -n $MINIMUM_MYSQL_VERSION && -n $REMOTE_MYSQLVERSION ]]; then
		version_sort "$REMOTE_MYSQLVERSION" "$MINIMUM_MYSQL_VERSION"
		if [ $? -eq 0 -o $? -eq 1 ]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Remote MySQL version ($REMOTE_MYSQLVERSION) is high enough to use the new WordPress version (required: $MINIMUM_MYSQL_VERSION)"
		else
			abort_die 100 "The MySQL version on the server ($REMOTE_MYSQLVERSION) is not high enough to use the new WordPress version (required: $MINIMUM_MYSQL_VERSION)"
		fi
	fi
elif [[ $DISABLEREMOTECLI -eq 0 && $METAMODE = "plugin" && ( $MODE = "normal" || $MODE = "install" ) && -n $MINIMUM_WP_VERSION && -n $REMOTE_WPVERSION ]]; then
	version_sort "$REMOTE_WPVERSION" "$MINIMUM_WP_VERSION"
	if [ $? -eq 0 -o $? -eq 1 ]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Remote WP version ($REMOTE_WPVERSION) is high enough to use the new plugin version (required: $MINIMUM_WP_VERSION)"
	else
		if [[ $IREALLYMEANIT -eq 1 ]]; then
			ws_event_warning "--ireallymeanit has over-ridden the plugin's specification of the minimum WordPress version required ($MINIMUM_WP_VERSION - the site has $REMOTE_WPVERSION)"
		else
			abort_die 100 "The WordPress version on the site ($REMOTE_WPVERSION) is not high enough to use the new plugin version (required: $MINIMUM_WP_VERSION); add --ireallymeanit if you wish to over-ride this check"
		fi
	fi
fi

TEST_SITEURL=$SITEURL
[[ ${TEST_SITEURL: -1} != "/" ]] && TEST_SITEURL="${TEST_SITEURL}/"


SITETEST_RETCODE=-1
# This is not done earlier, as we don't want to prevent the above PHP version check
if [[ $METAMODE = "core" && $MODE = "install" ]]; then
	DISABLEREMOTECLI=1
else
	# Check, unless a switch tells us not to, that the site is actually accessible. In restore mode, just warn; don't quit.
	if [[ $DOSITETEST -eq 1 ]]; then
		if [[ -z $SITEURL ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Skipping site HTTP check, because the URL for this site is not known"
		else
			[[ $DEBUG -ge 1 ]] && ws_event_debug "Going to test site reachability"
			# We are in the working directory
			COUNT_TMP=`mktemp tmp/counttmp.XXXXX`
			url_get "$TEST_SITEURL" stdout testonly | wc -c >$COUNT_TMP
			SITETEST_RETCODE=${PIPESTATUS[0]}
			SITETEST_CHARCOUNT=`cat $COUNT_TMP`
			rm -f "$COUNT_TMP"
			[[ $DEBUG -ge 1 ]] && ws_event_info "Characters found in returned page (counted by wc -c): $SITETEST_CHARCOUNT"
			if [ $SITETEST_RETCODE -eq 0 ]; then
				[[ $DEBUG -ge 1 ]] && echo "OK: Site check ($TEST_SITEURL) returned without error"
			else
				if [[ $MODE = "restore" || $MODE = "rollback" ]]; then
					ws_event_warning "Site check ($TEST_SITEURL) failed. Proceeding anyway with $MODE operation."
				else
					check_continue "Could not successfully load the site (pre-flight check - $TEST_SITEURL - use 'wordshell $SITE --visit' to try it yourself) (code: $SITETEST_RETCODE). Press c to continue anyway, or any other key to abort: "
				fi
			fi
		fi
	else
		[[ $DEBUG -ge 1 ]] && ws_event_info "--nositetest specified: skipping site HTTP check"
	fi
fi

# Put into maintenance mode (waiting for any other process to first finish); or, when doing a remotecli update, make sure it is clear
if [[ $METAMODE != "content" && ( $METAMODE != "core" || $MODE != "install" ) ]]; then
	if [[ $DRYRUN -eq 0 ]]; then
		if [[ $METAMODE = "core" && $MODE = "normal" && $FILEMETHOD -eq 0 ]]; then
			maintenance_mode waitclear
		else
			maintenance_mode enterwait
		fi
	else
		ws_event_info "Dry run mode: skipped putting site into maintenance mode"
	fi
fi

# Time now to do the install/update/deletion:
if [[ $DRYRUN -eq 0 && $METAMODE != "content" ]]; then
	# 1) (Not install mode) Remove/backup the old version
	if [[ $MODE != "install" && $MODE != "activate" && $MODE != "deactivate" && ( $MODE != "restore" || -z $RESTOREPATH ) ]]; then
		make_and_enter old.$METAMODE
		MOVETOLEAF="$SITE-$PLUGIN-$NOWDATE"
		[[ $DEBUG -ge 1 ]] && ws_event_debug "${BOLD}Moving old version to:${OFFBOLD} $WORKDIR/old.$METAMODE/$MOVETOLEAF"
		[[ $MODE = "delete" && $METAMODE != "core" && ( -z $SITEURL || $SITEURL = "none" || $SKIPDEACTIVATE -eq 1 ) ]] && ws_event_info "Next time you visit the WP administrator ${METAMODE}s page, it will display an (harmless) error due to the missing files"
		# Just symlink if we have one available
		if [[ $METAMODE != "core" && $ENTITY_UNMODIFIED -eq 1 && -n $THE_PRISTINE_ZIP ]]; then
			# In core mode, even if our core is unmodified, we still want the wp-config.php file
			ln -s "../$THE_PRISTINE_ZIP" "$MOVETOLEAF-$INSTALLED_PVER.zip"
			# File method install is not expecting an existing directory
			[[ $ACCESSMETHOD = "file" && $METAMODE != "core" ]] && rm -rf "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN"
		elif [[ $SKIPMAKEROLLBACK -eq 1 ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "--skipmakerollback given: will not create any backup"
		elif [[ $METAMODE = "core" ]]; then
			# We will take the backup from our cache to avoid complications.
			# The time interval here needs to match the sync interval used elsewhere, otherwise we internally decide to not bother syncing, then we complain to the user about it, which is unhelpful.
			[[ $((NOWDATE - `$STAT_MODTIME ../current/$SITE/core`)) -gt 10800 ]] && check_continue "We have not synced our local cache of this site recently; if you made any alterations outside of WordShell then they may not be retained in our backup. Do you wish to continue? (c to continue, any other to abort): "
			[[ $MODE = "restore" ]] && cp $COPYOPT -Rp ../current/$SITE/core "$MOVETOLEAF" 2>/dev/null
			[[ $MODE != "restore" ]] && cp $COPYOPT -Rp ../current/$SITE/core "$MOVETOLEAF"
		else
			# Bring old plugin/theme over
			if [[ $ACCESSMETHOD  = "file" ]]; then
				if [[ $MODE = "restore" ]]; then
					# Don't complain if it does not exist (in restore mode, the site can be assumed broken)
					mv "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN" "$MOVETOLEAF" 2>/dev/null
				else
					mv "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN" "$MOVETOLEAF"
				fi
			else
				# (S)FTP mode
				# If we cached on this run then use the local copy; if not, then do it the manual way
				BK_MIRRORCOMM1="$PLUGIN"
				BK_MIRRORCOMM2="$MOVETOLEAF"
				if [[ $FTP_SYNC_PASSED -eq 1 && -e "../current/$SITE/${METAMODE}s/$PLUGIN" ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "We synced the site earlier; therefore we will get our backup from the local cache"
					# This works just the same if it is a single-file plugin
					if [[ $MODE = "delete" ]]; then
						mv "../current/$SITE/${METAMODE}s/$PLUGIN" $MOVETOLEAF
						# Remove second parameter - remote deletion is the only thing needed
						BK_MIRRORCOMM2=""
					else
						cp $COPYOPT -Rp "../current/$SITE/${METAMODE}s/$PLUGIN" $MOVETOLEAF
						# Blank the parameters, as nothing more needs to be done in copy mode (no deletion)
						BK_MIRRORCOMM1=""
						BK_MIRRORCOMM2=""
					fi
				fi
				if [[ -n "${BK_MIRRORCOMM1}${BK_MIRRORCOMM2}" ]]; then
					if [[ $MODE = "delete" || $MODE = "restore" ]]; then
						if [[ -n $BK_MIRRORCOMM2 ]]; then
							ftp_mirror get-delsource $CONTENTDIR/${METAMODE}s "$BK_MIRRORCOMM1" "$BK_MIRRORCOMM2"
						else
							ftp_mirror delete $CONTENTDIR/${METAMODE}s "$BK_MIRRORCOMM1"
						fi
					else
						ftp_mirror get $CONTENTDIR/${METAMODE}s "$BK_MIRRORCOMM1" "$BK_MIRRORCOMM2"
					fi
				fi
				# Update local cache - otherwise leads to erroneous results when relying on cache
				if [[ $MODE = "delete" && -e "../current/$SITE/${METAMODE}s/$PLUGIN" ]]; then
					rm -rf "../current/$SITE/${METAMODE}s/$PLUGIN"
				fi
			fi
		fi
		# Zip up directory (not symlinks)
		if [[ -e $MOVETOLEAF ]]; then
			ws_event_notice "$SITE: $PLUGIN: Backed up old version ($INSTALLED_PVER -> $MOVETOLEAF)"
			if [[ -n $ZIP ]]; then
				if [[ $SKIPMAKEROLLBACK -eq 1 ]]; then
					ws_event_info "Skipping zip creation: --skipmakerollback was specified"
				else
					[[ $DEBUG -ge 1 ]] && ws_event_info "Zipping up old version ($MOVETOLEAF -> $MOVETOLEAF-$INSTALLED_PVER.zip)"
					find $MOVETOLEAF | $ZIP $ZIPOPT -m -y -@ $MOVETOLEAF-$INSTALLED_PVER.zip
				fi
			else
				ws_event_warning "Could not zip up old version; working zip command not found (command: $ZIP, path: $PATH) - run with --debug for more information"
			fi
		elif [ -L $MOVETOLEAF-$INSTALLED_PVER.zip ]; then
			ws_event_info "$SITE: $PLUGIN: Backed up unmodified old version via symlink ($INSTALLED_PVER -> $MOVETOLEAF-$INSTALLED_PVER.zip -> ../$THE_PRISTINE_ZIP)"
		else
			# In restore mode, we assume the other end could be corrupted, so we don't bother with this warning
			[[ $MODE != "restore" && $SKIPMAKEROLLBACK -eq 0 ]] && ws_event_warning "Backed-up old version was not found ($MOVETOLEAF)"
		fi
		# Return to working directory
		ws_cd ..
	fi
elif [[ $MODE != "install" && $MODE != "activate" && $MODE != "deactivate" && $METAMODE != "content" ]]; then
	ws_event_info "Dry run mode: skipped backing up old version of ${METAMODE}"
fi

# (Not delete mode) Now do the move in of the new if not in dry run mode
if [[ $DRYRUN -eq 0 && ( $MODE = "normal" || $MODE = "install" || $MODE = "restore" ) ]]; then
	# In this next block, we are guaranteed to pushd exactly once, and in core mode always two levels
	COPYIN_RETCODE=-1
	[[ $DEBUG -ge 1 ]] && ws_event_info "Beginning copying in of selected $METAMODE"
	# With --core --filemethod upgrades, we need to enumerate files that no longer exist
	if [[ $FILEMETHOD -eq 1 && $METAMODE = "core" && $MODE = "normal" && $INSTALLED_PVER != "$PVER" ]]; then
		# Find the files that will need to be removed afterwards
		ws_cd tmp
		GONECOREFILES=`mktemp GONECOREFILES.XXXXX` || exit 67
		ws_pushd "../fromwporg.core/$INSTALLED_PVER/wordpress"
		[[ $CHOSEN_CORE_IS_OVERLAY -eq 1 ]] && ensure_unpacked_core_exists $PVER
		find . -type f | cut -c3- | while read FORMERFILE; do
			# Next line is wrong - that directory may not exist (it does not get created automatically with the --core --filemethod --upgrade code path)
			#if [[ ! -f "../../$PVER/wordpress/$FORMERFILE" ]]; then
			# In the code path we are in (a filemethod core update) this is where the new files are
			if [[ ! -f "../../../tmp/$NEWPLUGDIR/wordpress/$FORMERFILE" && ( $CHOSEN_CORE_IS_OVERLAY -eq 0 || ! -f "../../$PVER/wordpress/$FORMERFILE" ) ]]; then
				# See wp-admin/includes/update-core.php; certain files are not in newer WPs, but not yet to be deleted
				# Happily for us, those certain files all match a certain regex, and no others do
				[[ $FORMERFILE =~ ^wp-([a-z]+)\.php$ ]] || echo $FORMERFILE >>../../../tmp/$GONECOREFILES
			fi
		done
		ws_popd
		ws_cd ..
	fi
	if [[ $MODE = "normal" || $MODE = "install" ]]; then
		ws_pushd "tmp/$NEWPLUGDIR"
	else
		# restore mode
		if [[ $METAMODE = "core" ]]; then
			CHOSEN_CORE_IS_OVERLAY=1
			ws_pushd "current/$SITE"
			NEWDIRNAME="core"
		elif [[ $METAMODE = "content" ]]; then
			ws_pushd "current/$SITE"
			NEWDIRNAME="content"
		elif [[ $PLUGIN_OR_THEME_MODE -eq 1 ]]; then
			ws_pushd "current/$SITE/${METAMODE_DIR}"
			NEWDIRNAME=$PLUGIN
		else
			abort_die 101 "$METAMODE: Unknown meta mode"
		fi
	fi
	# Flag to indicate whether to copy the local version file from our cache afterwards (not needed in file mode or if unsuccessful). Is implied automatically in FTP mode.
	COPY_LOCAL_VERSION_FILE=0
	if [[ $METAMODE = "core" && $MODE = "normal" && $FILEMETHOD -eq 0 ]]; then
		# Remote CLI method
		COPY_LOCAL_VERSION_FILE=1
		echo -n "${BOLD}Upgrading core (wait, don't abort):${OFFBOLD} "
		remotecli_process coreupgrade tellfile
		FIRSTLINE=`head -1 $REMOTECLI_OUTPUT`
		if [[ $FIRSTLINE =~ ^AUTHOK:ERROR ]]; then
			echo "Failed"
			ws_event_error "Upgrade failed: Error returned was: `tail -n +2 $REMOTECLI_OUTPUT`"
			ws_event_error "One common cause is that your files are not owned by the same user as runs PHP. You could re-try using the switch --filemethod"
		elif [[ $FIRSTLINE =~ ^AUTHOK:UPTODATE ]]; then
			echo "OK: Already at that version"
			[[ $DEBUG -ge 1 ]] && ws_event_info "Remote side returned: `cat $REMOTECLI_OUTPUT`"
		elif [[ $FIRSTLINE =~ ^AUTHOK:UPDATED ]]; then
			echo "OK"
			[[ $DEBUG -ge 1 ]] && ws_event_info "Remote side returned: `cat $REMOTECLI_OUTPUT`"
			COPYIN_RETCODE=0
		else
			echo "Failed"
			ws_event_error "${BOLD}ERROR: ${OFFBOLD} Unknown error: Remote site returned: `cat $REMOTECLI_OUTPUT`"
		fi
		rm -f "$REMOTECLI_OUTPUT"
	elif [[ $ACCESSMETHOD  = "file" ]]; then
		# Filesystem mode
		if [[ $PLUGIN_OR_THEME_MODE -eq 1 && -d "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN" && $MODE != "restore" ]]; then
			ws_event_error "Old ${METAMODE} directory still exists ($FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN)"
			# Do not exit - we want to leave maintenance mode
		else
			[[ $DEBUG -ge 1 && $PLUGIN_OR_THEME_MODE -eq 1 ]] && ws_event_debug "New ${METAMODE} directory: $FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN"
			[[ $DEBUG -ge 1 && $METAMODE = "content" ]] && ws_event_debug "New content directory: $FILEDIR/$CONTENTDIR"
			[[ $DEBUG -ge 1 && $METAMODE = "core" && $FILEMETHOD -eq 1 ]] && ws_event_debug "New ${METAMODE} directory: $FILEDIR"
			# In restore mode, we assume the site is damaged; do not complain, simply clear it out. In core mode, we are over-writing everything anyway.
			[[ $MODE = "restore" && $PLUGIN_OR_THEME_MODE -eq 1 ]] && rm -rf "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN" 2>/dev/null
			echo -n "${BOLD}Moving new ${METAMODE} in:${OFFBOLD} "
			if [[ $MODE = "restore" && $PLUGIN_OR_THEME_MODE -eq 1 ]]; then
				cp $COPYOPT -R $NEWDIRNAME "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN"
			elif [[ $MODE = "restore" && $METAMODE = "content" ]]; then
				ws_cd content
				cp $COPYOPT -R . "$FILEDIR/$CONTENTDIR"
				ws_cd ..
			elif [[ $PLUGIN_OR_THEME_MODE -eq 1 ]]; then
				mv $NEWDIRNAME "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN"
			elif [[ $METAMODE = "core" ]]; then
				# Both restore and not-restore are handled here
				# We are presently in tmp/$NEWPLUGDIR (not restore) or current/$SITE (restore); this may be a full pristine or patched core package; it may be a rollback which hence only contains our amends
				# Need to take notice of CHOSEN_CORE_IS_OVERLAY; if it is set, then we need to bring in the underlay first
				# TODO: Use rsync for speed? mv?
				if [[ $CHOSEN_CORE_IS_OVERLAY -eq 1 ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "The set we have been asked to install appears to be an overlay; we will first bring in the underlay (version: $PVER)"
					ensure_unpacked_core_exists $PVER
					ws_pushd ../../fromwporg.core/$PVER/wordpress
					cp -R . "$FILEDIR"
					ws_popd
				else
					[[ $DEBUG -ge 1 ]] && ws_event_info "The set we have been asked to install appears to be a full version"
					[[ ! -f "$NEWDIRNAME/index.php" ]] && ws_event_warning "Something seems wrong - no index.php file could be found amongst the new WordPress files ( pwd=`pwd`, looked for: $NEWDIRNAME/index.php)"
				fi
				# Now copy in the indicated directory
				ws_pushd "$NEWDIRNAME"
				cp -R . "$FILEDIR"
				# Back into tmp/$NEWPLUGDIR; or possibly into current/$SITE
				ws_popd ..
				[[ $MODE != "restore" ]] && rm -rf "$NEWDIRNAME"
				if [[ $MODE = "normal" && $PVER != $INSTALLED_PVER && -n $GONECOREFILES && -s "../$GONECOREFILES" ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "Will now seek for files that do not belong to the new version to remove"
					REMOVED_FILES=0
					# Loop over files in new version, and remove those which are not in the old version
					while read OLDFILE; do
						if [[ -f "$FILEDIR/$OLDFILE" ]]; then
							[[ $DEBUG -ge 2 ]] && ws_event_info "Removing obsolete file $OLDFILE from $FILEDIR"
							rm -f "$FILEDIR/$OLDFILE"
							REMOVED_FILES=$((REMOVED_FILES+1))
						else
							[[ $DEBUG -ge 1 ]] && ws_event_warning "Expected to find file $OLDFILE in $FILEDIR to remove, but it was not there"
						fi
					done <../$GONECOREFILES
					[[ $DEBUG -ge 1 ]] && ws_event_info "Total removed files: $REMOVED_FILES"
					rm -f "../$GONECOREFILES"
				fi
			fi
			COPYIN_RETCODE=$?
			[[ $COPYIN_RETCODE -eq 0 ]] && echo "Done"
			# Reset file permissions
			[[ $PLUGIN_OR_THEME_MODE -eq 1 ]] && setownership "$FILEDIR/$CONTENTDIR/${METAMODE}s" "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN"
			if [[ $METAMODE = "core" ]]; then
				# It's better to use an existing, unaffected sub-directory if we can; I have come across a case where the root directory was owned by someone different to the files within
				if [[ -d "$FILEDIR/$CONTENTDIR" ]]; then
					setownership "$FILEDIR/$CONTENTDIR" "$FILEDIR/"
				else
					setownership "$FILEDIR" "$FILEDIR/"
				fi
			elif [[ $METAMODE = "content" ]]; then
				if [[ -d "$FILEDIR/wp-includes" ]]; then
					setownership "$FILEDIR/wp-includes" "$FILEDIR/$CONTENTDIR"
				else
					setownership "$FILEDIR" "$FILEDIR/$CONTENTDIR"
				fi
			fi
			grep -q '^config#postfilecommand#' $CONFIGFILE
			if [ $? -eq 0 ]; then
				POSTFILECOMMAND=`grep '^config#postfilecommand#' $CONFIGFILE | cut -d\# -f3`
				[[ $PLUGIN_OR_THEME_MODE -eq 1 ]] && ws_pushd "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN"
				[[ $METAMODE = "content" ]] && ws_pushd "$FILEDIR/content"
				[[ $METAMODE = "core" ]] && ws_pushd "$FILEDIR"
				ws_event_notice "Execute postfilecommand: pwd=`pwd`, command=$POSTFILECOMMAND"
				$POSTFILECOMMAND
				ws_popd
			fi
			if [[ $PLUGIN_OR_THEME_MODE -eq 1 && ! -d "$FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN" ]]; then
				ws_event_error "Moved ${METAMODE} not found (should be at: $FILEDIR/$CONTENTDIR/${METAMODE}s/$PLUGIN)"
				COPYIN_RETCODE=-1
			elif [[ $METAMODE = "content" && ! -d "$FILEDIR/$CONTENTDIR" ]]; then
				ws_event_error "Moved ${METAMODE} not found (should be at: $FILEDIR/$CONTENTDIR"
				COPYIN_RETCODE=-1
			fi
		fi
	else
	# (S)FTP mode
		# Check/ensure the directory's existence
		CHECKDIR="$CONTENTDIR/${METAMODE}s/$PLUGIN/"
		[[ $METAMODE = "core" ]] && CHECKDIR="wp-includes/"
		[[ $METAMODE = "content" ]] && CHECKDIR="$CONTENTDIR/"
		if [[ $MODE = "install" || $MODE = "restore" ]]; then
			ftp_checkfileexistence "$CHECKDIR" makedir
		else
			ftp_checkfileexistence "$CHECKDIR"
		fi
		FTP_EXISTS=$?
		if [[ $FTP_EXISTS -eq 0 ]]; then
			ws_event_error "Could not find $ACCESSMETHOD://$FTPUSER@$FTPHOST/$FTPDIR/$CHECKDIR"
			[[ $DEBUG -ge 1 ]] && ws_event_debug "Output was: $FINDIT"
			COPYIN_RETCODE=12
			# Don't exit - we still want to exit maintenance mode
		else
			# Now do the upload
			if [[ $METAMODE = "core" ]]; then
				if [[ $CHOSEN_CORE_IS_OVERLAY -eq 1 ]]; then
					[[ $DEBUG -ge 1 ]] && ws_event_info "The set we have been asked to install appears to be an overlay; we will first bring in the underlay (version: $PVER)"
					ws_pushd ../../fromwporg.core/$PVER/wordpress
					ftp_mirror putnodelete . . .
					ws_popd
				else
					ws_event_info "The set we have been asked to install appears to be a full version"
				fi
				ws_pushd "$NEWDIRNAME"
				ftp_mirror putnodelete . . .
				if [[ $MODE = "normal" && $PVER != $INSTALLED_PVER && -n $GONECOREFILES && -s "../../$GONECOREFILES" ]]; then
					# Loop over files in new version, and remove those which are not in the old version
					[[ $DEBUG -ge 1 ]] && ws_event_info "Will now seek for files that do not belong to the new version to remove"
					ftp_deletefiles "../../$GONECOREFILES"
				fi
				[[ -n $GONECOREFILES && -f "../../$GONECOREFILES" ]] && rm -f "../../$GONECOREFILES"
			elif [[ $METAMODE = "content" ]]; then
				ws_pushd "$NEWDIRNAME"
				# Note: we use nodelete so as to not delete plugins/themes; however, this can leave old content in place
				ftp_mirror putnodelete "$CONTENTDIR" . .
			elif [[ $PLUGIN_OR_THEME_MODE -eq 1 ]]; then
				ws_pushd "$NEWDIRNAME"
				ftp_mirror put "$CONTENTDIR/${METAMODE}s/$PLUGIN" . .
			else
				abort_die 101 "$METAMODE: Unknown meta mode"
			fi
			COPYIN_RETCODE=$?
			ws_popd
		fi
	fi
	# Access mode specific code has now ended; we are now back to code executed for all methods
	if [ $COPYIN_RETCODE -eq 0 ]; then
		LOGLINE="$SITE: $METAMODE: $PLUGIN: Installed $PVER"
		[[ $METAMODE != "content" ]] && LOGLINE="$LOGLINE (old: $INSTALLED_PVER)"
		ws_event_notice "$LOGLINE"
		if [[ $PLUGIN_OR_THEME_MODE -eq 1 && $MODE = "install" && $ACTIVATE -eq 0 ]]; then
			ws_event_info "$PLUGIN: The files are copied in, but you must re-run with --activate to activate it (or visit the WP admin control panel)."
		fi
		[[ $PLUGIN_OR_THEME_MODE -eq 1 && $MODE = "restore" ]] && ws_event_info "$PLUGIN: The ${METAMODE} files are copied in, but depending on the previous state, you may need to activate it (--activate, or visit the WP admin control panel)"
		if [[ ( $ACCESSMETHOD =~ ftp || $COPY_LOCAL_VERSION_FILE -eq 1 ) && $MODE != "restore" ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Seems to have worked; will now update local cache using local install files"
			# Update local cache - no need to report on errors
			# Only needed in (S)FTP mode; in file mode, we automatically rsync anyway
			# We only really care about the version number, but it doesn't harm to sync more (it'll be synced later anyway)
			COPYOPT_ULC=""
			[[ $DEBUG -ge 2 ]] && COPYOPT_ULC="-v"
			if [[ $METAMODE = "core" ]]; then
				# We are not in restore mode here.
				# This file should be in both underlay and overlay
				mkdir -p "../../current/$SITE/core/wp-includes"
				[[ -f "$NEWDIRNAME/wp-includes/version.php" ]] && cp $COPYOPT_ULC $NEWDIRNAME/wp-includes/version.php "../../current/$SITE/core/wp-includes/version.php"
			else
				rm -rf "../../current/$SITE/${METAMODE}s/$PLUGIN"
				cp $COPYOPT_ULC -R $NEWDIRNAME "../../current/$SITE/${METAMODE}s/$PLUGIN"
			fi
		fi
	fi
	# Up into working directory
	ws_popd
elif [[ $MODE = "normal" || $MODE = "restore" || $MODE = "install" ]]; then
	ws_event_info "Dry run mode: skipped installing new ${METAMODE}"
fi

if [[ ( $MODE  = "normal" ||  $MODE  = "install" ) && ( -z "$COPYIN_RETCODE" || $COPYIN_RETCODE -eq 0 ) ]]; then
	[[ $DEBUG -ge 1 ]] && ws_event_debug "Remove temporary directory: tmp/$NEWPLUGDIR"
	rm -rf "tmp/$NEWPLUGDIR"
fi

if [[ $FILEMETHOD -eq 1 && $METAMODE = "core" && $COPYIN_RETCODE -eq 0 && $MODE = "normal" ]]; then
	if [[ $DISABLEREMOTECLI -eq 0 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "Upgraded core using file method; will now request WordPress to update its database if needed"
		# A failure is not necessarily a big deal
		remotecli_process dbupgrade setvar noquit
		if [[ $REMOTECLI_OUTPUT = "AUTHOK:OK" ]]; then
			[[ $DEBUG -ge 1 ]] && ws_event_info "Database update: OK"
		else
			[[ $DEBUG -ge 1 ]] && ws_event_error "Database update: Output returned was: $REMOTECLI_OUTPUT"
		fi
	else
		[[ $DEBUG -ge 1 ]] && ws_event_info "Upgraded core using file method; but remote cli commands were disabled so we will not call WordPress to upgrade its database (this will happen when you next log in to the administration console - or you can run WordShell with --remotecli=dbupgrade)"
	fi
fi

# We have to leave maintenance mode before we can do the activation operations
if [[ $DRYRUN -eq 0 && $METAMODE != "content" ]]; then
	# Leave maintenance mode
	[[ ( $METAMODE != "core" || $MODE != "install" ) && ( $PLUGIN_OR_THEME_MODE -eq 1 || $MODE != "normal" || $FILEMETHOD -eq 1 ) ]] && maintenance_mode exit
elif [[ $METAMODE != "content" ]]; then
	ws_event_info "Dry run mode: skipped taking site out of maintenance mode"
fi

# Now test the site again (whether it can be reached), and compare the result with before. Only bother if we tried before.
if [[ $SITETEST_RETCODE -ge 0 ]]; then
	[[ $DEBUG -ge 1 ]] && ws_event_debug "Going to test site reachability post-operation"

	COUNT_TMP=`mktemp tmp/counttmp.XXXXX`
	url_get "$TEST_SITEURL" stdout testonly | wc -c >$COUNT_TMP
	SITETEST2_RETCODE=${PIPESTATUS[0]}
	SITETEST_CHARCOUNT2=`cat $COUNT_TMP`
	rm -f "$COUNT_TMP"

	if [[ $SITETEST_CHARCOUNT -gt 0 ]]; then
		SITETEST_WORDCHANGE=$(( (SITETEST_CHARCOUNT2 - SITETEST_CHARCOUNT)*100/SITETEST_CHARCOUNT ))
	elif [[ $SITETEST_CHARCOUNT2 -gt 0 ]]; then
		SITETEST_WORDCHANGE=100
	else
		SITETEST_WORDCHANGE=0
	fi

	[[ $DEBUG -ge 1 ]] && ws_event_info "Characters found in returned page (counted by wc -c): $SITETEST_CHARCOUNT2 (before: $SITETEST_CHARCOUNT - percentage change: $SITETEST_WORDCHANGE)"

	if [[ $SITETEST_RETCODE -eq 0 && $SITETEST2_RETCODE -ne 0 ]]; then
		ws_event_error "Before operating on the site, we were able to load it successfully; but not afterwards. Use 'wordshell $SITE --visit' to see for yourself ($SITEURL). You will want to either investigate the problem, or (depending on what you were doing) --rollback."
	elif [[ $SITETEST_RETCODE -ne 0 && $SITETEST2_RETCODE -eq 0 ]]; then
		ws_event_info "OK: Site now successfully loads via HTTP ($SITEURL)"
	elif [[ $SITETEST_WORDCHANGE -gt 10 || $SITETEST_WORDCHANGE -lt -10 ]]; then
		ws_event_warning "We loaded the site successfully before and after upgrading; but the number of characters found on the page has changed by more than ten percent (amount: $SITETEST_WORDCHANGE %), which may indicate a problem. You will want to investigate, and if you find it was broken then perhaps use --rollback."
	elif [[ $SITETEST_RETCODE -eq 0 && $SITETEST2_RETCODE -eq 0 ]]; then
		[[ $DEBUG -ge 1 ]] && ws_event_info "OK: Successfully loaded site via HTTP after operation"
	else
		# Failed before, failed again now too
		[[ $DEBUG -ge 1 ]] && ws_event_info "Site failed to load via HTTP, as before ($SITEURL)"
	fi
fi

if [[ $METAMODE = "core" && $MODE = "install" ]]; then
	if [[ -n $SITEURL ]]; then
		echo "The WordPress files have been moved in; now visit $SITEURL to finish the install." >/dev/stderr
	else
		echo "The WordPress files have been moved in; now visit the site to finish the install." >/dev/stderr
	fi
fi

# (De-)activation
if [[ ( $ACTIVATE -eq 1 || $DEACTIVATE -eq 1 ) && $DRYRUN -eq 0 ]]; then
	ORIGINAL_MODE=$MODE
	MODE="activate"
	[[ $DEACTIVATE -eq 1 ]] && MODE="deactivate"
	setup_remote_manager $REMOTE_MANAGER_MINIMUM_PROTOCOL
	if [ $? -ne 0 ]; then
		echo $GET_REMOTE_MESSAGE >/dev/stderr
		# No need to exit - we are almost at the end
	else
		# We can now assume it is there; REMOTEMANAGER_KEY is also set
		# Now send the (de)activation command
		# Use actislug by preference - operates on all the plugins in the relevant directory (if there are multiple)
		if [[ ${PLUGIN%.php} != $PLUGIN ]]; then
			ACTI_COM="activate:$PLUGIN"
			[[ $METAMODE = "plugin" && $NETWORK_PLUGIN -eq 1 ]] && ACTI_COM="netactivate:$PLUGIN"
		else
			ACTI_COM="actislug:$PLUGIN"
			[[ $METAMODE = "plugin" && $NETWORK_PLUGIN -eq 1 ]] && ACTI_COM="netactislug:$PLUGIN"
		fi
		[[ $METAMODE = "theme" ]] && ACTI_COM="actitheme:$PLUGIN"
		# Deactivate is not possible in --theme mode; already screened for
		if [[ $DEACTIVATE -eq 1 ]]; then
			if [[ -n $INSTALLED_PFILE && $ORIGINAL_MODE = "delete" ]]; then
				# We can't deactivate a deleted version by slug, as it will not be found - try to use filename if we have it
				ACTI_COM="deactivate:$INSTALLED_PFILE"
				[[ $METAMODE = "plugin" && $NETWORK_PLUGIN -eq 1 ]] && ACTI_COM="netdeactivate:$INSTALLED_PFILE"
			else
				# Otherwise, prefer to go via slug (in case there are multiple plugins in the directory)
				ACTI_COM="deactislug:$PLUGIN"
				[[ $METAMODE = "plugin" && $NETWORK_PLUGIN -eq 1 ]] && ACTI_COM="netdeactislug:$PLUGIN"
			fi
		fi
		# Add network side ID parameter, if specified
		[[ $METAMODE = "plugin" && $NETWORK_BLOGID != "-1" ]] && ACTI_COM="$ACTI_COM:$NETWORK_BLOGID"
		REMOTE_DEBUG=""
		[[ $DEBUG -ge 1 ]] && REMOTE_DEBUG="&wpm-d=1"
		ACTI_OUTPUT=`url_post $SITEURL_HOST $SITEURL_LOCAL/wp-wordshell-controller.php "wpm-a=${REMOTEMANAGER_NONCE}${REMOTE_DEBUG}&wpm-c=$ACTI_COM" nocache`
		[[ $DEBUG -ge 1 ]] && ws_event_info "Sent $MODE command; response was: $ACTI_OUTPUT"
		if [[ ${ACTI_OUTPUT:0:7} = "AUTHOK:" ]]; then
			CUT_ACTI_OUTPUT=${ACTI_OUTPUT:7}
			OLDIFS="$IFS"
			IFS="
"
			for ACTILINE in $CUT_ACTI_OUTPUT; do
				if [[ $ACTILINE =~ ERROR:NotMulti ]]; then
					ws_event_error "Attempted to $MODE plugin: $SITE: This is not a multisite (network) install (cannot use --network)"
				elif [[ $ACTILINE =~ ERROR:NoSuchBlog ]]; then
					ws_event_error "$SITE: $PLUGIN: Attempted to $MODE plugin: This blog was not found (check your --blog parameter)"
				elif [[ ${ACTILINE:0:12} = "OK:Activated" ]]; then
					echo "$SITE: ${ACTILINE:13}: successfully activated"
				elif  [[ ${ACTILINE:0:15} = "OK:WasNotActive" ]]; then
					[[ $DEBUG -ge 1 ]] && echo "$SITE: ${ACTILINE:16}: No need to deactivate; ${METAMODE} was not active"
				elif  [[ ${ACTILINE:0:14} = "OK:Deactivated" ]]; then
					echo "$SITE: ${ACTILINE:15}: successfully deactivated"
				else
					ws_event_error "Attempted to $MODE: $SITE: $PLUGIN: Unknown response: $ACTILINE"
				fi
			done
			IFS="$OLDIFS"
		else
			ws_event_error "Failed to $MODE: authentication failure (output was: ${ACTI_OUTPUT}; auth counter: $REMOTEMANAGER_COUNTER)"
		fi
	fi
elif [[ $ACTIVATE -eq 1 || $DEACTIVATE -eq 1 ]]; then
	ws_event_info "Dry run mode: skipped ${METAMODE} $MODE command"
fi

[[ $SHOWDISKSPACE -eq 1 ]] && show_disk_space

[[ $DEBUG -ge 1 ]] && ws_event_debug "Finished: reached the end of the code"

exit
