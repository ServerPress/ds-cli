--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ READ_ME_FIRST_OGRE_MACPORTS.txt	2011-11-28 03:26:03.000000000 +0100
@@ -0,0 +1,81 @@
+This is a MacPorts-based release of OGRE (www.ogre3d.org)
+Currently this 64-bit distribution package of OGRE is maintained by Marin Saric.
+
+Unlike other releases, this one is STATIC by default. Your code will
+compile into a single executable that does not depend on ANY extra
+libraries. Your users will not need to install Ogre, MacPorts or
+anything else.
+
+This port is meant to be used from the command line using "cmake." You
+can edit/write your code using Aquamacs (a MacOS X version of Emacs)
+or some other editor of your choice. It is possible to use Xcode to
+drive the CMake builds.
+
+Known issues:
+
+NOTE: If you are programming on MacOS X 10.7 and using the OIS system
+          like the one used by the Sample and Tutorial code, it is
+          possible that you won't be able to receive any
+          keystrokes.
+
+          This is a libOIS.a problem. This will be fixed in a future
+          release. After a new release of OIS, you'll need to
+          recompile your code. You can still use other routines, such
+          as the ones from MacOS X libraries to capture keystrokes.
+
+============================================================
+To get started you will need to copy the SDKSamples and Tutorials
+folder into your source directory.
+============================================================
+
+Quick overview of the Contents:
+   - Docs -- General OGRE Documentation
+   - SDKSamples -- Sample code that comes with the OGRE SDK
+   - Tools -- Various miscellanous tools that might be useful
+   - Tutorials -- Use this to follow the Tutorials on OGRE Wiki
+
+============================================================
+Learning OGRE by going through the tutorials:
+============================================================
+
+http://www.ogre3d.org/tikiwiki/Basic+Tutorial+1&structure=Tutorials
+
+
+The code in the Tutorials folder is ready for Basic Tutorial 1. All
+you need to do is add your code in TutorialApplication.cpp and
+TutorialApplication.h
+
+The code will compile and run without any modifications:
+
+cmake . # <-- Don't forget the dot (.)
+make
+./TutorialApp
+
+NOTE: The BaseApplication.cpp and BaseApplication.h has been modified
+from the wiki. The CMakeLists.txt is different as well (and hopefully
+simpler). The modifications were needed to get the Tutorial working on
+MacOS X.
+============================================================
+
+
+============================================================
+Running the sample code:
+
+You can just open the SDKSamples/bin/SampleBrowser.app
+============================================================
+Building the sample code:
+
+cd SDKSamples
+cmake .
+make -j8    # (or use -j4 if you have fewer cores)
+
+The file in bin/SampleBrowser.app/Contents/MacOS will now contain the
+newest version of SampleBrowser
+============================================================
+
+
+
+
+
+============================================================
+OGRE is Copyright (c) 2000-2011 Torus Knot Software Ltd
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/BaseApplication.cpp	2011-11-26 23:42:40.000000000 +0100
@@ -0,0 +1,489 @@
+/* -*- mode: c++; c-file-style: "linux"; indent-tabs-mode: nil; c-basic-offset: 4; c-indent-level: 4 -*-
+-----------------------------------------------------------------------------
+Filename:    BaseApplication.cpp
+-----------------------------------------------------------------------------
+
+This source file is part of the
+   ___                 __    __ _ _    _ 
+  /___\__ _ _ __ ___  / / /\ \ (_) | _(_)
+ //  // _` | '__/ _ \ \ \/  \/ / | |/ / |
+/ \_// (_| | | |  __/  \  /\  /| |   <| |
+\___/ \__, |_|  \___|   \/  \/ |_|_|\_\_|
+      |___/                              
+      Tutorial Framework
+      http://www.ogre3d.org/tikiwiki/
+-----------------------------------------------------------------------------
+*/
+#include "BaseApplication.h"
+
+// ---------------------MacOgre----------------------------------
+#ifdef __APPLE__ & __MACH__
+
+#include "mac_app_loop.h"
+
+class MacTutorialAppLoop : public MacAppLoop {
+public:
+    void RenderFrame(double time_since_last_frame) {
+        if(Ogre::Root::getSingletonPtr()
+           && Ogre::Root::getSingleton().isInitialised()) {
+            Ogre::Root::getSingleton().renderOneFrame(time_since_last_frame);
+        } else {
+            RequestShutdown();
+        }
+    }
+};
+#endif  // __APPLE__ & __MACH__
+// ---------------------MacOgre----------------------------------
+
+
+//-------------------------------------------------------------------------------------
+BaseApplication::BaseApplication(void)
+    : mRoot(0),
+    mCamera(0),
+    mSceneMgr(0),
+    mWindow(0),
+    mResourcesCfg(Ogre::StringUtil::BLANK),
+    mPluginsCfg(Ogre::StringUtil::BLANK),
+    mTrayMgr(0),
+    mCameraMan(0),
+    mDetailsPanel(0),
+    mCursorWasVisible(false),
+    mShutDown(false),
+    mInputManager(0),
+    mMouse(0),
+    mKeyboard(0)
+// ---------------------MacOgre----------------------------------
+#ifdef __APPLE__ & __MACH__
+    ,mMacLoop(new MacTutorialAppLoop)
+#endif
+// ---------------------MacOgre----------------------------------
+{
+}
+
+//-------------------------------------------------------------------------------------
+BaseApplication::~BaseApplication(void)
+{
+    if (mTrayMgr) delete mTrayMgr;
+    if (mCameraMan) delete mCameraMan;
+
+    //Remove ourself as a Window listener
+    Ogre::WindowEventUtilities::removeWindowEventListener(mWindow, this);
+    windowClosed(mWindow);
+    delete mRoot;
+
+// --------------------OgreStatic--------------------------------
+#ifdef OGRE_STATIC_LIB
+    mStaticLoader.unload();
+#endif
+// --------------------OgreStatic--------------------------------
+
+// ---------------------MacOgre----------------------------------
+#ifdef __APPLE__ & __MACH__
+    delete mMacLoop;
+#endif
+// ---------------------MacOgre----------------------------------
+}
+
+//-------------------------------------------------------------------------------------
+bool BaseApplication::configure(void)
+{
+    // Show the configuration dialog and initialise the system
+    // You can skip this and use root.restoreConfig() to load configuration
+    // settings if you were sure there are valid ones saved in ogre.cfg
+    if(mRoot->showConfigDialog())
+    {
+        // If returned true, user clicked OK so initialise
+        // Here we choose to let the system create a default rendering window by passing 'true'
+        mWindow = mRoot->initialise(true, "TutorialApplication Render Window");
+
+        return true;
+    }
+    else
+    {
+        return false;
+    }
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::chooseSceneManager(void)
+{
+    // Get the SceneManager, in this case a generic one
+    mSceneMgr = mRoot->createSceneManager(Ogre::ST_GENERIC);
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::createCamera(void)
+{
+    // Create the camera
+    mCamera = mSceneMgr->createCamera("PlayerCam");
+
+    // Position it at 500 in Z direction
+    mCamera->setPosition(Ogre::Vector3(0,0,80));
+    // Look back along -Z
+    mCamera->lookAt(Ogre::Vector3(0,0,-300));
+    mCamera->setNearClipDistance(5);
+
+    mCameraMan = new OgreBites::SdkCameraMan(mCamera);   // create a default camera controller
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::createFrameListener(void)
+{
+    Ogre::LogManager::getSingletonPtr()->logMessage("*** Initializing OIS ***");
+    OIS::ParamList pl;
+    size_t windowHnd = 0;
+    std::ostringstream windowHndStr;
+
+    mWindow->getCustomAttribute("WINDOW", &windowHnd);
+    windowHndStr << windowHnd;
+    pl.insert(std::make_pair(std::string("WINDOW"), windowHndStr.str()));
+
+    mInputManager = OIS::InputManager::createInputSystem( pl );
+
+    mKeyboard = static_cast<OIS::Keyboard*>(mInputManager->createInputObject( OIS::OISKeyboard, true ));
+    mMouse = static_cast<OIS::Mouse*>(mInputManager->createInputObject( OIS::OISMouse, true ));
+
+    mMouse->setEventCallback(this);
+    mKeyboard->setEventCallback(this);
+
+    //Set initial mouse clipping size
+    windowResized(mWindow);
+
+    //Register as a Window listener
+    Ogre::WindowEventUtilities::addWindowEventListener(mWindow, this);
+
+    mTrayMgr = new OgreBites::SdkTrayManager("InterfaceName", mWindow, mMouse, this);
+    mTrayMgr->showFrameStats(OgreBites::TL_BOTTOMLEFT);
+    mTrayMgr->showLogo(OgreBites::TL_BOTTOMRIGHT);
+    mTrayMgr->hideCursor();
+
+    // create a params panel for displaying sample details
+    Ogre::StringVector items;
+    items.push_back("cam.pX");
+    items.push_back("cam.pY");
+    items.push_back("cam.pZ");
+    items.push_back("");
+    items.push_back("cam.oW");
+    items.push_back("cam.oX");
+    items.push_back("cam.oY");
+    items.push_back("cam.oZ");
+    items.push_back("");
+    items.push_back("Filtering");
+    items.push_back("Poly Mode");
+
+    mDetailsPanel = mTrayMgr->createParamsPanel(OgreBites::TL_NONE, "DetailsPanel", 200, items);
+    mDetailsPanel->setParamValue(9, "Bilinear");
+    mDetailsPanel->setParamValue(10, "Solid");
+    mDetailsPanel->hide();
+
+    mRoot->addFrameListener(this);
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::destroyScene(void)
+{
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::createViewports(void)
+{
+    // Create one viewport, entire window
+    Ogre::Viewport* vp = mWindow->addViewport(mCamera);
+    vp->setBackgroundColour(Ogre::ColourValue(0,0,0));
+
+    // Alter the camera aspect ratio to match the viewport
+    mCamera->setAspectRatio(
+        Ogre::Real(vp->getActualWidth()) / Ogre::Real(vp->getActualHeight()));
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::setupResources(void)
+{
+    // Load resource paths from config file
+    Ogre::ConfigFile cf;
+    cf.load(mResourcesCfg);
+
+    // Go through all sections & settings in the file
+    Ogre::ConfigFile::SectionIterator seci = cf.getSectionIterator();
+
+    Ogre::String secName, typeName, archName;
+    while (seci.hasMoreElements())
+    {
+        secName = seci.peekNextKey();
+        Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();
+        Ogre::ConfigFile::SettingsMultiMap::iterator i;
+        for (i = settings->begin(); i != settings->end(); ++i)
+        {
+            typeName = i->first;
+            archName = i->second;
+            Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
+                archName, typeName, secName);
+        }
+    }
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::createResourceListener(void)
+{
+
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::loadResources(void)
+{
+    Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
+}
+//-------------------------------------------------------------------------------------
+void BaseApplication::go(void)
+{
+#ifdef _DEBUG
+    mResourcesCfg = "resources_d.cfg";
+    mPluginsCfg = "plugins_d.cfg";
+#else
+    mResourcesCfg = "resources.cfg";
+    mPluginsCfg = "plugins.cfg";
+#endif
+
+// ---------------------OgreStatic-------------------------------
+#ifdef OGRE_STATIC_LIB
+    mPluginsCfg = "";
+#endif
+// ---------------------OgreStatic-------------------------------
+
+    if (!setup())
+        return;
+
+#ifdef __APPLE__ & __MACH__
+// ---------------------MacOgre----------------------------------
+    mMacLoop->Run();
+// ---------------------MacOgre----------------------------------
+#else
+    mRoot->startRendering();
+#endif
+
+    // clean up
+    destroyScene();
+}
+//-------------------------------------------------------------------------------------
+bool BaseApplication::setup(void)
+{
+#ifdef __APPLE__ & __MACH__
+// ---------------------MacOgre----------------------------------
+    mMacLoop->Setup();
+// ---------------------MacOgre----------------------------------
+#endif
+
+    mRoot = new Ogre::Root(mPluginsCfg);
+// ---------------------OgreStatic-------------------------------
+#ifdef OGRE_STATIC_LIB
+    mStaticLoader.load();
+#endif
+// ---------------------OgreStatic-------------------------------
+
+    setupResources();
+
+    bool carryOn = configure();
+    if (!carryOn) return false;
+
+    chooseSceneManager();
+    createCamera();
+    createViewports();
+
+    // Set default mipmap level (NB some APIs ignore this)
+    Ogre::TextureManager::getSingleton().setDefaultNumMipmaps(5);
+
+    // Create any resource listeners (for loading screens)
+    createResourceListener();
+    // Load resources
+    loadResources();
+
+    // Create the scene
+    createScene();
+
+    createFrameListener();
+
+    return true;
+};
+//-------------------------------------------------------------------------------------
+bool BaseApplication::frameRenderingQueued(const Ogre::FrameEvent& evt)
+{
+    if(mWindow->isClosed())
+        return false;
+
+#ifdef __APPLE__ & __MACH__
+// ---------------------MacOgre----------------------------------
+    if(mShutDown) {
+        mMacLoop->RequestShutdown();
+        return false;
+    }
+// ---------------------MacOgre----------------------------------
+#else
+    if(mShutDown)
+        return false;
+#endif
+
+    //Need to capture/update each device
+    mKeyboard->capture();
+    mMouse->capture();
+
+    mTrayMgr->frameRenderingQueued(evt);
+
+    if (!mTrayMgr->isDialogVisible())
+    {
+        mCameraMan->frameRenderingQueued(evt);   // if dialog isn't up, then update the camera
+        if (mDetailsPanel->isVisible())   // if details panel is visible, then update its contents
+        {
+            mDetailsPanel->setParamValue(0, Ogre::StringConverter::toString(mCamera->getDerivedPosition().x));
+            mDetailsPanel->setParamValue(1, Ogre::StringConverter::toString(mCamera->getDerivedPosition().y));
+            mDetailsPanel->setParamValue(2, Ogre::StringConverter::toString(mCamera->getDerivedPosition().z));
+            mDetailsPanel->setParamValue(4, Ogre::StringConverter::toString(mCamera->getDerivedOrientation().w));
+            mDetailsPanel->setParamValue(5, Ogre::StringConverter::toString(mCamera->getDerivedOrientation().x));
+            mDetailsPanel->setParamValue(6, Ogre::StringConverter::toString(mCamera->getDerivedOrientation().y));
+            mDetailsPanel->setParamValue(7, Ogre::StringConverter::toString(mCamera->getDerivedOrientation().z));
+        }
+    }
+
+    return true;
+}
+//-------------------------------------------------------------------------------------
+bool BaseApplication::keyPressed( const OIS::KeyEvent &arg )
+{
+    if (mTrayMgr->isDialogVisible()) return true;   // don't process any more keys if dialog is up
+
+    if (arg.key == OIS::KC_F)   // toggle visibility of advanced frame stats
+    {
+        mTrayMgr->toggleAdvancedFrameStats();
+    }
+    else if (arg.key == OIS::KC_G)   // toggle visibility of even rarer debugging details
+    {
+        if (mDetailsPanel->getTrayLocation() == OgreBites::TL_NONE)
+        {
+            mTrayMgr->moveWidgetToTray(mDetailsPanel, OgreBites::TL_TOPRIGHT, 0);
+            mDetailsPanel->show();
+        }
+        else
+        {
+            mTrayMgr->removeWidgetFromTray(mDetailsPanel);
+            mDetailsPanel->hide();
+        }
+    }
+    else if (arg.key == OIS::KC_T)   // cycle polygon rendering mode
+    {
+        Ogre::String newVal;
+        Ogre::TextureFilterOptions tfo;
+        unsigned int aniso;
+
+        switch (mDetailsPanel->getParamValue(9).asUTF8()[0])
+        {
+        case 'B':
+            newVal = "Trilinear";
+            tfo = Ogre::TFO_TRILINEAR;
+            aniso = 1;
+            break;
+        case 'T':
+            newVal = "Anisotropic";
+            tfo = Ogre::TFO_ANISOTROPIC;
+            aniso = 8;
+            break;
+        case 'A':
+            newVal = "None";
+            tfo = Ogre::TFO_NONE;
+            aniso = 1;
+            break;
+        default:
+            newVal = "Bilinear";
+            tfo = Ogre::TFO_BILINEAR;
+            aniso = 1;
+        }
+
+        Ogre::MaterialManager::getSingleton().setDefaultTextureFiltering(tfo);
+        Ogre::MaterialManager::getSingleton().setDefaultAnisotropy(aniso);
+        mDetailsPanel->setParamValue(9, newVal);
+    }
+    else if (arg.key == OIS::KC_R)   // cycle polygon rendering mode
+    {
+        Ogre::String newVal;
+        Ogre::PolygonMode pm;
+
+        switch (mCamera->getPolygonMode())
+        {
+        case Ogre::PM_SOLID:
+            newVal = "Wireframe";
+            pm = Ogre::PM_WIREFRAME;
+            break;
+        case Ogre::PM_WIREFRAME:
+            newVal = "Points";
+            pm = Ogre::PM_POINTS;
+            break;
+        default:
+            newVal = "Solid";
+            pm = Ogre::PM_SOLID;
+        }
+
+        mCamera->setPolygonMode(pm);
+        mDetailsPanel->setParamValue(10, newVal);
+    }
+    else if(arg.key == OIS::KC_F5)   // refresh all textures
+    {
+        Ogre::TextureManager::getSingleton().reloadAll();
+    }
+    else if (arg.key == OIS::KC_SYSRQ)   // take a screenshot
+    {
+        mWindow->writeContentsToTimestampedFile("screenshot", ".jpg");
+    }
+    else if (arg.key == OIS::KC_ESCAPE)
+    {
+        mShutDown = true;
+    }
+
+    mCameraMan->injectKeyDown(arg);
+    return true;
+}
+
+bool BaseApplication::keyReleased( const OIS::KeyEvent &arg )
+{
+    mCameraMan->injectKeyUp(arg);
+    return true;
+}
+
+bool BaseApplication::mouseMoved( const OIS::MouseEvent &arg )
+{
+    if (mTrayMgr->injectMouseMove(arg)) return true;
+    mCameraMan->injectMouseMove(arg);
+    return true;
+}
+
+bool BaseApplication::mousePressed( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
+{
+    if (mTrayMgr->injectMouseDown(arg, id)) return true;
+    mCameraMan->injectMouseDown(arg, id);
+    return true;
+}
+
+bool BaseApplication::mouseReleased( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
+{
+    if (mTrayMgr->injectMouseUp(arg, id)) return true;
+    mCameraMan->injectMouseUp(arg, id);
+    return true;
+}
+
+//Adjust mouse clipping area
+void BaseApplication::windowResized(Ogre::RenderWindow* rw)
+{
+    unsigned int width, height, depth;
+    int left, top;
+    rw->getMetrics(width, height, depth, left, top);
+
+    const OIS::MouseState &ms = mMouse->getMouseState();
+    ms.width = width;
+    ms.height = height;
+}
+
+//Unattach OIS before window shutdown (very important under Linux)
+void BaseApplication::windowClosed(Ogre::RenderWindow* rw)
+{
+    //Only close for window that created OIS (the main window in these demos)
+    if( rw == mWindow )
+    {
+        if( mInputManager )
+        {
+            mInputManager->destroyInputObject( mMouse );
+            mInputManager->destroyInputObject( mKeyboard );
+
+            OIS::InputManager::destroyInputSystem(mInputManager);
+            mInputManager = 0;
+        }
+    }
+}
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/BaseApplication.h	2011-11-26 23:43:29.000000000 +0100
@@ -0,0 +1,131 @@
+/* -*- mode: c++; c-file-style: "linux"; indent-tabs-mode: nil; c-basic-offset: 4; c-indent-level: 4 -*-
+-----------------------------------------------------------------------------
+Filename:    BaseApplication.h
+-----------------------------------------------------------------------------
+
+Minor modifications of this file were made to make it build with a
+static version of OGRE on MacOS X. The modifications for the static
+build are marked as OgreStatic. The MacOS X modifications are done
+under the compiler conditional and marked with MacOgre. You can search
+for these markers to see where the changes to the file have been made.
+
+This source file is part of the
+   ___                 __    __ _ _    _ 
+  /___\__ _ _ __ ___  / / /\ \ (_) | _(_)
+ //  // _` | '__/ _ \ \ \/  \/ / | |/ / |
+/ \_// (_| | | |  __/  \  /\  /| |   <| |
+\___/ \__, |_|  \___|   \/  \/ |_|_|\_\_|
+      |___/                              
+      Tutorial Framework
+      http://www.ogre3d.org/tikiwiki/
+-----------------------------------------------------------------------------
+*/
+#ifndef __BaseApplication_h_
+#define __BaseApplication_h_
+
+// ---------------------OgreStatic-------------------------------
+// Added for building the tutorials with a static version of OGRE
+#define OGRE_STATIC_LIB
+#define OGRE_STATIC_OctreeSceneManager
+#define OGRE_STATIC_ParticleFX
+#define OGRE_STATIC_BSPSceneManager
+#define OGRE_STATIC_GL
+
+#ifdef OGRE_STATIC_LIB
+#include <OgreStaticPluginLoader.h>
+#endif
+// ---------------------OgreStatic-------------------------------
+
+#include <OgreCamera.h>
+#include <OgreEntity.h>
+#include <OgreLogManager.h>
+#include <OgreRoot.h>
+#include <OgreViewport.h>
+#include <OgreSceneManager.h>
+#include <OgreRenderWindow.h>
+#include <OgreConfigFile.h>
+
+#include <OISEvents.h>
+#include <OISInputManager.h>
+#include <OISKeyboard.h>
+#include <OISMouse.h>
+
+#include <SdkTrays.h>
+#include <SdkCameraMan.h>
+
+#ifdef __APPLE__ & __MACH__
+//MacOgre
+class MacTutorialAppLoop;
+#endif
+
+class BaseApplication : public Ogre::FrameListener, public Ogre::WindowEventListener, public OIS::KeyListener, public OIS::MouseListener, OgreBites::SdkTrayListener
+{
+public:
+    BaseApplication(void);
+    virtual ~BaseApplication(void);
+
+    virtual void go(void);
+
+protected:
+    virtual bool setup();
+    virtual bool configure(void);
+    virtual void chooseSceneManager(void);
+    virtual void createCamera(void);
+    virtual void createFrameListener(void);
+    virtual void createScene(void) = 0; // Override me!
+    virtual void destroyScene(void);
+    virtual void createViewports(void);
+    virtual void setupResources(void);
+    virtual void createResourceListener(void);
+    virtual void loadResources(void);
+
+    // Ogre::FrameListener
+    virtual bool frameRenderingQueued(const Ogre::FrameEvent& evt);
+
+    // OIS::KeyListener
+    virtual bool keyPressed( const OIS::KeyEvent &arg );
+    virtual bool keyReleased( const OIS::KeyEvent &arg );
+    // OIS::MouseListener
+    virtual bool mouseMoved( const OIS::MouseEvent &arg );
+    virtual bool mousePressed( const OIS::MouseEvent &arg, OIS::MouseButtonID id );
+    virtual bool mouseReleased( const OIS::MouseEvent &arg, OIS::MouseButtonID id );
+
+    // Ogre::WindowEventListener
+    //Adjust mouse clipping area
+    virtual void windowResized(Ogre::RenderWindow* rw);
+    //Unattach OIS before window shutdown (very important under Linux)
+    virtual void windowClosed(Ogre::RenderWindow* rw);
+
+    Ogre::Root *mRoot;
+    Ogre::Camera* mCamera;
+    Ogre::SceneManager* mSceneMgr;
+    Ogre::RenderWindow* mWindow;
+    Ogre::String mResourcesCfg;
+    Ogre::String mPluginsCfg;
+
+    // OgreBites
+    OgreBites::SdkTrayManager* mTrayMgr;
+    OgreBites::SdkCameraMan* mCameraMan;       // basic camera controller
+    OgreBites::ParamsPanel* mDetailsPanel;     // sample details panel
+    bool mCursorWasVisible;                    // was cursor visible before dialog appeared
+    bool mShutDown;
+
+    //OIS Input devices
+    OIS::InputManager* mInputManager;
+    OIS::Mouse*    mMouse;
+    OIS::Keyboard* mKeyboard;
+
+// ---------------------OgreStatic-------------------------------
+#ifdef OGRE_STATIC_LIB
+    Ogre::StaticPluginLoader mStaticLoader;
+#endif
+// ---------------------OgreStatic-------------------------------
+
+// ---------------------MacOgre----------------------------------
+#ifdef __APPLE__ & __MACH__
+    MacTutorialAppLoop *mMacLoop;
+#endif
+// ---------------------MacOgre----------------------------------
+};
+
+#endif // #ifndef __BaseApplication_h_
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/CMakeLists.txt	2011-11-26 23:57:01.000000000 +0100
@@ -0,0 +1,44 @@
+CMAKE_MINIMUM_REQUIRED (VERSION 2.6.3)
+
+IF(APPLE)
+  LIST(APPEND CMAKE_PREFIX_PATH "@PREFIX@")
+  LIST(APPEND CMAKE_FRAMEWORK_PATH "@FRAMEWORKS_DIR@")
+ENDIF(APPLE)
+
+ADD_DEFINITIONS(-O3)
+
+SET(OGRE_STATIC TRUE)
+
+FIND_PACKAGE(OGRE REQUIRED)
+FIND_PACKAGE(OIS REQUIRED)
+
+SET(TUTORIAL_ALL_INCLUDES
+  ${OGRE_INCLUDE_DIRS}
+  ${OGRE_RenderSystem_GL_INCLUDE_DIR}
+  ${OGRE_Plugin_BSPSceneManager_INCLUDE_DIR}
+  ${OGRE_Plugin_OctreeSceneManager_INCLUDE_DIR}
+  ${OGRE_Plugin_PCZSceneManager_INCLUDE_DIR}
+  ${OGRE_Plugin_ParticleFX_INCLUDE_DIR}
+  ${OIS_INCLUDE_DIRS})
+
+SET(TUTORIAL_ALL_LIBRARIES
+  ${OGRE_LIBRARIES}
+  ${OGRE_RenderSystem_GL_LIBRARIES}
+  ${OGRE_Plugin_BSPSceneManager_LIBRARIES}
+  ${OGRE_Plugin_OctreeSceneManager_LIBRARIES}
+  ${OGRE_Plugin_PCZSceneManager_LIBRARIES}
+  ${OGRE_Plugin_ParticleFX_LIBRARIES}
+  ${OIS_LIBRARIES})
+
+INCLUDE_DIRECTORIES(${TUTORIAL_ALL_INCLUDES})
+
+ADD_EXECUTABLE(TutorialApp
+  BaseApplication.cpp
+  TutorialApplication.cpp
+  mac_app_loop.mm)
+
+TARGET_LINK_LIBRARIES(TutorialApp ${TUTORIAL_ALL_LIBRARIES})
+
+CONFIGURE_FILE(${OGRE_MEDIA_DIR}/../resources.cfg
+  ${CMAKE_CURRENT_BINARY_DIR}/resources.cfg
+  @ONLY)
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/README.txt	2011-11-27 00:03:24.000000000 +0100
@@ -0,0 +1,13 @@
+This folder contains the Tutorial code found on OGRE Wiki, adopted
+slightly to run on a static version of OGRE for MacOS X. The source
+code is essentially unchanged, there are just a few emacs markers to
+preserve the formatting. 
+
+To build, do:
+
+mkdir build
+cd build
+cmake ..
+make
+
+There should be an application named TutorialApp after the compile
\ No newline at end of file
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/TutorialApplication.cpp	2011-11-27 00:01:02.000000000 +0100
@@ -0,0 +1,70 @@
+/* -*- mode: c++; c-file-style: "linux"; indent-tabs-mode: nil; c-basic-offset: 4; c-indent-level: 4 -*-
+-----------------------------------------------------------------------------
+Filename:    TutorialApplication.cpp
+-----------------------------------------------------------------------------
+
+This source file is part of the
+   ___                 __    __ _ _    _ 
+  /___\__ _ _ __ ___  / / /\ \ (_) | _(_)
+ //  // _` | '__/ _ \ \ \/  \/ / | |/ / |
+/ \_// (_| | | |  __/  \  /\  /| |   <| |
+\___/ \__, |_|  \___|   \/  \/ |_|_|\_\_|
+      |___/                              
+      Tutorial Framework
+      http://www.ogre3d.org/tikiwiki/
+-----------------------------------------------------------------------------
+*/
+#include "TutorialApplication.h"
+
+//-------------------------------------------------------------------------------------
+TutorialApplication::TutorialApplication(void)
+{
+}
+//-------------------------------------------------------------------------------------
+TutorialApplication::~TutorialApplication(void)
+{
+}
+
+//-------------------------------------------------------------------------------------
+void TutorialApplication::createScene(void)
+{
+    // create your scene here :)
+}
+
+
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#define WIN32_LEAN_AND_MEAN
+#include "windows.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
+#else
+    int main(int argc, char *argv[])
+#endif
+    {
+        // Create application object
+        TutorialApplication app;
+
+        try {
+            app.go();
+        } catch( Ogre::Exception& e ) {
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
+#else
+            std::cerr << "An exception has occured: " <<
+                e.getFullDescription().c_str() << std::endl;
+#endif
+        }
+
+        return 0;
+    }
+
+#ifdef __cplusplus
+}
+#endif
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/TutorialApplication.h	2011-11-27 00:00:55.000000000 +0100
@@ -0,0 +1,32 @@
+/* -*- mode: c++; c-file-style: "linux"; indent-tabs-mode: nil; c-basic-offset: 4; c-indent-level: 4 -*-
+-----------------------------------------------------------------------------
+Filename:    TutorialApplication.h
+-----------------------------------------------------------------------------
+
+This source file is part of the
+   ___                 __    __ _ _    _ 
+  /___\__ _ _ __ ___  / / /\ \ (_) | _(_)
+ //  // _` | '__/ _ \ \ \/  \/ / | |/ / |
+/ \_// (_| | | |  __/  \  /\  /| |   <| |
+\___/ \__, |_|  \___|   \/  \/ |_|_|\_\_|
+      |___/                              
+      Tutorial Framework
+      http://www.ogre3d.org/tikiwiki/
+-----------------------------------------------------------------------------
+*/
+#ifndef __TutorialApplication_h_
+#define __TutorialApplication_h_
+
+#include "BaseApplication.h"
+
+class TutorialApplication : public BaseApplication
+{
+public:
+    TutorialApplication(void);
+    virtual ~TutorialApplication(void);
+
+protected:
+    virtual void createScene(void);
+};
+
+#endif // #ifndef __TutorialApplication_h_
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/mac_app_loop.h	2011-11-26 22:45:46.000000000 +0100
@@ -0,0 +1,126 @@
+// Copyright (c) 2011 Marin Saric
+// Portions Copyright (c) 2009-2011 Matt Gallagher
+// 
+// This software is provided 'as-is', without any express or implied
+// warranty. In no event will the authors be held liable for any damages
+// arising from the use of this software.
+//
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+//
+// 1. The origin of this software must not be misrepresented; you must not
+// claim that you wrote the original software. If you use this software in
+// a product, an acknowledgment in the product documentation would be
+// appreciated but is not required.
+//
+// 2. Altered source versions must be plainly marked as such, and must not
+// be misrepresented as being the original software.
+//
+// 3. This notice may not be removed or altered from any source
+// distribution.
+// 
+// MacAppLoop
+//
+// The MacAppLoop class abstracts away the MacOS X Cocoa internals
+//
+// This class header has a pure C++ interface and does not depend on you
+// doing an #include of any other files with your code.
+//
+// You also do NOT need to setup an Application Bundle, Info.plist, nib
+// files or do any of the other very MacOS X specific steps.
+//
+// To compile mac_app_loop.mm, you need either Apple's version of gcc or
+// clang. Remember to link with "-framework Cocoa" flag.
+//
+// This abstraction isolates you from needing to know about how the
+// Cocoa stuff works.
+//
+// If you just want to "play nice" when calling Cocoa-based routines,
+// it is probably enough to declare a MacMemoryPool before calling
+// such code. Creating a MacMemoryPool is comparable to the cost of
+// allocating a tiny block of memory. Thus, you can use it in
+// per-frame loops, etc.
+//
+// --------------------------------------------------------------------------
+// Code example for MacAppLoop:
+// The user of the "mac_app_loop.h" only needs to do this:
+//
+// # include "mac_app_loop.h"
+//
+// class MyAppLoop : public MacAppLoop {
+//   void RenderFrame(double time_since_last_frame) {
+//      do something...
+//   }
+// };
+//
+// and then
+//
+// int main(int argc, char **argv) {
+//   MyAppLoop app_loop;
+//
+//   // make sure to call Setup as early as possible in your code
+//   app_loop.Setup();
+//
+//   app_loop.Run();
+//   return 0;
+// }
+// --------------------------------------------------------------------------
+// Code example for MacMemoryPool:
+//
+// # include "mac_app_loop.h"
+//
+// void MyFunctionThatCallsCocoaSystems() {
+//    MacMemoryPool memory_pool;
+//
+//    SomeCocoaBasedRoutine();
+// }
+
+#ifndef MAC_APP_LOOP_H
+#define MAC_APP_LOOP_H
+
+// We hide the actual implementation in this class
+class MacAppLoopPrivate;
+
+class MacAppLoop {
+ public:
+  MacAppLoop();
+  virtual ~MacAppLoop();
+
+  // Call this before Run().
+  // refresh_hz - how many times per second do is RenderFrame called
+  void Setup(double refresh_hz = 60.0);
+
+  // Call this to get the App to Shutdown
+  void RequestShutdown();
+
+  // Override this method to get something to happen
+  virtual void RenderFrame(double time_since_last_frame) {}
+
+  // Call this to enter the application loop
+  void Run();
+
+ private:
+  MacAppLoopPrivate *private_;
+
+  // Disallow copying of this object
+  MacAppLoop(const MacAppLoop &rhs);
+  MacAppLoop& operator= (const MacAppLoop &rhs);
+};
+
+// Declare a MacMemoryPool in places that call Cocoa based code.
+// You will need at least one MacMemoryPool per application
+class MacMemoryPool {
+public:
+  MacMemoryPool();
+  ~MacMemoryPool();
+
+private:
+  void *data_;
+
+  // Disallow copying of this object
+  MacMemoryPool(const MacAppLoop &rhs);
+  MacMemoryPool& operator= (const MacAppLoop &rhs);
+};
+
+#endif  // MAC_APP_LOOP_H
--- /dev/null	2011-11-28 03:33:22.000000000 +0100
+++ Tutorials/mac_app_loop.mm	2011-11-26 22:50:19.000000000 +0100
@@ -0,0 +1,308 @@
+// Copyright (c) 2011 Marin Saric
+// Portions Copyright (c) 2009-2011 Matt Gallagher
+// 
+// This software is provided 'as-is', without any express or implied
+// warranty. In no event will the authors be held liable for any damages
+// arising from the use of this software.
+//
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+//
+// 1. The origin of this software must not be misrepresented; you must not
+// claim that you wrote the original software. If you use this software in
+// a product, an acknowledgment in the product documentation would be
+// appreciated but is not required.
+//
+// 2. Altered source versions must be plainly marked as such, and must not
+// be misrepresented as being the original software.
+//
+// 3. This notice may not be removed or altered from any source
+// distribution.
+//
+// MacAppLoop
+//
+// The idea of a NSTimer controlled Cocoa application stems from
+// masterfalcon's (David Rogers') implementation of SampleBrowser for
+// OGRE (Object-oriented Graphics Rendering Engine).
+//
+// The art of implementing a bundle-less, nib-less, Info.plist-less
+// Objective-C object is owed to Matt Gallagher, and an appropriate
+// zlib license copyright notice is included with the
+// MacAppLoopPrivate::Setup code
+//
+// This file must be compiled with Objective-C++ aware compiler,
+// either clang or Apple's version of gcc
+//
+// The MacAppLoop header file does not need Objective-C++ and can be
+// included by C++ programs.
+// The linkage parameters need to be "-framework Cocoa"
+
+# include "mac_app_loop.h"
+
+# include <iostream>
+# include <exception>
+# import <Cocoa/Cocoa.h>
+
+// The private implementation of the Mac Application Loop
+// The MacAppLoop class forwards all of its calls to MacAppLoopPrivate
+// The MacAppLoop methods are further down in the file
+class MacAppLoopPrivate {
+public:
+  MacAppLoopPrivate(MacAppLoop &app_loop);
+  ~MacAppLoopPrivate();
+
+  void SetRefreshHz(double refresh_hz) { refresh_hz_ = refresh_hz; }
+  inline double refresh_hz() { return refresh_hz_; }
+
+  void Setup(double refresh_hz);
+
+  void RequestShutdown() { exit_called_ = true; }
+  inline bool wants_shutdown() { return exit_called_; }
+
+  void RenderFrame(double time_since_last_frame);
+
+  void Run();
+
+private:
+  // Link to the public instance of the class
+  MacAppLoop &app_loop_;
+
+  // Internal variables
+  double refresh_hz_;  // Refresh rate in Hz
+  bool is_setup_;      // true if Setup() called
+  bool exit_called_;   // true if RequestShutdown() called
+
+  // Link to the Objective-C Cocoa object
+  id app_delegate_;
+
+  // The Cocoa envrionment autorelease pool
+  NSAutoreleasePool *pool_;
+};
+
+//--------------------------------------------------------------------------
+//               The implementation of MacAppLoop
+//           (simply forwards to MacAppLoopPrivate)
+
+MacAppLoop::MacAppLoop() 
+: private_(new MacAppLoopPrivate(*this)) {
+}
+
+MacAppLoop::~MacAppLoop() { delete private_; }
+
+void MacAppLoop::Setup(double refresh_hz) { private_->Setup(refresh_hz); }
+void MacAppLoop::RequestShutdown() { private_->RequestShutdown(); }
+void MacAppLoop::Run() { private_->Run(); }
+
+//--------------------------------------------------------------------------
+//           The MacAppDelegate Objective-C++ code region
+//
+
+// Supress the warnings for not implementing buttonPressed
+@implementation NSApplication (_suppressUnimplementedActionWarning)
+- (void) buttonPressed:(id)sender { /* Do nothing */ }
+@end
+
+// MacAppDelegate is the Objective-C++ Cocoa application delegate based
+// in essential design on the SampleBrowser_OSX.h code
+@interface MacAppDelegate : NSObject <NSApplicationDelegate> {
+  //  An instance of the NSTimer class that will
+  //  fire at the desired refresh rate.
+  NSTimer *timer;
+
+  // A pointer to a private implementation of MacAppLoop
+  // (the MacAppLoopPrivate code is  further below in this file)
+  MacAppLoopPrivate *app_loop_private;
+}
+
+// MacAppDelegate methods:
+//  initWithPrivateLoop is used as a "constructor"
+- (MacAppDelegate *)initWithPrivateLoop:(MacAppLoopPrivate *)loop;
+
+//  renderFrame is periodically called by the NSTimer instance 'timer'
+- (void)renderFrame:(id)sender;
+
+//  appShutdown is invoked when the MacAppLoop requests a shutdown
+- (void)appShutdown;
+@end
+
+// Implementation of the MacAppDelegate methods follow
+@implementation MacAppDelegate
+// The MacAppDelegate "constructor" accepts a pointer to an instance
+// of the MacAppLoopPrivate, an instance of C++ class which is a
+// private implementation
+- (MacAppDelegate *)initWithPrivateLoop:(MacAppLoopPrivate *)loop {
+  self = [super init];
+
+  if (self) app_loop_private = loop;
+
+  return self;
+}
+
+// The MacOS X Cocoa subsystem will call this method as soon as the
+// application is ready to start executing UI code.
+- (void)applicationDidFinishLaunching:(NSNotification *)application {
+  double refresh_hz = app_loop_private->refresh_hz();
+
+  // If we have a sane refresh rate specified, we create an instance
+  // of the NSTimer class, specifying [self renderFrame] as the target.
+  // The timer invokes renderFrame at the frequency of refresh_hz per second
+  if (refresh_hz > 0.) {
+    timer = [NSTimer
+             scheduledTimerWithTimeInterval:((NSTimeInterval)
+                                             (1.0 / refresh_hz))
+                                     target:self
+                                   selector:@selector(renderFrame:)
+                                   userInfo:nil
+                                    repeats:YES];
+  }
+}
+
+// The renderframe method is called periodically by the timer instance
+- (void)renderFrame:(id)sender {
+  // We check whether the Mac application loop requested a shutdown
+  if (app_loop_private->wants_shutdown()) {
+    [self appShutdown];
+    return;
+  }
+
+  // No shutdown was requested so render the frame, passing the time
+  // elapsed since the last frame
+  app_loop_private->RenderFrame([timer timeInterval]);
+}
+
+//  appShutdown is invoked when the MacAppLoop requests a shutdown
+- (void)appShutdown {
+  // Destroy the timer object
+  [timer invalidate];
+  timer = nil;
+  
+  // Do [NSapp stop] as soon as possible in the run loop
+  // (does not execute immediately)
+  // This will exit the run loop and return control to the caller of [NSApp run]
+  [NSApp performSelector:@selector(stop:)
+              withObject:nil 
+              afterDelay:0.0];
+}
+
+- (void)dealloc {
+  if(timer) {
+    [timer invalidate];
+    timer = nil;
+  }
+
+  [super dealloc];
+}
+@end
+
+//--------------------------------------------------------------------------
+//                MacAppLoopPrivate implementation
+
+MacAppLoopPrivate::MacAppLoopPrivate(MacAppLoop &app_loop)
+: app_loop_(app_loop),
+  refresh_hz_(0),
+  is_setup_(false),
+  exit_called_(false),
+  pool_(NULL) {
+}
+
+MacAppLoopPrivate::~MacAppLoopPrivate() {
+  // Destroy the autorelease pool
+  if (is_setup_) {
+    [pool_ release];
+  }
+}
+
+void MacAppLoopPrivate::Setup(double refresh_hz) {
+  if (is_setup_ || exit_called_) return;
+
+  SetRefreshHz(refresh_hz);
+
+  // ----------------------------------------------------------------------
+  // The code below uses an altered version of Matt Galagher's example:
+  // http://cocoawithlove.com/2010/09/minimalist-cocoa-programming.html
+  //
+  // Copyright (c) 2009-2011 Matt Gallagher. All rights reserved.
+  //
+  // This software is provided 'as-is', without any express or implied
+  // warranty. In no event will the authors be held liable for any damages
+  // arising from the use of this software. Permission is granted to anyone
+  // to use this software for any purpose, including commercial
+  // applications, and to alter it and redistribute it freely, subject to
+  // the following restrictions: 
+  //
+  // 1. The origin of this software must not be misrepresented; you must
+  //    not claim that you wrote the original software. If you use this
+  //    software in a product, an acknowledgment in the product
+  //    documentation would be appreciated but is not required.
+  //
+  // 2. Altered source versions must be plainly marked as such, and must
+  //    not be misrepresented as being the original software.
+  //
+  // 3. This notice may not be removed or altered from any source
+  //    distribution.
+
+  pool_ = [NSAutoreleasePool new];
+  [NSApplication sharedApplication];
+  [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];
+
+  id menubar = [[NSMenu new] autorelease];
+  id appMenuItem = [[NSMenuItem new] autorelease];
+  [menubar addItem:appMenuItem];
+  [NSApp setMainMenu:menubar];
+  id appMenu = [[NSMenu new] autorelease];
+  id appName = [[NSProcessInfo processInfo] processName];
+  id quitTitle = [@"Quit " stringByAppendingString:appName];
+  id quitMenuItem =
+    [[[NSMenuItem alloc]
+      initWithTitle:quitTitle
+      action:@selector(stop:)
+      keyEquivalent:@"q"] autorelease];
+
+  [appMenu addItem:quitMenuItem];
+  [appMenuItem setSubmenu:appMenu];
+  // ----------------------------------------------------------------------
+  
+  app_delegate_ = [[MacAppDelegate alloc]
+                   initWithPrivateLoop:this];
+
+  is_setup_ = true;
+}
+
+void MacAppLoopPrivate::Run() {
+  if (!is_setup_ || exit_called_) return;
+
+  [[NSApplication sharedApplication] setDelegate:app_delegate_];
+  [NSApp activateIgnoringOtherApps:YES];
+  [NSApp run];
+
+  // Set exit_called_, so that Run cannot be re-entered
+  exit_called_ = true;
+}
+
+void MacAppLoopPrivate::RenderFrame(double time_since_last_frame) {
+  try {
+    app_loop_.RenderFrame(time_since_last_frame);
+  } catch (const std::exception& e) {
+    std::cerr << "MacAppLoop::RenderFrame: "
+              << "Caught an exception: "
+              << e.what() << std::endl
+              << "MacAppLoop::RenderFrame: shutting down." << std::endl;
+    RequestShutdown();
+  } catch (...) {
+    std::cerr << "MacAppLoop::RenderFrame: "
+              << "Exception caught, shutting down." << std::endl;
+    RequestShutdown();
+  }
+}
+
+//--------------------------------------------------------------------------
+//                MacMemoryPool implementation
+
+MacMemoryPool::MacMemoryPool() {
+  data_ = (void *) [NSAutoreleasePool new];
+}
+
+MacMemoryPool::~MacMemoryPool() {
+  [((NSAutoreleasePool *) data_) release];
+}
