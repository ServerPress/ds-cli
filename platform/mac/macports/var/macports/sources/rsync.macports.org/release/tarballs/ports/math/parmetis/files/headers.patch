# HG changeset patch
# User Sean Farley <sean@mcs.anl.gov>
# Date 1332262777 18000
#      Tue Mar 20 11:59:37 2012 -0500
# Node ID 26bf6bd351436e6d2c3cf8f89485dc72a926cf55
# Parent  b51a142f9789feb5bda1d1546b8ec8525f356f74
gklib: copy headers from gklib repo

diff -r b51a142f9789 -r 26bf6bd35143 headers/GKlib.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/GKlib.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,83 @@
+/*
+ * GKlib.h
+ * 
+ * George's library of most frequently used routines
+ *
+ * $Id$
+ *
+ */
+
+#ifndef _GKLIB_H_
+#define _GKLIB_H_ 1
+
+#define GKMSPACE
+
+#if defined(_MSC_VER)
+#define __MSC__
+#endif
+#if defined(__ICC)
+#define __ICC__
+#endif
+
+
+#include "gk_arch.h" /*!< This should be here, prior to the includes */
+
+
+/*************************************************************************
+* Header file inclusion section
+**************************************************************************/
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <errno.h>
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
+#include <time.h>
+#include <string.h>
+#include <limits.h>
+#include <signal.h>
+#include <setjmp.h>
+#include <assert.h>
+#include <sys/stat.h>
+
+#if defined(__WITHPCRE__)
+  #include <pcreposix.h>
+#else
+  #if defined(USE_GKREGEX)
+    #include "gkregex.h"
+  #else
+    #include <regex.h>
+  #endif /* defined(USE_GKREGEX) */
+#endif /* defined(__WITHPCRE__) */
+
+
+
+#if defined(__OPENMP__) 
+#include <omp.h>
+#endif
+
+
+
+
+#include <gk_types.h>
+#include <gk_struct.h>
+#include <gk_externs.h>
+#include <gk_defs.h>
+#include <gk_macros.h>
+#include <gk_getopt.h>
+
+#include <gk_mksort.h>
+#include <gk_mkblas.h>
+#include <gk_mkmemory.h>
+#include <gk_mkpqueue.h>
+#include <gk_mkrandom.h>
+#include <gk_mkutils.h>
+
+#include <gk_proto.h>
+
+
+#endif  /* GKlib.h */
+
+
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_arch.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_arch.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,71 @@
+/*!
+\file gk_arch.h
+\brief This file contains various architecture-specific declerations
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_ARCH_H_
+#define _GK_ARCH_H_
+
+/*************************************************************************
+* Architecture-specific differences in header files
+**************************************************************************/
+#ifdef LINUX
+#if !defined(__USE_XOPEN)
+#define __USE_XOPEN
+#endif
+#if !defined(_XOPEN_SOURCE)
+#define _XOPEN_SOURCE 600
+#endif
+#if !defined(__USE_XOPEN2K)
+#define __USE_XOPEN2K
+#endif
+#endif
+
+
+#ifdef HAVE_EXECINFO_H
+#include <execinfo.h>
+#endif
+
+
+#ifdef __MSC__ 
+  #include "ms_stdint.h"
+  #include "ms_inttypes.h"
+  #include "ms_stat.h"
+#else
+#ifndef SUNOS
+  #include <stdint.h>
+#endif
+  #include <inttypes.h>
+  #include <sys/types.h>
+  #include <sys/resource.h>
+  #include <sys/time.h>
+#endif
+
+
+/*************************************************************************
+* Architecture-specific modifications
+**************************************************************************/
+#ifdef WIN32
+typedef ptrdiff_t ssize_t;
+#endif
+
+
+#ifdef SUNOS
+#define PTRDIFF_MAX  INT64_MAX
+#endif
+
+#ifdef __MSC__
+/* MSC does not have rint() function */
+#define rint(x) ((int)((x)+0.5))  
+
+/* MSC does not have INFINITY defined */
+#ifndef INFINITY
+#define INFINITY FLT_MAX
+#endif
+#endif
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_defs.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_defs.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,63 @@
+/*!
+\file gk_defs.h
+\brief This file contains various constants definitions
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_DEFS_H_
+#define _GK_DEFS_H_
+
+
+#define LTERM                   (void **) 0     /* List terminator for GKfree() */
+
+/* mopt_t types */
+#define GK_MOPT_MARK            1
+#define GK_MOPT_CORE            2
+#define GK_MOPT_HEAP            3
+
+#define HTABLE_EMPTY            -1
+#define HTABLE_DELETED          -2
+#define HTABLE_FIRST             1
+#define HTABLE_NEXT              2
+
+/* pdb corruption bit switches */
+#define CRP_ALTLOCS    1
+#define CRP_MISSINGCA  2
+#define CRP_MISSINGBB  4
+#define CRP_MULTICHAIN 8
+#define CRP_MULTICA    16
+#define CRP_MULTIBB    32
+
+#define MAXLINELEN 300000
+
+/* GKlib signals to standard signal mapping */
+#define SIGMEM  SIGABRT
+#define SIGERR  SIGTERM
+
+
+/* CSR-related defines */
+#define GK_CSR_ROW      1
+#define GK_CSR_COL      2
+
+#define GK_CSR_MAXTF    1
+#define GK_CSR_SQRT     2
+#define GK_CSR_POW25    3
+#define GK_CSR_POW65    4
+#define GK_CSR_POW75    5
+#define GK_CSR_POW85    6
+#define GK_CSR_LOG      7
+#define GK_CSR_IDF      8
+#define GK_CSR_IDF2     9
+
+#define GK_CSR_COS      1
+#define GK_CSR_JAC      2
+#define GK_CSR_MIN      3
+
+#define GK_CSR_FMT_CLUTO        1
+#define GK_CSR_FMT_CSR          2
+#define GK_CSR_FMT_METIS        3
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_externs.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_externs.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,25 @@
+/*!
+\file gk_externs.h
+\brief This file contains definitions of external variables created by GKlib
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_EXTERNS_H_
+#define _GK_EXTERNS_H_
+
+
+/*************************************************************************
+* Extern variable definition. Hopefully, the __thread makes them thread-safe.
+**************************************************************************/
+#ifndef _GK_ERROR_C_
+/* declared in error.c */
+extern __thread int gk_cur_jbufs;
+extern __thread jmp_buf gk_jbufs[];
+extern __thread jmp_buf gk_jbuf;
+
+#endif
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_getopt.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_getopt.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,64 @@
+/*!
+\file gk_getopt.h
+\brief This file contains GNU's externs/structs/prototypes
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_GETOPT_H_
+#define _GK_GETOPT_H_
+
+
+/* Externals from getopt.c */
+extern char *gk_optarg;
+extern int gk_optind;
+extern int gk_opterr;
+extern int gk_optopt;
+
+
+/*! \brief The structure that stores the information about the command-line options 
+
+This structure describes a single long option name for the sake of 
+gk_getopt_long(). The argument <tt>long_options</tt> must be an array 
+of these structures, one for each long option. Terminate the array with 
+an element containing all zeros.
+*/
+struct gk_option {
+  char *name;       /*!< This field is the name of the option. */
+  int has_arg;      /*!< This field says whether the option takes an argument. 
+                         It is an integer, and there are three legitimate values: 
+                         no_argument, required_argument and optional_argument. 
+                         */
+  int *flag;        /*!< See the discussion on ::gk_option#val */
+  int val;          /*!< These fields control how to report or act on the option 
+                         when it occurs. 
+                         
+                         If flag is a null pointer, then the val is a value which 
+                         identifies this option. Often these values are chosen 
+                         to uniquely identify particular long options.
+
+                         If flag is not a null pointer, it should be the address 
+                         of an int variable which is the flag for this option. 
+                         The value in val is the value to store in the flag to 
+                         indicate that the option was seen. */
+};
+
+/* Names for the values of the `has_arg' field of `struct gk_option'.  */
+#define no_argument		0
+#define required_argument	1
+#define optional_argument	2
+
+
+/* Function prototypes */
+extern int gk_getopt(int __argc, char **__argv, char *__shortopts);
+extern int gk_getopt_long(int __argc, char **__argv, char *__shortopts,
+              struct gk_option *__longopts, int *__longind);
+extern int gk_getopt_long_only (int __argc, char **__argv,
+              char *__shortopts, struct gk_option *__longopts, int *__longind);
+
+
+
+#endif
+
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_macros.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_macros.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,153 @@
+/*!
+\file gk_macros.h
+\brief This file contains various macros
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_MACROS_H_
+#define _GK_MACROS_H_
+
+/*-------------------------------------------------------------
+ * Usefull commands 
+ *-------------------------------------------------------------*/
+#define gk_max(a, b) ((a) >= (b) ? (a) : (b))
+#define gk_min(a, b) ((a) >= (b) ? (b) : (a))
+#define gk_max3(a, b, c) ((a) >= (b) && (a) >= (c) ? (a) : ((b) >= (a) && (b) >= (c) ? (b) : (c)))
+#define gk_SWAP(a, b, tmp) do {(tmp) = (a); (a) = (b); (b) = (tmp);} while(0) 
+#define INC_DEC(a, b, val) do {(a) += (val); (b) -= (val);} while(0)
+#define sign(a, b) ((a >= 0 ? b : -b))
+
+#define ONEOVERRANDMAX (1.0/(RAND_MAX+1.0))
+#define RandomInRange(u) ((int) (ONEOVERRANDMAX*(u)*rand()))
+
+#define gk_abs(x) ((x) >= 0 ? (x) : -(x))
+
+
+/*-------------------------------------------------------------
+ * Timing macros
+ *-------------------------------------------------------------*/
+#define gk_clearcputimer(tmr) (tmr = 0.0)
+#define gk_startcputimer(tmr) (tmr -= gk_CPUSeconds())
+#define gk_stopcputimer(tmr)  (tmr += gk_CPUSeconds())
+#define gk_getcputimer(tmr)   (tmr)
+
+#define gk_clearwctimer(tmr) (tmr = 0.0)
+#define gk_startwctimer(tmr) (tmr -= gk_WClockSeconds())
+#define gk_stopwctimer(tmr)  (tmr += gk_WClockSeconds())
+#define gk_getwctimer(tmr)   (tmr)
+
+/*-------------------------------------------------------------
+ * dbglvl handling macros
+ *-------------------------------------------------------------*/
+#define IFSET(a, flag, cmd) if ((a)&(flag)) (cmd);
+
+
+/*-------------------------------------------------------------
+ * gracefull library exit macro
+ *-------------------------------------------------------------*/
+#define GKSETJMP() (setjmp(gk_return_to_entry))
+#define gk_sigcatch() (setjmp(gk_jbufs[gk_cur_jbufs]))
+ 
+
+/*-------------------------------------------------------------
+ * Debuging memory leaks
+ *-------------------------------------------------------------*/
+#ifdef DMALLOC
+#   define MALLOC_CHECK(ptr)                                          \
+    if (malloc_verify((ptr)) == DMALLOC_VERIFY_ERROR) {  \
+        printf("***MALLOC_CHECK failed on line %d of file %s: " #ptr "\n", \
+              __LINE__, __FILE__);                               \
+        abort();                                                \
+    }
+#else
+#   define MALLOC_CHECK(ptr) ;
+#endif 
+
+
+/*-------------------------------------------------------------
+ * CSR conversion macros
+ *-------------------------------------------------------------*/
+#define MAKECSR(i, n, a) \
+   do { \
+     for (i=1; i<n; i++) a[i] += a[i-1]; \
+     for (i=n; i>0; i--) a[i] = a[i-1]; \
+     a[0] = 0; \
+   } while(0) 
+
+#define SHIFTCSR(i, n, a) \
+   do { \
+     for (i=n; i>0; i--) a[i] = a[i-1]; \
+     a[0] = 0; \
+   } while(0) 
+
+
+/*-------------------------------------------------------------
+ * ASSERTS that cannot be turned off!
+ *-------------------------------------------------------------*/
+#define GKASSERT(expr)                                          \
+    if (!(expr)) {                                               \
+        printf("***ASSERTION failed on line %d of file %s: " #expr "\n", \
+              __LINE__, __FILE__);                               \
+        abort();                                                \
+    }
+
+#define GKASSERTP(expr,msg)                                          \
+    if (!(expr)) {                                               \
+        printf("***ASSERTION failed on line %d of file %s: " #expr "\n", \
+              __LINE__, __FILE__);                               \
+        printf msg ; \
+        printf("\n"); \
+        abort();                                                \
+    }
+
+#define GKCUASSERT(expr)                                          \
+    if (!(expr)) {                                               \
+        printf("***ASSERTION failed on line %d of file %s: " #expr "\n", \
+              __LINE__, __FILE__);                               \
+    }
+
+#define GKCUASSERTP(expr,msg)                                          \
+    if (!(expr)) {                                               \
+        printf("***ASSERTION failed on line %d of file %s: " #expr "\n", \
+              __LINE__, __FILE__);                               \
+        printf msg ; \
+        printf("\n"); \
+    }
+
+/*-------------------------------------------------------------
+ * Program Assertions
+ *-------------------------------------------------------------*/
+#ifndef NDEBUG
+#   define ASSERT(expr)                                          \
+    if (!(expr)) {                                               \
+        printf("***ASSERTION failed on line %d of file %s: " #expr "\n", \
+              __LINE__, __FILE__);                               \
+        assert(expr);                                                \
+    }
+
+#   define ASSERTP(expr,msg)                                          \
+    if (!(expr)) {                                               \
+        printf("***ASSERTION failed on line %d of file %s: " #expr "\n", \
+              __LINE__, __FILE__);                               \
+        printf msg ; \
+        printf("\n"); \
+        assert(expr);                                                \
+    }
+#else
+#   define ASSERT(expr) ;
+#   define ASSERTP(expr,msg) ;
+#endif 
+
+#ifndef NDEBUG2
+#   define ASSERT2 ASSERT
+#   define ASSERTP2 ASSERTP
+#else
+#   define ASSERT2(expr) ;
+#   define ASSERTP2(expr,msg) ;
+#endif
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_mkblas.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_mkblas.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,201 @@
+/*!
+\file  gk_mkblas.h
+\brief Templates for BLAS-like routines
+
+\date   Started 3/28/07
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_MKBLAS_H_
+#define _GK_MKBLAS_H_
+
+
+#define GK_MKBLAS(PRFX, TYPE, OUTTYPE) \
+/*************************************************************************/\
+/*! The macro for gk_?incset()-class of routines */\
+/*************************************************************************/\
+TYPE *PRFX ## incset(size_t n, TYPE baseval, TYPE *x)\
+{\
+  size_t i;\
+\
+  for (i=0; i<n; i++)\
+    x[i] = baseval+i;\
+\
+  return x;\
+}\
+\
+/*************************************************************************/\
+/*! The macro for gk_?max()-class of routines */\
+/*************************************************************************/\
+TYPE PRFX ## max(size_t n, TYPE *x)\
+{\
+  size_t i, max=0; \
+\
+  if (n <= 0) return (TYPE) 0;\
+\
+  for (i=1; i<n; i++)\
+    max = (x[i] > x[max] ? i : max);\
+\
+  return x[max];\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?min()-class of routines */\
+/*************************************************************************/\
+TYPE PRFX ## min(size_t n, TYPE *x)\
+{\
+  size_t i, min=0;\
+\
+  if (n <= 0) return (TYPE) 0;\
+\
+  for (i=1; i<n; i++)\
+    min = (x[i] < x[min] ? i : min);\
+\
+  return x[min];\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?argmax()-class of routines */\
+/*************************************************************************/\
+size_t PRFX ## argmax(size_t n, TYPE *x)\
+{\
+  size_t i, max=0;\
+\
+  for (i=1; i<n; i++)\
+    max = (x[i] > x[max] ? i : max);\
+\
+  return max;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?argmin()-class of routines */\
+/*************************************************************************/\
+size_t PRFX ## argmin(size_t n, TYPE *x)\
+{\
+  size_t i, min=0;\
+\
+  for (i=1; i<n; i++)\
+    min = (x[i] < x[min] ? i : min);\
+\
+  return min;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?argmax_n()-class of routines */\
+/*************************************************************************/\
+size_t PRFX ## argmax_n(size_t n, TYPE *x, size_t k)\
+{\
+  size_t i, max_n;\
+  PRFX ## kv_t *cand;\
+\
+  cand = PRFX ## kvmalloc(n, "GK_ARGMAX_N: cand");\
+\
+  for (i=0; i<n; i++) {\
+    cand[i].val = i;\
+    cand[i].key = x[i];\
+  }\
+  PRFX ## kvsortd(n, cand);\
+\
+  max_n = cand[k-1].val;\
+\
+  gk_free((void *)&cand, LTERM);\
+\
+  return max_n;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?sum()-class of routines */\
+/**************************************************************************/\
+OUTTYPE PRFX ## sum(size_t n, TYPE *x, size_t incx)\
+{\
+  size_t i;\
+  OUTTYPE sum = 0;\
+\
+  for (i=0; i<n; i++, x+=incx)\
+    sum += (*x);\
+\
+  return sum;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?scale()-class of routines */\
+/**************************************************************************/\
+TYPE *PRFX ## scale(size_t n, TYPE alpha, TYPE *x, size_t incx)\
+{\
+  size_t i;\
+\
+  for (i=0; i<n; i++, x+=incx)\
+    (*x) *= alpha;\
+\
+  return x;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?norm2()-class of routines */\
+/**************************************************************************/\
+OUTTYPE PRFX ## norm2(size_t n, TYPE *x, size_t incx)\
+{\
+  size_t i;\
+  OUTTYPE partial = 0;\
+\
+  for (i=0; i<n; i++, x+=incx)\
+    partial += (*x) * (*x);\
+\
+  return (partial > 0 ? (OUTTYPE)sqrt((double)partial) : (OUTTYPE)0);\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?dot()-class of routines */\
+/**************************************************************************/\
+OUTTYPE PRFX ## dot(size_t n, TYPE *x, size_t incx, TYPE *y, size_t incy)\
+{\
+  size_t i;\
+  OUTTYPE partial = 0.0;\
+ \
+  for (i=0; i<n; i++, x+=incx, y+=incy)\
+    partial += (*x) * (*y);\
+\
+  return partial;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?axpy()-class of routines */\
+/**************************************************************************/\
+TYPE *PRFX ## axpy(size_t n, TYPE alpha, TYPE *x, size_t incx, TYPE *y, size_t incy)\
+{\
+  size_t i;\
+  TYPE *y_in = y;\
+\
+  for (i=0; i<n; i++, x+=incx, y+=incy)\
+    *y += alpha*(*x);\
+\
+  return y_in;\
+}\
+
+
+
+#define GK_MKBLAS_PROTO(PRFX, TYPE, OUTTYPE) \
+  TYPE    *PRFX ## incset(size_t n, TYPE baseval, TYPE *x);\
+  TYPE     PRFX ## max(size_t n, TYPE *x);\
+  TYPE     PRFX ## min(size_t n, TYPE *x);\
+  size_t   PRFX ## argmax(size_t n, TYPE *x);\
+  size_t   PRFX ## argmin(size_t n, TYPE *x);\
+  size_t   PRFX ## argmax_n(size_t n, TYPE *x, size_t k);\
+  OUTTYPE  PRFX ## sum(size_t n, TYPE *x, size_t incx);\
+  TYPE    *PRFX ## scale(size_t n, TYPE alpha, TYPE *x, size_t incx);\
+  OUTTYPE  PRFX ## norm2(size_t n, TYPE *x, size_t incx);\
+  OUTTYPE  PRFX ## dot(size_t n, TYPE *x, size_t incx, TYPE *y, size_t incy);\
+  TYPE    *PRFX ## axpy(size_t n, TYPE alpha, TYPE *x, size_t incx, TYPE *y, size_t incy);\
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_mkmemory.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_mkmemory.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,142 @@
+/*!
+\file  gk_mkmemory.h
+\brief Templates for memory allocation routines
+
+\date   Started 3/29/07
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_MKMEMORY_H_
+#define _GK_MKMEMORY_H_
+
+
+#define GK_MKALLOC(PRFX, TYPE)\
+/*************************************************************************/\
+/*! The macro for gk_?malloc()-class of routines */\
+/**************************************************************************/\
+TYPE *PRFX ## malloc(size_t n, char *msg)\
+{\
+  return (TYPE *)gk_malloc(sizeof(TYPE)*n, msg);\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?realloc()-class of routines */\
+/**************************************************************************/\
+TYPE *PRFX ## realloc(TYPE *ptr, size_t n, char *msg)\
+{\
+  return (TYPE *)gk_realloc((void *)ptr, sizeof(TYPE)*n, msg);\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?smalloc()-class of routines */\
+/**************************************************************************/\
+TYPE *PRFX ## smalloc(size_t n, TYPE ival, char *msg)\
+{\
+  TYPE *ptr;\
+\
+  ptr = (TYPE *)gk_malloc(sizeof(TYPE)*n, msg);\
+  if (ptr == NULL) \
+    return NULL; \
+\
+  return PRFX ## set(n, ival, ptr); \
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?set()-class of routines */\
+/*************************************************************************/\
+TYPE *PRFX ## set(size_t n, TYPE val, TYPE *x)\
+{\
+  size_t i;\
+\
+  for (i=0; i<n; i++)\
+    x[i] = val;\
+\
+  return x;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?set()-class of routines */\
+/*************************************************************************/\
+TYPE *PRFX ## copy(size_t n, TYPE *a, TYPE *b)\
+{\
+  return (TYPE *)memmove((void *)b, (void *)a, sizeof(TYPE)*n);\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?AllocMatrix()-class of routines */\
+/**************************************************************************/\
+TYPE **PRFX ## AllocMatrix(size_t ndim1, size_t ndim2, TYPE value, char *errmsg)\
+{\
+  gk_idx_t i, j;\
+  TYPE **matrix;\
+\
+  matrix = (TYPE **)gk_malloc(ndim1*sizeof(TYPE *), errmsg);\
+  if (matrix == NULL) \
+    return NULL;\
+\
+  for (i=0; i<ndim1; i++) { \
+    matrix[i] = PRFX ## smalloc(ndim2, value, errmsg);\
+    if (matrix[i] == NULL) { \
+      for (j=0; j<i; j++) \
+        gk_free((void **)&matrix[j], LTERM); \
+      return NULL; \
+    } \
+  }\
+\
+  return matrix;\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?AllocMatrix()-class of routines */\
+/**************************************************************************/\
+void PRFX ## FreeMatrix(TYPE ***r_matrix, size_t ndim1, size_t ndim2)\
+{\
+  gk_idx_t i;\
+  TYPE **matrix;\
+\
+  if (*r_matrix == NULL) \
+    return; \
+\
+  matrix = *r_matrix;\
+\
+  for (i=0; i<ndim1; i++) \
+    gk_free((void **)&(matrix[i]), LTERM);\
+\
+  gk_free((void **)r_matrix, LTERM);\
+}\
+\
+\
+/*************************************************************************/\
+/*! The macro for gk_?SetMatrix()-class of routines */\
+/**************************************************************************/\
+void PRFX ## SetMatrix(TYPE **matrix, size_t ndim1, size_t ndim2, TYPE value)\
+{\
+  gk_idx_t i, j;\
+\
+  for (i=0; i<ndim1; i++) {\
+    for (j=0; j<ndim2; j++)\
+      matrix[i][j] = value;\
+  }\
+}\
+
+
+#define GK_MKALLOC_PROTO(PRFX, TYPE)\
+  TYPE  *PRFX ## malloc(size_t n, char *msg);\
+  TYPE  *PRFX ## realloc(TYPE *ptr, size_t n, char *msg);\
+  TYPE  *PRFX ## smalloc(size_t n, TYPE ival, char *msg);\
+  TYPE  *PRFX ## set(size_t n, TYPE val, TYPE *x);\
+  TYPE  *PRFX ## copy(size_t n, TYPE *a, TYPE *b);\
+  TYPE **PRFX ## AllocMatrix(size_t ndim1, size_t ndim2, TYPE value, char *errmsg);\
+  void   PRFX ## FreeMatrix(TYPE ***r_matrix, size_t ndim1, size_t ndim2);\
+  void   PRFX ## SetMatrix(TYPE **matrix, size_t ndim1, size_t ndim2, TYPE value);\
+
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_mkpqueue.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_mkpqueue.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,435 @@
+/*!
+\file  gk_mkpqueue.h
+\brief Templates for priority queues
+
+\date   Started 4/09/07
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+
+#ifndef _GK_MKPQUEUE_H
+#define _GK_MKPQUEUE_H
+
+
+#define GK_MKPQUEUE(FPRFX, PQT, KVT, KT, VT, KVMALLOC, KMAX, KEY_LT)\
+/*************************************************************************/\
+/*! This function creates and initializes a priority queue */\
+/**************************************************************************/\
+PQT *FPRFX ## Create(size_t maxnodes)\
+{\
+  PQT *queue; \
+\
+  queue = (PQT *)gk_malloc(sizeof(PQT), "gk_pqCreate: queue");\
+  FPRFX ## Init(queue, maxnodes);\
+\
+  return queue;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function initializes the data structures of the priority queue */\
+/**************************************************************************/\
+void FPRFX ## Init(PQT *queue, size_t maxnodes)\
+{\
+  queue->nnodes = 0;\
+  queue->maxnodes = maxnodes;\
+\
+  queue->heap    = KVMALLOC(maxnodes, "gk_PQInit: heap");\
+  queue->locator = gk_idxsmalloc(maxnodes, -1, "gk_PQInit: locator");\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function resets the priority queue */\
+/**************************************************************************/\
+void FPRFX ## Reset(PQT *queue)\
+{\
+  gk_idx_t i;\
+  gk_idx_t *locator=queue->locator;\
+  KVT *heap=queue->heap;\
+\
+  for (i=queue->nnodes-1; i>=0; i--)\
+    locator[heap[i].val] = -1;\
+  queue->nnodes = 0;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function frees the internal datastructures of the priority queue */\
+/**************************************************************************/\
+void FPRFX ## Free(PQT *queue)\
+{\
+  gk_free((void **)&queue->heap, &queue->locator, LTERM);\
+  queue->maxnodes = 0;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function frees the internal datastructures of the priority queue \
+    and the queue itself */\
+/**************************************************************************/\
+void FPRFX ## Destroy(PQT *queue)\
+{\
+  FPRFX ## Free(queue);\
+  gk_free((void **)&queue, LTERM);\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function returns the length of the queue */\
+/**************************************************************************/\
+size_t FPRFX ## Length(PQT *queue)\
+{\
+  return queue->nnodes;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function adds an item in the priority queue */\
+/**************************************************************************/\
+int FPRFX ## Insert(PQT *queue, VT node, KT key)\
+{\
+  gk_idx_t i, j;\
+  gk_idx_t *locator=queue->locator;\
+  KVT *heap=queue->heap;\
+\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+\
+  ASSERT(locator[node] == -1);\
+\
+  i = queue->nnodes++;\
+  while (i > 0) {\
+    j = (i-1)>>1;\
+    if (KEY_LT(key, heap[j].key)) {\
+      heap[i] = heap[j];\
+      locator[heap[i].val] = i;\
+      i = j;\
+    }\
+    else\
+      break;\
+  }\
+  ASSERT(i >= 0);\
+  heap[i].key   = key;\
+  heap[i].val   = node;\
+  locator[node] = i;\
+\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+\
+  return 0;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function deletes an item from the priority queue */\
+/**************************************************************************/\
+int FPRFX ## Delete(PQT *queue, VT node)\
+{\
+  gk_idx_t i, j, nnodes;\
+  KT newkey, oldkey;\
+  gk_idx_t *locator=queue->locator;\
+  KVT *heap=queue->heap;\
+\
+  ASSERT(locator[node] != -1);\
+  ASSERT(heap[locator[node]].val == node);\
+\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+\
+  i = locator[node];\
+  locator[node] = -1;\
+\
+  if (--queue->nnodes > 0 && heap[queue->nnodes].val != node) {\
+    node   = heap[queue->nnodes].val;\
+    newkey = heap[queue->nnodes].key;\
+    oldkey = heap[i].key;\
+\
+    if (KEY_LT(newkey, oldkey)) { /* Filter-up */\
+      while (i > 0) {\
+        j = (i-1)>>1;\
+        if (KEY_LT(newkey, heap[j].key)) {\
+          heap[i] = heap[j];\
+          locator[heap[i].val] = i;\
+          i = j;\
+        }\
+        else\
+          break;\
+      }\
+    }\
+    else { /* Filter down */\
+      nnodes = queue->nnodes;\
+      while ((j=(i<<1)+1) < nnodes) {\
+        if (KEY_LT(heap[j].key, newkey)) {\
+          if (j+1 < nnodes && KEY_LT(heap[j+1].key, heap[j].key))\
+            j++;\
+          heap[i] = heap[j];\
+          locator[heap[i].val] = i;\
+          i = j;\
+        }\
+        else if (j+1 < nnodes && KEY_LT(heap[j+1].key, newkey)) {\
+          j++;\
+          heap[i] = heap[j];\
+          locator[heap[i].val] = i;\
+          i = j;\
+        }\
+        else\
+          break;\
+      }\
+    }\
+\
+    heap[i].key   = newkey;\
+    heap[i].val   = node;\
+    locator[node] = i;\
+  }\
+\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+\
+  return 0;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function updates the key values associated for a particular item */ \
+/**************************************************************************/\
+void FPRFX ## Update(PQT *queue, VT node, KT newkey)\
+{\
+  gk_idx_t i, j, nnodes;\
+  KT oldkey;\
+  gk_idx_t *locator=queue->locator;\
+  KVT *heap=queue->heap;\
+\
+  oldkey = heap[locator[node]].key;\
+\
+  ASSERT(locator[node] != -1);\
+  ASSERT(heap[locator[node]].val == node);\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+\
+  i = locator[node];\
+\
+  if (KEY_LT(newkey, oldkey)) { /* Filter-up */\
+    while (i > 0) {\
+      j = (i-1)>>1;\
+      if (KEY_LT(newkey, heap[j].key)) {\
+        heap[i] = heap[j];\
+        locator[heap[i].val] = i;\
+        i = j;\
+      }\
+      else\
+        break;\
+    }\
+  }\
+  else { /* Filter down */\
+    nnodes = queue->nnodes;\
+    while ((j=(i<<1)+1) < nnodes) {\
+      if (KEY_LT(heap[j].key, newkey)) {\
+        if (j+1 < nnodes && KEY_LT(heap[j+1].key, heap[j].key))\
+          j++;\
+        heap[i] = heap[j];\
+        locator[heap[i].val] = i;\
+        i = j;\
+      }\
+      else if (j+1 < nnodes && KEY_LT(heap[j+1].key, newkey)) {\
+        j++;\
+        heap[i] = heap[j];\
+        locator[heap[i].val] = i;\
+        i = j;\
+      }\
+      else\
+        break;\
+    }\
+  }\
+\
+  heap[i].key   = newkey;\
+  heap[i].val   = node;\
+  locator[node] = i;\
+\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+\
+  return;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function returns the item at the top of the queue and removes\
+    it from the priority queue */\
+/**************************************************************************/\
+VT FPRFX ## GetTop(PQT *queue)\
+{\
+  gk_idx_t i, j;\
+  gk_idx_t *locator;\
+  KVT *heap;\
+  VT vtx, node;\
+  KT key;\
+\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+\
+  if (queue->nnodes == 0)\
+    return -1;\
+\
+  queue->nnodes--;\
+\
+  heap    = queue->heap;\
+  locator = queue->locator;\
+\
+  vtx = heap[0].val;\
+  locator[vtx] = -1;\
+\
+  if ((i = queue->nnodes) > 0) {\
+    key  = heap[i].key;\
+    node = heap[i].val;\
+    i = 0;\
+    while ((j=2*i+1) < queue->nnodes) {\
+      if (KEY_LT(heap[j].key, key)) {\
+        if (j+1 < queue->nnodes && KEY_LT(heap[j+1].key, heap[j].key))\
+          j = j+1;\
+        heap[i] = heap[j];\
+        locator[heap[i].val] = i;\
+        i = j;\
+      }\
+      else if (j+1 < queue->nnodes && KEY_LT(heap[j+1].key, key)) {\
+        j = j+1;\
+        heap[i] = heap[j];\
+        locator[heap[i].val] = i;\
+        i = j;\
+      }\
+      else\
+        break;\
+    }\
+\
+    heap[i].key   = key;\
+    heap[i].val   = node;\
+    locator[node] = i;\
+  }\
+\
+  ASSERT2(FPRFX ## CheckHeap(queue));\
+  return vtx;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function returns the item at the top of the queue. The item is not\
+    deleted from the queue. */\
+/**************************************************************************/\
+VT FPRFX ## SeeTopVal(PQT *queue)\
+{\
+  return (queue->nnodes == 0 ? -1 : queue->heap[0].val);\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function returns the key of the top item. The item is not\
+    deleted from the queue. */\
+/**************************************************************************/\
+KT FPRFX ## SeeTopKey(PQT *queue)\
+{\
+  return (queue->nnodes == 0 ? KMAX : queue->heap[0].key);\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function returns the key of a specific item */\
+/**************************************************************************/\
+KT FPRFX ## SeeKey(PQT *queue, VT node)\
+{\
+  gk_idx_t *locator;\
+  KVT *heap;\
+\
+  heap    = queue->heap;\
+  locator = queue->locator;\
+\
+  return heap[locator[node]].key;\
+}\
+\
+\
+/*************************************************************************/\
+/*! This function returns the first item in a breadth-first traversal of\
+    the heap whose key is less than maxwgt. This function is here due to\
+    hMETIS and is not general!*/\
+/**************************************************************************/\
+/*\
+VT FPRFX ## SeeConstraintTop(PQT *queue, KT maxwgt, KT *wgts)\
+{\
+  gk_idx_t i;\
+\
+  if (queue->nnodes == 0)\
+    return -1;\
+\
+  if (maxwgt <= 1000)\
+    return FPRFX ## SeeTopVal(queue);\
+\
+  for (i=0; i<queue->nnodes; i++) {\
+    if (queue->heap[i].key > 0) {\
+      if (wgts[queue->heap[i].val] <= maxwgt)\
+        return queue->heap[i].val;\
+    }\
+    else {\
+      if (queue->heap[i/2].key <= 0)\
+        break;\
+    }\
+  }\
+\
+  return queue->heap[0].val;\
+\
+}\
+*/\
+\
+\
+/*************************************************************************/\
+/*! This functions checks the consistency of the heap */\
+/**************************************************************************/\
+int FPRFX ## CheckHeap(PQT *queue)\
+{\
+  gk_idx_t i, j;\
+  size_t nnodes;\
+  gk_idx_t *locator;\
+  KVT *heap;\
+\
+  heap    = queue->heap;\
+  locator = queue->locator;\
+  nnodes  = queue->nnodes;\
+\
+  if (nnodes == 0)\
+    return 1;\
+\
+  ASSERT(locator[heap[0].val] == 0);\
+  for (i=1; i<nnodes; i++) {\
+    ASSERT(locator[heap[i].val] == i);\
+    ASSERT(!KEY_LT(heap[i].key, heap[(i-1)/2].key));\
+  }\
+  for (i=1; i<nnodes; i++)\
+    ASSERT(!KEY_LT(heap[i].key, heap[0].key));\
+\
+  for (j=i=0; i<queue->maxnodes; i++) {\
+    if (locator[i] != -1)\
+      j++;\
+  }\
+  ASSERTP(j == nnodes, ("%jd %jd\n", (intmax_t)j, (intmax_t)nnodes));\
+\
+  return 1;\
+}\
+
+
+#define GK_MKPQUEUE_PROTO(FPRFX, PQT, KT, VT)\
+  PQT *  FPRFX ## Create(size_t maxnodes);\
+  void   FPRFX ## Init(PQT *queue, size_t maxnodes);\
+  void   FPRFX ## Reset(PQT *queue);\
+  void   FPRFX ## Free(PQT *queue);\
+  void   FPRFX ## Destroy(PQT *queue);\
+  size_t FPRFX ## Length(PQT *queue);\
+  int    FPRFX ## Insert(PQT *queue, VT node, KT key);\
+  int    FPRFX ## Delete(PQT *queue, VT node);\
+  void   FPRFX ## Update(PQT *queue, VT node, KT newkey);\
+  VT     FPRFX ## GetTop(PQT *queue);\
+  VT     FPRFX ## SeeTopVal(PQT *queue);\
+  KT     FPRFX ## SeeTopKey(PQT *queue);\
+  KT     FPRFX ## SeeKey(PQT *queue, VT node);\
+  VT     FPRFX ## SeeConstraintTop(PQT *queue, KT maxwgt, KT *wgts);\
+  int    FPRFX ## CheckHeap(PQT *queue);\
+
+
+/* This is how these macros are used
+GK_MKPQUEUE(gk_dkvPQ, gk_dkvPQ_t, double, gk_idx_t, gk_dkvmalloc, DBL_MAX)
+GK_MKPQUEUE_PROTO(gk_dkvPQ, gk_dkvPQ_t, double, gk_idx_t)
+*/
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_mkrandom.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_mkrandom.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,123 @@
+/*!
+\file  
+\brief Templates for portable random number generation
+
+\date   Started 5/17/07
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+
+#ifndef _GK_MKRANDOM_H
+#define _GK_MKRANDOM_H
+
+/*************************************************************************/\
+/*! The generator for the rand() related routines.  \
+   \params RNGT  the datatype that defines the range of values over which\
+                 random numbers will be generated\
+   \params VALT  the datatype that defines the contents of the array to \
+                 be permuted by randArrayPermute() \
+   \params FPRFX the function prefix \
+*/\
+/**************************************************************************/\
+#define GK_MKRANDOM(FPRFX, RNGT, VALT)\
+/*************************************************************************/\
+/*! Initializes the generator */ \
+/**************************************************************************/\
+void FPRFX ## srand(RNGT seed) \
+{\
+  gk_randinit((uint64_t) seed);\
+}\
+\
+\
+/*************************************************************************/\
+/*! Returns a random number */ \
+/**************************************************************************/\
+RNGT FPRFX ## rand() \
+{\
+  if (sizeof(RNGT) <= sizeof(int32_t)) \
+    return (RNGT)gk_randint32(); \
+  else \
+    return (RNGT)gk_randint64(); \
+}\
+\
+\
+/*************************************************************************/\
+/*! Returns a random number between [0, max) */ \
+/**************************************************************************/\
+RNGT FPRFX ## randInRange(RNGT max) \
+{\
+  return (RNGT)((FPRFX ## rand())%max); \
+}\
+\
+\
+/*************************************************************************/\
+/*! Randomly permutes the elements of an array p[]. \
+    flag == 1, p[i] = i prior to permutation, \
+    flag == 0, p[] is not initialized. */\
+/**************************************************************************/\
+void FPRFX ## randArrayPermute(RNGT n, VALT *p, RNGT nshuffles, int flag)\
+{\
+  RNGT i, u, v;\
+  VALT tmp;\
+\
+  if (flag == 1) {\
+    for (i=0; i<n; i++)\
+      p[i] = (VALT)i;\
+  }\
+\
+  if (n < 10) {\
+    for (i=0; i<n; i++) {\
+      v = FPRFX ## randInRange(n);\
+      u = FPRFX ## randInRange(n);\
+      gk_SWAP(p[v], p[u], tmp);\
+    }\
+  }\
+  else {\
+    for (i=0; i<nshuffles; i++) {\
+      v = FPRFX ## randInRange(n-3);\
+      u = FPRFX ## randInRange(n-3);\
+      /*gk_SWAP(p[v+0], p[u+0], tmp);*/\
+      /*gk_SWAP(p[v+1], p[u+1], tmp);*/\
+      /*gk_SWAP(p[v+2], p[u+2], tmp);*/\
+      /*gk_SWAP(p[v+3], p[u+3], tmp);*/\
+      gk_SWAP(p[v+0], p[u+2], tmp);\
+      gk_SWAP(p[v+1], p[u+3], tmp);\
+      gk_SWAP(p[v+2], p[u+0], tmp);\
+      gk_SWAP(p[v+3], p[u+1], tmp);\
+    }\
+  }\
+}\
+\
+\
+/*************************************************************************/\
+/*! Randomly permutes the elements of an array p[]. \
+    flag == 1, p[i] = i prior to permutation, \
+    flag == 0, p[] is not initialized. */\
+/**************************************************************************/\
+void FPRFX ## randArrayPermuteFine(RNGT n, VALT *p, int flag)\
+{\
+  RNGT i, v;\
+  VALT tmp;\
+\
+  if (flag == 1) {\
+    for (i=0; i<n; i++)\
+      p[i] = (VALT)i;\
+  }\
+\
+  for (i=0; i<n; i++) {\
+    v = FPRFX ## randInRange(n);\
+    gk_SWAP(p[i], p[v], tmp);\
+  }\
+}\
+
+
+#define GK_MKRANDOM_PROTO(FPRFX, RNGT, VALT)\
+  void FPRFX ## srand(RNGT seed); \
+  RNGT FPRFX ## rand(); \
+  RNGT FPRFX ## randInRange(RNGT max); \
+  void FPRFX ## randArrayPermute(RNGT n, VALT *p, RNGT nshuffles, int flag);\
+  void FPRFX ## randArrayPermuteFine(RNGT n, VALT *p, int flag);\
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_mksort.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_mksort.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,273 @@
+/*!
+\file  gk_mksort.h
+\brief Templates for the qsort routine
+
+\date   Started 3/28/07
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+
+#ifndef _GK_MKSORT_H_
+#define _GK_MKSORT_H_
+
+/* $Id$
+ * Adopted from GNU glibc by Mjt.
+ * See stdlib/qsort.c in glibc */
+
+/* Copyright (C) 1991, 1992, 1996, 1997, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by Douglas C. Schmidt (schmidt@ics.uci.edu).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* in-line qsort implementation.  Differs from traditional qsort() routine
+ * in that it is a macro, not a function, and instead of passing an address
+ * of a comparision routine to the function, it is possible to inline
+ * comparision routine, thus speed up sorting alot.
+ *
+ * Usage:
+ *  #include "iqsort.h"
+ *  #define islt(a,b) (strcmp((*a),(*b))<0)
+ *  char *arr[];
+ *  int n;
+ *  GKQSORT(char*, arr, n, islt);
+ *
+ * The "prototype" and 4 arguments are:
+ *  GKQSORT(TYPE,BASE,NELT,ISLT)
+ *  1) type of each element, TYPE,
+ *  2) address of the beginning of the array, of type TYPE*,
+ *  3) number of elements in the array, and
+ *  4) comparision routine.
+ * Array pointer and number of elements are referenced only once.
+ * This is similar to a call
+ *  qsort(BASE,NELT,sizeof(TYPE),ISLT)
+ * with the difference in last parameter.
+ * Note the islt macro/routine (it receives pointers to two elements):
+ * the only condition of interest is whenever one element is less than
+ * another, no other conditions (greather than, equal to etc) are tested.
+ * So, for example, to define integer sort, use:
+ *  #define islt(a,b) ((*a)<(*b))
+ *  GKQSORT(int, arr, n, islt)
+ *
+ * The macro could be used to implement a sorting function (see examples
+ * below), or to implement the sorting algorithm inline.  That is, either
+ * create a sorting function and use it whenever you want to sort something,
+ * or use GKQSORT() macro directly instead a call to such routine.  Note that
+ * the macro expands to quite some code (compiled size of int qsort on x86
+ * is about 700..800 bytes).
+ *
+ * Using this macro directly it isn't possible to implement traditional
+ * qsort() routine, because the macro assumes sizeof(element) == sizeof(TYPE),
+ * while qsort() allows element size to be different.
+ *
+ * Several ready-to-use examples:
+ *
+ * Sorting array of integers:
+ * void int_qsort(int *arr, unsigned n) {
+ * #define int_lt(a,b) ((*a)<(*b))
+ *   GKQSORT(int, arr, n, int_lt);
+ * }
+ *
+ * Sorting array of string pointers:
+ * void str_qsort(char *arr[], unsigned n) {
+ * #define str_lt(a,b) (strcmp((*a),(*b)) < 0)
+ *   GKQSORT(char*, arr, n, str_lt);
+ * }
+ *
+ * Sorting array of structures:
+ *
+ * struct elt {
+ *   int key;
+ *   ...
+ * };
+ * void elt_qsort(struct elt *arr, unsigned n) {
+ * #define elt_lt(a,b) ((a)->key < (b)->key)
+ *  GKQSORT(struct elt, arr, n, elt_lt);
+ * }
+ *
+ * And so on.
+ */
+
+/* Swap two items pointed to by A and B using temporary buffer t. */
+#define _GKQSORT_SWAP(a, b, t) ((void)((t = *a), (*a = *b), (*b = t)))
+
+/* Discontinue quicksort algorithm when partition gets below this size.
+   This particular magic number was chosen to work best on a Sun 4/260. */
+#define _GKQSORT_MAX_THRESH 4
+
+/* The next 4 #defines implement a very fast in-line stack abstraction. */
+#define _GKQSORT_STACK_SIZE	    (8 * sizeof(size_t))
+#define _GKQSORT_PUSH(top, low, high) (((top->_lo = (low)), (top->_hi = (high)), ++top))
+#define	_GKQSORT_POP(low, high, top)  ((--top, (low = top->_lo), (high = top->_hi)))
+#define	_GKQSORT_STACK_NOT_EMPTY	    (_stack < _top)
+
+
+/* The main code starts here... */
+#define GK_MKQSORT(GKQSORT_TYPE,GKQSORT_BASE,GKQSORT_NELT,GKQSORT_LT)   \
+{									\
+  GKQSORT_TYPE *const _base = (GKQSORT_BASE);				\
+  const size_t _elems = (GKQSORT_NELT);					\
+  GKQSORT_TYPE _hold;							\
+									\
+  if (_elems == 0)                                                      \
+    return;                                                             \
+                                                                        \
+  /* Don't declare two variables of type GKQSORT_TYPE in a single	\
+   * statement: eg `TYPE a, b;', in case if TYPE is a pointer,		\
+   * expands to `type* a, b;' wich isn't what we want.			\
+   */									\
+									\
+  if (_elems > _GKQSORT_MAX_THRESH) {					\
+    GKQSORT_TYPE *_lo = _base;						\
+    GKQSORT_TYPE *_hi = _lo + _elems - 1;				\
+    struct {								\
+      GKQSORT_TYPE *_hi; GKQSORT_TYPE *_lo;				\
+    } _stack[_GKQSORT_STACK_SIZE], *_top = _stack + 1;			\
+									\
+    while (_GKQSORT_STACK_NOT_EMPTY) {					\
+      GKQSORT_TYPE *_left_ptr; GKQSORT_TYPE *_right_ptr;		\
+									\
+      /* Select median value from among LO, MID, and HI. Rearrange	\
+         LO and HI so the three values are sorted. This lowers the	\
+         probability of picking a pathological pivot value and		\
+         skips a comparison for both the LEFT_PTR and RIGHT_PTR in	\
+         the while loops. */						\
+									\
+      GKQSORT_TYPE *_mid = _lo + ((_hi - _lo) >> 1);			\
+									\
+      if (GKQSORT_LT (_mid, _lo))					\
+        _GKQSORT_SWAP (_mid, _lo, _hold);				\
+      if (GKQSORT_LT (_hi, _mid))					\
+        _GKQSORT_SWAP (_mid, _hi, _hold);				\
+      else								\
+        goto _jump_over;						\
+      if (GKQSORT_LT (_mid, _lo))					\
+        _GKQSORT_SWAP (_mid, _lo, _hold);				\
+  _jump_over:;								\
+									\
+      _left_ptr  = _lo + 1;						\
+      _right_ptr = _hi - 1;						\
+									\
+      /* Here's the famous ``collapse the walls'' section of quicksort.	\
+         Gotta like those tight inner loops!  They are the main reason	\
+         that this algorithm runs much faster than others. */		\
+      do {								\
+        while (GKQSORT_LT (_left_ptr, _mid))				\
+         ++_left_ptr;							\
+									\
+        while (GKQSORT_LT (_mid, _right_ptr))				\
+          --_right_ptr;							\
+									\
+        if (_left_ptr < _right_ptr) {					\
+          _GKQSORT_SWAP (_left_ptr, _right_ptr, _hold);			\
+          if (_mid == _left_ptr)					\
+            _mid = _right_ptr;						\
+          else if (_mid == _right_ptr)					\
+            _mid = _left_ptr;						\
+          ++_left_ptr;							\
+          --_right_ptr;							\
+        }								\
+        else if (_left_ptr == _right_ptr) {				\
+          ++_left_ptr;							\
+          --_right_ptr;							\
+          break;							\
+        }								\
+      } while (_left_ptr <= _right_ptr);				\
+									\
+     /* Set up pointers for next iteration.  First determine whether	\
+        left and right partitions are below the threshold size.  If so,	\
+        ignore one or both.  Otherwise, push the larger partition's	\
+        bounds on the stack and continue sorting the smaller one. */	\
+									\
+      if (_right_ptr - _lo <= _GKQSORT_MAX_THRESH) {			\
+        if (_hi - _left_ptr <= _GKQSORT_MAX_THRESH)			\
+          /* Ignore both small partitions. */				\
+          _GKQSORT_POP (_lo, _hi, _top);				\
+        else								\
+          /* Ignore small left partition. */				\
+          _lo = _left_ptr;						\
+      }									\
+      else if (_hi - _left_ptr <= _GKQSORT_MAX_THRESH)			\
+        /* Ignore small right partition. */				\
+        _hi = _right_ptr;						\
+      else if (_right_ptr - _lo > _hi - _left_ptr) {			\
+        /* Push larger left partition indices. */			\
+        _GKQSORT_PUSH (_top, _lo, _right_ptr);				\
+        _lo = _left_ptr;						\
+      }									\
+      else {								\
+        /* Push larger right partition indices. */			\
+        _GKQSORT_PUSH (_top, _left_ptr, _hi);				\
+        _hi = _right_ptr;						\
+      }									\
+    }									\
+  }									\
+									\
+  /* Once the BASE array is partially sorted by quicksort the rest	\
+     is completely sorted using insertion sort, since this is efficient	\
+     for partitions below MAX_THRESH size. BASE points to the		\
+     beginning of the array to sort, and END_PTR points at the very	\
+     last element in the array (*not* one beyond it!). */		\
+									\
+  {									\
+    GKQSORT_TYPE *const _end_ptr = _base + _elems - 1;			\
+    GKQSORT_TYPE *_tmp_ptr = _base;					\
+    register GKQSORT_TYPE *_run_ptr;					\
+    GKQSORT_TYPE *_thresh;						\
+									\
+    _thresh = _base + _GKQSORT_MAX_THRESH;				\
+    if (_thresh > _end_ptr)						\
+      _thresh = _end_ptr;						\
+									\
+    /* Find smallest element in first threshold and place it at the	\
+       array's beginning.  This is the smallest array element,		\
+       and the operation speeds up insertion sort's inner loop. */	\
+									\
+    for (_run_ptr = _tmp_ptr + 1; _run_ptr <= _thresh; ++_run_ptr)	\
+      if (GKQSORT_LT (_run_ptr, _tmp_ptr))				\
+        _tmp_ptr = _run_ptr;						\
+									\
+    if (_tmp_ptr != _base)						\
+      _GKQSORT_SWAP (_tmp_ptr, _base, _hold);				\
+									\
+    /* Insertion sort, running from left-hand-side			\
+     * up to right-hand-side.  */					\
+									\
+    _run_ptr = _base + 1;						\
+    while (++_run_ptr <= _end_ptr) {					\
+      _tmp_ptr = _run_ptr - 1;						\
+      while (GKQSORT_LT (_run_ptr, _tmp_ptr))				\
+        --_tmp_ptr;							\
+									\
+      ++_tmp_ptr;							\
+      if (_tmp_ptr != _run_ptr) {					\
+        GKQSORT_TYPE *_trav = _run_ptr + 1;				\
+        while (--_trav >= _run_ptr) {					\
+          GKQSORT_TYPE *_hi; GKQSORT_TYPE *_lo;				\
+          _hold = *_trav;						\
+									\
+          for (_hi = _lo = _trav; --_lo >= _tmp_ptr; _hi = _lo)		\
+            *_hi = *_lo;						\
+          *_hi = _hold;							\
+        }								\
+      }									\
+    }									\
+  }									\
+									\
+}
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_mkutils.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_mkutils.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,40 @@
+/*!
+\file  
+\brief Templates for various utility routines
+
+\date   Started 5/28/07
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_MKUTILS_H_
+#define _GK_MKUTILS_H_
+
+
+#define GK_MKARRAY2CSR(PRFX, TYPE)\
+/*************************************************************************/\
+/*! The macro for gk_?array2csr() routine */\
+/**************************************************************************/\
+void PRFX ## array2csr(TYPE n, TYPE range, TYPE *array, TYPE *ptr, TYPE *ind)\
+{\
+  TYPE i;\
+\
+  for (i=0; i<=range; i++)\
+    ptr[i] = 0;\
+\
+  for (i=0; i<n; i++)\
+    ptr[array[i]]++;\
+\
+  /* Compute the ptr, ind structure */\
+  MAKECSR(i, range, ptr);\
+  for (i=0; i<n; i++)\
+    ind[ptr[array[i]]++] = i;\
+  SHIFTCSR(i, range, ptr);\
+}
+
+
+#define GK_MKARRAY2CSR_PROTO(PRFX, TYPE)\
+  void PRFX ## array2csr(TYPE n, TYPE range, TYPE *array, TYPE *ptr, TYPE *ind);\
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_proto.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_proto.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,352 @@
+/*!
+\file gk_proto.h
+\brief This file contains function prototypes
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_PROTO_H_
+#define _GK_PROTO_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*-------------------------------------------------------------
+ * blas.c 
+ *-------------------------------------------------------------*/
+GK_MKBLAS_PROTO(gk_c,   char,     intmax_t)
+GK_MKBLAS_PROTO(gk_i,   int,      intmax_t)
+GK_MKBLAS_PROTO(gk_i32, int32_t,  intmax_t)
+GK_MKBLAS_PROTO(gk_i64, int64_t,  intmax_t)
+GK_MKBLAS_PROTO(gk_z,   ssize_t,  ssize_t)
+GK_MKBLAS_PROTO(gk_f,   float,    float)
+GK_MKBLAS_PROTO(gk_d,   double,   double)
+GK_MKBLAS_PROTO(gk_idx, gk_idx_t, intmax_t)
+
+
+
+
+/*-------------------------------------------------------------
+ * io.c
+ *-------------------------------------------------------------*/
+FILE *gk_fopen(char *, char *, const char *);
+void gk_fclose(FILE *);
+gk_idx_t gk_getline(char **lineptr, size_t *n, FILE *stream);
+char **gk_readfile(char *fname, gk_idx_t *r_nlines);
+int32_t *gk_i32readfile(char *fname, gk_idx_t *r_nlines);
+int64_t *gk_i64readfile(char *fname, gk_idx_t *r_nlines);
+
+
+
+
+/*-------------------------------------------------------------
+ * fs.c
+ *-------------------------------------------------------------*/
+int gk_fexists(char *);
+int gk_dexists(char *);
+intmax_t gk_getfsize(char *);
+void gk_getfilestats(char *fname, size_t *r_nlines, size_t *r_ntokens, 
+          size_t *r_max_nlntokens, size_t *r_nbytes);
+char *gk_getbasename(char *path);
+char *gk_getextname(char *path);
+char *gk_getfilename(char *path);
+char *gk_getpathname(char *path);
+int gk_mkpath(char *);
+int gk_rmpath(char *);
+
+
+
+/*-------------------------------------------------------------
+ * memory.c
+ *-------------------------------------------------------------*/
+GK_MKALLOC_PROTO(gk_c,   char)
+GK_MKALLOC_PROTO(gk_i,   int)
+GK_MKALLOC_PROTO(gk_i32, int32_t)
+GK_MKALLOC_PROTO(gk_i64, int64_t)
+GK_MKALLOC_PROTO(gk_z,   ssize_t)
+GK_MKALLOC_PROTO(gk_f,   float)
+GK_MKALLOC_PROTO(gk_d,   double)
+GK_MKALLOC_PROTO(gk_idx, gk_idx_t)
+
+GK_MKALLOC_PROTO(gk_ckv,   gk_ckv_t)
+GK_MKALLOC_PROTO(gk_ikv,   gk_ikv_t)
+GK_MKALLOC_PROTO(gk_i32kv, gk_i32kv_t)
+GK_MKALLOC_PROTO(gk_i64kv, gk_i64kv_t)
+GK_MKALLOC_PROTO(gk_zkv,   gk_zkv_t)
+GK_MKALLOC_PROTO(gk_fkv,   gk_fkv_t)
+GK_MKALLOC_PROTO(gk_dkv,   gk_dkv_t)
+GK_MKALLOC_PROTO(gk_skv,   gk_skv_t)
+GK_MKALLOC_PROTO(gk_idxkv, gk_idxkv_t)
+
+void   gk_AllocMatrix(void ***, size_t, size_t , size_t);
+void   gk_FreeMatrix(void ***, size_t, size_t);
+int    gk_malloc_init();
+void   gk_malloc_cleanup(int showstats);
+void  *gk_malloc(size_t nbytes, char *msg);
+void  *gk_realloc(void *oldptr, size_t nbytes, char *msg);
+void   gk_free(void **ptr1,...);
+size_t gk_GetCurMemoryUsed();
+size_t gk_GetMaxMemoryUsed();
+
+
+
+/*-------------------------------------------------------------
+ * seq.c
+ *-------------------------------------------------------------*/
+gk_seq_t *gk_seq_ReadGKMODPSSM(char *file_name);
+gk_i2cc2i_t *gk_i2cc2i_create_common(char *alphabet);
+void gk_seq_init(gk_seq_t *seq);
+
+
+
+
+/*-------------------------------------------------------------
+ * pdb.c
+ *-------------------------------------------------------------*/
+char gk_threetoone(char *res);
+void gk_freepdbf(pdbf *p);
+pdbf *gk_readpdbfile(char *fname);
+void gk_writefullatom(pdbf *p, char *fname);
+void gk_writebackbone(pdbf *p, char *fname);
+void gk_writealphacarbons(pdbf *p, char *fname);
+void gk_showcorruption(pdbf *p);
+
+
+/*-------------------------------------------------------------
+ * error.c
+ *-------------------------------------------------------------*/
+void gk_set_exit_on_error(int value);
+void errexit(char *,...);
+void gk_errexit(int signum, char *,...);
+int gk_sigtrap();
+int gk_siguntrap();
+void gk_sigthrow(int signum);
+void gk_SetSignalHandlers();
+void gk_UnsetSignalHandlers();
+void gk_NonLocalExit_Handler(int signum);
+char *gk_strerror(int errnum);
+void PrintBackTrace();
+
+
+/*-------------------------------------------------------------
+ * util.c
+ *-------------------------------------------------------------*/
+void  gk_RandomPermute(size_t, int *, int);
+void  gk_array2csr(size_t n, size_t range, int *array, int *ptr, int *ind);
+int   gk_log2(int);
+int   gk_ispow2(int);
+float gk_flog2(float);
+
+
+/*-------------------------------------------------------------
+ * time.c
+ *-------------------------------------------------------------*/
+gk_wclock_t gk_WClockSeconds(void);
+double gk_CPUSeconds(void);
+
+/*-------------------------------------------------------------
+ * string.c
+ *-------------------------------------------------------------*/
+char   *gk_strchr_replace(char *str, char *fromlist, char *tolist);
+int     gk_strstr_replace(char *str, char *pattern, char *replacement, char *options, char **new_str);
+char   *gk_strtprune(char *, char *);
+char   *gk_strhprune(char *, char *);
+char   *gk_strtoupper(char *); 
+char   *gk_strtolower(char *); 
+char   *gk_strdup(char *orgstr);
+int     gk_strcasecmp(char *s1, char *s2);
+int     gk_strrcmp(char *s1, char *s2);
+char   *gk_time2str(time_t time);
+time_t  gk_str2time(char *str);
+int     gk_GetStringID(gk_StringMap_t *strmap, char *key);
+
+
+
+/*-------------------------------------------------------------
+ * sort.c 
+ *-------------------------------------------------------------*/
+void gk_csorti(size_t, char *);
+void gk_csortd(size_t, char *);
+void gk_isorti(size_t, int *);
+void gk_isortd(size_t, int *);
+void gk_fsorti(size_t, float *);
+void gk_fsortd(size_t, float *);
+void gk_dsorti(size_t, double *);
+void gk_dsortd(size_t, double *);
+void gk_idxsorti(size_t, gk_idx_t *);
+void gk_idxsortd(size_t, gk_idx_t *);
+void gk_ckvsorti(size_t, gk_ckv_t *);
+void gk_ckvsortd(size_t, gk_ckv_t *);
+void gk_ikvsorti(size_t, gk_ikv_t *);
+void gk_ikvsortd(size_t, gk_ikv_t *);
+void gk_i32kvsorti(size_t, gk_i32kv_t *);
+void gk_i32kvsortd(size_t, gk_i32kv_t *);
+void gk_i64kvsorti(size_t, gk_i64kv_t *);
+void gk_i64kvsortd(size_t, gk_i64kv_t *);
+void gk_zkvsorti(size_t, gk_zkv_t *);
+void gk_zkvsortd(size_t, gk_zkv_t *);
+void gk_fkvsorti(size_t, gk_fkv_t *);
+void gk_fkvsortd(size_t, gk_fkv_t *);
+void gk_dkvsorti(size_t, gk_dkv_t *);
+void gk_dkvsortd(size_t, gk_dkv_t *);
+void gk_skvsorti(size_t, gk_skv_t *);
+void gk_skvsortd(size_t, gk_skv_t *);
+void gk_idxkvsorti(size_t, gk_idxkv_t *);
+void gk_idxkvsortd(size_t, gk_idxkv_t *);
+
+
+/*-------------------------------------------------------------
+ * Selection routines
+ *-------------------------------------------------------------*/
+int  gk_dfkvkselect(size_t, int, gk_fkv_t *);
+int  gk_ifkvkselect(size_t, int, gk_fkv_t *);
+
+
+/*-------------------------------------------------------------
+ * Priority queue 
+ *-------------------------------------------------------------*/
+GK_MKPQUEUE_PROTO(gk_ipq,   gk_ipq_t,   int,      gk_idx_t)
+GK_MKPQUEUE_PROTO(gk_i32pq, gk_i32pq_t, int32_t,  gk_idx_t)
+GK_MKPQUEUE_PROTO(gk_i64pq, gk_i64pq_t, int64_t,  gk_idx_t)
+GK_MKPQUEUE_PROTO(gk_fpq,   gk_fpq_t,   float,    gk_idx_t)
+GK_MKPQUEUE_PROTO(gk_dpq,   gk_dpq_t,   double,   gk_idx_t)
+GK_MKPQUEUE_PROTO(gk_idxpq, gk_idxpq_t, gk_idx_t, gk_idx_t)
+
+
+/*-------------------------------------------------------------
+ * HTable routines
+ *-------------------------------------------------------------*/
+gk_HTable_t *HTable_Create(int nelements);
+void         HTable_Reset(gk_HTable_t *htable);
+void         HTable_Resize(gk_HTable_t *htable, int nelements);
+void         HTable_Insert(gk_HTable_t *htable, int key, int val);
+void         HTable_Delete(gk_HTable_t *htable, int key);
+int          HTable_Search(gk_HTable_t *htable, int key);
+int          HTable_GetNext(gk_HTable_t *htable, int key, int *val, int type);
+int          HTable_SearchAndDelete(gk_HTable_t *htable, int key);
+void         HTable_Destroy(gk_HTable_t *htable);
+int          HTable_HFunction(int nelements, int key);
+ 
+
+/*-------------------------------------------------------------
+ * Tokenizer routines
+ *-------------------------------------------------------------*/
+void gk_strtokenize(char *line, char *delim, gk_Tokens_t *tokens);
+void gk_freetokenslist(gk_Tokens_t *tokens);
+
+/*-------------------------------------------------------------
+ * Encoder/Decoder
+ *-------------------------------------------------------------*/
+void encodeblock(unsigned char *in, unsigned char *out);
+void decodeblock(unsigned char *in, unsigned char *out);
+void GKEncodeBase64(int nbytes, unsigned char *inbuffer, unsigned char *outbuffer);
+void GKDecodeBase64(int nbytes, unsigned char *inbuffer, unsigned char *outbuffer);
+
+
+/*-------------------------------------------------------------
+ * random.c
+ *-------------------------------------------------------------*/
+GK_MKRANDOM_PROTO(gk_c,   size_t, char)
+GK_MKRANDOM_PROTO(gk_i,   size_t, int)
+GK_MKRANDOM_PROTO(gk_f,   size_t, float)
+GK_MKRANDOM_PROTO(gk_d,   size_t, double)
+GK_MKRANDOM_PROTO(gk_idx, size_t, gk_idx_t)
+void gk_randinit(uint64_t);
+uint64_t gk_randint64(void);
+uint32_t gk_randint32(void);
+
+
+/*-------------------------------------------------------------
+ * OpenMP fake functions
+ *-------------------------------------------------------------*/
+#if !defined(__OPENMP__)
+void omp_set_num_threads(int num_threads);
+int omp_get_num_threads(void);
+int omp_get_max_threads(void);
+int omp_get_thread_num(void);
+int omp_get_num_procs(void);
+int omp_in_parallel(void);
+void omp_set_dynamic(int num_threads);
+int omp_get_dynamic(void);
+void omp_set_nested(int nested);
+int omp_get_nested(void);
+#endif /* __OPENMP__ */
+
+
+/*-------------------------------------------------------------
+ * CSR-related functions
+ *-------------------------------------------------------------*/
+gk_csr_t *gk_csr_Create();
+void gk_csr_Init(gk_csr_t *mat);
+void gk_csr_Free(gk_csr_t **mat);
+void gk_csr_FreeContents(gk_csr_t *mat);
+gk_csr_t *gk_csr_Dup(gk_csr_t *mat);
+gk_csr_t *gk_csr_ExtractSubmatrix(gk_csr_t *mat, int rstart, int nrows);
+gk_csr_t *gk_csr_ExtractRows(gk_csr_t *mat, int nrows, int *rind);
+gk_csr_t *gk_csr_ExtractPartition(gk_csr_t *mat, int *part, int pid);
+gk_csr_t **gk_csr_Split(gk_csr_t *mat, int *color);
+gk_csr_t *gk_csr_Read(char *filename, int format, int readvals, int numbering);
+void gk_csr_Write(gk_csr_t *mat, char *filename, int format, int writevals, int numbering);
+gk_csr_t *gk_csr_Prune(gk_csr_t *mat, int what, int minf, int maxf);
+gk_csr_t *gk_csr_LowFilter(gk_csr_t *mat, int what, int norm, float fraction);
+gk_csr_t *gk_csr_TopKPlusFilter(gk_csr_t *mat, int what, int topk, float keepval);
+gk_csr_t *gk_csr_ZScoreFilter(gk_csr_t *mat, int what, float zscore);
+void gk_csr_CompactColumns(gk_csr_t *mat);
+void gk_csr_SortIndices(gk_csr_t *mat, int what);
+void gk_csr_CreateIndex(gk_csr_t *mat, int what);
+void gk_csr_Normalize(gk_csr_t *mat, int what, int norm);
+void gk_csr_Scale(gk_csr_t *mat, int type);
+void gk_csr_ComputeSums(gk_csr_t *mat, int what);
+void gk_csr_ComputeSquaredNorms(gk_csr_t *mat, int what);
+float gk_csr_ComputeSimilarity(gk_csr_t *mat, int i1, int i2, int what, int simtype);
+int gk_csr_GetSimilarRows(gk_csr_t *mat, int nqterms, int *qind, float *qval,
+        int simtype, int nsim, float minsim, gk_fkv_t *hits, int *_imarker,
+        gk_fkv_t *i_cand);
+
+
+
+/* itemsets.c */
+void gk_find_frequent_itemsets(int ntrans, ssize_t *tranptr, int *tranind,
+        int minfreq, int maxfreq, int minlen, int maxlen,
+        void (*process_itemset)(void *stateptr, int nitems, int *itemind,
+                                int ntrans, int *tranind),
+        void *stateptr);
+
+
+/* evaluate.c */
+float ComputeAccuracy(int n, gk_fkv_t *list);
+float ComputeROCn(int n, int maxN, gk_fkv_t *list);
+float ComputeMedianRFP(int n, gk_fkv_t *list);
+float ComputeMean (int n, float *values);
+float ComputeStdDev(int  n, float *values);
+
+
+/* mcore.c */
+gk_mcore_t *gk_mcoreCreate(size_t coresize);
+gk_mcore_t *gk_gkmcoreCreate();
+void gk_mcoreDestroy(gk_mcore_t **r_mcore, int showstats);
+void gk_gkmcoreDestroy(gk_mcore_t **r_mcore, int showstats);
+void *gk_mcoreMalloc(gk_mcore_t *mcore, size_t nbytes);
+void gk_mcorePush(gk_mcore_t *mcore);
+void gk_gkmcorePush(gk_mcore_t *mcore);
+void gk_mcorePop(gk_mcore_t *mcore);
+void gk_gkmcorePop(gk_mcore_t *mcore);
+void gk_mcoreAdd(gk_mcore_t *mcore, int type, size_t nbytes, void *ptr);
+void gk_gkmcoreAdd(gk_mcore_t *mcore, int type, size_t nbytes, void *ptr);
+void gk_mcoreDel(gk_mcore_t *mcore, void *ptr);
+void gk_gkmcoreDel(gk_mcore_t *mcore, void *ptr);
+
+/* rw.c */
+int gk_rw_PageRank(gk_csr_t *mat, float lamda, float eps, int max_niter, float *pr);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_struct.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_struct.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,240 @@
+/*!
+\file gk_struct.h
+\brief This file contains various datastructures used/provided by GKlib
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_STRUCT_H_
+#define _GK_STRUCT_H_
+
+
+/********************************************************************/
+/*! Generator for gk_??KeyVal_t data structure */
+/********************************************************************/
+#define GK_MKKEYVALUE_T(NAME, KEYTYPE, VALTYPE) \
+typedef struct {\
+  KEYTYPE key;\
+  VALTYPE val;\
+} NAME;\
+
+/* The actual KeyVal data structures */
+GK_MKKEYVALUE_T(gk_ckv_t,   char,     ssize_t)
+GK_MKKEYVALUE_T(gk_ikv_t,   int,      ssize_t)
+GK_MKKEYVALUE_T(gk_i32kv_t, int32_t,  ssize_t)
+GK_MKKEYVALUE_T(gk_i64kv_t, int64_t,  ssize_t)
+GK_MKKEYVALUE_T(gk_zkv_t,   ssize_t,  ssize_t)
+GK_MKKEYVALUE_T(gk_fkv_t,   float,    ssize_t)
+GK_MKKEYVALUE_T(gk_dkv_t,   double,   ssize_t)
+GK_MKKEYVALUE_T(gk_skv_t,   char *,   ssize_t)
+GK_MKKEYVALUE_T(gk_idxkv_t, gk_idx_t, gk_idx_t)
+
+
+
+/********************************************************************/
+/*! Generator for gk_?pq_t data structure */
+/********************************************************************/
+#define GK_MKPQUEUE_T(NAME, KVTYPE)\
+typedef struct {\
+  gk_idx_t nnodes;\
+  gk_idx_t maxnodes;\
+\
+  /* Heap version of the data structure */ \
+  KVTYPE   *heap;\
+  gk_idx_t *locator;\
+} NAME;\
+
+GK_MKPQUEUE_T(gk_ipq_t,    gk_ikv_t)
+GK_MKPQUEUE_T(gk_i32pq_t,  gk_i32kv_t)
+GK_MKPQUEUE_T(gk_i64pq_t,  gk_i64kv_t)
+GK_MKPQUEUE_T(gk_fpq_t,    gk_fkv_t)
+GK_MKPQUEUE_T(gk_dpq_t,    gk_dkv_t)
+GK_MKPQUEUE_T(gk_idxpq_t,  gk_idxkv_t)
+
+
+
+/*-------------------------------------------------------------
+ * The following data structure stores a sparse CSR format
+ *-------------------------------------------------------------*/
+typedef struct gk_csr_t {
+  int32_t nrows, ncols;
+  ssize_t *rowptr, *colptr;
+  int32_t *rowind, *colind;
+  int32_t *rowids, *colids;
+  float *rowval, *colval;
+  float *rnorms, *cnorms;
+  float *rsums, *csums;
+  float *rsizes, *csizes;
+  float *rvols, *cvols;
+  float *rwgts, *cwgts;
+} gk_csr_t;
+
+
+/*-------------------------------------------------------------
+ * The following data structure stores stores a string as a 
+ * pair of its allocated buffer and the buffer itself.
+ *-------------------------------------------------------------*/
+typedef struct gk_str_t {
+  size_t len;
+  char *buf;
+} gk_str_t;
+
+
+
+
+/*-------------------------------------------------------------
+* The following data structure implements a string-2-int mapping
+* table used for parsing command-line options
+*-------------------------------------------------------------*/
+typedef struct gk_StringMap_t {
+  char *name;
+  int id;
+} gk_StringMap_t;
+
+
+/*------------------------------------------------------------
+ * This structure implements a simple hash table
+ *------------------------------------------------------------*/
+typedef struct gk_HTable_t {
+  int nelements;          /* The overall size of the hash-table */
+  int htsize;             /* The current size of the hash-table */
+  gk_ikv_t *harray;       /* The actual hash-table */
+} gk_HTable_t;
+
+
+/*------------------------------------------------------------
+ * This structure implements a gk_Tokens_t list returned by the
+ * string tokenizer
+ *------------------------------------------------------------*/
+typedef struct gk_Tokens_t {
+  int ntoks;        /* The number of tokens in the input string */
+  char *strbuf;     /* The memory that stores all the entries */
+  char **list;      /* Pointers to the strbuf for each element */
+} gk_Tokens_t;
+
+/*------------------------------------------------------------
+ * This structure implements storage for an atom in a pdb file
+ *------------------------------------------------------------*/
+typedef struct atom {
+  int       serial;
+  char      *name;
+  char	    altLoc;
+  char      *resname;
+  char      chainid;	
+  int       rserial;
+  char	    icode;
+  char      element;
+  double    x;
+  double    y;
+  double    z;
+  double    opcy;
+  double    tmpt;
+} atom;
+
+
+/*------------------------------------------------------------
+ * This structure implements storage for a center of mass for
+ * a single residue.
+ *------------------------------------------------------------*/
+typedef struct center_of_mass {
+  char name;
+  double x;
+  double y;
+  double z;
+} center_of_mass;
+
+
+/*------------------------------------------------------------
+ * This structure implements storage for a pdb protein 
+ *------------------------------------------------------------*/
+typedef struct pdbf {
+	int natoms;			/* Number of atoms */
+	int nresidues;  /* Number of residues based on coordinates */
+	int ncas;
+	int nbbs;
+	int corruption;
+	char *resSeq;	      /* Residue sequence based on coordinates    */
+  char **threeresSeq; /* three-letter residue sequence */
+	atom *atoms;
+	atom **bbs;
+	atom **cas;
+  center_of_mass *cm;
+} pdbf;
+
+
+
+/*************************************************************
+* Localization Structures for converting characters to integers
+**************************************************************/
+typedef struct gk_i2cc2i_t {
+    int n;
+    char *i2c;
+    int *c2i;
+} gk_i2cc2i_t;
+ 
+
+/*******************************************************************
+ *This structure implements storage of a protein sequence
+ * *****************************************************************/
+typedef struct gk_seq_t {
+    
+    int len; /*Number of Residues */
+    int *sequence; /* Stores the sequence*/
+    
+    
+    int **pssm; /* Stores the pssm matrix */
+    int **psfm; /* Stores the psfm matrix */
+    char *name; /* Stores the name of the sequence */
+
+    int nsymbols;
+
+    
+} gk_seq_t;
+
+
+
+
+/*************************************************************************/
+/*! The following data structure stores information about a memory 
+    allocation operation that can either be served from gk_mcore_t or by
+    a gk_malloc if not sufficient workspace memory is available. */
+/*************************************************************************/
+typedef struct gk_mop_t {
+  int type;
+  ssize_t nbytes;
+  void *ptr;
+} gk_mop_t;
+
+
+/*************************************************************************/
+/*! The following structure stores information used by Metis */
+/*************************************************************************/
+typedef struct gk_mcore_t {
+  /* Workspace information */
+  size_t coresize;     /*!< The amount of core memory that has been allocated */
+  size_t corecpos;     /*!< Index of the first free location in core */
+  void *core;	       /*!< Pointer to the core itself */
+
+  /* These are for implementing a stack-based allocation scheme using both
+     core and also dynamically allocated memory */
+  size_t nmops;         /*!< The number of maop_t entries that have been allocated */
+  size_t cmop;          /*!< Index of the first free location in maops */
+  gk_mop_t *mops;       /*!< The array recording the maop_t operations */
+
+  /* These are for keeping various statistics for wspacemalloc */
+  size_t num_callocs;   /*!< The number of core mallocs */
+  size_t num_hallocs;   /*!< The number of heap mallocs */
+  size_t size_callocs;  /*!< The total # of bytes in core mallocs */
+  size_t size_hallocs;  /*!< The total # of bytes in heap mallocs */
+  size_t cur_callocs;   /*!< The current # of bytes in core mallocs */
+  size_t cur_hallocs;   /*!< The current # of bytes in heap mallocs */
+  size_t max_callocs;   /*!< The maximum # of bytes in core mallocs at any given time */
+  size_t max_hallocs;   /*!< The maximum # of bytes in heap mallocs at any given time */
+
+} gk_mcore_t;
+
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gk_types.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gk_types.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,38 @@
+/*!
+\file  gk_types.h
+\brief This file contains basic scalar datatype used in GKlib
+
+\date   Started 3/27/2007
+\author George
+\version\verbatim $Id$ \endverbatim
+*/
+
+#ifndef _GK_TYPES_H_
+#define _GK_TYPES_H_
+
+/*************************************************************************
+* Basic data type definitions. These definitions allow GKlib to separate
+* the following elemental types:
+* - loop iterator variables, which are set to size_t
+* - signed and unsigned int variables that can be set to any # of bits
+* - signed and unsigned long variables that can be set to any # of bits
+* - real variables, which can be set to single or double precision.
+**************************************************************************/
+/*typedef ptrdiff_t       gk_idx_t;       */  /* index variable */
+typedef ssize_t         gk_idx_t;         /* index variable */
+typedef int32_t         gk_int_t;         /* integer values */
+typedef uint32_t        gk_uint_t;        /* unsigned integer values */
+typedef int64_t         gk_long_t;        /* long integer values */
+typedef uint64_t        gk_ulong_t;       /* unsigned long integer values */
+typedef float           gk_real_t;        /* real type */
+typedef double          gk_dreal_t;       /* double precission real type */
+typedef double          gk_wclock_t;	  /* wall-clock time */
+
+/*#define GK_IDX_MAX PTRDIFF_MAX*/
+#define GK_IDX_MAX ((SIZE_MAX>>1)-2)
+
+#define PRIGKIDX "zd"
+#define SCNGKIDX "zd"
+
+
+#endif
diff -r b51a142f9789 -r 26bf6bd35143 headers/gkregex.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/gkregex.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,556 @@
+/* Definitions for data structures and routines for the regular
+   expression library.
+   Copyright (C) 1985,1989-93,1995-98,2000,2001,2002,2003,2005,2006
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _REGEX_H
+#define _REGEX_H 1
+
+#include <sys/types.h>
+
+/* Allow the use in C++ code.  */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* The following two types have to be signed and unsigned integer type
+   wide enough to hold a value of a pointer.  For most ANSI compilers
+   ptrdiff_t and size_t should be likely OK.  Still size of these two
+   types is 2 for Microsoft C.  Ugh... */
+typedef long int s_reg_t;
+typedef unsigned long int active_reg_t;
+
+/* The following bits are used to determine the regexp syntax we
+   recognize.  The set/not-set meanings are chosen so that Emacs syntax
+   remains the value 0.  The bits are given in alphabetical order, and
+   the definitions shifted by one from the previous bit; thus, when we
+   add or remove a bit, only one other definition need change.  */
+typedef unsigned long int reg_syntax_t;
+
+/* If this bit is not set, then \ inside a bracket expression is literal.
+   If set, then such a \ quotes the following character.  */
+#define RE_BACKSLASH_ESCAPE_IN_LISTS ((unsigned long int) 1)
+
+/* If this bit is not set, then + and ? are operators, and \+ and \? are
+     literals.
+   If set, then \+ and \? are operators and + and ? are literals.  */
+#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
+
+/* If this bit is set, then character classes are supported.  They are:
+     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+   If not set, then character classes are not supported.  */
+#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
+
+/* If this bit is set, then ^ and $ are always anchors (outside bracket
+     expressions, of course).
+   If this bit is not set, then it depends:
+        ^  is an anchor if it is at the beginning of a regular
+           expression or after an open-group or an alternation operator;
+        $  is an anchor if it is at the end of a regular expression, or
+           before a close-group or an alternation operator.
+
+   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+   POSIX draft 11.2 says that * etc. in leading positions is undefined.
+   We already implemented a previous draft which made those constructs
+   invalid, though, so we haven't changed the code back.  */
+#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
+
+/* If this bit is set, then special characters are always special
+     regardless of where they are in the pattern.
+   If this bit is not set, then special characters are special only in
+     some contexts; otherwise they are ordinary.  Specifically,
+     * + ? and intervals are only special when not after the beginning,
+     open-group, or alternation operator.  */
+#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
+
+/* If this bit is set, then *, +, ?, and { cannot be first in an re or
+     immediately after an alternation or begin-group operator.  */
+#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
+
+/* If this bit is set, then . matches newline.
+   If not set, then it doesn't.  */
+#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
+
+/* If this bit is set, then . doesn't match NUL.
+   If not set, then it does.  */
+#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
+
+/* If this bit is set, nonmatching lists [^...] do not match newline.
+   If not set, they do.  */
+#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
+
+/* If this bit is set, either \{...\} or {...} defines an
+     interval, depending on RE_NO_BK_BRACES.
+   If not set, \{, \}, {, and } are literals.  */
+#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
+
+/* If this bit is set, +, ? and | aren't recognized as operators.
+   If not set, they are.  */
+#define RE_LIMITED_OPS (RE_INTERVALS << 1)
+
+/* If this bit is set, newline is an alternation operator.
+   If not set, newline is literal.  */
+#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
+
+/* If this bit is set, then `{...}' defines an interval, and \{ and \}
+     are literals.
+  If not set, then `\{...\}' defines an interval.  */
+#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
+
+/* If this bit is set, (...) defines a group, and \( and \) are literals.
+   If not set, \(...\) defines a group, and ( and ) are literals.  */
+#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
+
+/* If this bit is set, then \<digit> matches <digit>.
+   If not set, then \<digit> is a back-reference.  */
+#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
+
+/* If this bit is set, then | is an alternation operator, and \| is literal.
+   If not set, then \| is an alternation operator, and | is literal.  */
+#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
+
+/* If this bit is set, then an ending range point collating higher
+     than the starting range point, as in [z-a], is invalid.
+   If not set, then when ending range point collates higher than the
+     starting range point, the range is ignored.  */
+#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
+
+/* If this bit is set, then an unmatched ) is ordinary.
+   If not set, then an unmatched ) is invalid.  */
+#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
+
+/* If this bit is set, succeed as soon as we match the whole pattern,
+   without further backtracking.  */
+#define RE_NO_POSIX_BACKTRACKING (RE_UNMATCHED_RIGHT_PAREN_ORD << 1)
+
+/* If this bit is set, do not process the GNU regex operators.
+   If not set, then the GNU regex operators are recognized. */
+#define RE_NO_GNU_OPS (RE_NO_POSIX_BACKTRACKING << 1)
+
+/* If this bit is set, turn on internal regex debugging.
+   If not set, and debugging was on, turn it off.
+   This only works if regex.c is compiled -DDEBUG.
+   We define this bit always, so that all that's needed to turn on
+   debugging is to recompile regex.c; the calling code can always have
+   this bit set, and it won't affect anything in the normal case. */
+#define RE_DEBUG (RE_NO_GNU_OPS << 1)
+
+/* If this bit is set, a syntactically invalid interval is treated as
+   a string of ordinary characters.  For example, the ERE 'a{1' is
+   treated as 'a\{1'.  */
+#define RE_INVALID_INTERVAL_ORD (RE_DEBUG << 1)
+
+/* If this bit is set, then ignore case when matching.
+   If not set, then case is significant.  */
+#define RE_ICASE (RE_INVALID_INTERVAL_ORD << 1)
+
+/* This bit is used internally like RE_CONTEXT_INDEP_ANCHORS but only
+   for ^, because it is difficult to scan the regex backwards to find
+   whether ^ should be special.  */
+#define RE_CARET_ANCHORS_HERE (RE_ICASE << 1)
+
+/* If this bit is set, then \{ cannot be first in an bre or
+   immediately after an alternation or begin-group operator.  */
+#define RE_CONTEXT_INVALID_DUP (RE_CARET_ANCHORS_HERE << 1)
+
+/* If this bit is set, then no_sub will be set to 1 during
+   re_compile_pattern.  */
+#define RE_NO_SUB (RE_CONTEXT_INVALID_DUP << 1)
+
+/* This global variable defines the particular regexp syntax to use (for
+   some interfaces).  When a regexp is compiled, the syntax used is
+   stored in the pattern buffer, so changing this does not affect
+   already-compiled regexps.  */
+extern reg_syntax_t re_syntax_options;
+
+/* Define combinations of the above bits for the standard possibilities.
+   (The [[[ comments delimit what gets put into the Texinfo file, so
+   don't delete them!)  */
+/* [[[begin syntaxes]]] */
+#define RE_SYNTAX_EMACS 0
+
+#define RE_SYNTAX_AWK							\
+  (RE_BACKSLASH_ESCAPE_IN_LISTS   | RE_DOT_NOT_NULL			\
+   | RE_NO_BK_PARENS              | RE_NO_BK_REFS			\
+   | RE_NO_BK_VBAR                | RE_NO_EMPTY_RANGES			\
+   | RE_DOT_NEWLINE		  | RE_CONTEXT_INDEP_ANCHORS		\
+   | RE_UNMATCHED_RIGHT_PAREN_ORD | RE_NO_GNU_OPS)
+
+#define RE_SYNTAX_GNU_AWK						\
+  ((RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DEBUG)	\
+   & ~(RE_DOT_NOT_NULL | RE_INTERVALS | RE_CONTEXT_INDEP_OPS		\
+       | RE_CONTEXT_INVALID_OPS ))
+
+#define RE_SYNTAX_POSIX_AWK						\
+  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS		\
+   | RE_INTERVALS	    | RE_NO_GNU_OPS)
+
+#define RE_SYNTAX_GREP							\
+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
+   | RE_NEWLINE_ALT)
+
+#define RE_SYNTAX_EGREP							\
+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
+   | RE_NO_BK_VBAR)
+
+#define RE_SYNTAX_POSIX_EGREP						\
+  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES			\
+   | RE_INVALID_INTERVAL_ORD)
+
+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
+#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
+
+#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
+
+/* Syntax bits common to both basic and extended POSIX regex syntax.  */
+#define _RE_SYNTAX_POSIX_COMMON						\
+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
+   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
+
+#define RE_SYNTAX_POSIX_BASIC						\
+  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM | RE_CONTEXT_INVALID_DUP)
+
+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
+   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+   isn't minimal, since other operators, such as \`, aren't disabled.  */
+#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
+  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
+
+#define RE_SYNTAX_POSIX_EXTENDED					\
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INDEP_OPS   | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS        | RE_NO_BK_VBAR				\
+   | RE_CONTEXT_INVALID_OPS | RE_UNMATCHED_RIGHT_PAREN_ORD)
+
+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INDEP_OPS is
+   removed and RE_NO_BK_REFS is added.  */
+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
+   | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
+/* [[[end syntaxes]]] */
+
+/* Maximum number of duplicates an interval can allow.  Some systems
+   (erroneously) define this in other header files, but we want our
+   value, so remove any previous define.  */
+#ifdef RE_DUP_MAX
+# undef RE_DUP_MAX
+#endif
+/* If sizeof(int) == 2, then ((1 << 15) - 1) overflows.  */
+#define RE_DUP_MAX (0x7fff)
+
+
+/* POSIX `cflags' bits (i.e., information for `regcomp').  */
+
+/* If this bit is set, then use extended regular expression syntax.
+   If not set, then use basic regular expression syntax.  */
+#define REG_EXTENDED 1
+
+/* If this bit is set, then ignore case when matching.
+   If not set, then case is significant.  */
+#define REG_ICASE (REG_EXTENDED << 1)
+
+/* If this bit is set, then anchors do not match at newline
+     characters in the string.
+   If not set, then anchors do match at newlines.  */
+#define REG_NEWLINE (REG_ICASE << 1)
+
+/* If this bit is set, then report only success or fail in regexec.
+   If not set, then returns differ between not matching and errors.  */
+#define REG_NOSUB (REG_NEWLINE << 1)
+
+
+/* POSIX `eflags' bits (i.e., information for regexec).  */
+
+/* If this bit is set, then the beginning-of-line operator doesn't match
+     the beginning of the string (presumably because it's not the
+     beginning of a line).
+   If not set, then the beginning-of-line operator does match the
+     beginning of the string.  */
+#define REG_NOTBOL 1
+
+/* Like REG_NOTBOL, except for the end-of-line.  */
+#define REG_NOTEOL (1 << 1)
+
+/* Use PMATCH[0] to delimit the start and end of the search in the
+   buffer.  */
+#define REG_STARTEND (1 << 2)
+
+
+/* If any error codes are removed, changed, or added, update the
+   `re_error_msg' table in regex.c.  */
+typedef enum
+{
+#ifdef _XOPEN_SOURCE
+  REG_ENOSYS = -1,	/* This will never happen for this implementation.  */
+#endif
+
+  REG_NOERROR = 0,	/* Success.  */
+  REG_NOMATCH,		/* Didn't find a match (for regexec).  */
+
+  /* POSIX regcomp return error codes.  (In the order listed in the
+     standard.)  */
+  REG_BADPAT,		/* Invalid pattern.  */
+  REG_ECOLLATE,		/* Inalid collating element.  */
+  REG_ECTYPE,		/* Invalid character class name.  */
+  REG_EESCAPE,		/* Trailing backslash.  */
+  REG_ESUBREG,		/* Invalid back reference.  */
+  REG_EBRACK,		/* Unmatched left bracket.  */
+  REG_EPAREN,		/* Parenthesis imbalance.  */
+  REG_EBRACE,		/* Unmatched \{.  */
+  REG_BADBR,		/* Invalid contents of \{\}.  */
+  REG_ERANGE,		/* Invalid range end.  */
+  REG_ESPACE,		/* Ran out of memory.  */
+  REG_BADRPT,		/* No preceding re for repetition op.  */
+
+  /* Error codes we've added.  */
+  REG_EEND,		/* Premature end.  */
+  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
+  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
+} reg_errcode_t;
+
+/* This data structure represents a compiled pattern.  Before calling
+   the pattern compiler, the fields `buffer', `allocated', `fastmap',
+   `translate', and `no_sub' can be set.  After the pattern has been
+   compiled, the `re_nsub' field is available.  All other fields are
+   private to the regex routines.  */
+
+#ifndef RE_TRANSLATE_TYPE
+# define RE_TRANSLATE_TYPE unsigned char *
+#endif
+
+struct re_pattern_buffer
+{
+  /* Space that holds the compiled pattern.  It is declared as
+     `unsigned char *' because its elements are sometimes used as
+     array indexes.  */
+  unsigned char *buffer;
+
+  /* Number of bytes to which `buffer' points.  */
+  unsigned long int allocated;
+
+  /* Number of bytes actually used in `buffer'.  */
+  unsigned long int used;
+
+  /* Syntax setting with which the pattern was compiled.  */
+  reg_syntax_t syntax;
+
+  /* Pointer to a fastmap, if any, otherwise zero.  re_search uses the
+     fastmap, if there is one, to skip over impossible starting points
+     for matches.  */
+  char *fastmap;
+
+  /* Either a translate table to apply to all characters before
+     comparing them, or zero for no translation.  The translation is
+     applied to a pattern when it is compiled and to a string when it
+     is matched.  */
+  RE_TRANSLATE_TYPE translate;
+
+  /* Number of subexpressions found by the compiler.  */
+  size_t re_nsub;
+
+  /* Zero if this pattern cannot match the empty string, one else.
+     Well, in truth it's used only in `re_search_2', to see whether or
+     not we should use the fastmap, so we don't set this absolutely
+     perfectly; see `re_compile_fastmap' (the `duplicate' case).  */
+  unsigned can_be_null : 1;
+
+  /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+     for `max (RE_NREGS, re_nsub + 1)' groups.
+     If REGS_REALLOCATE, reallocate space if necessary.
+     If REGS_FIXED, use what's there.  */
+#define REGS_UNALLOCATED 0
+#define REGS_REALLOCATE 1
+#define REGS_FIXED 2
+  unsigned regs_allocated : 2;
+
+  /* Set to zero when `regex_compile' compiles a pattern; set to one
+     by `re_compile_fastmap' if it updates the fastmap.  */
+  unsigned fastmap_accurate : 1;
+
+  /* If set, `re_match_2' does not return information about
+     subexpressions.  */
+  unsigned no_sub : 1;
+
+  /* If set, a beginning-of-line anchor doesn't match at the beginning
+     of the string.  */
+  unsigned not_bol : 1;
+
+  /* Similarly for an end-of-line anchor.  */
+  unsigned not_eol : 1;
+
+  /* If true, an anchor at a newline matches.  */
+  unsigned newline_anchor : 1;
+};
+
+typedef struct re_pattern_buffer regex_t;
+
+/* Type for byte offsets within the string.  POSIX mandates this.  */
+typedef int regoff_t;
+
+
+/* This is the structure we store register match data in.  See
+   regex.texinfo for a full description of what registers match.  */
+struct re_registers
+{
+  unsigned num_regs;
+  regoff_t *start;
+  regoff_t *end;
+};
+
+
+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+   `re_match_2' returns information about at least this many registers
+   the first time a `regs' structure is passed.  */
+#ifndef RE_NREGS
+# define RE_NREGS 30
+#endif
+
+
+/* POSIX specification for registers.  Aside from the different names than
+   `re_registers', POSIX uses an array of structures, instead of a
+   structure of arrays.  */
+typedef struct
+{
+  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */
+  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */
+} regmatch_t;
+
+/* Declarations for routines.  */
+
+/* Sets the current default syntax to SYNTAX, and return the old syntax.
+   You can also simply assign to the `re_syntax_options' variable.  */
+extern reg_syntax_t re_set_syntax (reg_syntax_t __syntax);
+
+/* Compile the regular expression PATTERN, with length LENGTH
+   and syntax given by the global `re_syntax_options', into the buffer
+   BUFFER.  Return NULL if successful, and an error string if not.  */
+extern const char *re_compile_pattern (const char *__pattern, size_t __length,
+				       struct re_pattern_buffer *__buffer);
+
+
+/* Compile a fastmap for the compiled pattern in BUFFER; used to
+   accelerate searches.  Return 0 if successful and -2 if was an
+   internal error.  */
+extern int re_compile_fastmap (struct re_pattern_buffer *__buffer);
+
+
+/* Search in the string STRING (with length LENGTH) for the pattern
+   compiled into BUFFER.  Start searching at position START, for RANGE
+   characters.  Return the starting position of the match, -1 for no
+   match, or -2 for an internal error.  Also return register
+   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
+extern int re_search (struct re_pattern_buffer *__buffer, const char *__string,
+		      int __length, int __start, int __range,
+		      struct re_registers *__regs);
+
+
+/* Like `re_search', but search in the concatenation of STRING1 and
+   STRING2.  Also, stop searching at index START + STOP.  */
+extern int re_search_2 (struct re_pattern_buffer *__buffer,
+			const char *__string1, int __length1,
+			const char *__string2, int __length2, int __start,
+			int __range, struct re_registers *__regs, int __stop);
+
+
+/* Like `re_search', but return how many characters in STRING the regexp
+   in BUFFER matched, starting at position START.  */
+extern int re_match (struct re_pattern_buffer *__buffer, const char *__string,
+		     int __length, int __start, struct re_registers *__regs);
+
+
+/* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
+extern int re_match_2 (struct re_pattern_buffer *__buffer,
+		       const char *__string1, int __length1,
+		       const char *__string2, int __length2, int __start,
+		       struct re_registers *__regs, int __stop);
+
+
+/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
+   ENDS.  Subsequent matches using BUFFER and REGS will use this memory
+   for recording register information.  STARTS and ENDS must be
+   allocated with malloc, and must each be at least `NUM_REGS * sizeof
+   (regoff_t)' bytes long.
+
+   If NUM_REGS == 0, then subsequent matches should allocate their own
+   register data.
+
+   Unless this function is called, the first search or match using
+   PATTERN_BUFFER will allocate its own register data, without
+   freeing the old data.  */
+extern void re_set_registers (struct re_pattern_buffer *__buffer,
+			      struct re_registers *__regs,
+			      unsigned int __num_regs,
+			      regoff_t *__starts, regoff_t *__ends);
+
+#if defined _REGEX_RE_COMP || defined _LIBC
+# ifndef _CRAY
+/* 4.2 bsd compatibility.  */
+extern char *re_comp (const char *);
+extern int re_exec (const char *);
+# endif
+#endif
+
+/* GCC 2.95 and later have "__restrict"; C99 compilers have
+   "restrict", and "configure" may have defined "restrict".  */
+#ifndef __restrict
+# if ! (2 < __GNUC__ || (2 == __GNUC__ && 95 <= __GNUC_MINOR__))
+#  if defined restrict || 199901L <= __STDC_VERSION__
+#   define __restrict restrict
+#  else
+#   define __restrict
+#  endif
+# endif
+#endif
+/* gcc 3.1 and up support the [restrict] syntax.  */
+#ifndef __restrict_arr
+# if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)) \
+     && !defined __GNUG__
+#  define __restrict_arr __restrict
+# else
+#  define __restrict_arr
+# endif
+#endif
+
+/* POSIX compatibility.  */
+extern int regcomp (regex_t *__restrict __preg,
+		    const char *__restrict __pattern,
+		    int __cflags);
+
+extern int regexec (const regex_t *__restrict __preg,
+		    const char *__restrict __string, size_t __nmatch,
+		    regmatch_t __pmatch[__restrict_arr],
+		    int __eflags);
+
+extern size_t regerror (int __errcode, const regex_t *__restrict __preg,
+			char *__restrict __errbuf, size_t __errbuf_size);
+
+extern void regfree (regex_t *__preg);
+
+
+#ifdef __cplusplus
+}
+#endif	/* C++ */
+
+#endif /* regex.h */
diff -r b51a142f9789 -r 26bf6bd35143 headers/ms_inttypes.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/ms_inttypes.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,301 @@
+// ISO C9x  compliant inttypes.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
+// 
+//  Copyright (c) 2006 Alexander Chemeris
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+// 
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+// 
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_INTTYPES_H_ // [
+#define _MSC_INTTYPES_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include "ms_stdint.h"
+
+// 7.8 Format conversion of integer types
+
+typedef struct {
+   intmax_t quot;
+   intmax_t rem;
+} imaxdiv_t;
+
+// 7.8.1 Macros for format specifiers
+
+// The fprintf macros for signed integers are:
+#define PRId8       "d"
+#define PRIi8       "i"
+#define PRIdLEAST8  "d"
+#define PRIiLEAST8  "i"
+#define PRIdFAST8   "d"
+#define PRIiFAST8   "i"
+
+#define PRId16       "hd"
+#define PRIi16       "hi"
+#define PRIdLEAST16  "hd"
+#define PRIiLEAST16  "hi"
+#define PRIdFAST16   "hd"
+#define PRIiFAST16   "hi"
+
+#define PRId32       "I32d"
+#define PRIi32       "I32i"
+#define PRIdLEAST32  "I32d"
+#define PRIiLEAST32  "I32i"
+#define PRIdFAST32   "I32d"
+#define PRIiFAST32   "I32i"
+
+#define PRId64       "I64d"
+#define PRIi64       "I64i"
+#define PRIdLEAST64  "I64d"
+#define PRIiLEAST64  "I64i"
+#define PRIdFAST64   "I64d"
+#define PRIiFAST64   "I64i"
+
+#define PRIdMAX     "I64d"
+#define PRIiMAX     "I64i"
+
+#define PRIdPTR     "Id"
+#define PRIiPTR     "Ii"
+
+// The fprintf macros for unsigned integers are:
+#define PRIo8       "o"
+#define PRIu8       "u"
+#define PRIx8       "x"
+#define PRIX8       "X"
+#define PRIoLEAST8  "o"
+#define PRIuLEAST8  "u"
+#define PRIxLEAST8  "x"
+#define PRIXLEAST8  "X"
+#define PRIoFAST8   "o"
+#define PRIuFAST8   "u"
+#define PRIxFAST8   "x"
+#define PRIXFAST8   "X"
+
+#define PRIo16       "ho"
+#define PRIu16       "hu"
+#define PRIx16       "hx"
+#define PRIX16       "hX"
+#define PRIoLEAST16  "ho"
+#define PRIuLEAST16  "hu"
+#define PRIxLEAST16  "hx"
+#define PRIXLEAST16  "hX"
+#define PRIoFAST16   "ho"
+#define PRIuFAST16   "hu"
+#define PRIxFAST16   "hx"
+#define PRIXFAST16   "hX"
+
+#define PRIo32       "I32o"
+#define PRIu32       "I32u"
+#define PRIx32       "I32x"
+#define PRIX32       "I32X"
+#define PRIoLEAST32  "I32o"
+#define PRIuLEAST32  "I32u"
+#define PRIxLEAST32  "I32x"
+#define PRIXLEAST32  "I32X"
+#define PRIoFAST32   "I32o"
+#define PRIuFAST32   "I32u"
+#define PRIxFAST32   "I32x"
+#define PRIXFAST32   "I32X"
+
+#define PRIo64       "I64o"
+#define PRIu64       "I64u"
+#define PRIx64       "I64x"
+#define PRIX64       "I64X"
+#define PRIoLEAST64  "I64o"
+#define PRIuLEAST64  "I64u"
+#define PRIxLEAST64  "I64x"
+#define PRIXLEAST64  "I64X"
+#define PRIoFAST64   "I64o"
+#define PRIuFAST64   "I64u"
+#define PRIxFAST64   "I64x"
+#define PRIXFAST64   "I64X"
+
+#define PRIoMAX     "I64o"
+#define PRIuMAX     "I64u"
+#define PRIxMAX     "I64x"
+#define PRIXMAX     "I64X"
+
+#define PRIoPTR     "Io"
+#define PRIuPTR     "Iu"
+#define PRIxPTR     "Ix"
+#define PRIXPTR     "IX"
+
+// The fscanf macros for signed integers are:
+#define SCNd8       "d"
+#define SCNi8       "i"
+#define SCNdLEAST8  "d"
+#define SCNiLEAST8  "i"
+#define SCNdFAST8   "d"
+#define SCNiFAST8   "i"
+
+#define SCNd16       "hd"
+#define SCNi16       "hi"
+#define SCNdLEAST16  "hd"
+#define SCNiLEAST16  "hi"
+#define SCNdFAST16   "hd"
+#define SCNiFAST16   "hi"
+
+#define SCNd32       "ld"
+#define SCNi32       "li"
+#define SCNdLEAST32  "ld"
+#define SCNiLEAST32  "li"
+#define SCNdFAST32   "ld"
+#define SCNiFAST32   "li"
+
+#define SCNd64       "I64d"
+#define SCNi64       "I64i"
+#define SCNdLEAST64  "I64d"
+#define SCNiLEAST64  "I64i"
+#define SCNdFAST64   "I64d"
+#define SCNiFAST64   "I64i"
+
+#define SCNdMAX     "I64d"
+#define SCNiMAX     "I64i"
+
+#ifdef _WIN64 // [
+#  define SCNdPTR     "I64d"
+#  define SCNiPTR     "I64i"
+#else  // _WIN64 ][
+#  define SCNdPTR     "ld"
+#  define SCNiPTR     "li"
+#endif  // _WIN64 ]
+
+// The fscanf macros for unsigned integers are:
+#define SCNo8       "o"
+#define SCNu8       "u"
+#define SCNx8       "x"
+#define SCNX8       "X"
+#define SCNoLEAST8  "o"
+#define SCNuLEAST8  "u"
+#define SCNxLEAST8  "x"
+#define SCNXLEAST8  "X"
+#define SCNoFAST8   "o"
+#define SCNuFAST8   "u"
+#define SCNxFAST8   "x"
+#define SCNXFAST8   "X"
+
+#define SCNo16       "ho"
+#define SCNu16       "hu"
+#define SCNx16       "hx"
+#define SCNX16       "hX"
+#define SCNoLEAST16  "ho"
+#define SCNuLEAST16  "hu"
+#define SCNxLEAST16  "hx"
+#define SCNXLEAST16  "hX"
+#define SCNoFAST16   "ho"
+#define SCNuFAST16   "hu"
+#define SCNxFAST16   "hx"
+#define SCNXFAST16   "hX"
+
+#define SCNo32       "lo"
+#define SCNu32       "lu"
+#define SCNx32       "lx"
+#define SCNX32       "lX"
+#define SCNoLEAST32  "lo"
+#define SCNuLEAST32  "lu"
+#define SCNxLEAST32  "lx"
+#define SCNXLEAST32  "lX"
+#define SCNoFAST32   "lo"
+#define SCNuFAST32   "lu"
+#define SCNxFAST32   "lx"
+#define SCNXFAST32   "lX"
+
+#define SCNo64       "I64o"
+#define SCNu64       "I64u"
+#define SCNx64       "I64x"
+#define SCNX64       "I64X"
+#define SCNoLEAST64  "I64o"
+#define SCNuLEAST64  "I64u"
+#define SCNxLEAST64  "I64x"
+#define SCNXLEAST64  "I64X"
+#define SCNoFAST64   "I64o"
+#define SCNuFAST64   "I64u"
+#define SCNxFAST64   "I64x"
+#define SCNXFAST64   "I64X"
+
+#define SCNoMAX     "I64o"
+#define SCNuMAX     "I64u"
+#define SCNxMAX     "I64x"
+#define SCNXMAX     "I64X"
+
+#ifdef _WIN64 // [
+#  define SCNoPTR     "I64o"
+#  define SCNuPTR     "I64u"
+#  define SCNxPTR     "I64x"
+#  define SCNXPTR     "I64X"
+#else  // _WIN64 ][
+#  define SCNoPTR     "lo"
+#  define SCNuPTR     "lu"
+#  define SCNxPTR     "lx"
+#  define SCNXPTR     "lX"
+#endif  // _WIN64 ]
+
+// 7.8.2 Functions for greatest-width integer types
+
+// 7.8.2.1 The imaxabs function
+#define imaxabs _abs64
+
+// 7.8.2.2 The imaxdiv function
+
+// This is modified version of div() function from Microsoft's div.c found
+// in %MSVC.NET%\crt\src\div.c
+#ifdef STATIC_IMAXDIV // [
+static
+#else // STATIC_IMAXDIV ][
+_inline
+#endif // STATIC_IMAXDIV ]
+imaxdiv_t __cdecl imaxdiv(intmax_t numer, intmax_t denom)
+{
+   imaxdiv_t result;
+
+   result.quot = numer / denom;
+   result.rem = numer % denom;
+
+   if (numer < 0 && result.rem > 0) {
+      // did division wrong; must fix up
+      ++result.quot;
+      result.rem -= denom;
+   }
+
+   return result;
+}
+
+// 7.8.2.3 The strtoimax and strtoumax functions
+#define strtoimax _strtoi64
+#define strtoumax _strtoui64
+
+// 7.8.2.4 The wcstoimax and wcstoumax functions
+#define wcstoimax _wcstoi64
+#define wcstoumax _wcstoui64
+
+
+#endif // _MSC_INTTYPES_H_ ]
diff -r b51a142f9789 -r 26bf6bd35143 headers/ms_stat.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/ms_stat.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,22 @@
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MS_STAT_H_
+#define _MS_STAT_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <sys/stat.h>
+/* Test macros for file types.  */
+
+#define __S_ISTYPE(mode, mask)  (((mode) & S_IFMT) == (mask))
+
+#define S_ISDIR(mode)    __S_ISTYPE((mode), S_IFDIR)
+#define S_ISCHR(mode)    __S_ISTYPE((mode), S_IFCHR)
+#define S_ISBLK(mode)    __S_ISTYPE((mode), S_IFBLK)
+#define S_ISREG(mode)    __S_ISTYPE((mode), S_IFREG)
+
+#endif 
diff -r b51a142f9789 -r 26bf6bd35143 headers/ms_stdint.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/headers/ms_stdint.h	Tue Mar 20 11:59:37 2012 -0500
@@ -0,0 +1,222 @@
+// ISO C9x  compliant stdint.h for Microsoft Visual Studio
+// Based on ISO/IEC 9899:TC2 Committee draft (May 6, 2005) WG14/N1124 
+// 
+//  Copyright (c) 2006 Alexander Chemeris
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//   1. Redistributions of source code must retain the above copyright notice,
+//      this list of conditions and the following disclaimer.
+// 
+//   2. Redistributions in binary form must reproduce the above copyright
+//      notice, this list of conditions and the following disclaimer in the
+//      documentation and/or other materials provided with the distribution.
+// 
+//   3. The name of the author may be used to endorse or promote products
+//      derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+// EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
+// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+// 
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef _MSC_VER // [
+#error "Use this header only with Microsoft Visual C++ compilers!"
+#endif // _MSC_VER ]
+
+#ifndef _MSC_STDINT_H_ // [
+#define _MSC_STDINT_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif
+
+#include <limits.h>
+
+// For Visual Studio 6 in C++ mode wrap <wchar.h> include with 'extern "C++" {}'
+// or compiler give many errors like this:
+//   error C2733: second C linkage of overloaded function 'wmemchr' not allowed
+#if (_MSC_VER < 1300) && defined(__cplusplus)
+   extern "C++" {
+#endif 
+#     include <wchar.h>
+#if (_MSC_VER < 1300) && defined(__cplusplus)
+   }
+#endif
+
+// 7.18.1 Integer types
+
+// 7.18.1.1 Exact-width integer types
+typedef __int8            int8_t;
+typedef __int16           int16_t;
+typedef __int32           int32_t;
+typedef __int64           int64_t;
+typedef unsigned __int8   uint8_t;
+typedef unsigned __int16  uint16_t;
+typedef unsigned __int32  uint32_t;
+typedef unsigned __int64  uint64_t;
+
+// 7.18.1.2 Minimum-width integer types
+typedef int8_t    int_least8_t;
+typedef int16_t   int_least16_t;
+typedef int32_t   int_least32_t;
+typedef int64_t   int_least64_t;
+typedef uint8_t   uint_least8_t;
+typedef uint16_t  uint_least16_t;
+typedef uint32_t  uint_least32_t;
+typedef uint64_t  uint_least64_t;
+
+// 7.18.1.3 Fastest minimum-width integer types
+typedef int8_t    int_fast8_t;
+typedef int16_t   int_fast16_t;
+typedef int32_t   int_fast32_t;
+typedef int64_t   int_fast64_t;
+typedef uint8_t   uint_fast8_t;
+typedef uint16_t  uint_fast16_t;
+typedef uint32_t  uint_fast32_t;
+typedef uint64_t  uint_fast64_t;
+
+// 7.18.1.4 Integer types capable of holding object pointers
+#ifdef _WIN64 // [
+   typedef __int64           intptr_t;
+   typedef unsigned __int64  uintptr_t;
+#else // _WIN64 ][
+   typedef int               intptr_t;
+   typedef unsigned int      uintptr_t;
+#endif // _WIN64 ]
+
+// 7.18.1.5 Greatest-width integer types
+typedef int64_t   intmax_t;
+typedef uint64_t  uintmax_t;
+
+
+// 7.18.2 Limits of specified-width integer types
+
+#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS) // [   See footnote 220 at page 257 and footnote 221 at page 259
+
+// 7.18.2.1 Limits of exact-width integer types
+#define INT8_MIN     ((int8_t)_I8_MIN)
+#define INT8_MAX     _I8_MAX
+#define INT16_MIN    ((int16_t)_I16_MIN)
+#define INT16_MAX    _I16_MAX
+#define INT32_MIN    ((int32_t)_I32_MIN)
+#define INT32_MAX    _I32_MAX
+#define INT64_MIN    ((int64_t)_I64_MIN)
+#define INT64_MAX    _I64_MAX
+#define UINT8_MAX    _UI8_MAX
+#define UINT16_MAX   _UI16_MAX
+#define UINT32_MAX   _UI32_MAX
+#define UINT64_MAX   _UI64_MAX
+
+// 7.18.2.2 Limits of minimum-width integer types
+#define INT_LEAST8_MIN    INT8_MIN
+#define INT_LEAST8_MAX    INT8_MAX
+#define INT_LEAST16_MIN   INT16_MIN
+#define INT_LEAST16_MAX   INT16_MAX
+#define INT_LEAST32_MIN   INT32_MIN
+#define INT_LEAST32_MAX   INT32_MAX
+#define INT_LEAST64_MIN   INT64_MIN
+#define INT_LEAST64_MAX   INT64_MAX
+#define UINT_LEAST8_MAX   UINT8_MAX
+#define UINT_LEAST16_MAX  UINT16_MAX
+#define UINT_LEAST32_MAX  UINT32_MAX
+#define UINT_LEAST64_MAX  UINT64_MAX
+
+// 7.18.2.3 Limits of fastest minimum-width integer types
+#define INT_FAST8_MIN    INT8_MIN
+#define INT_FAST8_MAX    INT8_MAX
+#define INT_FAST16_MIN   INT16_MIN
+#define INT_FAST16_MAX   INT16_MAX
+#define INT_FAST32_MIN   INT32_MIN
+#define INT_FAST32_MAX   INT32_MAX
+#define INT_FAST64_MIN   INT64_MIN
+#define INT_FAST64_MAX   INT64_MAX
+#define UINT_FAST8_MAX   UINT8_MAX
+#define UINT_FAST16_MAX  UINT16_MAX
+#define UINT_FAST32_MAX  UINT32_MAX
+#define UINT_FAST64_MAX  UINT64_MAX
+
+// 7.18.2.4 Limits of integer types capable of holding object pointers
+#ifdef _WIN64 // [
+#  define INTPTR_MIN   INT64_MIN
+#  define INTPTR_MAX   INT64_MAX
+#  define UINTPTR_MAX  UINT64_MAX
+#else // _WIN64 ][
+#  define INTPTR_MIN   INT32_MIN
+#  define INTPTR_MAX   INT32_MAX
+#  define UINTPTR_MAX  UINT32_MAX
+#endif // _WIN64 ]
+
+// 7.18.2.5 Limits of greatest-width integer types
+#define INTMAX_MIN   INT64_MIN
+#define INTMAX_MAX   INT64_MAX
+#define UINTMAX_MAX  UINT64_MAX
+
+// 7.18.3 Limits of other integer types
+
+#ifdef _WIN64 // [
+#  define PTRDIFF_MIN  _I64_MIN
+#  define PTRDIFF_MAX  _I64_MAX
+#else  // _WIN64 ][
+#  define PTRDIFF_MIN  _I32_MIN
+#  define PTRDIFF_MAX  _I32_MAX
+#endif  // _WIN64 ]
+
+#define SIG_ATOMIC_MIN  INT_MIN
+#define SIG_ATOMIC_MAX  INT_MAX
+
+#ifndef SIZE_MAX // [
+#  ifdef _WIN64 // [
+#     define SIZE_MAX  _UI64_MAX
+#  else // _WIN64 ][
+#     define SIZE_MAX  _UI32_MAX
+#  endif // _WIN64 ]
+#endif // SIZE_MAX ]
+
+// WCHAR_MIN and WCHAR_MAX are also defined in <wchar.h>
+#ifndef WCHAR_MIN // [
+#  define WCHAR_MIN  0
+#endif  // WCHAR_MIN ]
+#ifndef WCHAR_MAX // [
+#  define WCHAR_MAX  _UI16_MAX
+#endif  // WCHAR_MAX ]
+
+#define WINT_MIN  0
+#define WINT_MAX  _UI16_MAX
+
+#endif // __STDC_LIMIT_MACROS ]
+
+
+// 7.18.4 Limits of other integer types
+
+#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS) // [   See footnote 224 at page 260
+
+// 7.18.4.1 Macros for minimum-width integer constants
+
+#define INT8_C(val)  val##i8
+#define INT16_C(val) val##i16
+#define INT32_C(val) val##i32
+#define INT64_C(val) val##i64
+
+#define UINT8_C(val)  val##ui8
+#define UINT16_C(val) val##ui16
+#define UINT32_C(val) val##ui32
+#define UINT64_C(val) val##ui64
+
+// 7.18.4.2 Macros for greatest-width integer constants
+#define INTMAX_C   INT64_C
+#define UINTMAX_C  UINT64_C
+
+#endif // __STDC_CONSTANT_MACROS ]
+
+
+#endif // _MSC_STDINT_H_ ]
