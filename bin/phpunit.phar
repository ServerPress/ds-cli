#!/usr/bin/env php
<?php
if (version_compare('7.4.0', PHP_VERSION, '>')) {
    fwrite(
        STDERR,
        sprintf(
            'PHPUnit nightly by Sebastian Bergmann and contributors.' . PHP_EOL . PHP_EOL .
            'This version of PHPUnit requires PHP >= 7.4.' . PHP_EOL .
            'You are using PHP %s (%s).' . PHP_EOL,
            PHP_VERSION,
            PHP_BINARY
        )
    );

    die(1);
}

if (__FILE__ === realpath($_SERVER['SCRIPT_NAME'])) {
    $execute = true;
} else {
    $execute = false;
}

$options = getopt('', array('manifest'));

if (isset($options['manifest'])) {
    $printManifest = true;
}

unset($options);

define('__PHPUNIT_PHAR__', str_replace(DIRECTORY_SEPARATOR, '/', __FILE__));
define('__PHPUNIT_PHAR_ROOT__', 'phar://phpunit-nightly.phar');

Phar::mapPhar('phpunit-nightly.phar');

require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/DeepCopy.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Exception/CloneException.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Exception/PropertyException.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Filter/Filter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Filter/Doctrine/DoctrineCollectionFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Filter/Doctrine/DoctrineEmptyCollectionFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Filter/Doctrine/DoctrineProxyFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Filter/KeepFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Filter/ReplaceFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Filter/SetNullFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Matcher/Matcher.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Matcher/Doctrine/DoctrineProxyMatcher.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Matcher/PropertyMatcher.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Matcher/PropertyNameMatcher.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Matcher/PropertyTypeMatcher.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/Reflection/ReflectionHelper.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeFilter/TypeFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeFilter/Date/DateIntervalFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeFilter/ReplaceFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeFilter/ShallowCopyFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeFilter/Spl/ArrayObjectFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeFilter/Spl/SplDoublyLinkedListFilter.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeFilter/Spl/SplDoublyLinkedList.php';
require 'phar://phpunit-nightly.phar' . '/myclabs-deep-copy/DeepCopy/TypeMatcher/TypeMatcher.php';
require 'phar://phpunit-nightly.phar' . '/doctrine-instantiator/Doctrine/Instantiator/Exception/ExceptionInterface.php';
require 'phar://phpunit-nightly.phar' . '/doctrine-instantiator/Doctrine/Instantiator/Exception/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/doctrine-instantiator/Doctrine/Instantiator/Exception/UnexpectedValueException.php';
require 'phar://phpunit-nightly.phar' . '/doctrine-instantiator/Doctrine/Instantiator/InstantiatorInterface.php';
require 'phar://phpunit-nightly.phar' . '/doctrine-instantiator/Doctrine/Instantiator/Instantiator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/ActualValueIsNotAnObjectException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Assert.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/SelfDescribing.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/AssertionFailedError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/After.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/AfterClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/BackupGlobals.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/BackupStaticProperties.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Before.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/BeforeClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/CodeCoverageIgnore.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/CoversClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/CoversFunction.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/CoversNothing.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DataProvider.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DataProviderExternal.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Depends.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DependsExternal.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DependsExternalUsingDeepClone.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DependsExternalUsingShallowClone.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DependsUsingDeepClone.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DependsUsingShallowClone.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/DoesNotPerformAssertions.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Group.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Large.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Medium.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/PostCondition.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/PreCondition.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/PreserveGlobalState.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresFunction.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresOperatingSystem.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresOperatingSystemFamily.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresPhp.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresPhpExtension.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresPhpunit.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RequiresSetting.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RunClassInSeparateProcess.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RunInSeparateProcess.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/RunTestsInSeparateProcesses.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Small.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Test.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/TestDox.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/TestWith.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/TestWithJson.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/Ticket.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/UsesClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Attributes/UsesFunction.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/CodeCoverageException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/ComparisonMethodDoesNotAcceptParameterTypeException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/ComparisonMethodDoesNotDeclareBoolReturnTypeException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/ComparisonMethodDoesNotDeclareExactlyOneParameterException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/ComparisonMethodDoesNotDeclareParameterTypeException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/ComparisonMethodDoesNotExistException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Constraint.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Traversable/ArrayHasKey.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Operator/Operator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Operator/BinaryOperator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Callback.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Object/ClassHasAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Object/ClassHasStaticAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Cardinality/Count.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Filesystem/DirectoryExists.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Exception/ExceptionCode.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Exception/ExceptionMessage.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Exception/ExceptionMessageRegularExpression.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Filesystem/FileExists.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Cardinality/GreaterThan.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/IsAnything.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Cardinality/IsEmpty.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Equality/IsEqual.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Equality/IsEqualCanonicalizing.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Equality/IsEqualIgnoringCase.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Equality/IsEqualWithDelta.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Boolean/IsFalse.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Math/IsFinite.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/IsIdentical.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Math/IsInfinite.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Type/IsInstanceOf.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/String/IsJson.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Math/IsNan.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Type/IsNull.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Filesystem/IsReadable.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Boolean/IsTrue.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Type/IsType.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Filesystem/IsWritable.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/JsonMatches.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/JsonMatchesErrorMessageProvider.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Cardinality/LessThan.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Operator/LogicalAnd.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Operator/UnaryOperator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Operator/LogicalNot.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Operator/LogicalOr.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Operator/LogicalXor.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Object/ObjectEquals.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Object/ObjectHasAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/String/RegularExpression.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Cardinality/SameSize.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/String/StringContains.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/String/StringEndsWith.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/String/StringMatchesFormatDescription.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/String/StringStartsWith.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Traversable/TraversableContains.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Traversable/TraversableContainsEqual.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Traversable/TraversableContainsIdentical.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Constraint/Traversable/TraversableContainsOnly.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/RiskyTestError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/CoveredCodeNotExecutedException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Reorderable.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Test.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSuite.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/DataProviderTestSuite.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/Error.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestCase.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/ErrorTestCase.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/ExceptionWrapper.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/ExecutionOrderDependency.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/ExpectationFailedException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/IncompleteTest.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/IncompleteTestCase.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/IncompleteTestError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/InvalidCoversTargetException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/InvalidDataProviderException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/InvalidParameterGroupException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/MissingCoversAnnotationException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Api/Api.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/BadMethodCallException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Builder/Identity.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Builder/InvocationStubber.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Builder/Stub.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Builder/ParametersMatch.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Builder/MethodNameMatch.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Builder/InvocationMocker.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/CannotUseAddMethodsException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/CannotUseOnlyMethodsException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/ClassAlreadyExistsException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/ClassIsFinalException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/ConfigurableMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/ConfigurableMethodsAlreadyInitializedException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/DuplicateMethodException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/TemplateLoader.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Generator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/IncompatibleReturnValueException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/InvalidMethodNameException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Invocation.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/InvocationHandler.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/MatchBuilderNotFoundException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Matcher.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/MatcherAlreadyRegisteredException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Api/Method.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/MethodCannotBeConfiguredException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/MethodNameAlreadyConfiguredException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MethodNameConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/MethodNameNotConfiguredException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/MethodParametersAlreadyConfiguredException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MockBuilder.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MockType.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MockClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MockMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MockMethodSet.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MockObject.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/MockTrait.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Api/MockedCloneMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/OriginalConstructorInvocationRequiredException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/ReflectionException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/ReturnValueNotConfiguredException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Verifiable.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/InvocationOrder.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/AnyInvokedCount.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/ParametersRule.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/AnyParameters.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/ConsecutiveParameters.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/InvokedAtLeastCount.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/InvokedAtLeastOnce.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/InvokedAtMostCount.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/InvokedCount.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/MethodName.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Rule/Parameters.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/SoapExtensionNotAvailableException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/Stub.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/ConsecutiveCalls.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/ReturnArgument.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/ReturnCallback.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/ReturnReference.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/ReturnSelf.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/ReturnStub.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Stub/ReturnValueMap.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/UnknownClassException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/UnknownTraitException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Exception/UnknownTypeException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/MockObject/Api/UnmockedCloneMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/NoChildTestSuiteException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/OutputError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/SyntheticError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/PHPTAssertionFailedError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/SkippedTest.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/SkippedTestCase.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/SkippedTestError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/SkippedTestSuiteError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/SyntheticSkippedError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestBuilder.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestFailure.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestListener.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestResult.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestRunner.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSize/TestSize.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSize/Known.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSize/Large.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSize/Medium.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSize/Small.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSize/Unknown.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/TestStatus.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Known.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Error.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Failure.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Incomplete.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Risky.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Skipped.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Success.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Unknown.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestStatus/Warning.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/TestSuiteIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/UnintentionallyCoveredCodeError.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/Exception/Warning.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Framework/WarningTestCase.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Metadata.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/After.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/AfterClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/Parser.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/AnnotationParser.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/Annotation/DocBlock.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/Annotation/Registry.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/AttributeParser.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/BackupGlobals.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/BackupStaticProperties.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Before.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/BeforeClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/CachingParser.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Facade/CodeCoverageFacade.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/CodeCoverageIgnore.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Covers.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/CoversClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/CoversDefaultClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/CoversFunction.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/CoversMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/CoversNothing.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/DataProvider.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Facade/DataProviderFacade.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Depends.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/DoesNotPerformAssertions.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Group.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Facade/GroupsFacade.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Facade/HookFacade.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/InlineAnnotationParser.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Exception/InvalidVersionRequirementException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/MetadataCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/MetadataCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Exception/NoVersionRequirementException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/ParserChain.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/PostCondition.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/PreCondition.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/PreserveGlobalState.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Parser/Registry.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Facade/RequirementsFacade.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresFunction.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresOperatingSystem.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresOperatingSystemFamily.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresPhp.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresPhpExtension.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresPhpunit.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RequiresSetting.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RunClassInSeparateProcess.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RunInSeparateProcess.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/RunTestsInSeparateProcesses.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Test.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/TestDox.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/TestWith.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Todo.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/Uses.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/UsesClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/UsesDefaultClass.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/UsesFunction.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/UsesMethod.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/VersionRequirement.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/VersionComparisonRequirement.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Metadata/VersionConstraintRequirement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Type.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Application.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/ApplicationName.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Author.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/AuthorCollection.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/AuthorCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ManifestElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/AuthorElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ElementCollection.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/AuthorElementCollection.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/BundledComponent.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/BundledComponentCollection.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/BundledComponentCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/BundlesElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ComponentElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ComponentElementCollection.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ContainsElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/CopyrightElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/CopyrightInformation.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/ElementCollectionException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Email.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ExtElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ExtElementCollection.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Extension.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ExtensionElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/InvalidApplicationNameException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/InvalidEmailException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/InvalidUrlException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Library.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/License.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/LicenseElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Manifest.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/ManifestDocument.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/ManifestDocumentException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/ManifestDocumentLoadingException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/ManifestDocumentMapper.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/ManifestDocumentMapperException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/ManifestElementException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/ManifestLoader.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/exceptions/ManifestLoaderException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/ManifestSerializer.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/PhpElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Requirement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/PhpExtensionRequirement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/PhpVersionRequirement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/RequirementCollection.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/RequirementCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/xml/RequiresElement.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-manifest/values/Url.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/VersionConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/AbstractVersionConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/AndVersionConstraintGroup.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/AnyVersionConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/ExactVersionConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/GreaterThanOrEqualToVersionConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/exceptions/InvalidPreReleaseSuffixException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/exceptions/InvalidVersionException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/exceptions/NoPreReleaseSuffixException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/OrVersionConstraintGroup.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/PreReleaseSuffix.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/SpecificMajorAndMinorVersionConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/constraints/SpecificMajorVersionConstraint.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/exceptions/UnsupportedVersionConstraintException.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/Version.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/VersionConstraintParser.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/VersionConstraintValue.php';
require 'phar://phpunit-nightly.phar' . '/phar-io-version/VersionNumber.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/BuilderFactory.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/BuilderHelpers.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/ClassConst.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Declaration.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Class_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/FunctionLike.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Function_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Interface_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Method.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Namespace_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Param.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Property.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/TraitUse.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/TraitUseAdaptation.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Trait_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Builder/Use_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Comment.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Comment/Doc.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/ConstExprEvaluationException.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/ConstExprEvaluator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Error.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/ErrorHandler.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/ErrorHandler/Collecting.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/ErrorHandler/Throwing.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Internal/DiffElem.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Internal/Differ.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeAbstract.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Internal/PrintableNewAnonClassNode.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Internal/TokenStream.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/JsonDecoder.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/Emulative.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/TokenEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/AttributeEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/CoaleseEqualTokenEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/KeywordEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/EnumTokenEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/FlexibleDocStringEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/FnTokenEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/MatchTokenEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/NullsafeTokenEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/NumericLiteralSeparatorEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Lexer/TokenEmulator/ReverseEmulator.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NameContext.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeDumper.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeFinder.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeTraverserInterface.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeTraverser.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitorAbstract.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitor/CloningVisitor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitor/FindingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitor/FirstFindingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitor/NameResolver.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitor/NodeConnectingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/NodeVisitor/ParentConnectingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Arg.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Attribute.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/AttributeGroup.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Const_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ArrayDimFetch.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ArrayItem.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Array_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/FunctionLike.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ArrowFunction.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Assign.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/BitwiseAnd.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/BitwiseOr.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/BitwiseXor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Coalesce.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Concat.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Div.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Minus.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Mod.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Mul.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Plus.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/Pow.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/ShiftLeft.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignOp/ShiftRight.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/AssignRef.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BitwiseAnd.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BitwiseOr.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BitwiseXor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BooleanAnd.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BooleanOr.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Coalesce.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Concat.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Div.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Equal.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Greater.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/GreaterOrEqual.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Identical.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/LogicalAnd.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/LogicalOr.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/LogicalXor.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Minus.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Mod.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Mul.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/NotEqual.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/NotIdentical.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Plus.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Pow.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/ShiftLeft.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/ShiftRight.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Smaller.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/SmallerOrEqual.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Spaceship.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BitwiseNot.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/BooleanNot.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast/Array_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast/Bool_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast/Double.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast/Int_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast/Object_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast/String_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Cast/Unset_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ClassConstFetch.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Clone_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Closure.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ClosureUse.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ConstFetch.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Empty_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Error.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ErrorSuppress.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Eval_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Exit_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/FuncCall.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Include_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Instanceof_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Isset_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/List_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Match_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/MethodCall.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/New_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/NullsafeMethodCall.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/NullsafePropertyFetch.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/PostDec.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/PostInc.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/PreDec.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/PreInc.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Print_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/PropertyFetch.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/ShellExec.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/StaticCall.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/StaticPropertyFetch.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Ternary.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Throw_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/UnaryMinus.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/UnaryPlus.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Variable.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/YieldFrom.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Expr/Yield_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Identifier.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/MatchArm.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Name.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Name/FullyQualified.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Name/Relative.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/NullableType.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Param.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/DNumber.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/Encapsed.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/EncapsedStringPart.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/LNumber.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Class_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Dir.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/File.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Function_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Line.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Method.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Namespace_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Trait_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Scalar/String_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Break_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Case_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Catch_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/ClassConst.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/ClassLike.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/ClassMethod.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Class_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Const_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Continue_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/DeclareDeclare.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Declare_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Do_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Echo_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/ElseIf_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Else_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/EnumCase.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Enum_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Expression.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Finally_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/For_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Foreach_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Function_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Global_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Goto_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/GroupUse.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/HaltCompiler.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/If_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/InlineHTML.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Interface_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Label.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Namespace_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Nop.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Property.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/PropertyProperty.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Return_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/StaticVar.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Static_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Switch_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Throw_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/TraitUse.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/TraitUseAdaptation.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/TraitUseAdaptation/Alias.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/TraitUseAdaptation/Precedence.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Trait_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/TryCatch.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Unset_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/UseUse.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/Use_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/Stmt/While_.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/UnionType.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Node/VarLikeIdentifier.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Parser.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/ParserAbstract.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/ParserFactory.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Parser/Multiple.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Parser/Php5.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Parser/Php7.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/Parser/Tokens.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/PrettyPrinterAbstract.php';
require 'phar://phpunit-nightly.phar' . '/nikic-php-parser/PhpParser/PrettyPrinter/Standard.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/Hook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/TestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterIncompleteTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterLastTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterRiskyTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterSkippedTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterSuccessfulTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterTestErrorHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterTestFailureHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/AfterTestWarningHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/BeforeFirstTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/BeforeTestHook.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/CodeCoverage.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/TestResultCache.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/DefaultTestResultCache.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Extension/ExtensionHandler.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Extension/PharLoader.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Filter/GroupFilterIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Filter/ExcludeGroupFilterIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Filter/Factory.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Filter/IncludeGroupFilterIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Filter/NameFilterIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/NullTestResultCache.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/PhptTestCase.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/ResultCacheExtension.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Hook/TestListenerAdapter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/TestSuiteLoader.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/TestSuiteSorter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Runner/Version.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-cli-parser/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-cli-parser/exceptions/AmbiguousOptionException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-cli-parser/exceptions/OptionDoesNotAllowArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-cli-parser/Parser.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-cli-parser/exceptions/RequiredOptionArgumentMissingException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-cli-parser/exceptions/UnknownOptionException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/BranchAndPathCoverageNotSupportedException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/CodeCoverage.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/CrapIndex.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/DeadCodeDetectionNotSupportedException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Directory.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/DirectoryCouldNotBeCreatedException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Driver/Driver.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/PathExistsButIsNotDirectoryException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Driver/PcovDriver.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/PcovNotAvailableException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Driver/PhpdbgDriver.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/PhpdbgNotAvailableException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Driver/Selector.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/WriteOperationFailedException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/WrongXdebugVersionException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Driver/Xdebug2Driver.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/Xdebug2NotEnabledException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Driver/Xdebug3Driver.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/Xdebug3NotEnabledException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/XdebugNotAvailableException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Filter.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/NoCodeCoverageDriverAvailableException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/NoCodeCoverageDriverWithPathCoverageSupportAvailableException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Node/AbstractNode.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Node/Builder.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Node/Directory.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Node/File.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Node/Iterator.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/ParserException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Percentage.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/ProcessedCodeCoverageData.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/RawCodeCoverageData.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/ReflectionException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/ReportAlreadyFinalizedException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Clover.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Cobertura.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Crap4j.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Html/Renderer.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Html/Renderer/Dashboard.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Html/Renderer/Directory.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Html/Facade.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Html/Renderer/File.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/PHP.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Text.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/BuildInformation.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Coverage.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Node.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Directory.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Facade.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/File.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Method.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Project.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Report.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Source.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Tests.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Totals.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Report/Xml/Unit.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/StaticAnalysisCacheNotConfiguredException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/Cache.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/CacheWarmer.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/CoveredFileAnalyser.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/CachingCoveredFileAnalyser.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/UncoveredFileAnalyser.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/CachingUncoveredFileAnalyser.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/CodeUnitFindingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/ExecutableLinesFindingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/IgnoredLinesFindingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/ParsingCoveredFileAnalyser.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/StaticAnalysis/ParsingUncoveredFileAnalyser.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/TestIdMissingException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/UnintentionallyCoveredCodeException.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Version.php';
require 'phar://phpunit-nightly.phar' . '/php-code-coverage/Exception/XmlException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit-reverse-lookup/Wizard.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/CodeUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/ClassMethodUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/ClassUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/CodeUnitCollection.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/CodeUnitCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/FileUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/FunctionUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/InterfaceMethodUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/InterfaceUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/exceptions/InvalidCodeUnitException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/Mapper.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/exceptions/NoTraitException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/exceptions/ReflectionException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/TraitMethodUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-code-unit/TraitUnit.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/Comparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/ArrayComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/ComparisonFailure.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/ObjectComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/DOMNodeComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/DateTimeComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/ScalarComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/NumericComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/DoubleComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/ExceptionComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/Factory.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/MockObjectComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/ResourceComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/exceptions/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/SplObjectStorageComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-comparator/TypeComparator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Calculator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Complexity/Complexity.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Visitor/ComplexityCalculatingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Complexity/ComplexityCollection.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Complexity/ComplexityCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Visitor/CyclomaticComplexityCalculatingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-complexity/Exception/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Chunk.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Exception/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Exception/ConfigurationException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Diff.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Differ.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Line.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/LongestCommonSubsequenceCalculator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/MemoryEfficientLongestCommonSubsequenceCalculator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Output/DiffOutputBuilderInterface.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Output/AbstractChunkOutputBuilder.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Output/DiffOnlyOutputBuilder.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Output/StrictUnifiedDiffOutputBuilder.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Output/UnifiedDiffOutputBuilder.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/Parser.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-diff/TimeEfficientLongestCommonSubsequenceCalculator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-environment/Console.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-environment/OperatingSystem.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-environment/Runtime.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-exporter/Exporter.php';
require 'phar://phpunit-nightly.phar' . '/php-file-iterator/Facade.php';
require 'phar://phpunit-nightly.phar' . '/php-file-iterator/Factory.php';
require 'phar://phpunit-nightly.phar' . '/php-file-iterator/Iterator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-global-state/CodeExporter.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-global-state/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-global-state/ExcludeList.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-global-state/Restorer.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-global-state/exceptions/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-global-state/Snapshot.php';
require 'phar://phpunit-nightly.phar' . '/php-invoker/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/php-invoker/Invoker.php';
require 'phar://phpunit-nightly.phar' . '/php-invoker/exceptions/ProcessControlExtensionNotLoadedException.php';
require 'phar://phpunit-nightly.phar' . '/php-invoker/exceptions/TimeoutException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-lines-of-code/Counter.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-lines-of-code/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-lines-of-code/Exception/IllogicalValuesException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-lines-of-code/LineCountingVisitor.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-lines-of-code/LinesOfCode.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-lines-of-code/Exception/NegativeValueException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-lines-of-code/Exception/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-object-enumerator/Enumerator.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-object-enumerator/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-object-enumerator/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-object-reflector/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-object-reflector/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-object-reflector/ObjectReflector.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-recursion-context/Context.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-recursion-context/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-recursion-context/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-resource-operations/ResourceOperations.php';
require 'phar://phpunit-nightly.phar' . '/php-text-template/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/php-text-template/exceptions/InvalidArgumentException.php';
require 'phar://phpunit-nightly.phar' . '/php-text-template/exceptions/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/php-text-template/Template.php';
require 'phar://phpunit-nightly.phar' . '/php-timer/Duration.php';
require 'phar://phpunit-nightly.phar' . '/php-timer/exceptions/Exception.php';
require 'phar://phpunit-nightly.phar' . '/php-timer/exceptions/NoActiveTimerException.php';
require 'phar://phpunit-nightly.phar' . '/php-timer/ResourceUsageFormatter.php';
require 'phar://phpunit-nightly.phar' . '/php-timer/exceptions/TimeSinceStartOfRequestNotAvailableException.php';
require 'phar://phpunit-nightly.phar' . '/php-timer/Timer.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/Type.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/CallableType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/GenericObjectType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/IterableType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/MixedType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/NullType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/ObjectType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/ReflectionMapper.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/exception/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/SimpleType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/StaticType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/TypeName.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/UnionType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/UnknownType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-type/VoidType.php';
require 'phar://phpunit-nightly.phar' . '/sebastian-version/Version.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/CliArguments/Builder.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/CliArguments/Configuration.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/CliArguments/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/CliArguments/Mapper.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/Command.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/ResultPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Printer.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/DefaultResultPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/Exception/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/Help.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/Exception/ReflectionException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/Exception/RuntimeException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/Exception/TestDirectoryNotFoundException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/Exception/TestFileNotFoundException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/TestRunner.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/TestSuiteMapper.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/CodeCoverage.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/FilterMapper.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Filter/Directory.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Filter/DirectoryCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Filter/DirectoryCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Clover.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Cobertura.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Crap4j.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Html.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Php.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Text.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Xml.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Configuration.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/Constant.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/ConstantCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/ConstantCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/Migration.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/ConvertLogTypes.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/LogToReportMigration.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageCloverToReport.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageCrap4jToReport.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageHtmlToReport.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoveragePhpToReport.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageTextToReport.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageXmlToReport.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Filesystem/Directory.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Filesystem/DirectoryCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Filesystem/DirectoryCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHPUnit/Extension.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHPUnit/ExtensionCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHPUnit/ExtensionCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Filesystem/File.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Filesystem/FileCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Filesystem/FileCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Generator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Group/Group.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Group/GroupCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Group/GroupCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Group/Groups.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/IniSetting.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/IniSettingCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/IniSettingCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/IntroduceCacheDirectoryAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/IntroduceCoverageElement.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Loader.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Logging/Junit.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Logging/Logging.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Logging/TeamCity.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Logging/TestDox/Html.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Logging/TestDox/Text.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Logging/TestDox/Xml.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Logging/Text.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/MigrationBuilder.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/MigrationBuilderException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/MigrationException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveAttributesFromFilterWhitelistToCoverage.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveAttributesFromRootToCoverage.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveWhitelistDirectoriesToCoverage.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveWhitelistExcludesToCoverage.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHPUnit/PHPUnit.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/Php.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/PhpHandler.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCacheResultFileAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCacheTokensAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCoverageElementCacheDirectoryAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCoverageElementProcessUncoveredFilesAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveEmptyFilter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveListeners.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveLogTypes.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveTestSuiteLoaderAttributes.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/RenameBackupStaticAttributesAttribute.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestDirectory.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestDirectoryCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestDirectoryCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestFile.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestFileCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestFileCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestSuite.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestSuiteCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/TestSuite/TestSuiteCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/Migration/Migrations/UpdateSchemaLocation.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/Variable.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/VariableCollection.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/TextUI/XmlConfiguration/PHP/VariableCollectionIterator.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/Exception.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/NamespaceUri.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/NamespaceUriException.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/Token.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/TokenCollection.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/TokenCollectionException.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/Tokenizer.php';
require 'phar://phpunit-nightly.phar' . '/theseer-tokenizer/XMLSerializer.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Color.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Error/Error.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Error/Deprecation.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Error/Handler.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Error/Notice.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Error/Warning.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/ExcludeList.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Filesystem.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Filter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/GlobalState.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/InvalidDataSetException.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Json.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Log/JUnit.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Log/TeamCity.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/PHP/AbstractPhpProcess.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/PHP/DefaultPhpProcess.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/PHP/WindowsPhpProcess.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/RegularExpression.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Test.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TestDox/TestDoxPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TestDox/CliTestDoxPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TestDox/ResultPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TestDox/HtmlResultPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TestDox/NamePrettifier.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TestDox/TextResultPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TestDox/XmlResultPrinter.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/TextTestListRenderer.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Type.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/VersionComparisonOperator.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Warning.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/XmlTestListRenderer.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/Exception.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/SchemaDetectionResult.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/FailedSchemaDetectionResult.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/Loader.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/SchemaDetector.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/SchemaFinder.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/SnapshotNodeList.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/SuccessfulSchemaDetectionResult.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/ValidationResult.php';
require 'phar://phpunit-nightly.phar' . '/phpunit/Util/Xml/Validator.php';
require __PHPUNIT_PHAR_ROOT__ . '/phpunit/Framework/Assert/Functions.php';

if ($execute) {
    if (isset($printManifest)) {
        print file_get_contents(__PHPUNIT_PHAR_ROOT__ . '/manifest.txt');

        exit;
    }

    unset($execute);

    PHPUnit\TextUI\Command::main();
}

__HALT_COMPILER(); ?>
H I         phpunit-nightly.phar    L   doctrine-instantiator/Doctrine/Instantiator/Exception/ExceptionInterface.php   `   Vm      R   doctrine-instantiator/Doctrine/Instantiator/Exception/InvalidArgumentException.php  `  O>      R   doctrine-instantiator/Doctrine/Instantiator/Exception/UnexpectedValueException.phpX  `X  7n      <   doctrine-instantiator/Doctrine/Instantiator/Instantiator.php  `  `      E   doctrine-instantiator/Doctrine/Instantiator/InstantiatorInterface.php  `  vh         doctrine-instantiator/LICENSE$  `$  
         manifest.txt6  `6  oe      '   myclabs-deep-copy/DeepCopy/DeepCopy.php`  ``  I*C      7   myclabs-deep-copy/DeepCopy/Exception/CloneException.php   `   H      :   myclabs-deep-copy/DeepCopy/Exception/PropertyException.php   `   =      G   myclabs-deep-copy/DeepCopy/Filter/Doctrine/DoctrineCollectionFilter.php@  `@  1,      L   myclabs-deep-copy/DeepCopy/Filter/Doctrine/DoctrineEmptyCollectionFilter.php;  `;  K1d      B   myclabs-deep-copy/DeepCopy/Filter/Doctrine/DoctrineProxyFilter.php  `  n)K      ,   myclabs-deep-copy/DeepCopy/Filter/Filter.phpd  `d  M      0   myclabs-deep-copy/DeepCopy/Filter/KeepFilter.php(  `(  9[      3   myclabs-deep-copy/DeepCopy/Filter/ReplaceFilter.php  `        3   myclabs-deep-copy/DeepCopy/Filter/SetNullFilter.php'  `'  L      D   myclabs-deep-copy/DeepCopy/Matcher/Doctrine/DoctrineProxyMatcher.php  `  B      .   myclabs-deep-copy/DeepCopy/Matcher/Matcher.php   `         6   myclabs-deep-copy/DeepCopy/Matcher/PropertyMatcher.php  `        :   myclabs-deep-copy/DeepCopy/Matcher/PropertyNameMatcher.php  `  (Z      :   myclabs-deep-copy/DeepCopy/Matcher/PropertyTypeMatcher.phpj  `j  03      :   myclabs-deep-copy/DeepCopy/Reflection/ReflectionHelper.phpT  `T        A   myclabs-deep-copy/DeepCopy/TypeFilter/Date/DateIntervalFilter.php  `  N      7   myclabs-deep-copy/DeepCopy/TypeFilter/ReplaceFilter.php0  `0  /      ;   myclabs-deep-copy/DeepCopy/TypeFilter/ShallowCopyFilter.php  `  a7      ?   myclabs-deep-copy/DeepCopy/TypeFilter/Spl/ArrayObjectFilter.php  `  7      A   myclabs-deep-copy/DeepCopy/TypeFilter/Spl/SplDoublyLinkedList.php   `   n      G   myclabs-deep-copy/DeepCopy/TypeFilter/Spl/SplDoublyLinkedListFilter.php`  ``  #QK      4   myclabs-deep-copy/DeepCopy/TypeFilter/TypeFilter.php   `   VD      6   myclabs-deep-copy/DeepCopy/TypeMatcher/TypeMatcher.php  `  QB      (   myclabs-deep-copy/DeepCopy/deep_copy.php  `  bS         myclabs-deep-copy/LICENSE5  `5           nikic-php-parser/LICENSE  `  *      &   nikic-php-parser/PhpParser/Builder.php   `   +`      1   nikic-php-parser/PhpParser/Builder/ClassConst.php  `  mr?      -   nikic-php-parser/PhpParser/Builder/Class_.php1  `1  o      2   nikic-php-parser/PhpParser/Builder/Declaration.php  `  @%w      3   nikic-php-parser/PhpParser/Builder/FunctionLike.php  `  "gG      0   nikic-php-parser/PhpParser/Builder/Function_.php  `  2      1   nikic-php-parser/PhpParser/Builder/Interface_.phpo  `o  (      -   nikic-php-parser/PhpParser/Builder/Method.php  `  wJ      1   nikic-php-parser/PhpParser/Builder/Namespace_.php  `  4      ,   nikic-php-parser/PhpParser/Builder/Param.php2
  `2
        /   nikic-php-parser/PhpParser/Builder/Property.php  `  _b      /   nikic-php-parser/PhpParser/Builder/TraitUse.php  `  N9r      9   nikic-php-parser/PhpParser/Builder/TraitUseAdaptation.phpa  `a  7OU      -   nikic-php-parser/PhpParser/Builder/Trait_.php  `        +   nikic-php-parser/PhpParser/Builder/Use_.phpH  `H  Z_      -   nikic-php-parser/PhpParser/BuilderFactory.php,  `,  +n      -   nikic-php-parser/PhpParser/BuilderHelpers.php&  `&  ke;      &   nikic-php-parser/PhpParser/Comment.php  `        *   nikic-php-parser/PhpParser/Comment/Doc.phpx   `x   p      ;   nikic-php-parser/PhpParser/ConstExprEvaluationException.php_   `_   I      1   nikic-php-parser/PhpParser/ConstExprEvaluator.php''  `''  R>`      $   nikic-php-parser/PhpParser/Error.php  `  QZ      +   nikic-php-parser/PhpParser/ErrorHandler.phpB  `B  Q      6   nikic-php-parser/PhpParser/ErrorHandler/Collecting.php  `  L      4   nikic-php-parser/PhpParser/ErrorHandler/Throwing.php  `  $      0   nikic-php-parser/PhpParser/Internal/DiffElem.php7  `7  $      .   nikic-php-parser/PhpParser/Internal/Differ.phpa  `a  h\      A   nikic-php-parser/PhpParser/Internal/PrintableNewAnonClassNode.phpz  `z  94`      3   nikic-php-parser/PhpParser/Internal/TokenStream.php%#  `%#  D      *   nikic-php-parser/PhpParser/JsonDecoder.phpl  `l  +;)Z      $   nikic-php-parser/PhpParser/Lexer.php>X  `>X  \      .   nikic-php-parser/PhpParser/Lexer/Emulative.php#  `#  O      D   nikic-php-parser/PhpParser/Lexer/TokenEmulator/AttributeEmulator.php'  `'  t}      L   nikic-php-parser/PhpParser/Lexer/TokenEmulator/CoaleseEqualTokenEmulator.phpK  `K  c_      D   nikic-php-parser/PhpParser/Lexer/TokenEmulator/EnumTokenEmulator.php  `        L   nikic-php-parser/PhpParser/Lexer/TokenEmulator/FlexibleDocStringEmulator.php	  `	  dM      B   nikic-php-parser/PhpParser/Lexer/TokenEmulator/FnTokenEmulator.php  `        B   nikic-php-parser/PhpParser/Lexer/TokenEmulator/KeywordEmulator.php  `  yh      E   nikic-php-parser/PhpParser/Lexer/TokenEmulator/MatchTokenEmulator.php  `  lJ3      H   nikic-php-parser/PhpParser/Lexer/TokenEmulator/NullsafeTokenEmulator.php  `  p      R   nikic-php-parser/PhpParser/Lexer/TokenEmulator/NumericLiteralSeparatorEmulator.php  `        B   nikic-php-parser/PhpParser/Lexer/TokenEmulator/ReverseEmulator.php6  `6  k      @   nikic-php-parser/PhpParser/Lexer/TokenEmulator/TokenEmulator.phpu  `u  D4h      *   nikic-php-parser/PhpParser/NameContext.php)  `)        #   nikic-php-parser/PhpParser/Node.php  `  y      '   nikic-php-parser/PhpParser/Node/Arg.phpC  `C  )      -   nikic-php-parser/PhpParser/Node/Attribute.phps  `s  :	      2   nikic-php-parser/PhpParser/Node/AttributeGroup.php  `  1s      *   nikic-php-parser/PhpParser/Node/Const_.php1  `1  t[1      (   nikic-php-parser/PhpParser/Node/Expr.php   `   /J      6   nikic-php-parser/PhpParser/Node/Expr/ArrayDimFetch.php  `  0      2   nikic-php-parser/PhpParser/Node/Expr/ArrayItem.php  `        /   nikic-php-parser/PhpParser/Node/Expr/Array_.phpP  `P  b      6   nikic-php-parser/PhpParser/Node/Expr/ArrowFunction.php	  `	  #      /   nikic-php-parser/PhpParser/Node/Expr/Assign.php_  `_  !      1   nikic-php-parser/PhpParser/Node/Expr/AssignOp.php+  `+  uK      <   nikic-php-parser/PhpParser/Node/Expr/AssignOp/BitwiseAnd.php  `        ;   nikic-php-parser/PhpParser/Node/Expr/AssignOp/BitwiseOr.php  `  *      <   nikic-php-parser/PhpParser/Node/Expr/AssignOp/BitwiseXor.php  `        :   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Coalesce.php  `  U7      8   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Concat.php  `        5   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Div.php  `  A-      7   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Minus.php  `  O6:      5   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Mod.php  `  ksLH      5   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Mul.php  `  $      6   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Plus.php  `  'n      5   nikic-php-parser/PhpParser/Node/Expr/AssignOp/Pow.php  `  f      ;   nikic-php-parser/PhpParser/Node/Expr/AssignOp/ShiftLeft.php  `  6      <   nikic-php-parser/PhpParser/Node/Expr/AssignOp/ShiftRight.php  `  FX      2   nikic-php-parser/PhpParser/Node/Expr/AssignRef.php  `  '~      1   nikic-php-parser/PhpParser/Node/Expr/BinaryOp.php  `  uu6      <   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BitwiseAnd.phpm  `m  \      ;   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BitwiseOr.phpk  `k  X      <   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BitwiseXor.phpm  `m  x      <   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BooleanAnd.phpn  `n  |      ;   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/BooleanOr.phpl  `l  ( (      :   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Coalesce.phpj  `j        8   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Concat.phpe  `e  !      5   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Div.php_  `_  <      7   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Equal.phpd  `d        9   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Greater.phpg  `g  Eq      @   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/GreaterOrEqual.phpv  `v  8:      ;   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Identical.phpm  `m  m+y      <   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/LogicalAnd.phpo  `o  =^      ;   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/LogicalOr.phpl  `l  l      <   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/LogicalXor.phpo  `o  n      7   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Minus.phpc  `c  _R      5   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Mod.php_  `_  =S      5   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Mul.php_  `_  02(      :   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/NotEqual.phpj  `j  d*      >   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/NotIdentical.phps  `s        6   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Plus.phpa  `a  !g      5   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Pow.php`  ``  -      ;   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/ShiftLeft.phpl  `l  6(      <   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/ShiftRight.phpn  `n        9   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Smaller.phpg  `g        @   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/SmallerOrEqual.phpv  `v  nuw      ;   nikic-php-parser/PhpParser/Node/Expr/BinaryOp/Spaceship.phpm  `m  C      3   nikic-php-parser/PhpParser/Node/Expr/BitwiseNot.php  `         3   nikic-php-parser/PhpParser/Node/Expr/BooleanNot.php  `  x'      -   nikic-php-parser/PhpParser/Node/Expr/Cast.phpq  `q  2:      4   nikic-php-parser/PhpParser/Node/Expr/Cast/Array_.php  `  'a      3   nikic-php-parser/PhpParser/Node/Expr/Cast/Bool_.php  `  m      4   nikic-php-parser/PhpParser/Node/Expr/Cast/Double.php  `        2   nikic-php-parser/PhpParser/Node/Expr/Cast/Int_.php   `   V!      5   nikic-php-parser/PhpParser/Node/Expr/Cast/Object_.php  `  B7lS      5   nikic-php-parser/PhpParser/Node/Expr/Cast/String_.php  `  D      4   nikic-php-parser/PhpParser/Node/Expr/Cast/Unset_.php  `  vd      8   nikic-php-parser/PhpParser/Node/Expr/ClassConstFetch.php$  `$  V6      /   nikic-php-parser/PhpParser/Node/Expr/Clone_.php  `  1{I      0   nikic-php-parser/PhpParser/Node/Expr/Closure.php
  `
        3   nikic-php-parser/PhpParser/Node/Expr/ClosureUse.php  `  ,      3   nikic-php-parser/PhpParser/Node/Expr/ConstFetch.php  `  dT      /   nikic-php-parser/PhpParser/Node/Expr/Empty_.php  `  /e      .   nikic-php-parser/PhpParser/Node/Expr/Error.php  `  \^      6   nikic-php-parser/PhpParser/Node/Expr/ErrorSuppress.php  `  c      .   nikic-php-parser/PhpParser/Node/Expr/Eval_.php  `        .   nikic-php-parser/PhpParser/Node/Expr/Exit_.php5  `5  0}      1   nikic-php-parser/PhpParser/Node/Expr/FuncCall.php  `        1   nikic-php-parser/PhpParser/Node/Expr/Include_.php  `  :Z?/      4   nikic-php-parser/PhpParser/Node/Expr/Instanceof_.php  `  c(o      /   nikic-php-parser/PhpParser/Node/Expr/Isset_.php  `  :u      .   nikic-php-parser/PhpParser/Node/Expr/List_.php  `  m      /   nikic-php-parser/PhpParser/Node/Expr/Match_.php  `  K      3   nikic-php-parser/PhpParser/Node/Expr/MethodCall.php  `        -   nikic-php-parser/PhpParser/Node/Expr/New_.php  `        ;   nikic-php-parser/PhpParser/Node/Expr/NullsafeMethodCall.php  `  t      >   nikic-php-parser/PhpParser/Node/Expr/NullsafePropertyFetch.php9  `9  a      0   nikic-php-parser/PhpParser/Node/Expr/PostDec.php  `  ]      0   nikic-php-parser/PhpParser/Node/Expr/PostInc.php  `  /      /   nikic-php-parser/PhpParser/Node/Expr/PreDec.php  `  *i      /   nikic-php-parser/PhpParser/Node/Expr/PreInc.php  `  tw{      /   nikic-php-parser/PhpParser/Node/Expr/Print_.php  `  K>      6   nikic-php-parser/PhpParser/Node/Expr/PropertyFetch.php  `  C'      2   nikic-php-parser/PhpParser/Node/Expr/ShellExec.php  `  z-      3   nikic-php-parser/PhpParser/Node/Expr/StaticCall.php  `  |Z      <   nikic-php-parser/PhpParser/Node/Expr/StaticPropertyFetch.phpV  `V  <      0   nikic-php-parser/PhpParser/Node/Expr/Ternary.php6  `6  P      /   nikic-php-parser/PhpParser/Node/Expr/Throw_.php  `        3   nikic-php-parser/PhpParser/Node/Expr/UnaryMinus.php  `        2   nikic-php-parser/PhpParser/Node/Expr/UnaryPlus.php  `        1   nikic-php-parser/PhpParser/Node/Expr/Variable.php  `  m      2   nikic-php-parser/PhpParser/Node/Expr/YieldFrom.php  `  ">      /   nikic-php-parser/PhpParser/Node/Expr/Yield_.php  `  t      0   nikic-php-parser/PhpParser/Node/FunctionLike.php  `  i      .   nikic-php-parser/PhpParser/Node/Identifier.php   `   .      ,   nikic-php-parser/PhpParser/Node/MatchArm.php  `  .      (   nikic-php-parser/PhpParser/Node/Name.php%  `%  k&       7   nikic-php-parser/PhpParser/Node/Name/FullyQualified.php  `  	      1   nikic-php-parser/PhpParser/Node/Name/Relative.php  `  Ef      0   nikic-php-parser/PhpParser/Node/NullableType.php'  `'  J/      )   nikic-php-parser/PhpParser/Node/Param.php	  `	        *   nikic-php-parser/PhpParser/Node/Scalar.php   `   67      2   nikic-php-parser/PhpParser/Node/Scalar/DNumber.phpi  `i        3   nikic-php-parser/PhpParser/Node/Scalar/Encapsed.php  `  1T      =   nikic-php-parser/PhpParser/Node/Scalar/EncapsedStringPart.php  `  0      2   nikic-php-parser/PhpParser/Node/Scalar/LNumber.php:
  `:
  _:      5   nikic-php-parser/PhpParser/Node/Scalar/MagicConst.php{  `{  l:      <   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Class_.phps  `s  	i      9   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Dir.phpl  `l  ;K      :   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/File.phpo  `o        ?   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Function_.php|  `|  22*      :   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Line.phpo  `o  o      <   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Method.phpu  `u  !$      @   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Namespace_.php  `  o      <   nikic-php-parser/PhpParser/Node/Scalar/MagicConst/Trait_.phps  `s  '9pY      2   nikic-php-parser/PhpParser/Node/Scalar/String_.php}  `}  '1      (   nikic-php-parser/PhpParser/Node/Stmt.php   `   O      /   nikic-php-parser/PhpParser/Node/Stmt/Break_.php  `  _      .   nikic-php-parser/PhpParser/Node/Stmt/Case_.php  `        /   nikic-php-parser/PhpParser/Node/Stmt/Catch_.php  `  85      3   nikic-php-parser/PhpParser/Node/Stmt/ClassConst.php  `  F      2   nikic-php-parser/PhpParser/Node/Stmt/ClassLike.phpn  `n  B      4   nikic-php-parser/PhpParser/Node/Stmt/ClassMethod.php  `  d      /   nikic-php-parser/PhpParser/Node/Stmt/Class_.php  `  C      /   nikic-php-parser/PhpParser/Node/Stmt/Const_.php  `        2   nikic-php-parser/PhpParser/Node/Stmt/Continue_.php  `  ?      7   nikic-php-parser/PhpParser/Node/Stmt/DeclareDeclare.php  `  >      1   nikic-php-parser/PhpParser/Node/Stmt/Declare_.php  `  K=      ,   nikic-php-parser/PhpParser/Node/Stmt/Do_.phph  `h        .   nikic-php-parser/PhpParser/Node/Stmt/Echo_.php  `        0   nikic-php-parser/PhpParser/Node/Stmt/ElseIf_.phpo  `o  <2      .   nikic-php-parser/PhpParser/Node/Stmt/Else_.php  `  
      1   nikic-php-parser/PhpParser/Node/Stmt/EnumCase.php  `  dU      .   nikic-php-parser/PhpParser/Node/Stmt/Enum_.phpm  `m        3   nikic-php-parser/PhpParser/Node/Stmt/Expression.php  `        1   nikic-php-parser/PhpParser/Node/Stmt/Finally_.php  `  "      -   nikic-php-parser/PhpParser/Node/Stmt/For_.phpQ  `Q  [|      1   nikic-php-parser/PhpParser/Node/Stmt/Foreach_.php  `  "      2   nikic-php-parser/PhpParser/Node/Stmt/Function_.php
  `
  &      0   nikic-php-parser/PhpParser/Node/Stmt/Global_.php  `  "      .   nikic-php-parser/PhpParser/Node/Stmt/Goto_.php@  `@  kp5      1   nikic-php-parser/PhpParser/Node/Stmt/GroupUse.phpW  `W  z      5   nikic-php-parser/PhpParser/Node/Stmt/HaltCompiler.php  `  30/      ,   nikic-php-parser/PhpParser/Node/Stmt/If_.php`  ``  P      3   nikic-php-parser/PhpParser/Node/Stmt/InlineHTML.php  `  0      3   nikic-php-parser/PhpParser/Node/Stmt/Interface_.php  `  W      .   nikic-php-parser/PhpParser/Node/Stmt/Label.php  `  d      3   nikic-php-parser/PhpParser/Node/Stmt/Namespace_.php  `  z.C      ,   nikic-php-parser/PhpParser/Node/Stmt/Nop.phpS  `S  ^      1   nikic-php-parser/PhpParser/Node/Stmt/Property.php
  `
  f      9   nikic-php-parser/PhpParser/Node/Stmt/PropertyProperty.php  `        0   nikic-php-parser/PhpParser/Node/Stmt/Return_.php  `  _/      2   nikic-php-parser/PhpParser/Node/Stmt/StaticVar.php  `  KE      0   nikic-php-parser/PhpParser/Node/Stmt/Static_.php  `  N[      0   nikic-php-parser/PhpParser/Node/Stmt/Switch_.php[  `[  B|      /   nikic-php-parser/PhpParser/Node/Stmt/Throw_.php  `  @      1   nikic-php-parser/PhpParser/Node/Stmt/TraitUse.php  `  S-      ;   nikic-php-parser/PhpParser/Node/Stmt/TraitUseAdaptation.php-  `-  bY8!      A   nikic-php-parser/PhpParser/Node/Stmt/TraitUseAdaptation/Alias.phpz  `z  >      F   nikic-php-parser/PhpParser/Node/Stmt/TraitUseAdaptation/Precedence.php  `  \Z3      /   nikic-php-parser/PhpParser/Node/Stmt/Trait_.php3  `3  %QT      1   nikic-php-parser/PhpParser/Node/Stmt/TryCatch.phpT  `T  k1$      /   nikic-php-parser/PhpParser/Node/Stmt/Unset_.php  `  |A      /   nikic-php-parser/PhpParser/Node/Stmt/UseUse.php  `  9      -   nikic-php-parser/PhpParser/Node/Stmt/Use_.php  `  @      /   nikic-php-parser/PhpParser/Node/Stmt/While_.phpk  `k        -   nikic-php-parser/PhpParser/Node/UnionType.php  `  +      5   nikic-php-parser/PhpParser/Node/VarLikeIdentifier.php  `  D(P      +   nikic-php-parser/PhpParser/NodeAbstract.php  `  w      )   nikic-php-parser/PhpParser/NodeDumper.php@  `@  }      )   nikic-php-parser/PhpParser/NodeFinder.php
  `
  cU      ,   nikic-php-parser/PhpParser/NodeTraverser.phpz(  `z(  DZ      5   nikic-php-parser/PhpParser/NodeTraverserInterface.php  `  {      *   nikic-php-parser/PhpParser/NodeVisitor.php  `  HQ      9   nikic-php-parser/PhpParser/NodeVisitor/CloningVisitor.php8  `8  W      9   nikic-php-parser/PhpParser/NodeVisitor/FindingVisitor.php  `  [      >   nikic-php-parser/PhpParser/NodeVisitor/FirstFindingVisitor.php5  `5  Y      7   nikic-php-parser/PhpParser/NodeVisitor/NameResolver.phpK(  `K(        @   nikic-php-parser/PhpParser/NodeVisitor/NodeConnectingVisitor.php  `        B   nikic-php-parser/PhpParser/NodeVisitor/ParentConnectingVisitor.php  `  +
      2   nikic-php-parser/PhpParser/NodeVisitorAbstract.php  `  %8@      %   nikic-php-parser/PhpParser/Parser.php  `        .   nikic-php-parser/PhpParser/Parser/Multiple.php  `        *   nikic-php-parser/PhpParser/Parser/Php5.phpfB `fB CS      *   nikic-php-parser/PhpParser/Parser/Php7.phpnP `nP 	      ,   nikic-php-parser/PhpParser/Parser/Tokens.php  `  0XD      -   nikic-php-parser/PhpParser/ParserAbstract.php.  `.  /A      ,   nikic-php-parser/PhpParser/ParserFactory.php  `  tI      5   nikic-php-parser/PhpParser/PrettyPrinter/Standard.phpc  `c  A`      4   nikic-php-parser/PhpParser/PrettyPrinterAbstract.php  `  x;S         object-enumerator/LICENSE  `  y{         object-reflector/LICENSE  `  9v         phar-io-manifest/LICENSE`  ``  p      +   phar-io-manifest/ManifestDocumentMapper.php  `  Zb      #   phar-io-manifest/ManifestLoader.php  `  \      '   phar-io-manifest/ManifestSerializer.php  `        :   phar-io-manifest/exceptions/ElementCollectionException.php  `        )   phar-io-manifest/exceptions/Exception.php  `        ?   phar-io-manifest/exceptions/InvalidApplicationNameException.php  `  -      5   phar-io-manifest/exceptions/InvalidEmailException.php  `  c      3   phar-io-manifest/exceptions/InvalidUrlException.php  `  D      9   phar-io-manifest/exceptions/ManifestDocumentException.php   `   {      @   phar-io-manifest/exceptions/ManifestDocumentLoadingException.phpa  `a  "/      ?   phar-io-manifest/exceptions/ManifestDocumentMapperException.php   `         8   phar-io-manifest/exceptions/ManifestElementException.php   `   KY      7   phar-io-manifest/exceptions/ManifestLoaderException.php   `         '   phar-io-manifest/values/Application.php  `  8      +   phar-io-manifest/values/ApplicationName.php  `  ]3Ta      "   phar-io-manifest/values/Author.php  `  	%      ,   phar-io-manifest/values/AuthorCollection.php  `  n      4   phar-io-manifest/values/AuthorCollectionIterator.phpe  `e        ,   phar-io-manifest/values/BundledComponent.phpp  `p  ~z      6   phar-io-manifest/values/BundledComponentCollection.phpk  `k  }      >   phar-io-manifest/values/BundledComponentCollectionIterator.php  `  b      0   phar-io-manifest/values/CopyrightInformation.php  `  w&3      !   phar-io-manifest/values/Email.phpg  `g  A      %   phar-io-manifest/values/Extension.phpe  `e  6      #   phar-io-manifest/values/Library.php  `  Bt\      #   phar-io-manifest/values/License.php!  `!  "v      $   phar-io-manifest/values/Manifest.phpd  `d  ij&      3   phar-io-manifest/values/PhpExtensionRequirement.php  `  a\      1   phar-io-manifest/values/PhpVersionRequirement.phpe  `e  a{j      '   phar-io-manifest/values/Requirement.php  `  d      1   phar-io-manifest/values/RequirementCollection.php*  `*  4*      9   phar-io-manifest/values/RequirementCollectionIterator.php  `  @v8          phar-io-manifest/values/Type.php{  `{  Jl         phar-io-manifest/values/Url.php  `  +      &   phar-io-manifest/xml/AuthorElement.php  `  x      0   phar-io-manifest/xml/AuthorElementCollection.phpw  `w  3
      '   phar-io-manifest/xml/BundlesElement.php  `  a      )   phar-io-manifest/xml/ComponentElement.php  `        3   phar-io-manifest/xml/ComponentElementCollection.php  `  &      (   phar-io-manifest/xml/ContainsElement.php  `        )   phar-io-manifest/xml/CopyrightElement.phpP  `P  57      *   phar-io-manifest/xml/ElementCollection.php  `  #`      #   phar-io-manifest/xml/ExtElement.php"  `"  ;      -   phar-io-manifest/xml/ExtElementCollection.phpn  `n  eYV      )   phar-io-manifest/xml/ExtensionElement.php  `  [      '   phar-io-manifest/xml/LicenseElement.php  `  6r      )   phar-io-manifest/xml/ManifestDocument.phpm  `m  _k      (   phar-io-manifest/xml/ManifestElement.php  `        #   phar-io-manifest/xml/PhpElement.phpK  `K  J      (   phar-io-manifest/xml/RequiresElement.phpo  `o  !^         phar-io-version/LICENSE1  `1  >:      $   phar-io-version/PreReleaseSuffix.php  `  R         phar-io-version/Version.php9  `9  .t      +   phar-io-version/VersionConstraintParser.phpL  `L  #      *   phar-io-version/VersionConstraintValue.php
  `
  '      !   phar-io-version/VersionNumber.php  `  O1      9   phar-io-version/constraints/AbstractVersionConstraint.php  `  
&c      9   phar-io-version/constraints/AndVersionConstraintGroup.php  `  4`      4   phar-io-version/constraints/AnyVersionConstraint.php  `  s      6   phar-io-version/constraints/ExactVersionConstraint.phpn  `n  g	X      E   phar-io-version/constraints/GreaterThanOrEqualToVersionConstraint.php  `  y.      8   phar-io-version/constraints/OrVersionConstraintGroup.php>  `>  )0      F   phar-io-version/constraints/SpecificMajorAndMinorVersionConstraint.php  `  x      >   phar-io-version/constraints/SpecificMajorVersionConstraint.php8  `8  MP5      1   phar-io-version/constraints/VersionConstraint.php  `  S      (   phar-io-version/exceptions/Exception.php  `  ?      ?   phar-io-version/exceptions/InvalidPreReleaseSuffixException.php   `   F5      6   phar-io-version/exceptions/InvalidVersionException.php   `   vw      :   phar-io-version/exceptions/NoPreReleaseSuffixException.php   `   kT      D   phar-io-version/exceptions/UnsupportedVersionConstraintException.php  `  x      "   php-code-coverage/CodeCoverage.phpD  `D  gw         php-code-coverage/CrapIndex.php}  `}  d_         php-code-coverage/Directory.php  `  a      #   php-code-coverage/Driver/Driver.php  `        '   php-code-coverage/Driver/PcovDriver.php)  `)        )   php-code-coverage/Driver/PhpdbgDriver.php  `  Aq;      %   php-code-coverage/Driver/Selector.php  `  `SJ      *   php-code-coverage/Driver/Xdebug2Driver.php  `  $      *   php-code-coverage/Driver/Xdebug3Driver.php  `  L}      J   php-code-coverage/Exception/BranchAndPathCoverageNotSupportedException.php  `  fp      F   php-code-coverage/Exception/DeadCodeDetectionNotSupportedException.php  `  zv      C   php-code-coverage/Exception/DirectoryCouldNotBeCreatedException.php  `  v      )   php-code-coverage/Exception/Exception.php~  `~  4      8   php-code-coverage/Exception/InvalidArgumentException.php  `  ?iB      F   php-code-coverage/Exception/NoCodeCoverageDriverAvailableException.phpX  `X  }~
      ]   php-code-coverage/Exception/NoCodeCoverageDriverWithPathCoverageSupportAvailableException.php  `  =      /   php-code-coverage/Exception/ParserException.php  `  0      D   php-code-coverage/Exception/PathExistsButIsNotDirectoryException.php  `  8      9   php-code-coverage/Exception/PcovNotAvailableException.php  `  P      ;   php-code-coverage/Exception/PhpdbgNotAvailableException.php  `        3   php-code-coverage/Exception/ReflectionException.php  `  	b      ?   php-code-coverage/Exception/ReportAlreadyFinalizedException.phpc  `c        I   php-code-coverage/Exception/StaticAnalysisCacheNotConfiguredException.php  `  Q      6   php-code-coverage/Exception/TestIdMissingException.php9  `9  i      C   php-code-coverage/Exception/UnintentionallyCoveredCodeException.php  `  U      =   php-code-coverage/Exception/WriteOperationFailedException.php  `   D      ;   php-code-coverage/Exception/WrongXdebugVersionException.php  `  jn      :   php-code-coverage/Exception/Xdebug2NotEnabledException.php  `        :   php-code-coverage/Exception/Xdebug3NotEnabledException.php  `  o      ;   php-code-coverage/Exception/XdebugNotAvailableException.php  `  RL      ,   php-code-coverage/Exception/XmlException.php  `  zy.         php-code-coverage/Filter.phpj  `j  s         php-code-coverage/LICENSE  `  \T      '   php-code-coverage/Node/AbstractNode.php  `  9      "   php-code-coverage/Node/Builder.php  `  kN      $   php-code-coverage/Node/Directory.php{#  `{#  %<         php-code-coverage/Node/File.phpZJ  `ZJ  r      #   php-code-coverage/Node/Iterator.php  `  Tu          php-code-coverage/Percentage.phpI  `I  ^      /   php-code-coverage/ProcessedCodeCoverageData.php	%  `	%  ,ko      )   php-code-coverage/RawCodeCoverageData.php  `  C       #   php-code-coverage/Report/Clover.php(  `(  .      &   php-code-coverage/Report/Cobertura.phpz1  `z1  "      #   php-code-coverage/Report/Crap4j.phpi  `i  Jz      (   php-code-coverage/Report/Html/Facade.php-  `-  ZQ      *   php-code-coverage/Report/Html/Renderer.phpv$  `v$  m      4   php-code-coverage/Report/Html/Renderer/Dashboard.php!  `!  <      4   php-code-coverage/Report/Html/Renderer/Directory.php*  `*  z      /   php-code-coverage/Report/Html/Renderer/File.php  `        B   php-code-coverage/Report/Html/Renderer/Template/branches.html.dist  `  h2+      F   php-code-coverage/Report/Html/Renderer/Template/coverage_bar.html.dist'  `'  O}      M   php-code-coverage/Report/Html/Renderer/Template/coverage_bar_branch.html.dist'  `'  O}      E   php-code-coverage/Report/Html/Renderer/Template/css/bootstrap.min.cssr `r ?l      >   php-code-coverage/Report/Html/Renderer/Template/css/custom.css    `              A   php-code-coverage/Report/Html/Renderer/Template/css/nv.d3.min.cssX%  `X%  0,      @   php-code-coverage/Report/Html/Renderer/Template/css/octicons.cssX   `X   '#      =   php-code-coverage/Report/Html/Renderer/Template/css/style.css  `  :      C   php-code-coverage/Report/Html/Renderer/Template/dashboard.html.distG  `G  l      J   php-code-coverage/Report/Html/Renderer/Template/dashboard_branch.html.distG  `G  l      C   php-code-coverage/Report/Html/Renderer/Template/directory.html.dist  `  GM      J   php-code-coverage/Report/Html/Renderer/Template/directory_branch.html.distj  `j  H      H   php-code-coverage/Report/Html/Renderer/Template/directory_item.html.distA  `A  ds      O   php-code-coverage/Report/Html/Renderer/Template/directory_item_branch.html.dist;  `;  m      >   php-code-coverage/Report/Html/Renderer/Template/file.html.dist  `  F      E   php-code-coverage/Report/Html/Renderer/Template/file_branch.html.dist	  `	        C   php-code-coverage/Report/Html/Renderer/Template/file_item.html.distt  `t        J   php-code-coverage/Report/Html/Renderer/Template/file_item_branch.html.distn  `n        C   php-code-coverage/Report/Html/Renderer/Template/icons/file-code.svg0  `0  QUU      H   php-code-coverage/Report/Html/Renderer/Template/icons/file-directory.svg   `   Z      C   php-code-coverage/Report/Html/Renderer/Template/js/bootstrap.min.js  `  s      <   php-code-coverage/Report/Html/Renderer/Template/js/d3.min.jsP `P hb      :   php-code-coverage/Report/Html/Renderer/Template/js/file.js  `  b      @   php-code-coverage/Report/Html/Renderer/Template/js/jquery.min.js] `] =      ?   php-code-coverage/Report/Html/Renderer/Template/js/nv.d3.min.jsR `R <Ms      @   php-code-coverage/Report/Html/Renderer/Template/js/popper.min.jsR  `R  Z\      >   php-code-coverage/Report/Html/Renderer/Template/line.html.dist   `   {      ?   php-code-coverage/Report/Html/Renderer/Template/lines.html.diste   `e   df      E   php-code-coverage/Report/Html/Renderer/Template/method_item.html.dist  `  s:      L   php-code-coverage/Report/Html/Renderer/Template/method_item_branch.html.dist|  `|  A\      ?   php-code-coverage/Report/Html/Renderer/Template/paths.html.dist  `  *'          php-code-coverage/Report/PHP.php%  `%  F      !   php-code-coverage/Report/Text.php(  `(  L      1   php-code-coverage/Report/Xml/BuildInformation.php	  `	  MY$      )   php-code-coverage/Report/Xml/Coverage.php  `  r      *   php-code-coverage/Report/Xml/Directory.php  `  W;      '   php-code-coverage/Report/Xml/Facade.php$  `$  }j      %   php-code-coverage/Report/Xml/File.php  `  `~      '   php-code-coverage/Report/Xml/Method.php=  `=  PW      %   php-code-coverage/Report/Xml/Node.php3	  `3	  K%      (   php-code-coverage/Report/Xml/Project.phpg	  `g	  K7      '   php-code-coverage/Report/Xml/Report.php
  `
  i      '   php-code-coverage/Report/Xml/Source.php  `  J9Q      &   php-code-coverage/Report/Xml/Tests.php  `  QT      '   php-code-coverage/Report/Xml/Totals.php0  `0  9P.      %   php-code-coverage/Report/Xml/Unit.php  `  Q=      *   php-code-coverage/StaticAnalysis/Cache.phpJ  `J  CT      0   php-code-coverage/StaticAnalysis/CacheWarmer.phpF  `F        ?   php-code-coverage/StaticAnalysis/CachingCoveredFileAnalyser.php  `  y      A   php-code-coverage/StaticAnalysis/CachingUncoveredFileAnalyser.phpa  `a  P-X      ;   php-code-coverage/StaticAnalysis/CodeUnitFindingVisitor.php!  `!  ^=6      8   php-code-coverage/StaticAnalysis/CoveredFileAnalyser.phpu  `u  NPu      B   php-code-coverage/StaticAnalysis/ExecutableLinesFindingVisitor.php  `  w      ?   php-code-coverage/StaticAnalysis/IgnoredLinesFindingVisitor.php  `  m      ?   php-code-coverage/StaticAnalysis/ParsingCoveredFileAnalyser.phpp  `p  CoA      A   php-code-coverage/StaticAnalysis/ParsingUncoveredFileAnalyser.php<  `<  4      :   php-code-coverage/StaticAnalysis/UncoveredFileAnalyser.php+  `+  B=         php-code-coverage/Version.php  `  $l         php-file-iterator/Facade.phpZ
  `Z
  	q         php-file-iterator/Factory.php	  `	  V         php-file-iterator/Iterator.phpd  `d  >         php-file-iterator/LICENSE  `  .         php-invoker/Invoker.phpX  `X  !L      $   php-invoker/exceptions/Exception.phps  `s        D   php-invoker/exceptions/ProcessControlExtensionNotLoadedException.php  `  Pd      +   php-invoker/exceptions/TimeoutException.php  `  j         php-text-template/LICENSE  `  u         php-text-template/Template.phpy	  `y	  n]      *   php-text-template/exceptions/Exception.phpz  `z  Zq      9   php-text-template/exceptions/InvalidArgumentException.php  `  1      1   php-text-template/exceptions/RuntimeException.php  `  %,Gm         php-timer/Duration.php"
  `"
  aM         php-timer/LICENSE  `  x      $   php-timer/ResourceUsageFormatter.php1  `1  i         php-timer/Timer.php  `        "   php-timer/exceptions/Exception.phpo  `o  y      /   php-timer/exceptions/NoActiveTimerException.php  `  NC      E   php-timer/exceptions/TimeSinceStartOfRequestNotAvailableException.php  `  &         phpunit.xsd,D  `,D  .         phpunit/Exception.php  `  jM         phpunit/Framework/Assert.phpM `M S=      &   phpunit/Framework/Assert/Functions.phpD `D  Y      &   phpunit/Framework/Attributes/After.php  `  3       +   phpunit/Framework/Attributes/AfterClass.php  `  7d      .   phpunit/Framework/Attributes/BackupGlobals.php  `  M      7   phpunit/Framework/Attributes/BackupStaticProperties.php  `  C      '   phpunit/Framework/Attributes/Before.php  `  .G      ,   phpunit/Framework/Attributes/BeforeClass.php  `  +      3   phpunit/Framework/Attributes/CodeCoverageIgnore.php  `  5      ,   phpunit/Framework/Attributes/CoversClass.php}  `}  G{      /   phpunit/Framework/Attributes/CoversFunction.php  `        .   phpunit/Framework/Attributes/CoversNothing.php  `  xr      -   phpunit/Framework/Attributes/DataProvider.php  `  }      5   phpunit/Framework/Attributes/DataProviderExternal.php<  `<  (o      (   phpunit/Framework/Attributes/Depends.php  `  J      0   phpunit/Framework/Attributes/DependsExternal.php7  `7  @b      >   phpunit/Framework/Attributes/DependsExternalUsingDeepClone.phpE  `E  0      A   phpunit/Framework/Attributes/DependsExternalUsingShallowClone.phpH  `H  |      6   phpunit/Framework/Attributes/DependsUsingDeepClone.php  `  c1      9   phpunit/Framework/Attributes/DependsUsingShallowClone.php  `  u[      9   phpunit/Framework/Attributes/DoesNotPerformAssertions.php  `  .      &   phpunit/Framework/Attributes/Group.php  `  ,"      &   phpunit/Framework/Attributes/Large.php  `        '   phpunit/Framework/Attributes/Medium.php  `  lS      .   phpunit/Framework/Attributes/PostCondition.php  `  f      -   phpunit/Framework/Attributes/PreCondition.php  `  (       4   phpunit/Framework/Attributes/PreserveGlobalState.php  `  KK      1   phpunit/Framework/Attributes/RequiresFunction.php  `        /   phpunit/Framework/Attributes/RequiresMethod.phpP  `P        8   phpunit/Framework/Attributes/RequiresOperatingSystem.php  `  `      >   phpunit/Framework/Attributes/RequiresOperatingSystemFamily.php:  `:  J'      ,   phpunit/Framework/Attributes/RequiresPhp.php  `  4-.      5   phpunit/Framework/Attributes/RequiresPhpExtension.phpe  `e  U}      0   phpunit/Framework/Attributes/RequiresPhpunit.php  `        0   phpunit/Framework/Attributes/RequiresSetting.php  `  w      :   phpunit/Framework/Attributes/RunClassInSeparateProcess.php  `  mv^      5   phpunit/Framework/Attributes/RunInSeparateProcess.php  `  +      <   phpunit/Framework/Attributes/RunTestsInSeparateProcesses.php  `  z      &   phpunit/Framework/Attributes/Small.php  `  `]o      %   phpunit/Framework/Attributes/Test.php  `  
$      (   phpunit/Framework/Attributes/TestDox.php  `  '      )   phpunit/Framework/Attributes/TestWith.php  `  "t      -   phpunit/Framework/Attributes/TestWithJson.php  `  7b      '   phpunit/Framework/Attributes/Ticket.php  `  s      *   phpunit/Framework/Attributes/UsesClass.php  `  w      -   phpunit/Framework/Attributes/UsesFunction.php  `  '      0   phpunit/Framework/Constraint/Boolean/IsFalse.php  `        /   phpunit/Framework/Constraint/Boolean/IsTrue.php  `  }      )   phpunit/Framework/Constraint/Callback.php?  `?  
b      2   phpunit/Framework/Constraint/Cardinality/Count.phpG  `G        8   phpunit/Framework/Constraint/Cardinality/GreaterThan.php  `  h,d}      4   phpunit/Framework/Constraint/Cardinality/IsEmpty.php  `  T.      5   phpunit/Framework/Constraint/Cardinality/LessThan.php  `  aT      5   phpunit/Framework/Constraint/Cardinality/SameSize.php  `  <G      +   phpunit/Framework/Constraint/Constraint.php#  `#  iAx      1   phpunit/Framework/Constraint/Equality/IsEqual.php  `  y      ?   phpunit/Framework/Constraint/Equality/IsEqualCanonicalizing.php  `  q60      =   phpunit/Framework/Constraint/Equality/IsEqualIgnoringCase.php   `   W<      :   phpunit/Framework/Constraint/Equality/IsEqualWithDelta.phpJ
  `J
  x=      4   phpunit/Framework/Constraint/Exception/Exception.php  `  %      8   phpunit/Framework/Constraint/Exception/ExceptionCode.php  `  %      ;   phpunit/Framework/Constraint/Exception/ExceptionMessage.php  `  :      L   phpunit/Framework/Constraint/Exception/ExceptionMessageRegularExpression.php  `  9      ;   phpunit/Framework/Constraint/Filesystem/DirectoryExists.phpl  `l  Y      6   phpunit/Framework/Constraint/Filesystem/FileExists.phpg  `g  4+      6   phpunit/Framework/Constraint/Filesystem/IsReadable.phpg  `g  uU      6   phpunit/Framework/Constraint/Filesystem/IsWritable.phpg  `g  V      +   phpunit/Framework/Constraint/IsAnything.php  `  E      ,   phpunit/Framework/Constraint/IsIdentical.php  `  h      ,   phpunit/Framework/Constraint/JsonMatches.php  `  n      @   phpunit/Framework/Constraint/JsonMatchesErrorMessageProvider.php<  `<  :4      .   phpunit/Framework/Constraint/Math/IsFinite.php  `  >      0   phpunit/Framework/Constraint/Math/IsInfinite.php  `  WoE      +   phpunit/Framework/Constraint/Math/IsNan.php  `  Dx      9   phpunit/Framework/Constraint/Object/ClassHasAttribute.php  `  hw      ?   phpunit/Framework/Constraint/Object/ClassHasStaticAttribute.php`  ``  ds      4   phpunit/Framework/Constraint/Object/ObjectEquals.php  `  A      :   phpunit/Framework/Constraint/Object/ObjectHasAttribute.php  `  X      8   phpunit/Framework/Constraint/Operator/BinaryOperator.php3  `3  	-~      4   phpunit/Framework/Constraint/Operator/LogicalAnd.php  `  bJ      4   phpunit/Framework/Constraint/Operator/LogicalNot.php  `  v"      3   phpunit/Framework/Constraint/Operator/LogicalOr.php  `  Z      4   phpunit/Framework/Constraint/Operator/LogicalXor.php&  `&        2   phpunit/Framework/Constraint/Operator/Operator.php&  `&  D      7   phpunit/Framework/Constraint/Operator/UnaryOperator.php  `  IB      .   phpunit/Framework/Constraint/String/IsJson.php  `        9   phpunit/Framework/Constraint/String/RegularExpression.php  `  J)j      6   phpunit/Framework/Constraint/String/StringContains.php  `  R>      6   phpunit/Framework/Constraint/String/StringEndsWith.php  `         F   phpunit/Framework/Constraint/String/StringMatchesFormatDescription.php
  `
  LMD      8   phpunit/Framework/Constraint/String/StringStartsWith.php;  `;  ~G      8   phpunit/Framework/Constraint/Traversable/ArrayHasKey.php  `  R	      @   phpunit/Framework/Constraint/Traversable/TraversableContains.php  `  4n      E   phpunit/Framework/Constraint/Traversable/TraversableContainsEqual.phpb  `b  ]eo      I   phpunit/Framework/Constraint/Traversable/TraversableContainsIdentical.php(  `(  dE"      D   phpunit/Framework/Constraint/Traversable/TraversableContainsOnly.php  `  vj      2   phpunit/Framework/Constraint/Type/IsInstanceOf.php"  `"  {      ,   phpunit/Framework/Constraint/Type/IsNull.php  `  ?)      ,   phpunit/Framework/Constraint/Type/IsType.php~  `~        +   phpunit/Framework/DataProviderTestSuite.php{  `{        #   phpunit/Framework/ErrorTestCase.php   `   L      A   phpunit/Framework/Exception/ActualValueIsNotAnObjectException.php  `  iOp      4   phpunit/Framework/Exception/AssertionFailedError.php  `        5   phpunit/Framework/Exception/CodeCoverageException.php  `  [      S   phpunit/Framework/Exception/ComparisonMethodDoesNotAcceptParameterTypeException.phpm  `m  Q%      U   phpunit/Framework/Exception/ComparisonMethodDoesNotDeclareBoolReturnTypeException.phpT  `T  p      Z   phpunit/Framework/Exception/ComparisonMethodDoesNotDeclareExactlyOneParameterException.php^  `^  !!      T   phpunit/Framework/Exception/ComparisonMethodDoesNotDeclareParameterTypeException.php\  `\  jyA      E   phpunit/Framework/Exception/ComparisonMethodDoesNotExistException.php1  `1        ?   phpunit/Framework/Exception/CoveredCodeNotExecutedException.php  `  8Y      %   phpunit/Framework/Exception/Error.php  `  j1      )   phpunit/Framework/Exception/Exception.php	  `	        :   phpunit/Framework/Exception/ExpectationFailedException.php,  `,  =Tyb      3   phpunit/Framework/Exception/IncompleteTestError.php  `        8   phpunit/Framework/Exception/InvalidArgumentException.php$  `$  rUi      <   phpunit/Framework/Exception/InvalidCoversTargetException.php  `  o      <   phpunit/Framework/Exception/InvalidDataProviderException.php  `  .      @   phpunit/Framework/Exception/MissingCoversAnnotationException.php  `  |      9   phpunit/Framework/Exception/NoChildTestSuiteException.php  `  P$      +   phpunit/Framework/Exception/OutputError.php  `        8   phpunit/Framework/Exception/PHPTAssertionFailedError.php  `  #      .   phpunit/Framework/Exception/RiskyTestError.php  `  *y      0   phpunit/Framework/Exception/SkippedTestError.php  `  O~      5   phpunit/Framework/Exception/SkippedTestSuiteError.php  `  x      .   phpunit/Framework/Exception/SyntheticError.php  `  ,      5   phpunit/Framework/Exception/SyntheticSkippedError.php  `        ?   phpunit/Framework/Exception/UnintentionallyCoveredCodeError.php  `        '   phpunit/Framework/Exception/Warning.php  `  8;      &   phpunit/Framework/ExceptionWrapper.php  `  b}      .   phpunit/Framework/ExecutionOrderDependency.phpe  `e  (3      $   phpunit/Framework/IncompleteTest.php  `  C
      (   phpunit/Framework/IncompleteTestCase.phpn  `n  ^_      4   phpunit/Framework/InvalidParameterGroupException.php  `        (   phpunit/Framework/MockObject/Api/Api.php  `  X      +   phpunit/Framework/MockObject/Api/Method.php  `        6   phpunit/Framework/MockObject/Api/MockedCloneMethod.php*  `*  ?z      8   phpunit/Framework/MockObject/Api/UnmockedCloneMethod.phpG  `G        1   phpunit/Framework/MockObject/Builder/Identity.php  `        9   phpunit/Framework/MockObject/Builder/InvocationMocker.phpZ$  `Z$  q      :   phpunit/Framework/MockObject/Builder/InvocationStubber.phpa  `a        8   phpunit/Framework/MockObject/Builder/MethodNameMatch.phpk  `k  0-x      8   phpunit/Framework/MockObject/Builder/ParametersMatch.php  `        -   phpunit/Framework/MockObject/Builder/Stub.php0  `0  :l      3   phpunit/Framework/MockObject/ConfigurableMethod.php  `  ?      A   phpunit/Framework/MockObject/Exception/BadMethodCallException.php  `  X      G   phpunit/Framework/MockObject/Exception/CannotUseAddMethodsException.php5  `5  R^      H   phpunit/Framework/MockObject/Exception/CannotUseOnlyMethodsException.phpC  `C  5      F   phpunit/Framework/MockObject/Exception/ClassAlreadyExistsException.php  `  3      @   phpunit/Framework/MockObject/Exception/ClassIsFinalException.php  `  ;+      Y   phpunit/Framework/MockObject/Exception/ConfigurableMethodsAlreadyInitializedException.php   `   W      C   phpunit/Framework/MockObject/Exception/DuplicateMethodException.php  `        4   phpunit/Framework/MockObject/Exception/Exception.php  `  [.      K   phpunit/Framework/MockObject/Exception/IncompatibleReturnValueException.php  `  *a      E   phpunit/Framework/MockObject/Exception/InvalidMethodNameException.php  `  IU@      H   phpunit/Framework/MockObject/Exception/MatchBuilderNotFoundException.php  `  s=v      L   phpunit/Framework/MockObject/Exception/MatcherAlreadyRegisteredException.php  `  :      L   phpunit/Framework/MockObject/Exception/MethodCannotBeConfiguredException.php  `        O   phpunit/Framework/MockObject/Exception/MethodNameAlreadyConfiguredException.php  `        K   phpunit/Framework/MockObject/Exception/MethodNameNotConfiguredException.php~  `~  x1)      U   phpunit/Framework/MockObject/Exception/MethodParametersAlreadyConfiguredException.php  `  	r      Y   phpunit/Framework/MockObject/Exception/OriginalConstructorInvocationRequiredException.php  `        >   phpunit/Framework/MockObject/Exception/ReflectionException.php  `  eE      L   phpunit/Framework/MockObject/Exception/ReturnValueNotConfiguredException.php!  `!  $      ;   phpunit/Framework/MockObject/Exception/RuntimeException.php  `  _|      M   phpunit/Framework/MockObject/Exception/SoapExtensionNotAvailableException.php  `  z      @   phpunit/Framework/MockObject/Exception/UnknownClassException.php  `  v<      @   phpunit/Framework/MockObject/Exception/UnknownTraitException.php  `  |n      ?   phpunit/Framework/MockObject/Exception/UnknownTypeException.php  `        *   phpunit/Framework/MockObject/Generator.phpu  `u  Z      6   phpunit/Framework/MockObject/Generator/deprecation.tpl;   `;   O5s      7   phpunit/Framework/MockObject/Generator/mocked_class.tpl   `   wZ      8   phpunit/Framework/MockObject/Generator/mocked_method.tplF  `F  K      =   phpunit/Framework/MockObject/Generator/mocked_method_void.tpl  `  p      ?   phpunit/Framework/MockObject/Generator/mocked_static_method.tpl   `    4R      9   phpunit/Framework/MockObject/Generator/proxied_method.tpl}  `}  @      >   phpunit/Framework/MockObject/Generator/proxied_method_void.tplv  `v  T      6   phpunit/Framework/MockObject/Generator/trait_class.tplQ   `Q   <      5   phpunit/Framework/MockObject/Generator/wsdl_class.tpl   `         6   phpunit/Framework/MockObject/Generator/wsdl_method.tpl<   `<   i      +   phpunit/Framework/MockObject/Invocation.php*  `*  X      2   phpunit/Framework/MockObject/InvocationHandler.php  `  +z      (   phpunit/Framework/MockObject/Matcher.php  `  fH      5   phpunit/Framework/MockObject/MethodNameConstraint.php  `  N6^      ,   phpunit/Framework/MockObject/MockBuilder.phpu&  `u&  Y|!      *   phpunit/Framework/MockObject/MockClass.php  `  DU      +   phpunit/Framework/MockObject/MockMethod.php&  `&  .X      .   phpunit/Framework/MockObject/MockMethodSet.phpB  `B  Z|W      +   phpunit/Framework/MockObject/MockObject.php  `  T      *   phpunit/Framework/MockObject/MockTrait.phpr  `r        )   phpunit/Framework/MockObject/MockType.php  `  FFt      5   phpunit/Framework/MockObject/Rule/AnyInvokedCount.php  `  1Xo.      3   phpunit/Framework/MockObject/Rule/AnyParameters.php  `  {G<      ;   phpunit/Framework/MockObject/Rule/ConsecutiveParameters.php  `  BD      5   phpunit/Framework/MockObject/Rule/InvocationOrder.phpO  `O  8      9   phpunit/Framework/MockObject/Rule/InvokedAtLeastCount.php  `        8   phpunit/Framework/MockObject/Rule/InvokedAtLeastOnce.phpt  `t  =(Z      8   phpunit/Framework/MockObject/Rule/InvokedAtMostCount.php  `  ,      2   phpunit/Framework/MockObject/Rule/InvokedCount.php	  `	  =|      0   phpunit/Framework/MockObject/Rule/MethodName.php  `  T5z      0   phpunit/Framework/MockObject/Rule/Parameters.php#  `#  L      4   phpunit/Framework/MockObject/Rule/ParametersRule.php  `  0W1      %   phpunit/Framework/MockObject/Stub.php  `        6   phpunit/Framework/MockObject/Stub/ConsecutiveCalls.php5  `5  `      /   phpunit/Framework/MockObject/Stub/Exception.phpw  `w        4   phpunit/Framework/MockObject/Stub/ReturnArgument.php  `  8s      4   phpunit/Framework/MockObject/Stub/ReturnCallback.php  `  aq      5   phpunit/Framework/MockObject/Stub/ReturnReference.phpN  `N  %}      0   phpunit/Framework/MockObject/Stub/ReturnSelf.phpR  `R  -      0   phpunit/Framework/MockObject/Stub/ReturnStub.php+  `+  v      4   phpunit/Framework/MockObject/Stub/ReturnValueMap.php  `  P6      *   phpunit/Framework/MockObject/Stub/Stub.phpd  `d  qb      /   phpunit/Framework/MockObject/TemplateLoader.php!  `!  tDu      +   phpunit/Framework/MockObject/Verifiable.php  `  s      !   phpunit/Framework/Reorderable.php  `  z0      $   phpunit/Framework/SelfDescribing.php
  `
  s      !   phpunit/Framework/SkippedTest.php  `  t      %   phpunit/Framework/SkippedTestCase.phph  `h  <         phpunit/Framework/Test.php
  `
  D      !   phpunit/Framework/TestBuilder.phpm%  `m%           phpunit/Framework/TestCase.php  `  w?      !   phpunit/Framework/TestFailure.php  `  ki      "   phpunit/Framework/TestListener.php  `  H          phpunit/Framework/TestResult.php>  `>  ~hfl          phpunit/Framework/TestRunner.php;B  `;B  s      $   phpunit/Framework/TestSize/Known.php  `  G      $   phpunit/Framework/TestSize/Large.php,  `,  7      %   phpunit/Framework/TestSize/Medium.php/  `/  e      $   phpunit/Framework/TestSize/Small.php   `   dP      '   phpunit/Framework/TestSize/TestSize.php2  `2  '3      &   phpunit/Framework/TestSize/Unknown.php  `  Jk      &   phpunit/Framework/TestStatus/Error.php  `        (   phpunit/Framework/TestStatus/Failure.php  `  V      +   phpunit/Framework/TestStatus/Incomplete.php  `  )j      &   phpunit/Framework/TestStatus/Known.phpw  `w  O      &   phpunit/Framework/TestStatus/Risky.php  `  RR{      (   phpunit/Framework/TestStatus/Skipped.php  `  
      (   phpunit/Framework/TestStatus/Success.php  `  z\y      +   phpunit/Framework/TestStatus/TestStatus.php  `  t      (   phpunit/Framework/TestStatus/Unknown.php  `        (   phpunit/Framework/TestStatus/Warning.php  `  2         phpunit/Framework/TestSuite.phpXM  `XM  B      '   phpunit/Framework/TestSuiteIterator.php  `  mU6      %   phpunit/Framework/WarningTestCase.php  `  W         phpunit/Metadata/After.php  `  .m         phpunit/Metadata/AfterClass.php  `  %      "   phpunit/Metadata/BackupGlobals.php  `        +   phpunit/Metadata/BackupStaticProperties.php  `  b`         phpunit/Metadata/Before.php  `  I          phpunit/Metadata/BeforeClass.php  `  4@4      '   phpunit/Metadata/CodeCoverageIgnore.php+  `+  W*         phpunit/Metadata/Covers.php  `  X2          phpunit/Metadata/CoversClass.php-  `-  Fl9      '   phpunit/Metadata/CoversDefaultClass.php  `  LM      #   phpunit/Metadata/CoversFunction.php  `  ^9      !   phpunit/Metadata/CoversMethod.php  `  H^      "   phpunit/Metadata/CoversNothing.php!  `!        !   phpunit/Metadata/DataProvider.phpL  `L  8C+         phpunit/Metadata/Depends.php  `  jYD      -   phpunit/Metadata/DoesNotPerformAssertions.php7  `7  h      (   phpunit/Metadata/Exception/Exception.phpO  `O  w      A   phpunit/Metadata/Exception/InvalidVersionRequirementException.php  `  r      <   phpunit/Metadata/Exception/NoVersionRequirementException.php  `        .   phpunit/Metadata/Facade/CodeCoverageFacade.php!  `!  tx      .   phpunit/Metadata/Facade/DataProviderFacade.php6  `6  1,      (   phpunit/Metadata/Facade/GroupsFacade.php  `  DJ      &   phpunit/Metadata/Facade/HookFacade.php   `   b      .   phpunit/Metadata/Facade/RequirementsFacade.php  `   V         phpunit/Metadata/Group.php  `  PK         phpunit/Metadata/Metadata.php}  `}  )83      '   phpunit/Metadata/MetadataCollection.php0,  `0,  EH      /   phpunit/Metadata/MetadataCollectionIterator.php  `  T2      /   phpunit/Metadata/Parser/Annotation/DocBlock.php$  `$        /   phpunit/Metadata/Parser/Annotation/Registry.php
  `
  -      ,   phpunit/Metadata/Parser/AnnotationParser.php7  `7   9      +   phpunit/Metadata/Parser/AttributeParser.php	I  `	I        )   phpunit/Metadata/Parser/CachingParser.php6  `6  p      2   phpunit/Metadata/Parser/InlineAnnotationParser.php  `  |      "   phpunit/Metadata/Parser/Parser.php  `  b      '   phpunit/Metadata/Parser/ParserChain.php>  `>        $   phpunit/Metadata/Parser/Registry.php  `  '      "   phpunit/Metadata/PostCondition.php!  `!  {T      !   phpunit/Metadata/PreCondition.php  `  O)      (   phpunit/Metadata/PreserveGlobalState.php  `  m{      %   phpunit/Metadata/RequiresFunction.php  `  g;7      #   phpunit/Metadata/RequiresMethod.phpP  `P  ]:V      ,   phpunit/Metadata/RequiresOperatingSystem.php4  `4  e7      2   phpunit/Metadata/RequiresOperatingSystemFamily.phpd  `d  y          phpunit/Metadata/RequiresPhp.php  `  Ip      )   phpunit/Metadata/RequiresPhpExtension.php  `        $   phpunit/Metadata/RequiresPhpunit.php  `  {      $   phpunit/Metadata/RequiresSetting.php  `  hQ@      .   phpunit/Metadata/RunClassInSeparateProcess.php9  `9  #      )   phpunit/Metadata/RunInSeparateProcess.php/  `/  e      0   phpunit/Metadata/RunTestsInSeparateProcesses.php=  `=  sC@         phpunit/Metadata/Test.php  `  ]fS         phpunit/Metadata/TestDox.php  `  8         phpunit/Metadata/TestWith.php  `  WR         phpunit/Metadata/Todo.php  `  e         phpunit/Metadata/Uses.php  `  `i         phpunit/Metadata/UsesClass.php)  `)  M      %   phpunit/Metadata/UsesDefaultClass.php  `  ':{      !   phpunit/Metadata/UsesFunction.php|  `|  <G         phpunit/Metadata/UsesMethod.php  `  s      1   phpunit/Metadata/VersionComparisonRequirement.phpa  `a  o      1   phpunit/Metadata/VersionConstraintRequirement.php&  `&  	      '   phpunit/Metadata/VersionRequirement.php  `           phpunit/Runner/CodeCoverage.php  `  !T      )   phpunit/Runner/DefaultTestResultCache.php  `  N         phpunit/Runner/Exception.php  `  $z      -   phpunit/Runner/Extension/ExtensionHandler.php(
  `(
  uw      '   phpunit/Runner/Extension/PharLoader.phpM
  `M
  rv      4   phpunit/Runner/Filter/ExcludeGroupFilterIterator.phpt  `t  $K      !   phpunit/Runner/Filter/Factory.php  `  AH      -   phpunit/Runner/Filter/GroupFilterIterator.php  `  1!      4   phpunit/Runner/Filter/IncludeGroupFilterIterator.phps  `s  ?      ,   phpunit/Runner/Filter/NameFilterIterator.php  `  v      /   phpunit/Runner/Hook/AfterIncompleteTestHook.phpG  `G  T      )   phpunit/Runner/Hook/AfterLastTestHook.php  `  w1      *   phpunit/Runner/Hook/AfterRiskyTestHook.php=  `=  m      ,   phpunit/Runner/Hook/AfterSkippedTestHook.phpA  `A  7G6      /   phpunit/Runner/Hook/AfterSuccessfulTestHook.php6  `6  *      *   phpunit/Runner/Hook/AfterTestErrorHook.php=  `=  H      ,   phpunit/Runner/Hook/AfterTestFailureHook.phpA  `A  z      %   phpunit/Runner/Hook/AfterTestHook.php  `  ZL-Z      ,   phpunit/Runner/Hook/AfterTestWarningHook.phpA  `A         +   phpunit/Runner/Hook/BeforeFirstTestHook.php  `  dR3      &   phpunit/Runner/Hook/BeforeTestHook.php  `  ]b         phpunit/Runner/Hook/Hook.php  `  <'w          phpunit/Runner/Hook/TestHook.php  `  K^      +   phpunit/Runner/Hook/TestListenerAdapter.phpL  `L         &   phpunit/Runner/NullTestResultCache.php  `  X         phpunit/Runner/PhptTestCase.php~W  `~W  Lt;      '   phpunit/Runner/ResultCacheExtension.php  `  (      "   phpunit/Runner/TestResultCache.phpI  `I  PY      "   phpunit/Runner/TestSuiteLoader.phpQ  `Q  R      "   phpunit/Runner/TestSuiteSorter.phpC-  `C-  B         phpunit/Runner/Version.php  `        '   phpunit/TextUI/CliArguments/Builder.phpU  `U  f      -   phpunit/TextUI/CliArguments/Configuration.php  `  m      )   phpunit/TextUI/CliArguments/Exception.php  `        &   phpunit/TextUI/CliArguments/Mapper.php+  `+  	         phpunit/TextUI/Command.phpc  `c  pV      '   phpunit/TextUI/DefaultResultPrinter.php9  `9  $      &   phpunit/TextUI/Exception/Exception.php  `  y5I      0   phpunit/TextUI/Exception/ReflectionException.php  `  [      -   phpunit/TextUI/Exception/RuntimeException.php  `  F      ;   phpunit/TextUI/Exception/TestDirectoryNotFoundException.php  `  I      6   phpunit/TextUI/Exception/TestFileNotFoundException.php  `  w         phpunit/TextUI/Help.php.  `.  2          phpunit/TextUI/ResultPrinter.php  `  y4k         phpunit/TextUI/TestRunner.phpJ  `J  I      "   phpunit/TextUI/TestSuiteMapper.php  `         =   phpunit/TextUI/XmlConfiguration/CodeCoverage/CodeCoverage.php#  `#  u,\      A   phpunit/TextUI/XmlConfiguration/CodeCoverage/Filter/Directory.php\  `\  O	      K   phpunit/TextUI/XmlConfiguration/CodeCoverage/Filter/DirectoryCollection.php  `  
      S   phpunit/TextUI/XmlConfiguration/CodeCoverage/Filter/DirectoryCollectionIterator.php  `  @      =   phpunit/TextUI/XmlConfiguration/CodeCoverage/FilterMapper.php  `  q      >   phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Clover.php  `  I9      A   phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Cobertura.php  `  P      >   phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Crap4j.php  `  +T%      <   phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Html.php  `  Px      ;   phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Php.php  `  h      <   phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Text.php  `  t      ;   phpunit/TextUI/XmlConfiguration/CodeCoverage/Report/Xml.php,  `,  ~      1   phpunit/TextUI/XmlConfiguration/Configuration.php  `  C      -   phpunit/TextUI/XmlConfiguration/Exception.php  `  K[      8   phpunit/TextUI/XmlConfiguration/Filesystem/Directory.phpw  `w        B   phpunit/TextUI/XmlConfiguration/Filesystem/DirectoryCollection.php  `        J   phpunit/TextUI/XmlConfiguration/Filesystem/DirectoryCollectionIterator.phpe  `e  ]LC      3   phpunit/TextUI/XmlConfiguration/Filesystem/File.phpr  `r  H      =   phpunit/TextUI/XmlConfiguration/Filesystem/FileCollection.phpL  `L  Xg	      E   phpunit/TextUI/XmlConfiguration/Filesystem/FileCollectionIterator.php-  `-  <%      -   phpunit/TextUI/XmlConfiguration/Generator.php%  `%        /   phpunit/TextUI/XmlConfiguration/Group/Group.phps  `s  ""      9   phpunit/TextUI/XmlConfiguration/Group/GroupCollection.php  `  N      A   phpunit/TextUI/XmlConfiguration/Group/GroupCollectionIterator.php7  `7  g.      0   phpunit/TextUI/XmlConfiguration/Group/Groups.php  `  76      *   phpunit/TextUI/XmlConfiguration/Loader.php|  `|  n      1   phpunit/TextUI/XmlConfiguration/Logging/Junit.php  `  ;      3   phpunit/TextUI/XmlConfiguration/Logging/Logging.php  `  |      4   phpunit/TextUI/XmlConfiguration/Logging/TeamCity.php  `  z      8   phpunit/TextUI/XmlConfiguration/Logging/TestDox/Html.php  `  O      8   phpunit/TextUI/XmlConfiguration/Logging/TestDox/Text.php  `        7   phpunit/TextUI/XmlConfiguration/Logging/TestDox/Xml.php  `  %      0   phpunit/TextUI/XmlConfiguration/Logging/Text.php  `        >   phpunit/TextUI/XmlConfiguration/Migration/MigrationBuilder.php@  `@  $#      G   phpunit/TextUI/XmlConfiguration/Migration/MigrationBuilderException.php  `  p       @   phpunit/TextUI/XmlConfiguration/Migration/MigrationException.php  `  H      H   phpunit/TextUI/XmlConfiguration/Migration/Migrations/ConvertLogTypes.php  `        O   phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageCloverToReport.phpZ  `Z        O   phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageCrap4jToReport.php  `  ^      M   phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageHtmlToReport.php  `  q      L   phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoveragePhpToReport.phpH  `H  QA      M   phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageTextToReport.php  `  8      L   phpunit/TextUI/XmlConfiguration/Migration/Migrations/CoverageXmlToReport.phpM  `M  P-      Y   phpunit/TextUI/XmlConfiguration/Migration/Migrations/IntroduceCacheDirectoryAttribute.php  `  Ni      Q   phpunit/TextUI/XmlConfiguration/Migration/Migrations/IntroduceCoverageElement.php  `  yG      M   phpunit/TextUI/XmlConfiguration/Migration/Migrations/LogToReportMigration.php  `  \2      B   phpunit/TextUI/XmlConfiguration/Migration/Migrations/Migration.php  `        d   phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveAttributesFromFilterWhitelistToCoverage.php  `  2]      Y   phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveAttributesFromRootToCoverage.phpE  `E  Ar      [   phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveWhitelistDirectoriesToCoverage.php  `  ,y      X   phpunit/TextUI/XmlConfiguration/Migration/Migrations/MoveWhitelistExcludesToCoverage.php  `  ,S      W   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCacheResultFileAttribute.php  `  99      S   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCacheTokensAttribute.php  `  [\      e   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCoverageElementCacheDirectoryAttribute.php  `  4Jc      l   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveCoverageElementProcessUncoveredFilesAttribute.php  `  S!      J   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveEmptyFilter.php  `  p      H   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveListeners.php)  `)  ZVW      G   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveLogTypes.php:  `:  |8      X   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RemoveTestSuiteLoaderAttributes.phpv  `v  >      ^   phpunit/TextUI/XmlConfiguration/Migration/Migrations/RenameBackupStaticAttributesAttribute.php  `  h      M   phpunit/TextUI/XmlConfiguration/Migration/Migrations/UpdateSchemaLocation.php0  `0  ND6      6   phpunit/TextUI/XmlConfiguration/Migration/Migrator.php  `  c~      0   phpunit/TextUI/XmlConfiguration/PHP/Constant.php  `  l4      :   phpunit/TextUI/XmlConfiguration/PHP/ConstantCollection.php6  `6  A      B   phpunit/TextUI/XmlConfiguration/PHP/ConstantCollectionIterator.phpU  `U  ZD      2   phpunit/TextUI/XmlConfiguration/PHP/IniSetting.php  `  I%      <   phpunit/TextUI/XmlConfiguration/PHP/IniSettingCollection.phpV  `V  d      D   phpunit/TextUI/XmlConfiguration/PHP/IniSettingCollectionIterator.phpi  `i        +   phpunit/TextUI/XmlConfiguration/PHP/Php.phpI  `I  c	      2   phpunit/TextUI/XmlConfiguration/PHP/PhpHandler.php  `  N<      0   phpunit/TextUI/XmlConfiguration/PHP/Variable.php  `        :   phpunit/TextUI/XmlConfiguration/PHP/VariableCollection.php6  `6  2|      B   phpunit/TextUI/XmlConfiguration/PHP/VariableCollectionIterator.phpU  `U  u~m      5   phpunit/TextUI/XmlConfiguration/PHPUnit/Extension.phpR  `R  t      ?   phpunit/TextUI/XmlConfiguration/PHPUnit/ExtensionCollection.php  `  pz      G   phpunit/TextUI/XmlConfiguration/PHPUnit/ExtensionCollectionIterator.php_  `_  u      3   phpunit/TextUI/XmlConfiguration/PHPUnit/PHPUnit.php99  `99        ;   phpunit/TextUI/XmlConfiguration/TestSuite/TestDirectory.php  `  z      E   phpunit/TextUI/XmlConfiguration/TestSuite/TestDirectoryCollection.php  `  )!      M   phpunit/TextUI/XmlConfiguration/TestSuite/TestDirectoryCollectionIterator.phpu  `u  >9=Z      6   phpunit/TextUI/XmlConfiguration/TestSuite/TestFile.php  `  _!=      @   phpunit/TextUI/XmlConfiguration/TestSuite/TestFileCollection.phph  `h  L      H   phpunit/TextUI/XmlConfiguration/TestSuite/TestFileCollectionIterator.php=  `=  J      7   phpunit/TextUI/XmlConfiguration/TestSuite/TestSuite.php  `        A   phpunit/TextUI/XmlConfiguration/TestSuite/TestSuiteCollection.php  `  s$      I   phpunit/TextUI/XmlConfiguration/TestSuite/TestSuiteCollectionIterator.php_  `_  VV          phpunit/Util/Color.php  `   '      "   phpunit/Util/Error/Deprecation.phpq  `q  |         phpunit/Util/Error/Error.phpz  `z  S0         phpunit/Util/Error/Handler.php  `  fs         phpunit/Util/Error/Notice.phpl  `l  ;X=x         phpunit/Util/Error/Warning.phpm  `m  0s;         phpunit/Util/Exception.php  `  6i         phpunit/Util/ExcludeList.php  `  o         phpunit/Util/Filesystem.php  `  5         phpunit/Util/Filter.php  `  d         phpunit/Util/GlobalState.php8  `8  {      (   phpunit/Util/InvalidDataSetException.php  `  kX8         phpunit/Util/Json.phpe  `e           phpunit/Util/Log/JUnit.php+  `+  5@c         phpunit/Util/Log/TeamCity.php.(  `.(  7
      '   phpunit/Util/PHP/AbstractPhpProcess.php(  `(  yo      &   phpunit/Util/PHP/DefaultPhpProcess.php  `  $      +   phpunit/Util/PHP/Template/TestCaseClass.tpl(  `(  !      ,   phpunit/Util/PHP/Template/TestCaseMethod.tplw  `w  C      *   phpunit/Util/PHP/Template/PhptTestCase.tpl  `  1      &   phpunit/Util/PHP/WindowsPhpProcess.php  `  C.m         phpunit/Util/Printer.php	  `	  Y      "   phpunit/Util/RegularExpression.php   `            phpunit/Util/Test.phpK
  `K
  Kg      *   phpunit/Util/TestDox/CliTestDoxPrinter.phpf+  `f+  s      *   phpunit/Util/TestDox/HtmlResultPrinter.php
  `
  @      '   phpunit/Util/TestDox/NamePrettifier.php$  `$        &   phpunit/Util/TestDox/ResultPrinter.php  `  Y-      '   phpunit/Util/TestDox/TestDoxPrinter.php+  `+  R-      *   phpunit/Util/TestDox/TextResultPrinter.php  `  k      )   phpunit/Util/TestDox/XmlResultPrinter.php&  `&        %   phpunit/Util/TextTestListRenderer.phps  `s  w         phpunit/Util/Type.php  `  XV      *   phpunit/Util/VersionComparisonOperator.php  `  RDD         phpunit/Util/Warning.phpq  `q           phpunit/Util/Xml.php  `            phpunit/Util/Xml/Exception.php  `  lJ      0   phpunit/Util/Xml/FailedSchemaDetectionResult.php  `  #S         phpunit/Util/Xml/Loader.php  `  <      *   phpunit/Util/Xml/SchemaDetectionResult.php  `  4z      #   phpunit/Util/Xml/SchemaDetector.php4  `4  D      !   phpunit/Util/Xml/SchemaFinder.php  `  g      %   phpunit/Util/Xml/SnapshotNodeList.php  `  -r.      4   phpunit/Util/Xml/SuccessfulSchemaDetectionResult.php  `  <"      %   phpunit/Util/Xml/ValidationResult.php  `  z         phpunit/Util/Xml/Validator.php
  `
  +f      $   phpunit/Util/XmlTestListRenderer.php	
  `	
  F~         schema/8.5.xsdB  `B  Wo*         schema/9.2.xsdB  `B  I*)         schema/9.5.xsd
F  `
F  ~         sebastian-cli-parser/LICENSE  `  u         sebastian-cli-parser/Parser.php  `  3      <   sebastian-cli-parser/exceptions/AmbiguousOptionException.phpm  `m  7d      -   sebastian-cli-parser/exceptions/Exception.phpv  `v  U      G   sebastian-cli-parser/exceptions/OptionDoesNotAllowArgumentException.php  `  O      J   sebastian-cli-parser/exceptions/RequiredOptionArgumentMissingException.php  `  l#      :   sebastian-cli-parser/exceptions/UnknownOptionException.phpf  `f  kr\      *   sebastian-code-unit-reverse-lookup/LICENSE  `  3G	(      -   sebastian-code-unit-reverse-lookup/Wizard.php  `  K      '   sebastian-code-unit/ClassMethodUnit.php;  `;  =q      !   sebastian-code-unit/ClassUnit.php)  `)  F          sebastian-code-unit/CodeUnit.phpO,  `O,  pk      *   sebastian-code-unit/CodeUnitCollection.php  `  ^3      2   sebastian-code-unit/CodeUnitCollectionIterator.phpn  `n  Vw          sebastian-code-unit/FileUnit.php&  `&  @      $   sebastian-code-unit/FunctionUnit.php2  `2        +   sebastian-code-unit/InterfaceMethodUnit.phpC  `C  X      %   sebastian-code-unit/InterfaceUnit.php5  `5           sebastian-code-unit/LICENSE  `  kl         sebastian-code-unit/Mapper.phpI  `I  rM      '   sebastian-code-unit/TraitMethodUnit.php;  `;  LE      !   sebastian-code-unit/TraitUnit.php)  `)  *      ,   sebastian-code-unit/exceptions/Exception.phpt  `t  |o      ;   sebastian-code-unit/exceptions/InvalidCodeUnitException.php  `  (x      3   sebastian-code-unit/exceptions/NoTraitException.php  `  g@\      6   sebastian-code-unit/exceptions/ReflectionException.php  `  +2      (   sebastian-comparator/ArrayComparator.php  `  1      #   sebastian-comparator/Comparator.php  `  i0      *   sebastian-comparator/ComparisonFailure.php  `  1i      *   sebastian-comparator/DOMNodeComparator.phpv  `v  *{      +   sebastian-comparator/DateTimeComparator.php	  `	  u      )   sebastian-comparator/DoubleComparator.php  `  @G^      ,   sebastian-comparator/ExceptionComparator.php  `  e          sebastian-comparator/Factory.php<  `<           sebastian-comparator/LICENSE	  `	  =(      -   sebastian-comparator/MockObjectComparator.php0  `0  \I      *   sebastian-comparator/NumericComparator.php	  `	  -      )   sebastian-comparator/ObjectComparator.php  `         +   sebastian-comparator/ResourceComparator.phpj  `j        )   sebastian-comparator/ScalarComparator.phpn  `n  u      3   sebastian-comparator/SplObjectStorageComparator.phpq  `q  :kh      '   sebastian-comparator/TypeComparator.php6  `6  YB      -   sebastian-comparator/exceptions/Exception.phpw  `w        4   sebastian-comparator/exceptions/RuntimeException.php  `  8t      #   sebastian-complexity/Calculator.php  `  E      .   sebastian-complexity/Complexity/Complexity.php  `  '      8   sebastian-complexity/Complexity/ComplexityCollection.phpS  `S  k      @   sebastian-complexity/Complexity/ComplexityCollectionIterator.phpc  `c  E_K      ,   sebastian-complexity/Exception/Exception.phpw  `w        3   sebastian-complexity/Exception/RuntimeException.php  `  y         sebastian-complexity/LICENSE  `        =   sebastian-complexity/Visitor/ComplexityCalculatingVisitor.phpe  `e  p      G   sebastian-complexity/Visitor/CyclomaticComplexityCalculatingVisitor.php  `  3J         sebastian-diff/Chunk.php  `  #I         sebastian-diff/Diff.phpj  `j  bXA         sebastian-diff/Differ.php%  `%  D'F      3   sebastian-diff/Exception/ConfigurationException.phpb  `b  @      &   sebastian-diff/Exception/Exception.phpk  `k  q{8^      5   sebastian-diff/Exception/InvalidArgumentException.php  `  " b         sebastian-diff/LICENSE  `  a1         sebastian-diff/Line.phpL  `L  
q      5   sebastian-diff/LongestCommonSubsequenceCalculator.php  `  }e7z      D   sebastian-diff/MemoryEfficientLongestCommonSubsequenceCalculator.php  `  yc      4   sebastian-diff/Output/AbstractChunkOutputBuilder.php  `  d      /   sebastian-diff/Output/DiffOnlyOutputBuilder.php	  `	  {N      4   sebastian-diff/Output/DiffOutputBuilderInterface.php  `  V      8   sebastian-diff/Output/StrictUnifiedDiffOutputBuilder.php*  `*  2tJB      2   sebastian-diff/Output/UnifiedDiffOutputBuilder.php   `            sebastian-diff/Parser.php  `  z      B   sebastian-diff/TimeEfficientLongestCommonSubsequenceCalculator.php  `  %`      !   sebastian-environment/Console.php  `  kg         sebastian-environment/LICENSE  `  lm|      )   sebastian-environment/OperatingSystem.php  `        !   sebastian-environment/Runtime.php  `  U         sebastian-exporter/Exporter.php)#  `)#  ,         sebastian-exporter/LICENSE  `        '   sebastian-global-state/CodeExporter.php	  `	  7      &   sebastian-global-state/ExcludeList.php
  `
  s!2         sebastian-global-state/LICENSE  `  a      #   sebastian-global-state/Restorer.php  `  tH}      #   sebastian-global-state/Snapshot.php*  `*        /   sebastian-global-state/exceptions/Exception.phpz  `z  @l6      6   sebastian-global-state/exceptions/RuntimeException.php  `  Wy      #   sebastian-lines-of-code/Counter.phpO
  `O
  >_      /   sebastian-lines-of-code/Exception/Exception.php{  `{  b_      >   sebastian-lines-of-code/Exception/IllogicalValuesException.php  `        <   sebastian-lines-of-code/Exception/NegativeValueException.php  `  ^      6   sebastian-lines-of-code/Exception/RuntimeException.php  `  VK         sebastian-lines-of-code/LICENSE  `        /   sebastian-lines-of-code/LineCountingVisitor.php	  `	  P60      '   sebastian-lines-of-code/LinesOfCode.phpD
  `D
  ^/[      *   sebastian-object-enumerator/Enumerator.php	  `	  |      )   sebastian-object-enumerator/Exception.php  `  -3}      8   sebastian-object-enumerator/InvalidArgumentException.php  `  XD      (   sebastian-object-reflector/Exception.php  `  [ 8      7   sebastian-object-reflector/InvalidArgumentException.php  `  j{      .   sebastian-object-reflector/ObjectReflector.php  `  C      '   sebastian-recursion-context/Context.phpC  `C  )E      )   sebastian-recursion-context/Exception.php  `  9S      8   sebastian-recursion-context/InvalidArgumentException.php  `  I      #   sebastian-recursion-context/LICENSE  `  `      %   sebastian-resource-operations/LICENSE  `  ]<      4   sebastian-resource-operations/ResourceOperations.php  `           sebastian-type/CallableType.php  `  ]f      $   sebastian-type/GenericObjectType.php(  `(  *z         sebastian-type/IterableType.phpY  `Y  P         sebastian-type/LICENSE  `  +         sebastian-type/MixedType.php  `  /         sebastian-type/NullType.php  `  1K         sebastian-type/ObjectType.phpy  `y  N      #   sebastian-type/ReflectionMapper.php  `  (         sebastian-type/SimpleType.php  `  p2         sebastian-type/StaticType.php  `  k_C         sebastian-type/Type.php  `  Q         sebastian-type/TypeName.php	  `	  `c8         sebastian-type/UnionType.php
  `
  U         sebastian-type/UnknownType.phpm  `m  lV         sebastian-type/VoidType.php  `   l      &   sebastian-type/exception/Exception.phpk  `k         -   sebastian-type/exception/RuntimeException.php  `  r         sebastian-version/LICENSE  `  LN         sebastian-version/Version.phpi  `i  A         theseer-tokenizer/Exception.phpn   `n   '         theseer-tokenizer/LICENSE  `  R(      "   theseer-tokenizer/NamespaceUri.phpc  `c  jpw      +   theseer-tokenizer/NamespaceUriException.php   `   >JD         theseer-tokenizer/Token.php  `  4      %   theseer-tokenizer/TokenCollection.php  `  K      .   theseer-tokenizer/TokenCollectionException.php   `   'p         theseer-tokenizer/Tokenizer.php  `  `      #   theseer-tokenizer/XMLSerializer.phpq	  `q	  !         .phpstorm.meta.php  `  G      <?php

namespace PHPUnit\Doctrine\Instantiator\Exception;

use Throwable;
/**
 * Base exception marker interface for the instantiator component
 */
interface ExceptionInterface extends \Throwable
{
}
<?php

namespace PHPUnit\Doctrine\Instantiator\Exception;

use InvalidArgumentException as BaseInvalidArgumentException;
use ReflectionClass;
use function interface_exists;
use function sprintf;
use function trait_exists;
/**
 * Exception for invalid arguments provided to the instantiator
 */
class InvalidArgumentException extends \InvalidArgumentException implements \PHPUnit\Doctrine\Instantiator\Exception\ExceptionInterface
{
    public static function fromNonExistingClass(string $className) : self
    {
        if (\interface_exists($className)) {
            return new self(\sprintf('The provided type "%s" is an interface, and can not be instantiated', $className));
        }
        if (\trait_exists($className)) {
            return new self(\sprintf('The provided type "%s" is a trait, and can not be instantiated', $className));
        }
        return new self(\sprintf('The provided class "%s" does not exist', $className));
    }
    /**
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    public static function fromAbstractClass(\ReflectionClass $reflectionClass) : self
    {
        return new self(\sprintf('The provided class "%s" is abstract, and can not be instantiated', $reflectionClass->getName()));
    }
}
<?php

namespace PHPUnit\Doctrine\Instantiator\Exception;

use Exception;
use ReflectionClass;
use UnexpectedValueException as BaseUnexpectedValueException;
use function sprintf;
/**
 * Exception for given parameters causing invalid/unexpected state on instantiation
 */
class UnexpectedValueException extends \UnexpectedValueException implements \PHPUnit\Doctrine\Instantiator\Exception\ExceptionInterface
{
    /**
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    public static function fromSerializationTriggeredException(\ReflectionClass $reflectionClass, \Exception $exception) : self
    {
        return new self(\sprintf('An exception was raised while trying to instantiate an instance of "%s" via un-serialization', $reflectionClass->getName()), 0, $exception);
    }
    /**
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    public static function fromUncleanUnSerialization(\ReflectionClass $reflectionClass, string $errorString, int $errorCode, string $errorFile, int $errorLine) : self
    {
        return new self(\sprintf('Could not produce an instance of "%s" via un-serialization, since an error was triggered ' . 'in file "%s" at line "%d"', $reflectionClass->getName(), $errorFile, $errorLine), 0, new \Exception($errorString, $errorCode));
    }
}
<?php

namespace PHPUnit\Doctrine\Instantiator;

use ArrayIterator;
use PHPUnit\Doctrine\Instantiator\Exception\InvalidArgumentException;
use PHPUnit\Doctrine\Instantiator\Exception\UnexpectedValueException;
use Exception;
use ReflectionClass;
use ReflectionException;
use Serializable;
use function class_exists;
use function is_subclass_of;
use function restore_error_handler;
use function set_error_handler;
use function sprintf;
use function strlen;
use function unserialize;
final class Instantiator implements \PHPUnit\Doctrine\Instantiator\InstantiatorInterface
{
    /**
     * Markers used internally by PHP to define whether {@see \unserialize} should invoke
     * the method {@see \Serializable::unserialize()} when dealing with classes implementing
     * the {@see \Serializable} interface.
     */
    public const SERIALIZATION_FORMAT_USE_UNSERIALIZER = 'C';
    public const SERIALIZATION_FORMAT_AVOID_UNSERIALIZER = 'O';
    /**
     * Used to instantiate specific classes, indexed by class name.
     *
     * @var callable[]
     */
    private static $cachedInstantiators = [];
    /**
     * Array of objects that can directly be cloned, indexed by class name.
     *
     * @var object[]
     */
    private static $cachedCloneables = [];
    /**
     * {@inheritDoc}
     */
    public function instantiate($className)
    {
        if (isset(self::$cachedCloneables[$className])) {
            return clone self::$cachedCloneables[$className];
        }
        if (isset(self::$cachedInstantiators[$className])) {
            $factory = self::$cachedInstantiators[$className];
            return $factory();
        }
        return $this->buildAndCacheFromFactory($className);
    }
    /**
     * Builds the requested object and caches it in static properties for performance
     *
     * @return object
     *
     * @template T of object
     * @phpstan-param class-string<T> $className
     *
     * @phpstan-return T
     */
    private function buildAndCacheFromFactory(string $className)
    {
        $factory = self::$cachedInstantiators[$className] = $this->buildFactory($className);
        $instance = $factory();
        if ($this->isSafeToClone(new \ReflectionClass($instance))) {
            self::$cachedCloneables[$className] = clone $instance;
        }
        return $instance;
    }
    /**
     * Builds a callable capable of instantiating the given $className without
     * invoking its constructor.
     *
     * @throws InvalidArgumentException
     * @throws UnexpectedValueException
     * @throws ReflectionException
     *
     * @template T of object
     * @phpstan-param class-string<T> $className
     *
     * @phpstan-return callable(): T
     */
    private function buildFactory(string $className) : callable
    {
        $reflectionClass = $this->getReflectionClass($className);
        if ($this->isInstantiableViaReflection($reflectionClass)) {
            return [$reflectionClass, 'newInstanceWithoutConstructor'];
        }
        $serializedString = \sprintf('%s:%d:"%s":0:{}', \is_subclass_of($className, \Serializable::class) ? self::SERIALIZATION_FORMAT_USE_UNSERIALIZER : self::SERIALIZATION_FORMAT_AVOID_UNSERIALIZER, \strlen($className), $className);
        $this->checkIfUnSerializationIsSupported($reflectionClass, $serializedString);
        return static function () use($serializedString) {
            return \unserialize($serializedString);
        };
    }
    /**
     * @throws InvalidArgumentException
     * @throws ReflectionException
     *
     * @template T of object
     * @phpstan-param class-string<T> $className
     *
     * @phpstan-return ReflectionClass<T>
     */
    private function getReflectionClass(string $className) : \ReflectionClass
    {
        if (!\class_exists($className)) {
            throw \PHPUnit\Doctrine\Instantiator\Exception\InvalidArgumentException::fromNonExistingClass($className);
        }
        $reflection = new \ReflectionClass($className);
        if ($reflection->isAbstract()) {
            throw \PHPUnit\Doctrine\Instantiator\Exception\InvalidArgumentException::fromAbstractClass($reflection);
        }
        return $reflection;
    }
    /**
     * @throws UnexpectedValueException
     *
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    private function checkIfUnSerializationIsSupported(\ReflectionClass $reflectionClass, string $serializedString) : void
    {
        \set_error_handler(static function (int $code, string $message, string $file, int $line) use($reflectionClass, &$error) : bool {
            $error = \PHPUnit\Doctrine\Instantiator\Exception\UnexpectedValueException::fromUncleanUnSerialization($reflectionClass, $message, $code, $file, $line);
            return \true;
        });
        try {
            $this->attemptInstantiationViaUnSerialization($reflectionClass, $serializedString);
        } finally {
            \restore_error_handler();
        }
        if ($error) {
            throw $error;
        }
    }
    /**
     * @throws UnexpectedValueException
     *
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    private function attemptInstantiationViaUnSerialization(\ReflectionClass $reflectionClass, string $serializedString) : void
    {
        try {
            \unserialize($serializedString);
        } catch (\Exception $exception) {
            throw \PHPUnit\Doctrine\Instantiator\Exception\UnexpectedValueException::fromSerializationTriggeredException($reflectionClass, $exception);
        }
    }
    /**
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    private function isInstantiableViaReflection(\ReflectionClass $reflectionClass) : bool
    {
        return !($this->hasInternalAncestors($reflectionClass) && $reflectionClass->isFinal());
    }
    /**
     * Verifies whether the given class is to be considered internal
     *
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    private function hasInternalAncestors(\ReflectionClass $reflectionClass) : bool
    {
        do {
            if ($reflectionClass->isInternal()) {
                return \true;
            }
            $reflectionClass = $reflectionClass->getParentClass();
        } while ($reflectionClass);
        return \false;
    }
    /**
     * Checks if a class is cloneable
     *
     * Classes implementing `__clone` cannot be safely cloned, as that may cause side-effects.
     *
     * @template T of object
     * @phpstan-param ReflectionClass<T> $reflectionClass
     */
    private function isSafeToClone(\ReflectionClass $reflectionClass) : bool
    {
        return $reflectionClass->isCloneable() && !$reflectionClass->hasMethod('__clone') && !$reflectionClass->isSubclassOf(\ArrayIterator::class);
    }
}
<?php

namespace PHPUnit\Doctrine\Instantiator;

use PHPUnit\Doctrine\Instantiator\Exception\ExceptionInterface;
/**
 * Instantiator provides utility methods to build objects without invoking their constructors
 */
interface InstantiatorInterface
{
    /**
     * @param string $className
     *
     * @return object
     *
     * @throws ExceptionInterface
     *
     * @template T of object
     * @phpstan-param class-string<T> $className
     */
    public function instantiate($className);
}
Copyright (c) 2014 Doctrine Project

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
phpunit/phpunit: master@bf65459024fbba4b86cf96a34db77e9cd114830a
doctrine/instantiator: 1.4.0
myclabs/deep-copy: 1.10.2
nikic/php-parser: v4.10.5
phar-io/manifest: 2.0.1
phar-io/version: 3.1.0
phpunit/php-code-coverage: dev-master@e9a3c44ea916a9878834b1bfeffb2cba5a6e57cb
phpunit/php-file-iterator: 3.0.5
phpunit/php-invoker: 3.1.1
phpunit/php-text-template: 2.0.4
phpunit/php-timer: 5.0.3
sebastian/cli-parser: 1.0.1
sebastian/code-unit: dev-master@0cbcc3b60805d93a1b10ae180e557a980ad2b0d4
sebastian/code-unit-reverse-lookup: 2.0.3
sebastian/comparator: 4.0.6
sebastian/complexity: dev-master@9469022fc36561d7372819361e7cf4497eee0afa
sebastian/diff: 4.0.4
sebastian/environment: 5.1.3
sebastian/exporter: 4.0.3
sebastian/global-state: 5.0.2
sebastian/lines-of-code: dev-master@2afa4bfbaacc7ad7cfc73811c09f070a157835f6
sebastian/object-enumerator: 4.0.4
sebastian/object-reflector: 2.0.4
sebastian/recursion-context: 4.0.4
sebastian/resource-operations: 3.0.3
sebastian/type: 2.3.1
sebastian/version: dev-master@49701f70ea1c19671039b413f4c8a0ca75910da9
theseer/tokenizer: 1.2.0
<?php

namespace PHPUnit\DeepCopy;

use ArrayObject;
use DateInterval;
use DateTimeInterface;
use DateTimeZone;
use PHPUnit\DeepCopy\Exception\CloneException;
use PHPUnit\DeepCopy\Filter\Filter;
use PHPUnit\DeepCopy\Matcher\Matcher;
use PHPUnit\DeepCopy\Reflection\ReflectionHelper;
use PHPUnit\DeepCopy\TypeFilter\Date\DateIntervalFilter;
use PHPUnit\DeepCopy\TypeFilter\Spl\ArrayObjectFilter;
use PHPUnit\DeepCopy\TypeFilter\Spl\SplDoublyLinkedListFilter;
use PHPUnit\DeepCopy\TypeFilter\TypeFilter;
use PHPUnit\DeepCopy\TypeMatcher\TypeMatcher;
use ReflectionObject;
use ReflectionProperty;
use SplDoublyLinkedList;
/**
 * @final
 */
class DeepCopy
{
    /**
     * @var object[] List of objects copied.
     */
    private $hashMap = [];
    /**
     * Filters to apply.
     *
     * @var array Array of ['filter' => Filter, 'matcher' => Matcher] pairs.
     */
    private $filters = [];
    /**
     * Type Filters to apply.
     *
     * @var array Array of ['filter' => Filter, 'matcher' => Matcher] pairs.
     */
    private $typeFilters = [];
    /**
     * @var bool
     */
    private $skipUncloneable = \false;
    /**
     * @var bool
     */
    private $useCloneMethod;
    /**
     * @param bool $useCloneMethod   If set to true, when an object implements the __clone() function, it will be used
     *                               instead of the regular deep cloning.
     */
    public function __construct($useCloneMethod = \false)
    {
        $this->useCloneMethod = $useCloneMethod;
        $this->addTypeFilter(new \PHPUnit\DeepCopy\TypeFilter\Spl\ArrayObjectFilter($this), new \PHPUnit\DeepCopy\TypeMatcher\TypeMatcher(\ArrayObject::class));
        $this->addTypeFilter(new \PHPUnit\DeepCopy\TypeFilter\Date\DateIntervalFilter(), new \PHPUnit\DeepCopy\TypeMatcher\TypeMatcher(\DateInterval::class));
        $this->addTypeFilter(new \PHPUnit\DeepCopy\TypeFilter\Spl\SplDoublyLinkedListFilter($this), new \PHPUnit\DeepCopy\TypeMatcher\TypeMatcher(\SplDoublyLinkedList::class));
    }
    /**
     * If enabled, will not throw an exception when coming across an uncloneable property.
     *
     * @param $skipUncloneable
     *
     * @return $this
     */
    public function skipUncloneable($skipUncloneable = \true)
    {
        $this->skipUncloneable = $skipUncloneable;
        return $this;
    }
    /**
     * Deep copies the given object.
     *
     * @param mixed $object
     *
     * @return mixed
     */
    public function copy($object)
    {
        $this->hashMap = [];
        return $this->recursiveCopy($object);
    }
    public function addFilter(\PHPUnit\DeepCopy\Filter\Filter $filter, \PHPUnit\DeepCopy\Matcher\Matcher $matcher)
    {
        $this->filters[] = ['matcher' => $matcher, 'filter' => $filter];
    }
    public function prependFilter(\PHPUnit\DeepCopy\Filter\Filter $filter, \PHPUnit\DeepCopy\Matcher\Matcher $matcher)
    {
        \array_unshift($this->filters, ['matcher' => $matcher, 'filter' => $filter]);
    }
    public function addTypeFilter(\PHPUnit\DeepCopy\TypeFilter\TypeFilter $filter, \PHPUnit\DeepCopy\TypeMatcher\TypeMatcher $matcher)
    {
        $this->typeFilters[] = ['matcher' => $matcher, 'filter' => $filter];
    }
    private function recursiveCopy($var)
    {
        // Matches Type Filter
        if ($filter = $this->getFirstMatchedTypeFilter($this->typeFilters, $var)) {
            return $filter->apply($var);
        }
        // Resource
        if (\is_resource($var)) {
            return $var;
        }
        // Array
        if (\is_array($var)) {
            return $this->copyArray($var);
        }
        // Scalar
        if (!\is_object($var)) {
            return $var;
        }
        // Object
        return $this->copyObject($var);
    }
    /**
     * Copy an array
     * @param array $array
     * @return array
     */
    private function copyArray(array $array)
    {
        foreach ($array as $key => $value) {
            $array[$key] = $this->recursiveCopy($value);
        }
        return $array;
    }
    /**
     * Copies an object.
     *
     * @param object $object
     *
     * @throws CloneException
     *
     * @return object
     */
    private function copyObject($object)
    {
        $objectHash = \spl_object_hash($object);
        if (isset($this->hashMap[$objectHash])) {
            return $this->hashMap[$objectHash];
        }
        $reflectedObject = new \ReflectionObject($object);
        $isCloneable = $reflectedObject->isCloneable();
        if (\false === $isCloneable) {
            if ($this->skipUncloneable) {
                $this->hashMap[$objectHash] = $object;
                return $object;
            }
            throw new \PHPUnit\DeepCopy\Exception\CloneException(\sprintf('The class "%s" is not cloneable.', $reflectedObject->getName()));
        }
        $newObject = clone $object;
        $this->hashMap[$objectHash] = $newObject;
        if ($this->useCloneMethod && $reflectedObject->hasMethod('__clone')) {
            return $newObject;
        }
        if ($newObject instanceof \DateTimeInterface || $newObject instanceof \DateTimeZone) {
            return $newObject;
        }
        foreach (\PHPUnit\DeepCopy\Reflection\ReflectionHelper::getProperties($reflectedObject) as $property) {
            $this->copyObjectProperty($newObject, $property);
        }
        return $newObject;
    }
    private function copyObjectProperty($object, \ReflectionProperty $property)
    {
        // Ignore static properties
        if ($property->isStatic()) {
            return;
        }
        // Apply the filters
        foreach ($this->filters as $item) {
            /** @var Matcher $matcher */
            $matcher = $item['matcher'];
            /** @var Filter $filter */
            $filter = $item['filter'];
            if ($matcher->matches($object, $property->getName())) {
                $filter->apply($object, $property->getName(), function ($object) {
                    return $this->recursiveCopy($object);
                });
                // If a filter matches, we stop processing this property
                return;
            }
        }
        $property->setAccessible(\true);
        // Ignore uninitialized properties (for PHP >7.4)
        if (\method_exists($property, 'isInitialized') && !$property->isInitialized($object)) {
            return;
        }
        $propertyValue = $property->getValue($object);
        // Copy the property
        $property->setValue($object, $this->recursiveCopy($propertyValue));
    }
    /**
     * Returns first filter that matches variable, `null` if no such filter found.
     *
     * @param array $filterRecords Associative array with 2 members: 'filter' with value of type {@see TypeFilter} and
     *                             'matcher' with value of type {@see TypeMatcher}
     * @param mixed $var
     *
     * @return TypeFilter|null
     */
    private function getFirstMatchedTypeFilter(array $filterRecords, $var)
    {
        $matched = $this->first($filterRecords, function (array $record) use($var) {
            /* @var TypeMatcher $matcher */
            $matcher = $record['matcher'];
            return $matcher->matches($var);
        });
        return isset($matched) ? $matched['filter'] : null;
    }
    /**
     * Returns first element that matches predicate, `null` if no such element found.
     *
     * @param array    $elements Array of ['filter' => Filter, 'matcher' => Matcher] pairs.
     * @param callable $predicate Predicate arguments are: element.
     *
     * @return array|null Associative array with 2 members: 'filter' with value of type {@see TypeFilter} and 'matcher'
     *                    with value of type {@see TypeMatcher} or `null`.
     */
    private function first(array $elements, callable $predicate)
    {
        foreach ($elements as $element) {
            if (\call_user_func($predicate, $element)) {
                return $element;
            }
        }
        return null;
    }
}
<?php

namespace PHPUnit\DeepCopy\Exception;

use UnexpectedValueException;
class CloneException extends \UnexpectedValueException
{
}
<?php

namespace PHPUnit\DeepCopy\Exception;

use ReflectionException;
class PropertyException extends \ReflectionException
{
}
<?php

namespace PHPUnit\DeepCopy\Filter\Doctrine;

use PHPUnit\DeepCopy\Filter\Filter;
use PHPUnit\DeepCopy\Reflection\ReflectionHelper;
/**
 * @final
 */
class DoctrineCollectionFilter implements \PHPUnit\DeepCopy\Filter\Filter
{
    /**
     * Copies the object property doctrine collection.
     *
     * {@inheritdoc}
     */
    public function apply($object, $property, $objectCopier)
    {
        $reflectionProperty = \PHPUnit\DeepCopy\Reflection\ReflectionHelper::getProperty($object, $property);
        $reflectionProperty->setAccessible(\true);
        $oldCollection = $reflectionProperty->getValue($object);
        $newCollection = $oldCollection->map(function ($item) use($objectCopier) {
            return $objectCopier($item);
        });
        $reflectionProperty->setValue($object, $newCollection);
    }
}
<?php

namespace PHPUnit\DeepCopy\Filter\Doctrine;

use PHPUnit\DeepCopy\Filter\Filter;
use PHPUnit\DeepCopy\Reflection\ReflectionHelper;
use PHPUnit\Doctrine\Common\Collections\ArrayCollection;
/**
 * @final
 */
class DoctrineEmptyCollectionFilter implements \PHPUnit\DeepCopy\Filter\Filter
{
    /**
     * Sets the object property to an empty doctrine collection.
     *
     * @param object   $object
     * @param string   $property
     * @param callable $objectCopier
     */
    public function apply($object, $property, $objectCopier)
    {
        $reflectionProperty = \PHPUnit\DeepCopy\Reflection\ReflectionHelper::getProperty($object, $property);
        $reflectionProperty->setAccessible(\true);
        $reflectionProperty->setValue($object, new \PHPUnit\Doctrine\Common\Collections\ArrayCollection());
    }
}
<?php

namespace PHPUnit\DeepCopy\Filter\Doctrine;

use PHPUnit\DeepCopy\Filter\Filter;
/**
 * @final
 */
class DoctrineProxyFilter implements \PHPUnit\DeepCopy\Filter\Filter
{
    /**
     * Triggers the magic method __load() on a Doctrine Proxy class to load the
     * actual entity from the database.
     *
     * {@inheritdoc}
     */
    public function apply($object, $property, $objectCopier)
    {
        $object->__load();
    }
}
<?php

namespace PHPUnit\DeepCopy\Filter;

/**
 * Filter to apply to a property while copying an object
 */
interface Filter
{
    /**
     * Applies the filter to the object.
     *
     * @param object   $object
     * @param string   $property
     * @param callable $objectCopier
     */
    public function apply($object, $property, $objectCopier);
}
<?php

namespace PHPUnit\DeepCopy\Filter;

class KeepFilter implements \PHPUnit\DeepCopy\Filter\Filter
{
    /**
     * Keeps the value of the object property.
     *
     * {@inheritdoc}
     */
    public function apply($object, $property, $objectCopier)
    {
        // Nothing to do
    }
}
<?php

namespace PHPUnit\DeepCopy\Filter;

use PHPUnit\DeepCopy\Reflection\ReflectionHelper;
/**
 * @final
 */
class ReplaceFilter implements \PHPUnit\DeepCopy\Filter\Filter
{
    /**
     * @var callable
     */
    protected $callback;
    /**
     * @param callable $callable Will be called to get the new value for each property to replace
     */
    public function __construct(callable $callable)
    {
        $this->callback = $callable;
    }
    /**
     * Replaces the object property by the result of the callback called with the object property.
     *
     * {@inheritdoc}
     */
    public function apply($object, $property, $objectCopier)
    {
        $reflectionProperty = \PHPUnit\DeepCopy\Reflection\ReflectionHelper::getProperty($object, $property);
        $reflectionProperty->setAccessible(\true);
        $value = \call_user_func($this->callback, $reflectionProperty->getValue($object));
        $reflectionProperty->setValue($object, $value);
    }
}
<?php

namespace PHPUnit\DeepCopy\Filter;

use PHPUnit\DeepCopy\Reflection\ReflectionHelper;
/**
 * @final
 */
class SetNullFilter implements \PHPUnit\DeepCopy\Filter\Filter
{
    /**
     * Sets the object property to null.
     *
     * {@inheritdoc}
     */
    public function apply($object, $property, $objectCopier)
    {
        $reflectionProperty = \PHPUnit\DeepCopy\Reflection\ReflectionHelper::getProperty($object, $property);
        $reflectionProperty->setAccessible(\true);
        $reflectionProperty->setValue($object, null);
    }
}
<?php

namespace PHPUnit\DeepCopy\Matcher\Doctrine;

use PHPUnit\DeepCopy\Matcher\Matcher;
use PHPUnit\Doctrine\Common\Persistence\Proxy;
/**
 * @final
 */
class DoctrineProxyMatcher implements \PHPUnit\DeepCopy\Matcher\Matcher
{
    /**
     * Matches a Doctrine Proxy class.
     *
     * {@inheritdoc}
     */
    public function matches($object, $property)
    {
        return $object instanceof \PHPUnit\Doctrine\Common\Persistence\Proxy;
    }
}
<?php

namespace PHPUnit\DeepCopy\Matcher;

interface Matcher
{
    /**
     * @param object $object
     * @param string $property
     *
     * @return boolean
     */
    public function matches($object, $property);
}
<?php

namespace PHPUnit\DeepCopy\Matcher;

/**
 * @final
 */
class PropertyMatcher implements \PHPUnit\DeepCopy\Matcher\Matcher
{
    /**
     * @var string
     */
    private $class;
    /**
     * @var string
     */
    private $property;
    /**
     * @param string $class    Class name
     * @param string $property Property name
     */
    public function __construct($class, $property)
    {
        $this->class = $class;
        $this->property = $property;
    }
    /**
     * Matches a specific property of a specific class.
     *
     * {@inheritdoc}
     */
    public function matches($object, $property)
    {
        return $object instanceof $this->class && $property == $this->property;
    }
}
<?php

namespace PHPUnit\DeepCopy\Matcher;

/**
 * @final
 */
class PropertyNameMatcher implements \PHPUnit\DeepCopy\Matcher\Matcher
{
    /**
     * @var string
     */
    private $property;
    /**
     * @param string $property Property name
     */
    public function __construct($property)
    {
        $this->property = $property;
    }
    /**
     * Matches a property by its name.
     *
     * {@inheritdoc}
     */
    public function matches($object, $property)
    {
        return $property == $this->property;
    }
}
<?php

namespace PHPUnit\DeepCopy\Matcher;

use PHPUnit\DeepCopy\Reflection\ReflectionHelper;
use ReflectionException;
/**
 * Matches a property by its type.
 *
 * It is recommended to use {@see DeepCopy\TypeFilter\TypeFilter} instead, as it applies on all occurrences
 * of given type in copied context (eg. array elements), not just on object properties.
 *
 * @final
 */
class PropertyTypeMatcher implements \PHPUnit\DeepCopy\Matcher\Matcher
{
    /**
     * @var string
     */
    private $propertyType;
    /**
     * @param string $propertyType Property type
     */
    public function __construct($propertyType)
    {
        $this->propertyType = $propertyType;
    }
    /**
     * {@inheritdoc}
     */
    public function matches($object, $property)
    {
        try {
            $reflectionProperty = \PHPUnit\DeepCopy\Reflection\ReflectionHelper::getProperty($object, $property);
        } catch (\ReflectionException $exception) {
            return \false;
        }
        $reflectionProperty->setAccessible(\true);
        // Uninitialized properties (for PHP >7.4)
        if (\method_exists($reflectionProperty, 'isInitialized') && !$reflectionProperty->isInitialized($object)) {
            // null instanceof $this->propertyType
            return \false;
        }
        return $reflectionProperty->getValue($object) instanceof $this->propertyType;
    }
}
<?php

namespace PHPUnit\DeepCopy\Reflection;

use PHPUnit\DeepCopy\Exception\PropertyException;
use ReflectionClass;
use ReflectionException;
use ReflectionObject;
use ReflectionProperty;
class ReflectionHelper
{
    /**
     * Retrieves all properties (including private ones), from object and all its ancestors.
     *
     * Standard \ReflectionClass->getProperties() does not return private properties from ancestor classes.
     *
     * @author muratyaman@gmail.com
     * @see http://php.net/manual/en/reflectionclass.getproperties.php
     *
     * @param ReflectionClass $ref
     *
     * @return ReflectionProperty[]
     */
    public static function getProperties(\ReflectionClass $ref)
    {
        $props = $ref->getProperties();
        $propsArr = array();
        foreach ($props as $prop) {
            $propertyName = $prop->getName();
            $propsArr[$propertyName] = $prop;
        }
        if ($parentClass = $ref->getParentClass()) {
            $parentPropsArr = self::getProperties($parentClass);
            foreach ($propsArr as $key => $property) {
                $parentPropsArr[$key] = $property;
            }
            return $parentPropsArr;
        }
        return $propsArr;
    }
    /**
     * Retrieves property by name from object and all its ancestors.
     *
     * @param object|string $object
     * @param string $name
     *
     * @throws PropertyException
     * @throws ReflectionException
     *
     * @return ReflectionProperty
     */
    public static function getProperty($object, $name)
    {
        $reflection = \is_object($object) ? new \ReflectionObject($object) : new \ReflectionClass($object);
        if ($reflection->hasProperty($name)) {
            return $reflection->getProperty($name);
        }
        if ($parentClass = $reflection->getParentClass()) {
            return self::getProperty($parentClass->getName(), $name);
        }
        throw new \PHPUnit\DeepCopy\Exception\PropertyException(\sprintf('The class "%s" doesn\'t have a property with the given name: "%s".', \is_object($object) ? \get_class($object) : $object, $name));
    }
}
<?php

namespace PHPUnit\DeepCopy\TypeFilter\Date;

use DateInterval;
use PHPUnit\DeepCopy\TypeFilter\TypeFilter;
/**
 * @final
 *
 * @deprecated Will be removed in 2.0. This filter will no longer be necessary in PHP 7.1+.
 */
class DateIntervalFilter implements \PHPUnit\DeepCopy\TypeFilter\TypeFilter
{
    /**
     * {@inheritdoc}
     *
     * @param DateInterval $element
     *
     * @see http://news.php.net/php.bugs/205076
     */
    public function apply($element)
    {
        $copy = new \DateInterval('P0D');
        foreach ($element as $propertyName => $propertyValue) {
            $copy->{$propertyName} = $propertyValue;
        }
        return $copy;
    }
}
<?php

namespace PHPUnit\DeepCopy\TypeFilter;

/**
 * @final
 */
class ReplaceFilter implements \PHPUnit\DeepCopy\TypeFilter\TypeFilter
{
    /**
     * @var callable
     */
    protected $callback;
    /**
     * @param callable $callable Will be called to get the new value for each element to replace
     */
    public function __construct(callable $callable)
    {
        $this->callback = $callable;
    }
    /**
     * {@inheritdoc}
     */
    public function apply($element)
    {
        return \call_user_func($this->callback, $element);
    }
}
<?php

namespace PHPUnit\DeepCopy\TypeFilter;

/**
 * @final
 */
class ShallowCopyFilter implements \PHPUnit\DeepCopy\TypeFilter\TypeFilter
{
    /**
     * {@inheritdoc}
     */
    public function apply($element)
    {
        return clone $element;
    }
}
<?php

namespace PHPUnit\DeepCopy\TypeFilter\Spl;

use PHPUnit\DeepCopy\DeepCopy;
use PHPUnit\DeepCopy\TypeFilter\TypeFilter;
/**
 * In PHP 7.4 the storage of an ArrayObject isn't returned as
 * ReflectionProperty. So we deep copy its array copy.
 */
final class ArrayObjectFilter implements \PHPUnit\DeepCopy\TypeFilter\TypeFilter
{
    /**
     * @var DeepCopy
     */
    private $copier;
    public function __construct(\PHPUnit\DeepCopy\DeepCopy $copier)
    {
        $this->copier = $copier;
    }
    /**
     * {@inheritdoc}
     */
    public function apply($arrayObject)
    {
        $clone = clone $arrayObject;
        foreach ($arrayObject->getArrayCopy() as $k => $v) {
            $clone->offsetSet($k, $this->copier->copy($v));
        }
        return $clone;
    }
}
<?php

namespace PHPUnit\DeepCopy\TypeFilter\Spl;

/**
 * @deprecated Use {@see SplDoublyLinkedListFilter} instead.
 */
class SplDoublyLinkedList extends \PHPUnit\DeepCopy\TypeFilter\Spl\SplDoublyLinkedListFilter
{
}
<?php

namespace PHPUnit\DeepCopy\TypeFilter\Spl;

use Closure;
use PHPUnit\DeepCopy\DeepCopy;
use PHPUnit\DeepCopy\TypeFilter\TypeFilter;
use SplDoublyLinkedList;
/**
 * @final
 */
class SplDoublyLinkedListFilter implements \PHPUnit\DeepCopy\TypeFilter\TypeFilter
{
    private $copier;
    public function __construct(\PHPUnit\DeepCopy\DeepCopy $copier)
    {
        $this->copier = $copier;
    }
    /**
     * {@inheritdoc}
     */
    public function apply($element)
    {
        $newElement = clone $element;
        $copy = $this->createCopyClosure();
        return $copy($newElement);
    }
    private function createCopyClosure()
    {
        $copier = $this->copier;
        $copy = function (\SplDoublyLinkedList $list) use($copier) {
            // Replace each element in the list with a deep copy of itself
            for ($i = 1; $i <= $list->count(); $i++) {
                $copy = $copier->recursiveCopy($list->shift());
                $list->push($copy);
            }
            return $list;
        };
        return \Closure::bind($copy, null, \PHPUnit\DeepCopy\DeepCopy::class);
    }
}
<?php

namespace PHPUnit\DeepCopy\TypeFilter;

interface TypeFilter
{
    /**
     * Applies the filter to the object.
     *
     * @param mixed $element
     */
    public function apply($element);
}
<?php

namespace PHPUnit\DeepCopy\TypeMatcher;

class TypeMatcher
{
    /**
     * @var string
     */
    private $type;
    /**
     * @param string $type
     */
    public function __construct($type)
    {
        $this->type = $type;
    }
    /**
     * @param mixed $element
     *
     * @return boolean
     */
    public function matches($element)
    {
        return \is_object($element) ? \is_a($element, $this->type) : \gettype($element) === $this->type;
    }
}
<?php

namespace PHPUnit\DeepCopy;

use function function_exists;
if (\false === \function_exists('PHPUnit\\DeepCopy\\deep_copy')) {
    /**
     * Deep copies the given value.
     *
     * @param mixed $value
     * @param bool  $useCloneMethod
     *
     * @return mixed
     */
    function deep_copy($value, $useCloneMethod = \false)
    {
        return (new \PHPUnit\DeepCopy\DeepCopy($useCloneMethod))->copy($value);
    }
}
The MIT License (MIT)

Copyright (c) 2013 My C-Sense

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
BSD 3-Clause License

Copyright (c) 2011, Nikita Popov
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

interface Builder
{
    /**
     * Returns the built node.
     *
     * @return Node The built node
     */
    public function getNode() : \PHPUnit\PhpParser\Node;
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node\Const_;
use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Stmt;
class ClassConst implements \PHPUnit\PhpParser\Builder
{
    protected $flags = 0;
    protected $attributes = [];
    protected $constants = [];
    /**
     * Creates a class constant builder
     *
     * @param string|Identifier                          $name  Name
     * @param Node\Expr|bool|null|int|float|string|array $value Value
     */
    public function __construct($name, $value)
    {
        $this->constants = [new \PHPUnit\PhpParser\Node\Const_($name, \PHPUnit\PhpParser\BuilderHelpers::normalizeValue($value))];
    }
    /**
     * Add another constant to const group
     *
     * @param string|Identifier                          $name  Name
     * @param Node\Expr|bool|null|int|float|string|array $value Value
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addConst($name, $value)
    {
        $this->constants[] = new \PHPUnit\PhpParser\Node\Const_($name, \PHPUnit\PhpParser\BuilderHelpers::normalizeValue($value));
        return $this;
    }
    /**
     * Makes the constant public.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePublic()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC);
        return $this;
    }
    /**
     * Makes the constant protected.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeProtected()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED);
        return $this;
    }
    /**
     * Makes the constant private.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePrivate()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE);
        return $this;
    }
    /**
     * Sets doc comment for the constant.
     *
     * @param PhpParser\Comment\Doc|string $docComment Doc comment to set
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function setDocComment($docComment)
    {
        $this->attributes = ['comments' => [\PHPUnit\PhpParser\BuilderHelpers::normalizeDocComment($docComment)]];
        return $this;
    }
    /**
     * Returns the built class node.
     *
     * @return Stmt\ClassConst The built constant node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\ClassConst($this->constants, $this->flags, $this->attributes);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Stmt;
class Class_ extends \PHPUnit\PhpParser\Builder\Declaration
{
    protected $name;
    protected $extends = null;
    protected $implements = [];
    protected $flags = 0;
    protected $uses = [];
    protected $constants = [];
    protected $properties = [];
    protected $methods = [];
    /**
     * Creates a class builder.
     *
     * @param string $name Name of the class
     */
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    /**
     * Extends a class.
     *
     * @param Name|string $class Name of class to extend
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function extend($class)
    {
        $this->extends = \PHPUnit\PhpParser\BuilderHelpers::normalizeName($class);
        return $this;
    }
    /**
     * Implements one or more interfaces.
     *
     * @param Name|string ...$interfaces Names of interfaces to implement
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function implement(...$interfaces)
    {
        foreach ($interfaces as $interface) {
            $this->implements[] = \PHPUnit\PhpParser\BuilderHelpers::normalizeName($interface);
        }
        return $this;
    }
    /**
     * Makes the class abstract.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeAbstract()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT);
        return $this;
    }
    /**
     * Makes the class final.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeFinal()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL);
        return $this;
    }
    /**
     * Adds a statement.
     *
     * @param Stmt|PhpParser\Builder $stmt The statement to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addStmt($stmt)
    {
        $stmt = \PHPUnit\PhpParser\BuilderHelpers::normalizeNode($stmt);
        $targets = [\PHPUnit\PhpParser\Node\Stmt\TraitUse::class => &$this->uses, \PHPUnit\PhpParser\Node\Stmt\ClassConst::class => &$this->constants, \PHPUnit\PhpParser\Node\Stmt\Property::class => &$this->properties, \PHPUnit\PhpParser\Node\Stmt\ClassMethod::class => &$this->methods];
        $class = \get_class($stmt);
        if (!isset($targets[$class])) {
            throw new \LogicException(\sprintf('Unexpected node of type "%s"', $stmt->getType()));
        }
        $targets[$class][] = $stmt;
        return $this;
    }
    /**
     * Returns the built class node.
     *
     * @return Stmt\Class_ The built class node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\Class_($this->name, ['flags' => $this->flags, 'extends' => $this->extends, 'implements' => $this->implements, 'stmts' => \array_merge($this->uses, $this->constants, $this->properties, $this->methods)], $this->attributes);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
abstract class Declaration implements \PHPUnit\PhpParser\Builder
{
    protected $attributes = [];
    public abstract function addStmt($stmt);
    /**
     * Adds multiple statements.
     *
     * @param array $stmts The statements to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addStmts(array $stmts)
    {
        foreach ($stmts as $stmt) {
            $this->addStmt($stmt);
        }
        return $this;
    }
    /**
     * Sets doc comment for the declaration.
     *
     * @param PhpParser\Comment\Doc|string $docComment Doc comment to set
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function setDocComment($docComment)
    {
        $this->attributes['comments'] = [\PHPUnit\PhpParser\BuilderHelpers::normalizeDocComment($docComment)];
        return $this;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
abstract class FunctionLike extends \PHPUnit\PhpParser\Builder\Declaration
{
    protected $returnByRef = \false;
    protected $params = [];
    /** @var string|Node\Name|Node\NullableType|null */
    protected $returnType = null;
    /**
     * Make the function return by reference.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeReturnByRef()
    {
        $this->returnByRef = \true;
        return $this;
    }
    /**
     * Adds a parameter.
     *
     * @param Node\Param|Param $param The parameter to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addParam($param)
    {
        $param = \PHPUnit\PhpParser\BuilderHelpers::normalizeNode($param);
        if (!$param instanceof \PHPUnit\PhpParser\Node\Param) {
            throw new \LogicException(\sprintf('Expected parameter node, got "%s"', $param->getType()));
        }
        $this->params[] = $param;
        return $this;
    }
    /**
     * Adds multiple parameters.
     *
     * @param array $params The parameters to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addParams(array $params)
    {
        foreach ($params as $param) {
            $this->addParam($param);
        }
        return $this;
    }
    /**
     * Sets the return type for PHP 7.
     *
     * @param string|Node\Name|Node\NullableType $type One of array, callable, string, int, float,
     *                                                 bool, iterable, or a class/interface name.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function setReturnType($type)
    {
        $this->returnType = \PHPUnit\PhpParser\BuilderHelpers::normalizeType($type);
        return $this;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt;
class Function_ extends \PHPUnit\PhpParser\Builder\FunctionLike
{
    protected $name;
    protected $stmts = [];
    /**
     * Creates a function builder.
     *
     * @param string $name Name of the function
     */
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    /**
     * Adds a statement.
     *
     * @param Node|PhpParser\Builder $stmt The statement to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addStmt($stmt)
    {
        $this->stmts[] = \PHPUnit\PhpParser\BuilderHelpers::normalizeStmt($stmt);
        return $this;
    }
    /**
     * Returns the built function node.
     *
     * @return Stmt\Function_ The built function node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\Function_($this->name, ['byRef' => $this->returnByRef, 'params' => $this->params, 'returnType' => $this->returnType, 'stmts' => $this->stmts], $this->attributes);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Stmt;
class Interface_ extends \PHPUnit\PhpParser\Builder\Declaration
{
    protected $name;
    protected $extends = [];
    protected $constants = [];
    protected $methods = [];
    /**
     * Creates an interface builder.
     *
     * @param string $name Name of the interface
     */
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    /**
     * Extends one or more interfaces.
     *
     * @param Name|string ...$interfaces Names of interfaces to extend
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function extend(...$interfaces)
    {
        foreach ($interfaces as $interface) {
            $this->extends[] = \PHPUnit\PhpParser\BuilderHelpers::normalizeName($interface);
        }
        return $this;
    }
    /**
     * Adds a statement.
     *
     * @param Stmt|PhpParser\Builder $stmt The statement to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addStmt($stmt)
    {
        $stmt = \PHPUnit\PhpParser\BuilderHelpers::normalizeNode($stmt);
        if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\ClassConst) {
            $this->constants[] = $stmt;
        } elseif ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod) {
            // we erase all statements in the body of an interface method
            $stmt->stmts = null;
            $this->methods[] = $stmt;
        } else {
            throw new \LogicException(\sprintf('Unexpected node of type "%s"', $stmt->getType()));
        }
        return $this;
    }
    /**
     * Returns the built interface node.
     *
     * @return Stmt\Interface_ The built interface node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\Interface_($this->name, ['extends' => $this->extends, 'stmts' => \array_merge($this->constants, $this->methods)], $this->attributes);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt;
class Method extends \PHPUnit\PhpParser\Builder\FunctionLike
{
    protected $name;
    protected $flags = 0;
    /** @var array|null */
    protected $stmts = [];
    /**
     * Creates a method builder.
     *
     * @param string $name Name of the method
     */
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    /**
     * Makes the method public.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePublic()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC);
        return $this;
    }
    /**
     * Makes the method protected.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeProtected()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED);
        return $this;
    }
    /**
     * Makes the method private.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePrivate()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE);
        return $this;
    }
    /**
     * Makes the method static.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeStatic()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC);
        return $this;
    }
    /**
     * Makes the method abstract.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeAbstract()
    {
        if (!empty($this->stmts)) {
            throw new \LogicException('Cannot make method with statements abstract');
        }
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT);
        $this->stmts = null;
        // abstract methods don't have statements
        return $this;
    }
    /**
     * Makes the method final.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeFinal()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL);
        return $this;
    }
    /**
     * Adds a statement.
     *
     * @param Node|PhpParser\Builder $stmt The statement to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addStmt($stmt)
    {
        if (null === $this->stmts) {
            throw new \LogicException('Cannot add statements to an abstract method');
        }
        $this->stmts[] = \PHPUnit\PhpParser\BuilderHelpers::normalizeStmt($stmt);
        return $this;
    }
    /**
     * Returns the built method node.
     *
     * @return Stmt\ClassMethod The built method node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\ClassMethod($this->name, ['flags' => $this->flags, 'byRef' => $this->returnByRef, 'params' => $this->params, 'returnType' => $this->returnType, 'stmts' => $this->stmts], $this->attributes);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt;
class Namespace_ extends \PHPUnit\PhpParser\Builder\Declaration
{
    private $name;
    private $stmts = [];
    /**
     * Creates a namespace builder.
     *
     * @param Node\Name|string|null $name Name of the namespace
     */
    public function __construct($name)
    {
        $this->name = null !== $name ? \PHPUnit\PhpParser\BuilderHelpers::normalizeName($name) : null;
    }
    /**
     * Adds a statement.
     *
     * @param Node|PhpParser\Builder $stmt The statement to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addStmt($stmt)
    {
        $this->stmts[] = \PHPUnit\PhpParser\BuilderHelpers::normalizeStmt($stmt);
        return $this;
    }
    /**
     * Returns the built node.
     *
     * @return Stmt\Namespace_ The built node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\Namespace_($this->name, $this->stmts, $this->attributes);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
class Param implements \PHPUnit\PhpParser\Builder
{
    protected $name;
    protected $default = null;
    /** @var Node\Identifier|Node\Name|Node\NullableType|null */
    protected $type = null;
    protected $byRef = \false;
    protected $variadic = \false;
    /**
     * Creates a parameter builder.
     *
     * @param string $name Name of the parameter
     */
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    /**
     * Sets default value for the parameter.
     *
     * @param mixed $value Default value to use
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function setDefault($value)
    {
        $this->default = \PHPUnit\PhpParser\BuilderHelpers::normalizeValue($value);
        return $this;
    }
    /**
     * Sets type for the parameter.
     *
     * @param string|Node\Name|Node\NullableType|Node\UnionType $type Parameter type
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function setType($type)
    {
        $this->type = \PHPUnit\PhpParser\BuilderHelpers::normalizeType($type);
        if ($this->type == 'void') {
            throw new \LogicException('Parameter type cannot be void');
        }
        return $this;
    }
    /**
     * Sets type for the parameter.
     *
     * @param string|Node\Name|Node\NullableType|Node\UnionType $type Parameter type
     *
     * @return $this The builder instance (for fluid interface)
     *
     * @deprecated Use setType() instead
     */
    public function setTypeHint($type)
    {
        return $this->setType($type);
    }
    /**
     * Make the parameter accept the value by reference.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeByRef()
    {
        $this->byRef = \true;
        return $this;
    }
    /**
     * Make the parameter variadic
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeVariadic()
    {
        $this->variadic = \true;
        return $this;
    }
    /**
     * Returns the built parameter node.
     *
     * @return Node\Param The built parameter node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Param(new \PHPUnit\PhpParser\Node\Expr\Variable($this->name), $this->default, $this->type, $this->byRef, $this->variadic);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\NullableType;
use PHPUnit\PhpParser\Node\Stmt;
class Property implements \PHPUnit\PhpParser\Builder
{
    protected $name;
    protected $flags = 0;
    protected $default = null;
    protected $attributes = [];
    /** @var null|Identifier|Name|NullableType */
    protected $type;
    /**
     * Creates a property builder.
     *
     * @param string $name Name of the property
     */
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    /**
     * Makes the property public.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePublic()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC);
        return $this;
    }
    /**
     * Makes the property protected.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeProtected()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED);
        return $this;
    }
    /**
     * Makes the property private.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePrivate()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE);
        return $this;
    }
    /**
     * Makes the property static.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeStatic()
    {
        $this->flags = \PHPUnit\PhpParser\BuilderHelpers::addModifier($this->flags, \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC);
        return $this;
    }
    /**
     * Sets default value for the property.
     *
     * @param mixed $value Default value to use
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function setDefault($value)
    {
        $this->default = \PHPUnit\PhpParser\BuilderHelpers::normalizeValue($value);
        return $this;
    }
    /**
     * Sets doc comment for the property.
     *
     * @param PhpParser\Comment\Doc|string $docComment Doc comment to set
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function setDocComment($docComment)
    {
        $this->attributes = ['comments' => [\PHPUnit\PhpParser\BuilderHelpers::normalizeDocComment($docComment)]];
        return $this;
    }
    /**
     * Sets the property type for PHP 7.4+.
     *
     * @param string|Name|NullableType|Identifier $type
     *
     * @return $this
     */
    public function setType($type)
    {
        $this->type = \PHPUnit\PhpParser\BuilderHelpers::normalizeType($type);
        return $this;
    }
    /**
     * Returns the built class node.
     *
     * @return Stmt\Property The built property node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\Property($this->flags !== 0 ? $this->flags : \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC, [new \PHPUnit\PhpParser\Node\Stmt\PropertyProperty($this->name, $this->default)], $this->attributes, $this->type);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser\Builder;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt;
class TraitUse implements \PHPUnit\PhpParser\Builder
{
    protected $traits = [];
    protected $adaptations = [];
    /**
     * Creates a trait use builder.
     *
     * @param Node\Name|string ...$traits Names of used traits
     */
    public function __construct(...$traits)
    {
        foreach ($traits as $trait) {
            $this->and($trait);
        }
    }
    /**
     * Adds used trait.
     *
     * @param Node\Name|string $trait Trait name
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function and($trait)
    {
        $this->traits[] = \PHPUnit\PhpParser\BuilderHelpers::normalizeName($trait);
        return $this;
    }
    /**
     * Adds trait adaptation.
     *
     * @param Stmt\TraitUseAdaptation|Builder\TraitUseAdaptation $adaptation Trait adaptation
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function with($adaptation)
    {
        $adaptation = \PHPUnit\PhpParser\BuilderHelpers::normalizeNode($adaptation);
        if (!$adaptation instanceof \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation) {
            throw new \LogicException('Adaptation must have type TraitUseAdaptation');
        }
        $this->adaptations[] = $adaptation;
        return $this;
    }
    /**
     * Returns the built node.
     *
     * @return Node The built node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\TraitUse($this->traits, $this->adaptations);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser\Builder;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt;
class TraitUseAdaptation implements \PHPUnit\PhpParser\Builder
{
    const TYPE_UNDEFINED = 0;
    const TYPE_ALIAS = 1;
    const TYPE_PRECEDENCE = 2;
    /** @var int Type of building adaptation */
    protected $type;
    protected $trait;
    protected $method;
    protected $modifier = null;
    protected $alias = null;
    protected $insteadof = [];
    /**
     * Creates a trait use adaptation builder.
     *
     * @param Node\Name|string|null  $trait  Name of adaptated trait
     * @param Node\Identifier|string $method Name of adaptated method
     */
    public function __construct($trait, $method)
    {
        $this->type = self::TYPE_UNDEFINED;
        $this->trait = \is_null($trait) ? null : \PHPUnit\PhpParser\BuilderHelpers::normalizeName($trait);
        $this->method = \PHPUnit\PhpParser\BuilderHelpers::normalizeIdentifier($method);
    }
    /**
     * Sets alias of method.
     *
     * @param Node\Identifier|string $alias Alias for adaptated method
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function as($alias)
    {
        if ($this->type === self::TYPE_UNDEFINED) {
            $this->type = self::TYPE_ALIAS;
        }
        if ($this->type !== self::TYPE_ALIAS) {
            throw new \LogicException('Cannot set alias for not alias adaptation buider');
        }
        $this->alias = $alias;
        return $this;
    }
    /**
     * Sets adaptated method public.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePublic()
    {
        $this->setModifier(\PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC);
        return $this;
    }
    /**
     * Sets adaptated method protected.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makeProtected()
    {
        $this->setModifier(\PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED);
        return $this;
    }
    /**
     * Sets adaptated method private.
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function makePrivate()
    {
        $this->setModifier(\PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE);
        return $this;
    }
    /**
     * Adds overwritten traits.
     *
     * @param Node\Name|string ...$traits Traits for overwrite
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function insteadof(...$traits)
    {
        if ($this->type === self::TYPE_UNDEFINED) {
            if (\is_null($this->trait)) {
                throw new \LogicException('Precedence adaptation must have trait');
            }
            $this->type = self::TYPE_PRECEDENCE;
        }
        if ($this->type !== self::TYPE_PRECEDENCE) {
            throw new \LogicException('Cannot add overwritten traits for not precedence adaptation buider');
        }
        foreach ($traits as $trait) {
            $this->insteadof[] = \PHPUnit\PhpParser\BuilderHelpers::normalizeName($trait);
        }
        return $this;
    }
    protected function setModifier(int $modifier)
    {
        if ($this->type === self::TYPE_UNDEFINED) {
            $this->type = self::TYPE_ALIAS;
        }
        if ($this->type !== self::TYPE_ALIAS) {
            throw new \LogicException('Cannot set access modifier for not alias adaptation buider');
        }
        if (\is_null($this->modifier)) {
            $this->modifier = $modifier;
        } else {
            throw new \LogicException('Multiple access type modifiers are not allowed');
        }
    }
    /**
     * Returns the built node.
     *
     * @return Node The built node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        switch ($this->type) {
            case self::TYPE_ALIAS:
                return new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->trait, $this->method, $this->modifier, $this->alias);
            case self::TYPE_PRECEDENCE:
                return new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Precedence($this->trait, $this->method, $this->insteadof);
            default:
                throw new \LogicException('Type of adaptation is not defined');
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node\Stmt;
class Trait_ extends \PHPUnit\PhpParser\Builder\Declaration
{
    protected $name;
    protected $uses = [];
    protected $properties = [];
    protected $methods = [];
    /**
     * Creates an interface builder.
     *
     * @param string $name Name of the interface
     */
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    /**
     * Adds a statement.
     *
     * @param Stmt|PhpParser\Builder $stmt The statement to add
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function addStmt($stmt)
    {
        $stmt = \PHPUnit\PhpParser\BuilderHelpers::normalizeNode($stmt);
        if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Property) {
            $this->properties[] = $stmt;
        } elseif ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod) {
            $this->methods[] = $stmt;
        } elseif ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\TraitUse) {
            $this->uses[] = $stmt;
        } else {
            throw new \LogicException(\sprintf('Unexpected node of type "%s"', $stmt->getType()));
        }
        return $this;
    }
    /**
     * Returns the built trait node.
     *
     * @return Stmt\Trait_ The built interface node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\Trait_($this->name, ['stmts' => \array_merge($this->uses, $this->properties, $this->methods)], $this->attributes);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Builder;

use PHPUnit\PhpParser\Builder;
use PHPUnit\PhpParser\BuilderHelpers;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt;
class Use_ implements \PHPUnit\PhpParser\Builder
{
    protected $name;
    protected $type;
    protected $alias = null;
    /**
     * Creates a name use (alias) builder.
     *
     * @param Node\Name|string $name Name of the entity (namespace, class, function, constant) to alias
     * @param int              $type One of the Stmt\Use_::TYPE_* constants
     */
    public function __construct($name, int $type)
    {
        $this->name = \PHPUnit\PhpParser\BuilderHelpers::normalizeName($name);
        $this->type = $type;
    }
    /**
     * Sets alias for used name.
     *
     * @param string $alias Alias to use (last component of full name by default)
     *
     * @return $this The builder instance (for fluid interface)
     */
    public function as(string $alias)
    {
        $this->alias = $alias;
        return $this;
    }
    /**
     * Returns the built node.
     *
     * @return Stmt\Use_ The built node
     */
    public function getNode() : \PHPUnit\PhpParser\Node
    {
        return new \PHPUnit\PhpParser\Node\Stmt\Use_([new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->name, $this->alias)], $this->type);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\Node\Arg;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat;
use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Scalar\String_;
use PHPUnit\PhpParser\Node\Stmt\Use_;
class BuilderFactory
{
    /**
     * Creates a namespace builder.
     *
     * @param null|string|Node\Name $name Name of the namespace
     *
     * @return Builder\Namespace_ The created namespace builder
     */
    public function namespace($name) : \PHPUnit\PhpParser\Builder\Namespace_
    {
        return new \PHPUnit\PhpParser\Builder\Namespace_($name);
    }
    /**
     * Creates a class builder.
     *
     * @param string $name Name of the class
     *
     * @return Builder\Class_ The created class builder
     */
    public function class(string $name) : \PHPUnit\PhpParser\Builder\Class_
    {
        return new \PHPUnit\PhpParser\Builder\Class_($name);
    }
    /**
     * Creates an interface builder.
     *
     * @param string $name Name of the interface
     *
     * @return Builder\Interface_ The created interface builder
     */
    public function interface(string $name) : \PHPUnit\PhpParser\Builder\Interface_
    {
        return new \PHPUnit\PhpParser\Builder\Interface_($name);
    }
    /**
     * Creates a trait builder.
     *
     * @param string $name Name of the trait
     *
     * @return Builder\Trait_ The created trait builder
     */
    public function trait(string $name) : \PHPUnit\PhpParser\Builder\Trait_
    {
        return new \PHPUnit\PhpParser\Builder\Trait_($name);
    }
    /**
     * Creates a trait use builder.
     *
     * @param Node\Name|string ...$traits Trait names
     *
     * @return Builder\TraitUse The create trait use builder
     */
    public function useTrait(...$traits) : \PHPUnit\PhpParser\Builder\TraitUse
    {
        return new \PHPUnit\PhpParser\Builder\TraitUse(...$traits);
    }
    /**
     * Creates a trait use adaptation builder.
     *
     * @param Node\Name|string|null  $trait  Trait name
     * @param Node\Identifier|string $method Method name
     *
     * @return Builder\TraitUseAdaptation The create trait use adaptation builder
     */
    public function traitUseAdaptation($trait, $method = null) : \PHPUnit\PhpParser\Builder\TraitUseAdaptation
    {
        if ($method === null) {
            $method = $trait;
            $trait = null;
        }
        return new \PHPUnit\PhpParser\Builder\TraitUseAdaptation($trait, $method);
    }
    /**
     * Creates a method builder.
     *
     * @param string $name Name of the method
     *
     * @return Builder\Method The created method builder
     */
    public function method(string $name) : \PHPUnit\PhpParser\Builder\Method
    {
        return new \PHPUnit\PhpParser\Builder\Method($name);
    }
    /**
     * Creates a parameter builder.
     *
     * @param string $name Name of the parameter
     *
     * @return Builder\Param The created parameter builder
     */
    public function param(string $name) : \PHPUnit\PhpParser\Builder\Param
    {
        return new \PHPUnit\PhpParser\Builder\Param($name);
    }
    /**
     * Creates a property builder.
     *
     * @param string $name Name of the property
     *
     * @return Builder\Property The created property builder
     */
    public function property(string $name) : \PHPUnit\PhpParser\Builder\Property
    {
        return new \PHPUnit\PhpParser\Builder\Property($name);
    }
    /**
     * Creates a function builder.
     *
     * @param string $name Name of the function
     *
     * @return Builder\Function_ The created function builder
     */
    public function function(string $name) : \PHPUnit\PhpParser\Builder\Function_
    {
        return new \PHPUnit\PhpParser\Builder\Function_($name);
    }
    /**
     * Creates a namespace/class use builder.
     *
     * @param Node\Name|string $name Name of the entity (namespace or class) to alias
     *
     * @return Builder\Use_ The created use builder
     */
    public function use($name) : \PHPUnit\PhpParser\Builder\Use_
    {
        return new \PHPUnit\PhpParser\Builder\Use_($name, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL);
    }
    /**
     * Creates a function use builder.
     *
     * @param Node\Name|string $name Name of the function to alias
     *
     * @return Builder\Use_ The created use function builder
     */
    public function useFunction($name) : \PHPUnit\PhpParser\Builder\Use_
    {
        return new \PHPUnit\PhpParser\Builder\Use_($name, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION);
    }
    /**
     * Creates a constant use builder.
     *
     * @param Node\Name|string $name Name of the const to alias
     *
     * @return Builder\Use_ The created use const builder
     */
    public function useConst($name) : \PHPUnit\PhpParser\Builder\Use_
    {
        return new \PHPUnit\PhpParser\Builder\Use_($name, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT);
    }
    /**
     * Creates a class constant builder.
     *
     * @param string|Identifier                          $name  Name
     * @param Node\Expr|bool|null|int|float|string|array $value Value
     *
     * @return Builder\ClassConst The created use const builder
     */
    public function classConst($name, $value) : \PHPUnit\PhpParser\Builder\ClassConst
    {
        return new \PHPUnit\PhpParser\Builder\ClassConst($name, $value);
    }
    /**
     * Creates node a for a literal value.
     *
     * @param Expr|bool|null|int|float|string|array $value $value
     *
     * @return Expr
     */
    public function val($value) : \PHPUnit\PhpParser\Node\Expr
    {
        return \PHPUnit\PhpParser\BuilderHelpers::normalizeValue($value);
    }
    /**
     * Creates variable node.
     *
     * @param string|Expr $name Name
     *
     * @return Expr\Variable
     */
    public function var($name) : \PHPUnit\PhpParser\Node\Expr\Variable
    {
        if (!\is_string($name) && !$name instanceof \PHPUnit\PhpParser\Node\Expr) {
            throw new \LogicException('Variable name must be string or Expr');
        }
        return new \PHPUnit\PhpParser\Node\Expr\Variable($name);
    }
    /**
     * Normalizes an argument list.
     *
     * Creates Arg nodes for all arguments and converts literal values to expressions.
     *
     * @param array $args List of arguments to normalize
     *
     * @return Arg[]
     */
    public function args(array $args) : array
    {
        $normalizedArgs = [];
        foreach ($args as $arg) {
            if ($arg instanceof \PHPUnit\PhpParser\Node\Arg) {
                $normalizedArgs[] = $arg;
            } else {
                $normalizedArgs[] = new \PHPUnit\PhpParser\Node\Arg(\PHPUnit\PhpParser\BuilderHelpers::normalizeValue($arg));
            }
        }
        return $normalizedArgs;
    }
    /**
     * Creates a function call node.
     *
     * @param string|Name|Expr $name Function name
     * @param array            $args Function arguments
     *
     * @return Expr\FuncCall
     */
    public function funcCall($name, array $args = []) : \PHPUnit\PhpParser\Node\Expr\FuncCall
    {
        return new \PHPUnit\PhpParser\Node\Expr\FuncCall(\PHPUnit\PhpParser\BuilderHelpers::normalizeNameOrExpr($name), $this->args($args));
    }
    /**
     * Creates a method call node.
     *
     * @param Expr                   $var  Variable the method is called on
     * @param string|Identifier|Expr $name Method name
     * @param array                  $args Method arguments
     *
     * @return Expr\MethodCall
     */
    public function methodCall(\PHPUnit\PhpParser\Node\Expr $var, $name, array $args = []) : \PHPUnit\PhpParser\Node\Expr\MethodCall
    {
        return new \PHPUnit\PhpParser\Node\Expr\MethodCall($var, \PHPUnit\PhpParser\BuilderHelpers::normalizeIdentifierOrExpr($name), $this->args($args));
    }
    /**
     * Creates a static method call node.
     *
     * @param string|Name|Expr       $class Class name
     * @param string|Identifier|Expr $name  Method name
     * @param array                  $args  Method arguments
     *
     * @return Expr\StaticCall
     */
    public function staticCall($class, $name, array $args = []) : \PHPUnit\PhpParser\Node\Expr\StaticCall
    {
        return new \PHPUnit\PhpParser\Node\Expr\StaticCall(\PHPUnit\PhpParser\BuilderHelpers::normalizeNameOrExpr($class), \PHPUnit\PhpParser\BuilderHelpers::normalizeIdentifierOrExpr($name), $this->args($args));
    }
    /**
     * Creates an object creation node.
     *
     * @param string|Name|Expr $class Class name
     * @param array            $args  Constructor arguments
     *
     * @return Expr\New_
     */
    public function new($class, array $args = []) : \PHPUnit\PhpParser\Node\Expr\New_
    {
        return new \PHPUnit\PhpParser\Node\Expr\New_(\PHPUnit\PhpParser\BuilderHelpers::normalizeNameOrExpr($class), $this->args($args));
    }
    /**
     * Creates a constant fetch node.
     *
     * @param string|Name $name Constant name
     *
     * @return Expr\ConstFetch
     */
    public function constFetch($name) : \PHPUnit\PhpParser\Node\Expr\ConstFetch
    {
        return new \PHPUnit\PhpParser\Node\Expr\ConstFetch(\PHPUnit\PhpParser\BuilderHelpers::normalizeName($name));
    }
    /**
     * Creates a property fetch node.
     *
     * @param Expr                   $var  Variable holding object
     * @param string|Identifier|Expr $name Property name
     *
     * @return Expr\PropertyFetch
     */
    public function propertyFetch(\PHPUnit\PhpParser\Node\Expr $var, $name) : \PHPUnit\PhpParser\Node\Expr\PropertyFetch
    {
        return new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($var, \PHPUnit\PhpParser\BuilderHelpers::normalizeIdentifierOrExpr($name));
    }
    /**
     * Creates a class constant fetch node.
     *
     * @param string|Name|Expr  $class Class name
     * @param string|Identifier $name  Constant name
     *
     * @return Expr\ClassConstFetch
     */
    public function classConstFetch($class, $name) : \PHPUnit\PhpParser\Node\Expr\ClassConstFetch
    {
        return new \PHPUnit\PhpParser\Node\Expr\ClassConstFetch(\PHPUnit\PhpParser\BuilderHelpers::normalizeNameOrExpr($class), \PHPUnit\PhpParser\BuilderHelpers::normalizeIdentifier($name));
    }
    /**
     * Creates nested Concat nodes from a list of expressions.
     *
     * @param Expr|string ...$exprs Expressions or literal strings
     *
     * @return Concat
     */
    public function concat(...$exprs) : \PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat
    {
        $numExprs = \count($exprs);
        if ($numExprs < 2) {
            throw new \LogicException('Expected at least two expressions');
        }
        $lastConcat = $this->normalizeStringExpr($exprs[0]);
        for ($i = 1; $i < $numExprs; $i++) {
            $lastConcat = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat($lastConcat, $this->normalizeStringExpr($exprs[$i]));
        }
        return $lastConcat;
    }
    /**
     * @param string|Expr $expr
     * @return Expr
     */
    private function normalizeStringExpr($expr) : \PHPUnit\PhpParser\Node\Expr
    {
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr) {
            return $expr;
        }
        if (\is_string($expr)) {
            return new \PHPUnit\PhpParser\Node\Scalar\String_($expr);
        }
        throw new \LogicException('Expected string or Expr');
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\NullableType;
use PHPUnit\PhpParser\Node\Scalar;
use PHPUnit\PhpParser\Node\Stmt;
use PHPUnit\PhpParser\Node\UnionType;
/**
 * This class defines helpers used in the implementation of builders. Don't use it directly.
 *
 * @internal
 */
final class BuilderHelpers
{
    /**
     * Normalizes a node: Converts builder objects to nodes.
     *
     * @param Node|Builder $node The node to normalize
     *
     * @return Node The normalized node
     */
    public static function normalizeNode($node) : \PHPUnit\PhpParser\Node
    {
        if ($node instanceof \PHPUnit\PhpParser\Builder) {
            return $node->getNode();
        } elseif ($node instanceof \PHPUnit\PhpParser\Node) {
            return $node;
        }
        throw new \LogicException('Expected node or builder object');
    }
    /**
     * Normalizes a node to a statement.
     *
     * Expressions are wrapped in a Stmt\Expression node.
     *
     * @param Node|Builder $node The node to normalize
     *
     * @return Stmt The normalized statement node
     */
    public static function normalizeStmt($node) : \PHPUnit\PhpParser\Node\Stmt
    {
        $node = self::normalizeNode($node);
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt) {
            return $node;
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\Expr) {
            return new \PHPUnit\PhpParser\Node\Stmt\Expression($node);
        }
        throw new \LogicException('Expected statement or expression node');
    }
    /**
     * Normalizes strings to Identifier.
     *
     * @param string|Identifier $name The identifier to normalize
     *
     * @return Identifier The normalized identifier
     */
    public static function normalizeIdentifier($name) : \PHPUnit\PhpParser\Node\Identifier
    {
        if ($name instanceof \PHPUnit\PhpParser\Node\Identifier) {
            return $name;
        }
        if (\is_string($name)) {
            return new \PHPUnit\PhpParser\Node\Identifier($name);
        }
        throw new \LogicException('PHPUnit\\Expected string or instance of Node\\Identifier');
    }
    /**
     * Normalizes strings to Identifier, also allowing expressions.
     *
     * @param string|Identifier|Expr $name The identifier to normalize
     *
     * @return Identifier|Expr The normalized identifier or expression
     */
    public static function normalizeIdentifierOrExpr($name)
    {
        if ($name instanceof \PHPUnit\PhpParser\Node\Identifier || $name instanceof \PHPUnit\PhpParser\Node\Expr) {
            return $name;
        }
        if (\is_string($name)) {
            return new \PHPUnit\PhpParser\Node\Identifier($name);
        }
        throw new \LogicException('PHPUnit\\Expected string or instance of Node\\Identifier or Node\\Expr');
    }
    /**
     * Normalizes a name: Converts string names to Name nodes.
     *
     * @param Name|string $name The name to normalize
     *
     * @return Name The normalized name
     */
    public static function normalizeName($name) : \PHPUnit\PhpParser\Node\Name
    {
        return self::normalizeNameCommon($name, \false);
    }
    /**
     * Normalizes a name: Converts string names to Name nodes, while also allowing expressions.
     *
     * @param Expr|Name|string $name The name to normalize
     *
     * @return Name|Expr The normalized name or expression
     */
    public static function normalizeNameOrExpr($name)
    {
        return self::normalizeNameCommon($name, \true);
    }
    /**
     * Normalizes a name: Converts string names to Name nodes, optionally allowing expressions.
     *
     * @param Expr|Name|string $name      The name to normalize
     * @param bool             $allowExpr Whether to also allow expressions
     *
     * @return Name|Expr The normalized name, or expression (if allowed)
     */
    private static function normalizeNameCommon($name, bool $allowExpr)
    {
        if ($name instanceof \PHPUnit\PhpParser\Node\Name) {
            return $name;
        } elseif (\is_string($name)) {
            if (!$name) {
                throw new \LogicException('Name cannot be empty');
            }
            if ($name[0] === '\\') {
                return new \PHPUnit\PhpParser\Node\Name\FullyQualified(\substr($name, 1));
            } elseif (0 === \strpos($name, 'namespace\\')) {
                return new \PHPUnit\PhpParser\Node\Name\Relative(\substr($name, \strlen('namespace\\')));
            } else {
                return new \PHPUnit\PhpParser\Node\Name($name);
            }
        }
        if ($allowExpr) {
            if ($name instanceof \PHPUnit\PhpParser\Node\Expr) {
                return $name;
            }
            throw new \LogicException('PHPUnit\\Name must be a string or an instance of Node\\Name or Node\\Expr');
        } else {
            throw new \LogicException('PHPUnit\\Name must be a string or an instance of Node\\Name');
        }
    }
    /**
     * Normalizes a type: Converts plain-text type names into proper AST representation.
     *
     * In particular, builtin types become Identifiers, custom types become Names and nullables
     * are wrapped in NullableType nodes.
     *
     * @param string|Name|Identifier|NullableType|UnionType $type The type to normalize
     *
     * @return Name|Identifier|NullableType|UnionType The normalized type
     */
    public static function normalizeType($type)
    {
        if (!\is_string($type)) {
            if (!$type instanceof \PHPUnit\PhpParser\Node\Name && !$type instanceof \PHPUnit\PhpParser\Node\Identifier && !$type instanceof \PHPUnit\PhpParser\Node\NullableType && !$type instanceof \PHPUnit\PhpParser\Node\UnionType) {
                throw new \LogicException('Type must be a string, or an instance of Name, Identifier, NullableType or UnionType');
            }
            return $type;
        }
        $nullable = \false;
        if (\strlen($type) > 0 && $type[0] === '?') {
            $nullable = \true;
            $type = \substr($type, 1);
        }
        $builtinTypes = ['array', 'callable', 'string', 'int', 'float', 'bool', 'iterable', 'void', 'object', 'mixed'];
        $lowerType = \strtolower($type);
        if (\in_array($lowerType, $builtinTypes)) {
            $type = new \PHPUnit\PhpParser\Node\Identifier($lowerType);
        } else {
            $type = self::normalizeName($type);
        }
        if ($nullable && (string) $type === 'void') {
            throw new \LogicException('void type cannot be nullable');
        }
        if ($nullable && (string) $type === 'mixed') {
            throw new \LogicException('mixed type cannot be nullable');
        }
        return $nullable ? new \PHPUnit\PhpParser\Node\NullableType($type) : $type;
    }
    /**
     * Normalizes a value: Converts nulls, booleans, integers,
     * floats, strings and arrays into their respective nodes
     *
     * @param Node\Expr|bool|null|int|float|string|array $value The value to normalize
     *
     * @return Expr The normalized value
     */
    public static function normalizeValue($value) : \PHPUnit\PhpParser\Node\Expr
    {
        if ($value instanceof \PHPUnit\PhpParser\Node\Expr) {
            return $value;
        } elseif (\is_null($value)) {
            return new \PHPUnit\PhpParser\Node\Expr\ConstFetch(new \PHPUnit\PhpParser\Node\Name('null'));
        } elseif (\is_bool($value)) {
            return new \PHPUnit\PhpParser\Node\Expr\ConstFetch(new \PHPUnit\PhpParser\Node\Name($value ? 'true' : 'false'));
        } elseif (\is_int($value)) {
            return new \PHPUnit\PhpParser\Node\Scalar\LNumber($value);
        } elseif (\is_float($value)) {
            return new \PHPUnit\PhpParser\Node\Scalar\DNumber($value);
        } elseif (\is_string($value)) {
            return new \PHPUnit\PhpParser\Node\Scalar\String_($value);
        } elseif (\is_array($value)) {
            $items = [];
            $lastKey = -1;
            foreach ($value as $itemKey => $itemValue) {
                // for consecutive, numeric keys don't generate keys
                if (null !== $lastKey && ++$lastKey === $itemKey) {
                    $items[] = new \PHPUnit\PhpParser\Node\Expr\ArrayItem(self::normalizeValue($itemValue));
                } else {
                    $lastKey = null;
                    $items[] = new \PHPUnit\PhpParser\Node\Expr\ArrayItem(self::normalizeValue($itemValue), self::normalizeValue($itemKey));
                }
            }
            return new \PHPUnit\PhpParser\Node\Expr\Array_($items);
        } else {
            throw new \LogicException('Invalid value');
        }
    }
    /**
     * Normalizes a doc comment: Converts plain strings to PhpParser\Comment\Doc.
     *
     * @param Comment\Doc|string $docComment The doc comment to normalize
     *
     * @return Comment\Doc The normalized doc comment
     */
    public static function normalizeDocComment($docComment) : \PHPUnit\PhpParser\Comment\Doc
    {
        if ($docComment instanceof \PHPUnit\PhpParser\Comment\Doc) {
            return $docComment;
        } elseif (\is_string($docComment)) {
            return new \PHPUnit\PhpParser\Comment\Doc($docComment);
        } else {
            throw new \LogicException('PHPUnit\\Doc comment must be a string or an instance of PhpParser\\Comment\\Doc');
        }
    }
    /**
     * Adds a modifier and returns new modifier bitmask.
     *
     * @param int $modifiers Existing modifiers
     * @param int $modifier  Modifier to set
     *
     * @return int New modifiers
     */
    public static function addModifier(int $modifiers, int $modifier) : int
    {
        \PHPUnit\PhpParser\Node\Stmt\Class_::verifyModifier($modifiers, $modifier);
        return $modifiers | $modifier;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

class Comment implements \JsonSerializable
{
    protected $text;
    protected $startLine;
    protected $startFilePos;
    protected $startTokenPos;
    protected $endLine;
    protected $endFilePos;
    protected $endTokenPos;
    /**
     * Constructs a comment node.
     *
     * @param string $text          Comment text (including comment delimiters like /*)
     * @param int    $startLine     Line number the comment started on
     * @param int    $startFilePos  File offset the comment started on
     * @param int    $startTokenPos Token offset the comment started on
     */
    public function __construct(string $text, int $startLine = -1, int $startFilePos = -1, int $startTokenPos = -1, int $endLine = -1, int $endFilePos = -1, int $endTokenPos = -1)
    {
        $this->text = $text;
        $this->startLine = $startLine;
        $this->startFilePos = $startFilePos;
        $this->startTokenPos = $startTokenPos;
        $this->endLine = $endLine;
        $this->endFilePos = $endFilePos;
        $this->endTokenPos = $endTokenPos;
    }
    /**
     * Gets the comment text.
     *
     * @return string The comment text (including comment delimiters like /*)
     */
    public function getText() : string
    {
        return $this->text;
    }
    /**
     * Gets the line number the comment started on.
     *
     * @return int Line number (or -1 if not available)
     */
    public function getStartLine() : int
    {
        return $this->startLine;
    }
    /**
     * Gets the file offset the comment started on.
     *
     * @return int File offset (or -1 if not available)
     */
    public function getStartFilePos() : int
    {
        return $this->startFilePos;
    }
    /**
     * Gets the token offset the comment started on.
     *
     * @return int Token offset (or -1 if not available)
     */
    public function getStartTokenPos() : int
    {
        return $this->startTokenPos;
    }
    /**
     * Gets the line number the comment ends on.
     *
     * @return int Line number (or -1 if not available)
     */
    public function getEndLine() : int
    {
        return $this->endLine;
    }
    /**
     * Gets the file offset the comment ends on.
     *
     * @return int File offset (or -1 if not available)
     */
    public function getEndFilePos() : int
    {
        return $this->endFilePos;
    }
    /**
     * Gets the token offset the comment ends on.
     *
     * @return int Token offset (or -1 if not available)
     */
    public function getEndTokenPos() : int
    {
        return $this->endTokenPos;
    }
    /**
     * Gets the line number the comment started on.
     *
     * @deprecated Use getStartLine() instead
     *
     * @return int Line number
     */
    public function getLine() : int
    {
        return $this->startLine;
    }
    /**
     * Gets the file offset the comment started on.
     *
     * @deprecated Use getStartFilePos() instead
     *
     * @return int File offset
     */
    public function getFilePos() : int
    {
        return $this->startFilePos;
    }
    /**
     * Gets the token offset the comment started on.
     *
     * @deprecated Use getStartTokenPos() instead
     *
     * @return int Token offset
     */
    public function getTokenPos() : int
    {
        return $this->startTokenPos;
    }
    /**
     * Gets the comment text.
     *
     * @return string The comment text (including comment delimiters like /*)
     */
    public function __toString() : string
    {
        return $this->text;
    }
    /**
     * Gets the reformatted comment text.
     *
     * "Reformatted" here means that we try to clean up the whitespace at the
     * starts of the lines. This is necessary because we receive the comments
     * without trailing whitespace on the first line, but with trailing whitespace
     * on all subsequent lines.
     *
     * @return mixed|string
     */
    public function getReformattedText()
    {
        $text = \trim($this->text);
        $newlinePos = \strpos($text, "\n");
        if (\false === $newlinePos) {
            // Single line comments don't need further processing
            return $text;
        } elseif (\preg_match('((*BSR_ANYCRLF)(*ANYCRLF)^.*(?:\\R\\s+\\*.*)+$)', $text)) {
            // Multi line comment of the type
            //
            //     /*
            //      * Some text.
            //      * Some more text.
            //      */
            //
            // is handled by replacing the whitespace sequences before the * by a single space
            return \preg_replace('(^\\s+\\*)m', ' *', $this->text);
        } elseif (\preg_match('(^/\\*\\*?\\s*[\\r\\n])', $text) && \preg_match('(\\n(\\s*)\\*/$)', $text, $matches)) {
            // Multi line comment of the type
            //
            //    /*
            //        Some text.
            //        Some more text.
            //    */
            //
            // is handled by removing the whitespace sequence on the line before the closing
            // */ on all lines. So if the last line is "    */", then "    " is removed at the
            // start of all lines.
            return \preg_replace('(^' . \preg_quote($matches[1]) . ')m', '', $text);
        } elseif (\preg_match('(^/\\*\\*?\\s*(?!\\s))', $text, $matches)) {
            // Multi line comment of the type
            //
            //     /* Some text.
            //        Some more text.
            //          Indented text.
            //        Even more text. */
            //
            // is handled by removing the difference between the shortest whitespace prefix on all
            // lines and the length of the "/* " opening sequence.
            $prefixLen = $this->getShortestWhitespacePrefixLen(\substr($text, $newlinePos + 1));
            $removeLen = $prefixLen - \strlen($matches[0]);
            return \preg_replace('(^\\s{' . $removeLen . '})m', '', $text);
        }
        // No idea how to format this comment, so simply return as is
        return $text;
    }
    /**
     * Get length of shortest whitespace prefix (at the start of a line).
     *
     * If there is a line with no prefix whitespace, 0 is a valid return value.
     *
     * @param string $str String to check
     * @return int Length in characters. Tabs count as single characters.
     */
    private function getShortestWhitespacePrefixLen(string $str) : int
    {
        $lines = \explode("\n", $str);
        $shortestPrefixLen = \INF;
        foreach ($lines as $line) {
            \preg_match('(^\\s*)', $line, $matches);
            $prefixLen = \strlen($matches[0]);
            if ($prefixLen < $shortestPrefixLen) {
                $shortestPrefixLen = $prefixLen;
            }
        }
        return $shortestPrefixLen;
    }
    /**
     * @return       array
     * @psalm-return array{nodeType:string, text:mixed, line:mixed, filePos:mixed}
     */
    public function jsonSerialize() : array
    {
        // Technically not a node, but we make it look like one anyway
        $type = $this instanceof \PHPUnit\PhpParser\Comment\Doc ? 'Comment_Doc' : 'Comment';
        return [
            'nodeType' => $type,
            'text' => $this->text,
            // TODO: Rename these to include "start".
            'line' => $this->startLine,
            'filePos' => $this->startFilePos,
            'tokenPos' => $this->startTokenPos,
            'endLine' => $this->endLine,
            'endFilePos' => $this->endFilePos,
            'endTokenPos' => $this->endTokenPos,
        ];
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Comment;

class Doc extends \PHPUnit\PhpParser\Comment
{
}
<?php

namespace PHPUnit\PhpParser;

class ConstExprEvaluationException extends \Exception
{
}
<?php

namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Scalar;
/**
 * Evaluates constant expressions.
 *
 * This evaluator is able to evaluate all constant expressions (as defined by PHP), which can be
 * evaluated without further context. If a subexpression is not of this type, a user-provided
 * fallback evaluator is invoked. To support all constant expressions that are also supported by
 * PHP (and not already handled by this class), the fallback evaluator must be able to handle the
 * following node types:
 *
 *  * All Scalar\MagicConst\* nodes.
 *  * Expr\ConstFetch nodes. Only null/false/true are already handled by this class.
 *  * Expr\ClassConstFetch nodes.
 *
 * The fallback evaluator should throw ConstExprEvaluationException for nodes it cannot evaluate.
 *
 * The evaluation is dependent on runtime configuration in two respects: Firstly, floating
 * point to string conversions are affected by the precision ini setting. Secondly, they are also
 * affected by the LC_NUMERIC locale.
 */
class ConstExprEvaluator
{
    private $fallbackEvaluator;
    /**
     * Create a constant expression evaluator.
     *
     * The provided fallback evaluator is invoked whenever a subexpression cannot be evaluated. See
     * class doc comment for more information.
     *
     * @param callable|null $fallbackEvaluator To call if subexpression cannot be evaluated
     */
    public function __construct(callable $fallbackEvaluator = null)
    {
        $this->fallbackEvaluator = $fallbackEvaluator ?? function (\PHPUnit\PhpParser\Node\Expr $expr) {
            throw new \PHPUnit\PhpParser\ConstExprEvaluationException("Expression of type {$expr->getType()} cannot be evaluated");
        };
    }
    /**
     * Silently evaluates a constant expression into a PHP value.
     *
     * Thrown Errors, warnings or notices will be converted into a ConstExprEvaluationException.
     * The original source of the exception is available through getPrevious().
     *
     * If some part of the expression cannot be evaluated, the fallback evaluator passed to the
     * constructor will be invoked. By default, if no fallback is provided, an exception of type
     * ConstExprEvaluationException is thrown.
     *
     * See class doc comment for caveats and limitations.
     *
     * @param Expr $expr Constant expression to evaluate
     * @return mixed Result of evaluation
     *
     * @throws ConstExprEvaluationException if the expression cannot be evaluated or an error occurred
     */
    public function evaluateSilently(\PHPUnit\PhpParser\Node\Expr $expr)
    {
        \set_error_handler(function ($num, $str, $file, $line) {
            throw new \ErrorException($str, 0, $num, $file, $line);
        });
        try {
            return $this->evaluate($expr);
        } catch (\Throwable $e) {
            if (!$e instanceof \PHPUnit\PhpParser\ConstExprEvaluationException) {
                $e = new \PHPUnit\PhpParser\ConstExprEvaluationException("An error occurred during constant expression evaluation", 0, $e);
            }
            throw $e;
        } finally {
            \restore_error_handler();
        }
    }
    /**
     * Directly evaluates a constant expression into a PHP value.
     *
     * May generate Error exceptions, warnings or notices. Use evaluateSilently() to convert these
     * into a ConstExprEvaluationException.
     *
     * If some part of the expression cannot be evaluated, the fallback evaluator passed to the
     * constructor will be invoked. By default, if no fallback is provided, an exception of type
     * ConstExprEvaluationException is thrown.
     *
     * See class doc comment for caveats and limitations.
     *
     * @param Expr $expr Constant expression to evaluate
     * @return mixed Result of evaluation
     *
     * @throws ConstExprEvaluationException if the expression cannot be evaluated
     */
    public function evaluateDirectly(\PHPUnit\PhpParser\Node\Expr $expr)
    {
        return $this->evaluate($expr);
    }
    private function evaluate(\PHPUnit\PhpParser\Node\Expr $expr)
    {
        if ($expr instanceof \PHPUnit\PhpParser\Node\Scalar\LNumber || $expr instanceof \PHPUnit\PhpParser\Node\Scalar\DNumber || $expr instanceof \PHPUnit\PhpParser\Node\Scalar\String_) {
            return $expr->value;
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\Array_) {
            return $this->evaluateArray($expr);
        }
        // Unary operators
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\UnaryPlus) {
            return +$this->evaluate($expr->expr);
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\UnaryMinus) {
            return -$this->evaluate($expr->expr);
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\BooleanNot) {
            return !$this->evaluate($expr->expr);
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\BitwiseNot) {
            return ~$this->evaluate($expr->expr);
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\BinaryOp) {
            return $this->evaluateBinaryOp($expr);
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\Ternary) {
            return $this->evaluateTernary($expr);
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch && null !== $expr->dim) {
            return $this->evaluate($expr->var)[$this->evaluate($expr->dim)];
        }
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\ConstFetch) {
            return $this->evaluateConstFetch($expr);
        }
        return ($this->fallbackEvaluator)($expr);
    }
    private function evaluateArray(\PHPUnit\PhpParser\Node\Expr\Array_ $expr)
    {
        $array = [];
        foreach ($expr->items as $item) {
            if (null !== $item->key) {
                $array[$this->evaluate($item->key)] = $this->evaluate($item->value);
            } else {
                $array[] = $this->evaluate($item->value);
            }
        }
        return $array;
    }
    private function evaluateTernary(\PHPUnit\PhpParser\Node\Expr\Ternary $expr)
    {
        if (null === $expr->if) {
            return $this->evaluate($expr->cond) ?: $this->evaluate($expr->else);
        }
        return $this->evaluate($expr->cond) ? $this->evaluate($expr->if) : $this->evaluate($expr->else);
    }
    private function evaluateBinaryOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp $expr)
    {
        if ($expr instanceof \PHPUnit\PhpParser\Node\Expr\BinaryOp\Coalesce && $expr->left instanceof \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch) {
            // This needs to be special cased to respect BP_VAR_IS fetch semantics
            return $this->evaluate($expr->left->var)[$this->evaluate($expr->left->dim)] ?? $this->evaluate($expr->right);
        }
        // The evaluate() calls are repeated in each branch, because some of the operators are
        // short-circuiting and evaluating the RHS in advance may be illegal in that case
        $l = $expr->left;
        $r = $expr->right;
        switch ($expr->getOperatorSigil()) {
            case '&':
                return $this->evaluate($l) & $this->evaluate($r);
            case '|':
                return $this->evaluate($l) | $this->evaluate($r);
            case '^':
                return $this->evaluate($l) ^ $this->evaluate($r);
            case '&&':
                return $this->evaluate($l) && $this->evaluate($r);
            case '||':
                return $this->evaluate($l) || $this->evaluate($r);
            case '??':
                return $this->evaluate($l) ?? $this->evaluate($r);
            case '.':
                return $this->evaluate($l) . $this->evaluate($r);
            case '/':
                return $this->evaluate($l) / $this->evaluate($r);
            case '==':
                return $this->evaluate($l) == $this->evaluate($r);
            case '>':
                return $this->evaluate($l) > $this->evaluate($r);
            case '>=':
                return $this->evaluate($l) >= $this->evaluate($r);
            case '===':
                return $this->evaluate($l) === $this->evaluate($r);
            case 'and':
                return $this->evaluate($l) and $this->evaluate($r);
            case 'or':
                return $this->evaluate($l) or $this->evaluate($r);
            case 'xor':
                return $this->evaluate($l) xor $this->evaluate($r);
            case '-':
                return $this->evaluate($l) - $this->evaluate($r);
            case '%':
                return $this->evaluate($l) % $this->evaluate($r);
            case '*':
                return $this->evaluate($l) * $this->evaluate($r);
            case '!=':
                return $this->evaluate($l) != $this->evaluate($r);
            case '!==':
                return $this->evaluate($l) !== $this->evaluate($r);
            case '+':
                return $this->evaluate($l) + $this->evaluate($r);
            case '**':
                return $this->evaluate($l) ** $this->evaluate($r);
            case '<<':
                return $this->evaluate($l) << $this->evaluate($r);
            case '>>':
                return $this->evaluate($l) >> $this->evaluate($r);
            case '<':
                return $this->evaluate($l) < $this->evaluate($r);
            case '<=':
                return $this->evaluate($l) <= $this->evaluate($r);
            case '<=>':
                return $this->evaluate($l) <=> $this->evaluate($r);
        }
        throw new \Exception('Should not happen');
    }
    private function evaluateConstFetch(\PHPUnit\PhpParser\Node\Expr\ConstFetch $expr)
    {
        $name = $expr->name->toLowerString();
        switch ($name) {
            case 'null':
                return null;
            case 'false':
                return \false;
            case 'true':
                return \true;
        }
        return ($this->fallbackEvaluator)($expr);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

class Error extends \RuntimeException
{
    protected $rawMessage;
    protected $attributes;
    /**
     * Creates an Exception signifying a parse error.
     *
     * @param string    $message    Error message
     * @param array|int $attributes Attributes of node/token where error occurred
     *                              (or start line of error -- deprecated)
     */
    public function __construct(string $message, $attributes = [])
    {
        $this->rawMessage = $message;
        if (\is_array($attributes)) {
            $this->attributes = $attributes;
        } else {
            $this->attributes = ['startLine' => $attributes];
        }
        $this->updateMessage();
    }
    /**
     * Gets the error message
     *
     * @return string Error message
     */
    public function getRawMessage() : string
    {
        return $this->rawMessage;
    }
    /**
     * Gets the line the error starts in.
     *
     * @return int Error start line
     */
    public function getStartLine() : int
    {
        return $this->attributes['startLine'] ?? -1;
    }
    /**
     * Gets the line the error ends in.
     *
     * @return int Error end line
     */
    public function getEndLine() : int
    {
        return $this->attributes['endLine'] ?? -1;
    }
    /**
     * Gets the attributes of the node/token the error occurred at.
     *
     * @return array
     */
    public function getAttributes() : array
    {
        return $this->attributes;
    }
    /**
     * Sets the attributes of the node/token the error occurred at.
     *
     * @param array $attributes
     */
    public function setAttributes(array $attributes)
    {
        $this->attributes = $attributes;
        $this->updateMessage();
    }
    /**
     * Sets the line of the PHP file the error occurred in.
     *
     * @param string $message Error message
     */
    public function setRawMessage(string $message)
    {
        $this->rawMessage = $message;
        $this->updateMessage();
    }
    /**
     * Sets the line the error starts in.
     *
     * @param int $line Error start line
     */
    public function setStartLine(int $line)
    {
        $this->attributes['startLine'] = $line;
        $this->updateMessage();
    }
    /**
     * Returns whether the error has start and end column information.
     *
     * For column information enable the startFilePos and endFilePos in the lexer options.
     *
     * @return bool
     */
    public function hasColumnInfo() : bool
    {
        return isset($this->attributes['startFilePos'], $this->attributes['endFilePos']);
    }
    /**
     * Gets the start column (1-based) into the line where the error started.
     *
     * @param string $code Source code of the file
     * @return int
     */
    public function getStartColumn(string $code) : int
    {
        if (!$this->hasColumnInfo()) {
            throw new \RuntimeException('Error does not have column information');
        }
        return $this->toColumn($code, $this->attributes['startFilePos']);
    }
    /**
     * Gets the end column (1-based) into the line where the error ended.
     *
     * @param string $code Source code of the file
     * @return int
     */
    public function getEndColumn(string $code) : int
    {
        if (!$this->hasColumnInfo()) {
            throw new \RuntimeException('Error does not have column information');
        }
        return $this->toColumn($code, $this->attributes['endFilePos']);
    }
    /**
     * Formats message including line and column information.
     *
     * @param string $code Source code associated with the error, for calculation of the columns
     *
     * @return string Formatted message
     */
    public function getMessageWithColumnInfo(string $code) : string
    {
        return \sprintf('%s from %d:%d to %d:%d', $this->getRawMessage(), $this->getStartLine(), $this->getStartColumn($code), $this->getEndLine(), $this->getEndColumn($code));
    }
    /**
     * Converts a file offset into a column.
     *
     * @param string $code Source code that $pos indexes into
     * @param int    $pos  0-based position in $code
     *
     * @return int 1-based column (relative to start of line)
     */
    private function toColumn(string $code, int $pos) : int
    {
        if ($pos > \strlen($code)) {
            throw new \RuntimeException('Invalid position information');
        }
        $lineStartPos = \strrpos($code, "\n", $pos - \strlen($code));
        if (\false === $lineStartPos) {
            $lineStartPos = -1;
        }
        return $pos - $lineStartPos;
    }
    /**
     * Updates the exception message after a change to rawMessage or rawLine.
     */
    protected function updateMessage()
    {
        $this->message = $this->rawMessage;
        if (-1 === $this->getStartLine()) {
            $this->message .= ' on unknown line';
        } else {
            $this->message .= ' on line ' . $this->getStartLine();
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

interface ErrorHandler
{
    /**
     * Handle an error generated during lexing, parsing or some other operation.
     *
     * @param Error $error The error that needs to be handled
     */
    public function handleError(\PHPUnit\PhpParser\Error $error);
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\ErrorHandler;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\ErrorHandler;
/**
 * Error handler that collects all errors into an array.
 *
 * This allows graceful handling of errors.
 */
class Collecting implements \PHPUnit\PhpParser\ErrorHandler
{
    /** @var Error[] Collected errors */
    private $errors = [];
    public function handleError(\PHPUnit\PhpParser\Error $error)
    {
        $this->errors[] = $error;
    }
    /**
     * Get collected errors.
     *
     * @return Error[]
     */
    public function getErrors() : array
    {
        return $this->errors;
    }
    /**
     * Check whether there are any errors.
     *
     * @return bool
     */
    public function hasErrors() : bool
    {
        return !empty($this->errors);
    }
    /**
     * Reset/clear collected errors.
     */
    public function clearErrors()
    {
        $this->errors = [];
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\ErrorHandler;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\ErrorHandler;
/**
 * Error handler that handles all errors by throwing them.
 *
 * This is the default strategy used by all components.
 */
class Throwing implements \PHPUnit\PhpParser\ErrorHandler
{
    public function handleError(\PHPUnit\PhpParser\Error $error)
    {
        throw $error;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Internal;

/**
 * @internal
 */
class DiffElem
{
    const TYPE_KEEP = 0;
    const TYPE_REMOVE = 1;
    const TYPE_ADD = 2;
    const TYPE_REPLACE = 3;
    /** @var int One of the TYPE_* constants */
    public $type;
    /** @var mixed Is null for add operations */
    public $old;
    /** @var mixed Is null for remove operations */
    public $new;
    public function __construct(int $type, $old, $new)
    {
        $this->type = $type;
        $this->old = $old;
        $this->new = $new;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Internal;

/**
 * Implements the Myers diff algorithm.
 *
 * Myers, Eugene W. "An O (ND) difference algorithm and its variations."
 * Algorithmica 1.1 (1986): 251-266.
 *
 * @internal
 */
class Differ
{
    private $isEqual;
    /**
     * Create differ over the given equality relation.
     *
     * @param callable $isEqual Equality relation with signature function($a, $b) : bool
     */
    public function __construct(callable $isEqual)
    {
        $this->isEqual = $isEqual;
    }
    /**
     * Calculate diff (edit script) from $old to $new.
     *
     * @param array $old Original array
     * @param array $new New array
     *
     * @return DiffElem[] Diff (edit script)
     */
    public function diff(array $old, array $new)
    {
        list($trace, $x, $y) = $this->calculateTrace($old, $new);
        return $this->extractDiff($trace, $x, $y, $old, $new);
    }
    /**
     * Calculate diff, including "replace" operations.
     *
     * If a sequence of remove operations is followed by the same number of add operations, these
     * will be coalesced into replace operations.
     *
     * @param array $old Original array
     * @param array $new New array
     *
     * @return DiffElem[] Diff (edit script), including replace operations
     */
    public function diffWithReplacements(array $old, array $new)
    {
        return $this->coalesceReplacements($this->diff($old, $new));
    }
    private function calculateTrace(array $a, array $b)
    {
        $n = \count($a);
        $m = \count($b);
        $max = $n + $m;
        $v = [1 => 0];
        $trace = [];
        for ($d = 0; $d <= $max; $d++) {
            $trace[] = $v;
            for ($k = -$d; $k <= $d; $k += 2) {
                if ($k === -$d || $k !== $d && $v[$k - 1] < $v[$k + 1]) {
                    $x = $v[$k + 1];
                } else {
                    $x = $v[$k - 1] + 1;
                }
                $y = $x - $k;
                while ($x < $n && $y < $m && ($this->isEqual)($a[$x], $b[$y])) {
                    $x++;
                    $y++;
                }
                $v[$k] = $x;
                if ($x >= $n && $y >= $m) {
                    return [$trace, $x, $y];
                }
            }
        }
        throw new \Exception('Should not happen');
    }
    private function extractDiff(array $trace, int $x, int $y, array $a, array $b)
    {
        $result = [];
        for ($d = \count($trace) - 1; $d >= 0; $d--) {
            $v = $trace[$d];
            $k = $x - $y;
            if ($k === -$d || $k !== $d && $v[$k - 1] < $v[$k + 1]) {
                $prevK = $k + 1;
            } else {
                $prevK = $k - 1;
            }
            $prevX = $v[$prevK];
            $prevY = $prevX - $prevK;
            while ($x > $prevX && $y > $prevY) {
                $result[] = new \PHPUnit\PhpParser\Internal\DiffElem(\PHPUnit\PhpParser\Internal\DiffElem::TYPE_KEEP, $a[$x - 1], $b[$y - 1]);
                $x--;
                $y--;
            }
            if ($d === 0) {
                break;
            }
            while ($x > $prevX) {
                $result[] = new \PHPUnit\PhpParser\Internal\DiffElem(\PHPUnit\PhpParser\Internal\DiffElem::TYPE_REMOVE, $a[$x - 1], null);
                $x--;
            }
            while ($y > $prevY) {
                $result[] = new \PHPUnit\PhpParser\Internal\DiffElem(\PHPUnit\PhpParser\Internal\DiffElem::TYPE_ADD, null, $b[$y - 1]);
                $y--;
            }
        }
        return \array_reverse($result);
    }
    /**
     * Coalesce equal-length sequences of remove+add into a replace operation.
     *
     * @param DiffElem[] $diff
     * @return DiffElem[]
     */
    private function coalesceReplacements(array $diff)
    {
        $newDiff = [];
        $c = \count($diff);
        for ($i = 0; $i < $c; $i++) {
            $diffType = $diff[$i]->type;
            if ($diffType !== \PHPUnit\PhpParser\Internal\DiffElem::TYPE_REMOVE) {
                $newDiff[] = $diff[$i];
                continue;
            }
            $j = $i;
            while ($j < $c && $diff[$j]->type === \PHPUnit\PhpParser\Internal\DiffElem::TYPE_REMOVE) {
                $j++;
            }
            $k = $j;
            while ($k < $c && $diff[$k]->type === \PHPUnit\PhpParser\Internal\DiffElem::TYPE_ADD) {
                $k++;
            }
            if ($j - $i === $k - $j) {
                $len = $j - $i;
                for ($n = 0; $n < $len; $n++) {
                    $newDiff[] = new \PHPUnit\PhpParser\Internal\DiffElem(\PHPUnit\PhpParser\Internal\DiffElem::TYPE_REPLACE, $diff[$i + $n]->old, $diff[$j + $n]->new);
                }
            } else {
                for (; $i < $k; $i++) {
                    $newDiff[] = $diff[$i];
                }
            }
            $i = $k - 1;
        }
        return $newDiff;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Internal;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
/**
 * This node is used internally by the format-preserving pretty printer to print anonymous classes.
 *
 * The normal anonymous class structure violates assumptions about the order of token offsets.
 * Namely, the constructor arguments are part of the Expr\New_ node and follow the class node, even
 * though they are actually interleaved with them. This special node type is used temporarily to
 * restore a sane token offset order.
 *
 * @internal
 */
class PrintableNewAnonClassNode extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Node\AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    /** @var Node\Arg[] Arguments */
    public $args;
    /** @var null|Node\Name Name of extended class */
    public $extends;
    /** @var Node\Name[] Names of implemented interfaces */
    public $implements;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    public function __construct(array $attrGroups, array $args, \PHPUnit\PhpParser\Node\Name $extends = null, array $implements, array $stmts, array $attributes)
    {
        parent::__construct($attributes);
        $this->attrGroups = $attrGroups;
        $this->args = $args;
        $this->extends = $extends;
        $this->implements = $implements;
        $this->stmts = $stmts;
    }
    public static function fromNewNode(\PHPUnit\PhpParser\Node\Expr\New_ $newNode)
    {
        $class = $newNode->class;
        \assert($class instanceof \PHPUnit\PhpParser\Node\Stmt\Class_);
        // We don't assert that $class->name is null here, to allow consumers to assign unique names
        // to anonymous classes for their own purposes. We simplify ignore the name here.
        return new self($class->attrGroups, $newNode->args, $class->extends, $class->implements, $class->stmts, $newNode->getAttributes());
    }
    public function getType() : string
    {
        return 'Expr_PrintableNewAnonClass';
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'args', 'extends', 'implements', 'stmts'];
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Internal;

/**
 * Provides operations on token streams, for use by pretty printer.
 *
 * @internal
 */
class TokenStream
{
    /** @var array Tokens (in token_get_all format) */
    private $tokens;
    /** @var int[] Map from position to indentation */
    private $indentMap;
    /**
     * Create token stream instance.
     *
     * @param array $tokens Tokens in token_get_all() format
     */
    public function __construct(array $tokens)
    {
        $this->tokens = $tokens;
        $this->indentMap = $this->calcIndentMap();
    }
    /**
     * Whether the given position is immediately surrounded by parenthesis.
     *
     * @param int $startPos Start position
     * @param int $endPos   End position
     *
     * @return bool
     */
    public function haveParens(int $startPos, int $endPos) : bool
    {
        return $this->haveTokenImmediatelyBefore($startPos, '(') && $this->haveTokenImmediatelyAfter($endPos, ')');
    }
    /**
     * Whether the given position is immediately surrounded by braces.
     *
     * @param int $startPos Start position
     * @param int $endPos   End position
     *
     * @return bool
     */
    public function haveBraces(int $startPos, int $endPos) : bool
    {
        return ($this->haveTokenImmediatelyBefore($startPos, '{') || $this->haveTokenImmediatelyBefore($startPos, \T_CURLY_OPEN)) && $this->haveTokenImmediatelyAfter($endPos, '}');
    }
    /**
     * Check whether the position is directly preceded by a certain token type.
     *
     * During this check whitespace and comments are skipped.
     *
     * @param int        $pos               Position before which the token should occur
     * @param int|string $expectedTokenType Token to check for
     *
     * @return bool Whether the expected token was found
     */
    public function haveTokenImmediatelyBefore(int $pos, $expectedTokenType) : bool
    {
        $tokens = $this->tokens;
        $pos--;
        for (; $pos >= 0; $pos--) {
            $tokenType = $tokens[$pos][0];
            if ($tokenType === $expectedTokenType) {
                return \true;
            }
            if ($tokenType !== \T_WHITESPACE && $tokenType !== \T_COMMENT && $tokenType !== \T_DOC_COMMENT) {
                break;
            }
        }
        return \false;
    }
    /**
     * Check whether the position is directly followed by a certain token type.
     *
     * During this check whitespace and comments are skipped.
     *
     * @param int        $pos               Position after which the token should occur
     * @param int|string $expectedTokenType Token to check for
     *
     * @return bool Whether the expected token was found
     */
    public function haveTokenImmediatelyAfter(int $pos, $expectedTokenType) : bool
    {
        $tokens = $this->tokens;
        $pos++;
        for (; $pos < \count($tokens); $pos++) {
            $tokenType = $tokens[$pos][0];
            if ($tokenType === $expectedTokenType) {
                return \true;
            }
            if ($tokenType !== \T_WHITESPACE && $tokenType !== \T_COMMENT && $tokenType !== \T_DOC_COMMENT) {
                break;
            }
        }
        return \false;
    }
    public function skipLeft(int $pos, $skipTokenType)
    {
        $tokens = $this->tokens;
        $pos = $this->skipLeftWhitespace($pos);
        if ($skipTokenType === \T_WHITESPACE) {
            return $pos;
        }
        if ($tokens[$pos][0] !== $skipTokenType) {
            // Shouldn't happen. The skip token MUST be there
            throw new \Exception('Encountered unexpected token');
        }
        $pos--;
        return $this->skipLeftWhitespace($pos);
    }
    public function skipRight(int $pos, $skipTokenType)
    {
        $tokens = $this->tokens;
        $pos = $this->skipRightWhitespace($pos);
        if ($skipTokenType === \T_WHITESPACE) {
            return $pos;
        }
        if ($tokens[$pos][0] !== $skipTokenType) {
            // Shouldn't happen. The skip token MUST be there
            throw new \Exception('Encountered unexpected token');
        }
        $pos++;
        return $this->skipRightWhitespace($pos);
    }
    /**
     * Return first non-whitespace token position smaller or equal to passed position.
     *
     * @param int $pos Token position
     * @return int Non-whitespace token position
     */
    public function skipLeftWhitespace(int $pos)
    {
        $tokens = $this->tokens;
        for (; $pos >= 0; $pos--) {
            $type = $tokens[$pos][0];
            if ($type !== \T_WHITESPACE && $type !== \T_COMMENT && $type !== \T_DOC_COMMENT) {
                break;
            }
        }
        return $pos;
    }
    /**
     * Return first non-whitespace position greater or equal to passed position.
     *
     * @param int $pos Token position
     * @return int Non-whitespace token position
     */
    public function skipRightWhitespace(int $pos)
    {
        $tokens = $this->tokens;
        for ($count = \count($tokens); $pos < $count; $pos++) {
            $type = $tokens[$pos][0];
            if ($type !== \T_WHITESPACE && $type !== \T_COMMENT && $type !== \T_DOC_COMMENT) {
                break;
            }
        }
        return $pos;
    }
    public function findRight(int $pos, $findTokenType)
    {
        $tokens = $this->tokens;
        for ($count = \count($tokens); $pos < $count; $pos++) {
            $type = $tokens[$pos][0];
            if ($type === $findTokenType) {
                return $pos;
            }
        }
        return -1;
    }
    /**
     * Whether the given position range contains a certain token type.
     *
     * @param int $startPos Starting position (inclusive)
     * @param int $endPos Ending position (exclusive)
     * @param int|string $tokenType Token type to look for
     * @return bool Whether the token occurs in the given range
     */
    public function haveTokenInRange(int $startPos, int $endPos, $tokenType)
    {
        $tokens = $this->tokens;
        for ($pos = $startPos; $pos < $endPos; $pos++) {
            if ($tokens[$pos][0] === $tokenType) {
                return \true;
            }
        }
        return \false;
    }
    public function haveBracesInRange(int $startPos, int $endPos)
    {
        return $this->haveTokenInRange($startPos, $endPos, '{') || $this->haveTokenInRange($startPos, $endPos, \T_CURLY_OPEN) || $this->haveTokenInRange($startPos, $endPos, '}');
    }
    /**
     * Get indentation before token position.
     *
     * @param int $pos Token position
     *
     * @return int Indentation depth (in spaces)
     */
    public function getIndentationBefore(int $pos) : int
    {
        return $this->indentMap[$pos];
    }
    /**
     * Get the code corresponding to a token offset range, optionally adjusted for indentation.
     *
     * @param int $from   Token start position (inclusive)
     * @param int $to     Token end position (exclusive)
     * @param int $indent By how much the code should be indented (can be negative as well)
     *
     * @return string Code corresponding to token range, adjusted for indentation
     */
    public function getTokenCode(int $from, int $to, int $indent) : string
    {
        $tokens = $this->tokens;
        $result = '';
        for ($pos = $from; $pos < $to; $pos++) {
            $token = $tokens[$pos];
            if (\is_array($token)) {
                $type = $token[0];
                $content = $token[1];
                if ($type === \T_CONSTANT_ENCAPSED_STRING || $type === \T_ENCAPSED_AND_WHITESPACE) {
                    $result .= $content;
                } else {
                    // TODO Handle non-space indentation
                    if ($indent < 0) {
                        $result .= \str_replace("\n" . \str_repeat(" ", -$indent), "\n", $content);
                    } elseif ($indent > 0) {
                        $result .= \str_replace("\n", "\n" . \str_repeat(" ", $indent), $content);
                    } else {
                        $result .= $content;
                    }
                }
            } else {
                $result .= $token;
            }
        }
        return $result;
    }
    /**
     * Precalculate the indentation at every token position.
     *
     * @return int[] Token position to indentation map
     */
    private function calcIndentMap()
    {
        $indentMap = [];
        $indent = 0;
        foreach ($this->tokens as $token) {
            $indentMap[] = $indent;
            if ($token[0] === \T_WHITESPACE) {
                $content = $token[1];
                $newlinePos = \strrpos($content, "\n");
                if (\false !== $newlinePos) {
                    $indent = \strlen($content) - $newlinePos - 1;
                }
            }
        }
        // Add a sentinel for one past end of the file
        $indentMap[] = $indent;
        return $indentMap;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

class JsonDecoder
{
    /** @var \ReflectionClass[] Node type to reflection class map */
    private $reflectionClassCache;
    public function decode(string $json)
    {
        $value = \json_decode($json, \true);
        if (\json_last_error()) {
            throw new \RuntimeException('JSON decoding error: ' . \json_last_error_msg());
        }
        return $this->decodeRecursive($value);
    }
    private function decodeRecursive($value)
    {
        if (\is_array($value)) {
            if (isset($value['nodeType'])) {
                if ($value['nodeType'] === 'Comment' || $value['nodeType'] === 'Comment_Doc') {
                    return $this->decodeComment($value);
                }
                return $this->decodeNode($value);
            }
            return $this->decodeArray($value);
        }
        return $value;
    }
    private function decodeArray(array $array) : array
    {
        $decodedArray = [];
        foreach ($array as $key => $value) {
            $decodedArray[$key] = $this->decodeRecursive($value);
        }
        return $decodedArray;
    }
    private function decodeNode(array $value) : \PHPUnit\PhpParser\Node
    {
        $nodeType = $value['nodeType'];
        if (!\is_string($nodeType)) {
            throw new \RuntimeException('Node type must be a string');
        }
        $reflectionClass = $this->reflectionClassFromNodeType($nodeType);
        /** @var Node $node */
        $node = $reflectionClass->newInstanceWithoutConstructor();
        if (isset($value['attributes'])) {
            if (!\is_array($value['attributes'])) {
                throw new \RuntimeException('Attributes must be an array');
            }
            $node->setAttributes($this->decodeArray($value['attributes']));
        }
        foreach ($value as $name => $subNode) {
            if ($name === 'nodeType' || $name === 'attributes') {
                continue;
            }
            $node->{$name} = $this->decodeRecursive($subNode);
        }
        return $node;
    }
    private function decodeComment(array $value) : \PHPUnit\PhpParser\Comment
    {
        $className = $value['nodeType'] === 'Comment' ? \PHPUnit\PhpParser\Comment::class : \PHPUnit\PhpParser\Comment\Doc::class;
        if (!isset($value['text'])) {
            throw new \RuntimeException('Comment must have text');
        }
        return new $className($value['text'], $value['line'] ?? -1, $value['filePos'] ?? -1, $value['tokenPos'] ?? -1, $value['endLine'] ?? -1, $value['endFilePos'] ?? -1, $value['endTokenPos'] ?? -1);
    }
    private function reflectionClassFromNodeType(string $nodeType) : \ReflectionClass
    {
        if (!isset($this->reflectionClassCache[$nodeType])) {
            $className = $this->classNameFromNodeType($nodeType);
            $this->reflectionClassCache[$nodeType] = new \ReflectionClass($className);
        }
        return $this->reflectionClassCache[$nodeType];
    }
    private function classNameFromNodeType(string $nodeType) : string
    {
        $className = 'PhpParser\\Node\\' . \strtr($nodeType, '_', '\\');
        if (\class_exists($className)) {
            return $className;
        }
        $className .= '_';
        if (\class_exists($className)) {
            return $className;
        }
        throw new \RuntimeException("Unknown node type \"{$nodeType}\"");
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\Parser\Tokens;
class Lexer
{
    protected $code;
    protected $tokens;
    protected $pos;
    protected $line;
    protected $filePos;
    protected $prevCloseTagHasNewline;
    protected $tokenMap;
    protected $dropTokens;
    protected $identifierTokens;
    private $attributeStartLineUsed;
    private $attributeEndLineUsed;
    private $attributeStartTokenPosUsed;
    private $attributeEndTokenPosUsed;
    private $attributeStartFilePosUsed;
    private $attributeEndFilePosUsed;
    private $attributeCommentsUsed;
    /**
     * Creates a Lexer.
     *
     * @param array $options Options array. Currently only the 'usedAttributes' option is supported,
     *                       which is an array of attributes to add to the AST nodes. Possible
     *                       attributes are: 'comments', 'startLine', 'endLine', 'startTokenPos',
     *                       'endTokenPos', 'startFilePos', 'endFilePos'. The option defaults to the
     *                       first three. For more info see getNextToken() docs.
     */
    public function __construct(array $options = [])
    {
        // Create Map from internal tokens to PhpParser tokens.
        $this->defineCompatibilityTokens();
        $this->tokenMap = $this->createTokenMap();
        $this->identifierTokens = $this->createIdentifierTokenMap();
        // map of tokens to drop while lexing (the map is only used for isset lookup,
        // that's why the value is simply set to 1; the value is never actually used.)
        $this->dropTokens = \array_fill_keys([\T_WHITESPACE, \T_OPEN_TAG, \T_COMMENT, \T_DOC_COMMENT, \T_BAD_CHARACTER], 1);
        $defaultAttributes = ['comments', 'startLine', 'endLine'];
        $usedAttributes = \array_fill_keys($options['usedAttributes'] ?? $defaultAttributes, \true);
        // Create individual boolean properties to make these checks faster.
        $this->attributeStartLineUsed = isset($usedAttributes['startLine']);
        $this->attributeEndLineUsed = isset($usedAttributes['endLine']);
        $this->attributeStartTokenPosUsed = isset($usedAttributes['startTokenPos']);
        $this->attributeEndTokenPosUsed = isset($usedAttributes['endTokenPos']);
        $this->attributeStartFilePosUsed = isset($usedAttributes['startFilePos']);
        $this->attributeEndFilePosUsed = isset($usedAttributes['endFilePos']);
        $this->attributeCommentsUsed = isset($usedAttributes['comments']);
    }
    /**
     * Initializes the lexer for lexing the provided source code.
     *
     * This function does not throw if lexing errors occur. Instead, errors may be retrieved using
     * the getErrors() method.
     *
     * @param string $code The source code to lex
     * @param ErrorHandler|null $errorHandler Error handler to use for lexing errors. Defaults to
     *                                        ErrorHandler\Throwing
     */
    public function startLexing(string $code, \PHPUnit\PhpParser\ErrorHandler $errorHandler = null)
    {
        if (null === $errorHandler) {
            $errorHandler = new \PHPUnit\PhpParser\ErrorHandler\Throwing();
        }
        $this->code = $code;
        // keep the code around for __halt_compiler() handling
        $this->pos = -1;
        $this->line = 1;
        $this->filePos = 0;
        // If inline HTML occurs without preceding code, treat it as if it had a leading newline.
        // This ensures proper composability, because having a newline is the "safe" assumption.
        $this->prevCloseTagHasNewline = \true;
        $scream = \ini_set('xdebug.scream', '0');
        $this->tokens = @\token_get_all($code);
        $this->postprocessTokens($errorHandler);
        if (\false !== $scream) {
            \ini_set('xdebug.scream', $scream);
        }
    }
    private function handleInvalidCharacterRange($start, $end, $line, \PHPUnit\PhpParser\ErrorHandler $errorHandler)
    {
        $tokens = [];
        for ($i = $start; $i < $end; $i++) {
            $chr = $this->code[$i];
            if ($chr === "\0") {
                // PHP cuts error message after null byte, so need special case
                $errorMsg = 'Unexpected null byte';
            } else {
                $errorMsg = \sprintf('Unexpected character "%s" (ASCII %d)', $chr, \ord($chr));
            }
            $tokens[] = [\T_BAD_CHARACTER, $chr, $line];
            $errorHandler->handleError(new \PHPUnit\PhpParser\Error($errorMsg, ['startLine' => $line, 'endLine' => $line, 'startFilePos' => $i, 'endFilePos' => $i]));
        }
        return $tokens;
    }
    /**
     * Check whether comment token is unterminated.
     *
     * @return bool
     */
    private function isUnterminatedComment($token) : bool
    {
        return ($token[0] === \T_COMMENT || $token[0] === \T_DOC_COMMENT) && \substr($token[1], 0, 2) === '/*' && \substr($token[1], -2) !== '*/';
    }
    protected function postprocessTokens(\PHPUnit\PhpParser\ErrorHandler $errorHandler)
    {
        // PHP's error handling for token_get_all() is rather bad, so if we want detailed
        // error information we need to compute it ourselves. Invalid character errors are
        // detected by finding "gaps" in the token array. Unterminated comments are detected
        // by checking if a trailing comment has a "*/" at the end.
        //
        // Additionally, we canonicalize to the PHP 8 comment format here, which does not include
        // the trailing whitespace anymore.
        //
        // We also canonicalize to the PHP 8 T_NAME_* tokens.
        $filePos = 0;
        $line = 1;
        $numTokens = \count($this->tokens);
        for ($i = 0; $i < $numTokens; $i++) {
            $token = $this->tokens[$i];
            // Since PHP 7.4 invalid characters are represented by a T_BAD_CHARACTER token.
            // In this case we only need to emit an error.
            if ($token[0] === \T_BAD_CHARACTER) {
                $this->handleInvalidCharacterRange($filePos, $filePos + 1, $line, $errorHandler);
            }
            if ($token[0] === \T_COMMENT && \substr($token[1], 0, 2) !== '/*' && \preg_match('/(\\r\\n|\\n|\\r)$/D', $token[1], $matches)) {
                $trailingNewline = $matches[0];
                $token[1] = \substr($token[1], 0, -\strlen($trailingNewline));
                $this->tokens[$i] = $token;
                if (isset($this->tokens[$i + 1]) && $this->tokens[$i + 1][0] === \T_WHITESPACE) {
                    // Move trailing newline into following T_WHITESPACE token, if it already exists.
                    $this->tokens[$i + 1][1] = $trailingNewline . $this->tokens[$i + 1][1];
                    $this->tokens[$i + 1][2]--;
                } else {
                    // Otherwise, we need to create a new T_WHITESPACE token.
                    \array_splice($this->tokens, $i + 1, 0, [[\T_WHITESPACE, $trailingNewline, $line]]);
                    $numTokens++;
                }
            }
            // Emulate PHP 8 T_NAME_* tokens, by combining sequences of T_NS_SEPARATOR and T_STRING
            // into a single token.
            if (\is_array($token) && ($token[0] === \T_NS_SEPARATOR || isset($this->identifierTokens[$token[0]]))) {
                $lastWasSeparator = $token[0] === \T_NS_SEPARATOR;
                $text = $token[1];
                for ($j = $i + 1; isset($this->tokens[$j]); $j++) {
                    if ($lastWasSeparator) {
                        if (!isset($this->identifierTokens[$this->tokens[$j][0]])) {
                            break;
                        }
                        $lastWasSeparator = \false;
                    } else {
                        if ($this->tokens[$j][0] !== \T_NS_SEPARATOR) {
                            break;
                        }
                        $lastWasSeparator = \true;
                    }
                    $text .= $this->tokens[$j][1];
                }
                if ($lastWasSeparator) {
                    // Trailing separator is not part of the name.
                    $j--;
                    $text = \substr($text, 0, -1);
                }
                if ($j > $i + 1) {
                    if ($token[0] === \T_NS_SEPARATOR) {
                        $type = \T_NAME_FULLY_QUALIFIED;
                    } else {
                        if ($token[0] === \T_NAMESPACE) {
                            $type = \T_NAME_RELATIVE;
                        } else {
                            $type = \T_NAME_QUALIFIED;
                        }
                    }
                    $token = [$type, $text, $line];
                    \array_splice($this->tokens, $i, $j - $i, [$token]);
                    $numTokens -= $j - $i - 1;
                }
            }
            $tokenValue = \is_string($token) ? $token : $token[1];
            $tokenLen = \strlen($tokenValue);
            if (\substr($this->code, $filePos, $tokenLen) !== $tokenValue) {
                // Something is missing, must be an invalid character
                $nextFilePos = \strpos($this->code, $tokenValue, $filePos);
                $badCharTokens = $this->handleInvalidCharacterRange($filePos, $nextFilePos, $line, $errorHandler);
                $filePos = (int) $nextFilePos;
                \array_splice($this->tokens, $i, 0, $badCharTokens);
                $numTokens += \count($badCharTokens);
                $i += \count($badCharTokens);
            }
            $filePos += $tokenLen;
            $line += \substr_count($tokenValue, "\n");
        }
        if ($filePos !== \strlen($this->code)) {
            if (\substr($this->code, $filePos, 2) === '/*') {
                // Unlike PHP, HHVM will drop unterminated comments entirely
                $comment = \substr($this->code, $filePos);
                $errorHandler->handleError(new \PHPUnit\PhpParser\Error('Unterminated comment', ['startLine' => $line, 'endLine' => $line + \substr_count($comment, "\n"), 'startFilePos' => $filePos, 'endFilePos' => $filePos + \strlen($comment)]));
                // Emulate the PHP behavior
                $isDocComment = isset($comment[3]) && $comment[3] === '*';
                $this->tokens[] = [$isDocComment ? \T_DOC_COMMENT : \T_COMMENT, $comment, $line];
            } else {
                // Invalid characters at the end of the input
                $badCharTokens = $this->handleInvalidCharacterRange($filePos, \strlen($this->code), $line, $errorHandler);
                $this->tokens = \array_merge($this->tokens, $badCharTokens);
            }
            return;
        }
        if (\count($this->tokens) > 0) {
            // Check for unterminated comment
            $lastToken = $this->tokens[\count($this->tokens) - 1];
            if ($this->isUnterminatedComment($lastToken)) {
                $errorHandler->handleError(new \PHPUnit\PhpParser\Error('Unterminated comment', ['startLine' => $line - \substr_count($lastToken[1], "\n"), 'endLine' => $line, 'startFilePos' => $filePos - \strlen($lastToken[1]), 'endFilePos' => $filePos]));
            }
        }
    }
    /**
     * Fetches the next token.
     *
     * The available attributes are determined by the 'usedAttributes' option, which can
     * be specified in the constructor. The following attributes are supported:
     *
     *  * 'comments'      => Array of PhpParser\Comment or PhpParser\Comment\Doc instances,
     *                       representing all comments that occurred between the previous
     *                       non-discarded token and the current one.
     *  * 'startLine'     => Line in which the node starts.
     *  * 'endLine'       => Line in which the node ends.
     *  * 'startTokenPos' => Offset into the token array of the first token in the node.
     *  * 'endTokenPos'   => Offset into the token array of the last token in the node.
     *  * 'startFilePos'  => Offset into the code string of the first character that is part of the node.
     *  * 'endFilePos'    => Offset into the code string of the last character that is part of the node.
     *
     * @param mixed $value           Variable to store token content in
     * @param mixed $startAttributes Variable to store start attributes in
     * @param mixed $endAttributes   Variable to store end attributes in
     *
     * @return int Token id
     */
    public function getNextToken(&$value = null, &$startAttributes = null, &$endAttributes = null) : int
    {
        $startAttributes = [];
        $endAttributes = [];
        while (1) {
            if (isset($this->tokens[++$this->pos])) {
                $token = $this->tokens[$this->pos];
            } else {
                // EOF token with ID 0
                $token = "\0";
            }
            if ($this->attributeStartLineUsed) {
                $startAttributes['startLine'] = $this->line;
            }
            if ($this->attributeStartTokenPosUsed) {
                $startAttributes['startTokenPos'] = $this->pos;
            }
            if ($this->attributeStartFilePosUsed) {
                $startAttributes['startFilePos'] = $this->filePos;
            }
            if (\is_string($token)) {
                $value = $token;
                if (isset($token[1])) {
                    // bug in token_get_all
                    $this->filePos += 2;
                    $id = \ord('"');
                } else {
                    $this->filePos += 1;
                    $id = \ord($token);
                }
            } elseif (!isset($this->dropTokens[$token[0]])) {
                $value = $token[1];
                $id = $this->tokenMap[$token[0]];
                if (\T_CLOSE_TAG === $token[0]) {
                    $this->prevCloseTagHasNewline = \false !== \strpos($token[1], "\n") || \false !== \strpos($token[1], "\r");
                } elseif (\T_INLINE_HTML === $token[0]) {
                    $startAttributes['hasLeadingNewline'] = $this->prevCloseTagHasNewline;
                }
                $this->line += \substr_count($value, "\n");
                $this->filePos += \strlen($value);
            } else {
                $origLine = $this->line;
                $origFilePos = $this->filePos;
                $this->line += \substr_count($token[1], "\n");
                $this->filePos += \strlen($token[1]);
                if (\T_COMMENT === $token[0] || \T_DOC_COMMENT === $token[0]) {
                    if ($this->attributeCommentsUsed) {
                        $comment = \T_DOC_COMMENT === $token[0] ? new \PHPUnit\PhpParser\Comment\Doc($token[1], $origLine, $origFilePos, $this->pos, $this->line, $this->filePos - 1, $this->pos) : new \PHPUnit\PhpParser\Comment($token[1], $origLine, $origFilePos, $this->pos, $this->line, $this->filePos - 1, $this->pos);
                        $startAttributes['comments'][] = $comment;
                    }
                }
                continue;
            }
            if ($this->attributeEndLineUsed) {
                $endAttributes['endLine'] = $this->line;
            }
            if ($this->attributeEndTokenPosUsed) {
                $endAttributes['endTokenPos'] = $this->pos;
            }
            if ($this->attributeEndFilePosUsed) {
                $endAttributes['endFilePos'] = $this->filePos - 1;
            }
            return $id;
        }
        throw new \RuntimeException('Reached end of lexer loop');
    }
    /**
     * Returns the token array for current code.
     *
     * The token array is in the same format as provided by the
     * token_get_all() function and does not discard tokens (i.e.
     * whitespace and comments are included). The token position
     * attributes are against this token array.
     *
     * @return array Array of tokens in token_get_all() format
     */
    public function getTokens() : array
    {
        return $this->tokens;
    }
    /**
     * Handles __halt_compiler() by returning the text after it.
     *
     * @return string Remaining text
     */
    public function handleHaltCompiler() : string
    {
        // text after T_HALT_COMPILER, still including ();
        $textAfter = \substr($this->code, $this->filePos);
        // ensure that it is followed by ();
        // this simplifies the situation, by not allowing any comments
        // in between of the tokens.
        if (!\preg_match('~^\\s*\\(\\s*\\)\\s*(?:;|\\?>\\r?\\n?)~', $textAfter, $matches)) {
            throw new \PHPUnit\PhpParser\Error('__HALT_COMPILER must be followed by "();"');
        }
        // prevent the lexer from returning any further tokens
        $this->pos = \count($this->tokens);
        // return with (); removed
        return \substr($textAfter, \strlen($matches[0]));
    }
    private function defineCompatibilityTokens()
    {
        static $compatTokensDefined = \false;
        if ($compatTokensDefined) {
            return;
        }
        $compatTokens = [
            // PHP 7.4
            'T_BAD_CHARACTER',
            'T_FN',
            'T_COALESCE_EQUAL',
            // PHP 8.0
            'T_NAME_QUALIFIED',
            'T_NAME_FULLY_QUALIFIED',
            'T_NAME_RELATIVE',
            'T_MATCH',
            'T_NULLSAFE_OBJECT_OPERATOR',
            'T_ATTRIBUTE',
            // PHP 8.1
            'T_ENUM',
        ];
        // PHP-Parser might be used together with another library that also emulates some or all
        // of these tokens. Perform a sanity-check that all already defined tokens have been
        // assigned a unique ID.
        $usedTokenIds = [];
        foreach ($compatTokens as $token) {
            if (\defined($token)) {
                $tokenId = \constant($token);
                $clashingToken = $usedTokenIds[$tokenId] ?? null;
                if ($clashingToken !== null) {
                    throw new \Error(\sprintf('Token %s has same ID as token %s, ' . 'you may be using a library with broken token emulation', $token, $clashingToken));
                }
                $usedTokenIds[$tokenId] = $token;
            }
        }
        // Now define any tokens that have not yet been emulated. Try to assign IDs from -1
        // downwards, but skip any IDs that may already be in use.
        $newTokenId = -1;
        foreach ($compatTokens as $token) {
            if (!\defined($token)) {
                while (isset($usedTokenIds[$newTokenId])) {
                    $newTokenId--;
                }
                \define($token, $newTokenId);
                $newTokenId--;
            }
        }
        $compatTokensDefined = \true;
    }
    /**
     * Creates the token map.
     *
     * The token map maps the PHP internal token identifiers
     * to the identifiers used by the Parser. Additionally it
     * maps T_OPEN_TAG_WITH_ECHO to T_ECHO and T_CLOSE_TAG to ';'.
     *
     * @return array The token map
     */
    protected function createTokenMap() : array
    {
        $tokenMap = [];
        // 256 is the minimum possible token number, as everything below
        // it is an ASCII value
        for ($i = 256; $i < 1000; ++$i) {
            if (\T_DOUBLE_COLON === $i) {
                // T_DOUBLE_COLON is equivalent to T_PAAMAYIM_NEKUDOTAYIM
                $tokenMap[$i] = \PHPUnit\PhpParser\Parser\Tokens::T_PAAMAYIM_NEKUDOTAYIM;
            } elseif (\T_OPEN_TAG_WITH_ECHO === $i) {
                // T_OPEN_TAG_WITH_ECHO with dropped T_OPEN_TAG results in T_ECHO
                $tokenMap[$i] = \PHPUnit\PhpParser\Parser\Tokens::T_ECHO;
            } elseif (\T_CLOSE_TAG === $i) {
                // T_CLOSE_TAG is equivalent to ';'
                $tokenMap[$i] = \ord(';');
            } elseif ('UNKNOWN' !== ($name = \token_name($i))) {
                if ('T_HASHBANG' === $name) {
                    // HHVM uses a special token for #! hashbang lines
                    $tokenMap[$i] = \PHPUnit\PhpParser\Parser\Tokens::T_INLINE_HTML;
                } elseif (\defined($name = \PHPUnit\PhpParser\Parser\Tokens::class . '::' . $name)) {
                    // Other tokens can be mapped directly
                    $tokenMap[$i] = \constant($name);
                }
            }
        }
        // HHVM uses a special token for numbers that overflow to double
        if (\defined('T_ONUMBER')) {
            $tokenMap[\T_ONUMBER] = \PHPUnit\PhpParser\Parser\Tokens::T_DNUMBER;
        }
        // HHVM also has a separate token for the __COMPILER_HALT_OFFSET__ constant
        if (\defined('T_COMPILER_HALT_OFFSET')) {
            $tokenMap[\T_COMPILER_HALT_OFFSET] = \PHPUnit\PhpParser\Parser\Tokens::T_STRING;
        }
        // Assign tokens for which we define compatibility constants, as token_name() does not know them.
        $tokenMap[\T_FN] = \PHPUnit\PhpParser\Parser\Tokens::T_FN;
        $tokenMap[\T_COALESCE_EQUAL] = \PHPUnit\PhpParser\Parser\Tokens::T_COALESCE_EQUAL;
        $tokenMap[\T_NAME_QUALIFIED] = \PHPUnit\PhpParser\Parser\Tokens::T_NAME_QUALIFIED;
        $tokenMap[\T_NAME_FULLY_QUALIFIED] = \PHPUnit\PhpParser\Parser\Tokens::T_NAME_FULLY_QUALIFIED;
        $tokenMap[\T_NAME_RELATIVE] = \PHPUnit\PhpParser\Parser\Tokens::T_NAME_RELATIVE;
        $tokenMap[\T_MATCH] = \PHPUnit\PhpParser\Parser\Tokens::T_MATCH;
        $tokenMap[\T_NULLSAFE_OBJECT_OPERATOR] = \PHPUnit\PhpParser\Parser\Tokens::T_NULLSAFE_OBJECT_OPERATOR;
        $tokenMap[\T_ATTRIBUTE] = \PHPUnit\PhpParser\Parser\Tokens::T_ATTRIBUTE;
        $tokenMap[\T_ENUM] = \PHPUnit\PhpParser\Parser\Tokens::T_ENUM;
        return $tokenMap;
    }
    private function createIdentifierTokenMap() : array
    {
        // Based on semi_reserved production.
        return \array_fill_keys([\T_STRING, \T_STATIC, \T_ABSTRACT, \T_FINAL, \T_PRIVATE, \T_PROTECTED, \T_PUBLIC, \T_INCLUDE, \T_INCLUDE_ONCE, \T_EVAL, \T_REQUIRE, \T_REQUIRE_ONCE, \T_LOGICAL_OR, \T_LOGICAL_XOR, \T_LOGICAL_AND, \T_INSTANCEOF, \T_NEW, \T_CLONE, \T_EXIT, \T_IF, \T_ELSEIF, \T_ELSE, \T_ENDIF, \T_ECHO, \T_DO, \T_WHILE, \T_ENDWHILE, \T_FOR, \T_ENDFOR, \T_FOREACH, \T_ENDFOREACH, \T_DECLARE, \T_ENDDECLARE, \T_AS, \T_TRY, \T_CATCH, \T_FINALLY, \T_THROW, \T_USE, \T_INSTEADOF, \T_GLOBAL, \T_VAR, \T_UNSET, \T_ISSET, \T_EMPTY, \T_CONTINUE, \T_GOTO, \T_FUNCTION, \T_CONST, \T_RETURN, \T_PRINT, \T_YIELD, \T_LIST, \T_SWITCH, \T_ENDSWITCH, \T_CASE, \T_DEFAULT, \T_BREAK, \T_ARRAY, \T_CALLABLE, \T_EXTENDS, \T_IMPLEMENTS, \T_NAMESPACE, \T_TRAIT, \T_INTERFACE, \T_CLASS, \T_CLASS_C, \T_TRAIT_C, \T_FUNC_C, \T_METHOD_C, \T_LINE, \T_FILE, \T_DIR, \T_NS_C, \T_HALT_COMPILER, \T_FN, \T_MATCH], \true);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\ErrorHandler;
use PHPUnit\PhpParser\Lexer;
use PHPUnit\PhpParser\Lexer\TokenEmulator\AttributeEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\EnumTokenEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\CoaleseEqualTokenEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\FlexibleDocStringEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\FnTokenEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\MatchTokenEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\NullsafeTokenEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\NumericLiteralSeparatorEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\ReverseEmulator;
use PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator;
class Emulative extends \PHPUnit\PhpParser\Lexer
{
    const PHP_7_3 = '7.3dev';
    const PHP_7_4 = '7.4dev';
    const PHP_8_0 = '8.0dev';
    const PHP_8_1 = '8.1dev';
    /** @var mixed[] Patches used to reverse changes introduced in the code */
    private $patches = [];
    /** @var TokenEmulator[] */
    private $emulators = [];
    /** @var string */
    private $targetPhpVersion;
    /**
     * @param mixed[] $options Lexer options. In addition to the usual options,
     *                         accepts a 'phpVersion' string that specifies the
     *                         version to emulated. Defaults to newest supported.
     */
    public function __construct(array $options = [])
    {
        $this->targetPhpVersion = $options['phpVersion'] ?? \PHPUnit\PhpParser\Lexer\Emulative::PHP_8_1;
        unset($options['phpVersion']);
        parent::__construct($options);
        $emulators = [new \PHPUnit\PhpParser\Lexer\TokenEmulator\FlexibleDocStringEmulator(), new \PHPUnit\PhpParser\Lexer\TokenEmulator\FnTokenEmulator(), new \PHPUnit\PhpParser\Lexer\TokenEmulator\MatchTokenEmulator(), new \PHPUnit\PhpParser\Lexer\TokenEmulator\CoaleseEqualTokenEmulator(), new \PHPUnit\PhpParser\Lexer\TokenEmulator\NumericLiteralSeparatorEmulator(), new \PHPUnit\PhpParser\Lexer\TokenEmulator\NullsafeTokenEmulator(), new \PHPUnit\PhpParser\Lexer\TokenEmulator\AttributeEmulator(), new \PHPUnit\PhpParser\Lexer\TokenEmulator\EnumTokenEmulator()];
        // Collect emulators that are relevant for the PHP version we're running
        // and the PHP version we're targeting for emulation.
        foreach ($emulators as $emulator) {
            $emulatorPhpVersion = $emulator->getPhpVersion();
            if ($this->isForwardEmulationNeeded($emulatorPhpVersion)) {
                $this->emulators[] = $emulator;
            } else {
                if ($this->isReverseEmulationNeeded($emulatorPhpVersion)) {
                    $this->emulators[] = new \PHPUnit\PhpParser\Lexer\TokenEmulator\ReverseEmulator($emulator);
                }
            }
        }
    }
    public function startLexing(string $code, \PHPUnit\PhpParser\ErrorHandler $errorHandler = null)
    {
        $emulators = \array_filter($this->emulators, function ($emulator) use($code) {
            return $emulator->isEmulationNeeded($code);
        });
        if (empty($emulators)) {
            // Nothing to emulate, yay
            parent::startLexing($code, $errorHandler);
            return;
        }
        $this->patches = [];
        foreach ($emulators as $emulator) {
            $code = $emulator->preprocessCode($code, $this->patches);
        }
        $collector = new \PHPUnit\PhpParser\ErrorHandler\Collecting();
        parent::startLexing($code, $collector);
        $this->sortPatches();
        $this->fixupTokens();
        $errors = $collector->getErrors();
        if (!empty($errors)) {
            $this->fixupErrors($errors);
            foreach ($errors as $error) {
                $errorHandler->handleError($error);
            }
        }
        foreach ($emulators as $emulator) {
            $this->tokens = $emulator->emulate($code, $this->tokens);
        }
    }
    private function isForwardEmulationNeeded(string $emulatorPhpVersion) : bool
    {
        return \version_compare(\PHP_VERSION, $emulatorPhpVersion, '<') && \version_compare($this->targetPhpVersion, $emulatorPhpVersion, '>=');
    }
    private function isReverseEmulationNeeded(string $emulatorPhpVersion) : bool
    {
        return \version_compare(\PHP_VERSION, $emulatorPhpVersion, '>=') && \version_compare($this->targetPhpVersion, $emulatorPhpVersion, '<');
    }
    private function sortPatches()
    {
        // Patches may be contributed by different emulators.
        // Make sure they are sorted by increasing patch position.
        \usort($this->patches, function ($p1, $p2) {
            return $p1[0] <=> $p2[0];
        });
    }
    private function fixupTokens()
    {
        if (\count($this->patches) === 0) {
            return;
        }
        // Load first patch
        $patchIdx = 0;
        list($patchPos, $patchType, $patchText) = $this->patches[$patchIdx];
        // We use a manual loop over the tokens, because we modify the array on the fly
        $pos = 0;
        for ($i = 0, $c = \count($this->tokens); $i < $c; $i++) {
            $token = $this->tokens[$i];
            if (\is_string($token)) {
                if ($patchPos === $pos) {
                    // Only support replacement for string tokens.
                    \assert($patchType === 'replace');
                    $this->tokens[$i] = $patchText;
                    // Fetch the next patch
                    $patchIdx++;
                    if ($patchIdx >= \count($this->patches)) {
                        // No more patches, we're done
                        return;
                    }
                    list($patchPos, $patchType, $patchText) = $this->patches[$patchIdx];
                }
                $pos += \strlen($token);
                continue;
            }
            $len = \strlen($token[1]);
            $posDelta = 0;
            while ($patchPos >= $pos && $patchPos < $pos + $len) {
                $patchTextLen = \strlen($patchText);
                if ($patchType === 'remove') {
                    if ($patchPos === $pos && $patchTextLen === $len) {
                        // Remove token entirely
                        \array_splice($this->tokens, $i, 1, []);
                        $i--;
                        $c--;
                    } else {
                        // Remove from token string
                        $this->tokens[$i][1] = \substr_replace($token[1], '', $patchPos - $pos + $posDelta, $patchTextLen);
                        $posDelta -= $patchTextLen;
                    }
                } elseif ($patchType === 'add') {
                    // Insert into the token string
                    $this->tokens[$i][1] = \substr_replace($token[1], $patchText, $patchPos - $pos + $posDelta, 0);
                    $posDelta += $patchTextLen;
                } else {
                    if ($patchType === 'replace') {
                        // Replace inside the token string
                        $this->tokens[$i][1] = \substr_replace($token[1], $patchText, $patchPos - $pos + $posDelta, $patchTextLen);
                    } else {
                        \assert(\false);
                    }
                }
                // Fetch the next patch
                $patchIdx++;
                if ($patchIdx >= \count($this->patches)) {
                    // No more patches, we're done
                    return;
                }
                list($patchPos, $patchType, $patchText) = $this->patches[$patchIdx];
                // Multiple patches may apply to the same token. Reload the current one to check
                // If the new patch applies
                $token = $this->tokens[$i];
            }
            $pos += $len;
        }
        // A patch did not apply
        \assert(\false);
    }
    /**
     * Fixup line and position information in errors.
     *
     * @param Error[] $errors
     */
    private function fixupErrors(array $errors)
    {
        foreach ($errors as $error) {
            $attrs = $error->getAttributes();
            $posDelta = 0;
            $lineDelta = 0;
            foreach ($this->patches as $patch) {
                list($patchPos, $patchType, $patchText) = $patch;
                if ($patchPos >= $attrs['startFilePos']) {
                    // No longer relevant
                    break;
                }
                if ($patchType === 'add') {
                    $posDelta += \strlen($patchText);
                    $lineDelta += \substr_count($patchText, "\n");
                } else {
                    if ($patchType === 'remove') {
                        $posDelta -= \strlen($patchText);
                        $lineDelta -= \substr_count($patchText, "\n");
                    }
                }
            }
            $attrs['startFilePos'] += $posDelta;
            $attrs['endFilePos'] += $posDelta;
            $attrs['startLine'] += $lineDelta;
            $attrs['endLine'] += $lineDelta;
            $error->setAttributes($attrs);
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class AttributeEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator
{
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_8_0;
    }
    public function isEmulationNeeded(string $code) : bool
    {
        return \strpos($code, '#[') !== \false;
    }
    public function emulate(string $code, array $tokens) : array
    {
        // We need to manually iterate and manage a count because we'll change
        // the tokens array on the way.
        $line = 1;
        for ($i = 0, $c = \count($tokens); $i < $c; ++$i) {
            if ($tokens[$i] === '#' && isset($tokens[$i + 1]) && $tokens[$i + 1] === '[') {
                \array_splice($tokens, $i, 2, [[\T_ATTRIBUTE, '#[', $line]]);
                $c--;
                continue;
            }
            if (\is_array($tokens[$i])) {
                $line += \substr_count($tokens[$i][1], "\n");
            }
        }
        return $tokens;
    }
    public function reverseEmulate(string $code, array $tokens) : array
    {
        // TODO
        return $tokens;
    }
    public function preprocessCode(string $code, array &$patches) : string
    {
        $pos = 0;
        while (\false !== ($pos = \strpos($code, '#[', $pos))) {
            // Replace #[ with %[
            $code[$pos] = '%';
            $patches[] = [$pos, 'replace', '#'];
            $pos += 2;
        }
        return $code;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class CoaleseEqualTokenEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator
{
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_7_4;
    }
    public function isEmulationNeeded(string $code) : bool
    {
        return \strpos($code, '??=') !== \false;
    }
    public function emulate(string $code, array $tokens) : array
    {
        // We need to manually iterate and manage a count because we'll change
        // the tokens array on the way
        $line = 1;
        for ($i = 0, $c = \count($tokens); $i < $c; ++$i) {
            if (isset($tokens[$i + 1])) {
                if ($tokens[$i][0] === \T_COALESCE && $tokens[$i + 1] === '=') {
                    \array_splice($tokens, $i, 2, [[\T_COALESCE_EQUAL, '??=', $line]]);
                    $c--;
                    continue;
                }
            }
            if (\is_array($tokens[$i])) {
                $line += \substr_count($tokens[$i][1], "\n");
            }
        }
        return $tokens;
    }
    public function reverseEmulate(string $code, array $tokens) : array
    {
        // ??= was not valid code previously, don't bother.
        return $tokens;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class EnumTokenEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\KeywordEmulator
{
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_8_1;
    }
    public function getKeywordString() : string
    {
        return 'enum';
    }
    public function getKeywordToken() : int
    {
        return \T_ENUM;
    }
    protected function isKeywordContext(array $tokens, int $pos) : bool
    {
        return parent::isKeywordContext($tokens, $pos) && isset($tokens[$pos + 2]) && $tokens[$pos + 1][0] === \T_WHITESPACE && $tokens[$pos + 2][0] === \T_STRING;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class FlexibleDocStringEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator
{
    const FLEXIBLE_DOC_STRING_REGEX = <<<'REGEX'
/<<<[ \t]*(['"]?)([a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*)\1\r?\n
(?:.*\r?\n)*?
(?<indentation>\h*)\2(?![a-zA-Z0-9_\x80-\xff])(?<separator>(?:;?[\r\n])?)/x
REGEX;
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_7_3;
    }
    public function isEmulationNeeded(string $code) : bool
    {
        return \strpos($code, '<<<') !== \false;
    }
    public function emulate(string $code, array $tokens) : array
    {
        // Handled by preprocessing + fixup.
        return $tokens;
    }
    public function reverseEmulate(string $code, array $tokens) : array
    {
        // Not supported.
        return $tokens;
    }
    public function preprocessCode(string $code, array &$patches) : string
    {
        if (!\preg_match_all(self::FLEXIBLE_DOC_STRING_REGEX, $code, $matches, \PREG_SET_ORDER | \PREG_OFFSET_CAPTURE)) {
            // No heredoc/nowdoc found
            return $code;
        }
        // Keep track of how much we need to adjust string offsets due to the modifications we
        // already made
        $posDelta = 0;
        foreach ($matches as $match) {
            $indentation = $match['indentation'][0];
            $indentationStart = $match['indentation'][1];
            $separator = $match['separator'][0];
            $separatorStart = $match['separator'][1];
            if ($indentation === '' && $separator !== '') {
                // Ordinary heredoc/nowdoc
                continue;
            }
            if ($indentation !== '') {
                // Remove indentation
                $indentationLen = \strlen($indentation);
                $code = \substr_replace($code, '', $indentationStart + $posDelta, $indentationLen);
                $patches[] = [$indentationStart + $posDelta, 'add', $indentation];
                $posDelta -= $indentationLen;
            }
            if ($separator === '') {
                // Insert newline as separator
                $code = \substr_replace($code, "\n", $separatorStart + $posDelta, 0);
                $patches[] = [$separatorStart + $posDelta, 'remove', "\n"];
                $posDelta += 1;
            }
        }
        return $code;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class FnTokenEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\KeywordEmulator
{
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_7_4;
    }
    public function getKeywordString() : string
    {
        return 'fn';
    }
    public function getKeywordToken() : int
    {
        return \T_FN;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

abstract class KeywordEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator
{
    abstract function getKeywordString() : string;
    abstract function getKeywordToken() : int;
    public function isEmulationNeeded(string $code) : bool
    {
        return \strpos(\strtolower($code), $this->getKeywordString()) !== \false;
    }
    protected function isKeywordContext(array $tokens, int $pos) : bool
    {
        $previousNonSpaceToken = $this->getPreviousNonSpaceToken($tokens, $pos);
        return $previousNonSpaceToken === null || $previousNonSpaceToken[0] !== \T_OBJECT_OPERATOR;
    }
    public function emulate(string $code, array $tokens) : array
    {
        $keywordString = $this->getKeywordString();
        foreach ($tokens as $i => $token) {
            if ($token[0] === \T_STRING && \strtolower($token[1]) === $keywordString && $this->isKeywordContext($tokens, $i)) {
                $tokens[$i][0] = $this->getKeywordToken();
            }
        }
        return $tokens;
    }
    /**
     * @param mixed[] $tokens
     * @return mixed[]|null
     */
    private function getPreviousNonSpaceToken(array $tokens, int $start)
    {
        for ($i = $start - 1; $i >= 0; --$i) {
            if ($tokens[$i][0] === \T_WHITESPACE) {
                continue;
            }
            return $tokens[$i];
        }
        return null;
    }
    public function reverseEmulate(string $code, array $tokens) : array
    {
        $keywordToken = $this->getKeywordToken();
        foreach ($tokens as $i => $token) {
            if ($token[0] === $keywordToken) {
                $tokens[$i][0] = \T_STRING;
            }
        }
        return $tokens;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class MatchTokenEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\KeywordEmulator
{
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_8_0;
    }
    public function getKeywordString() : string
    {
        return 'match';
    }
    public function getKeywordToken() : int
    {
        return \T_MATCH;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class NullsafeTokenEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator
{
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_8_0;
    }
    public function isEmulationNeeded(string $code) : bool
    {
        return \strpos($code, '?->') !== \false;
    }
    public function emulate(string $code, array $tokens) : array
    {
        // We need to manually iterate and manage a count because we'll change
        // the tokens array on the way
        $line = 1;
        for ($i = 0, $c = \count($tokens); $i < $c; ++$i) {
            if ($tokens[$i] === '?' && isset($tokens[$i + 1]) && $tokens[$i + 1][0] === \T_OBJECT_OPERATOR) {
                \array_splice($tokens, $i, 2, [[\T_NULLSAFE_OBJECT_OPERATOR, '?->', $line]]);
                $c--;
                continue;
            }
            // Handle ?-> inside encapsed string.
            if ($tokens[$i][0] === \T_ENCAPSED_AND_WHITESPACE && isset($tokens[$i - 1]) && $tokens[$i - 1][0] === \T_VARIABLE && \preg_match('/^\\?->([a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*)/', $tokens[$i][1], $matches)) {
                $replacement = [[\T_NULLSAFE_OBJECT_OPERATOR, '?->', $line], [\T_STRING, $matches[1], $line]];
                if (\strlen($matches[0]) !== \strlen($tokens[$i][1])) {
                    $replacement[] = [\T_ENCAPSED_AND_WHITESPACE, \substr($tokens[$i][1], \strlen($matches[0])), $line];
                }
                \array_splice($tokens, $i, 1, $replacement);
                $c += \count($replacement) - 1;
                continue;
            }
            if (\is_array($tokens[$i])) {
                $line += \substr_count($tokens[$i][1], "\n");
            }
        }
        return $tokens;
    }
    public function reverseEmulate(string $code, array $tokens) : array
    {
        // ?-> was not valid code previously, don't bother.
        return $tokens;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

use PHPUnit\PhpParser\Lexer\Emulative;
final class NumericLiteralSeparatorEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator
{
    const BIN = '(?:0b[01]+(?:_[01]+)*)';
    const HEX = '(?:0x[0-9a-f]+(?:_[0-9a-f]+)*)';
    const DEC = '(?:[0-9]+(?:_[0-9]+)*)';
    const SIMPLE_FLOAT = '(?:' . self::DEC . '\\.' . self::DEC . '?|\\.' . self::DEC . ')';
    const EXP = '(?:e[+-]?' . self::DEC . ')';
    const FLOAT = '(?:' . self::SIMPLE_FLOAT . self::EXP . '?|' . self::DEC . self::EXP . ')';
    const NUMBER = '~' . self::FLOAT . '|' . self::BIN . '|' . self::HEX . '|' . self::DEC . '~iA';
    public function getPhpVersion() : string
    {
        return \PHPUnit\PhpParser\Lexer\Emulative::PHP_7_4;
    }
    public function isEmulationNeeded(string $code) : bool
    {
        return \preg_match('~[0-9]_[0-9]~', $code) || \preg_match('~0x[0-9a-f]+_[0-9a-f]~i', $code);
    }
    public function emulate(string $code, array $tokens) : array
    {
        // We need to manually iterate and manage a count because we'll change
        // the tokens array on the way
        $codeOffset = 0;
        for ($i = 0, $c = \count($tokens); $i < $c; ++$i) {
            $token = $tokens[$i];
            $tokenLen = \strlen(\is_array($token) ? $token[1] : $token);
            if ($token[0] !== \T_LNUMBER && $token[0] !== \T_DNUMBER) {
                $codeOffset += $tokenLen;
                continue;
            }
            $res = \preg_match(self::NUMBER, $code, $matches, 0, $codeOffset);
            \assert($res, "No number at number token position");
            $match = $matches[0];
            $matchLen = \strlen($match);
            if ($matchLen === $tokenLen) {
                // Original token already holds the full number.
                $codeOffset += $tokenLen;
                continue;
            }
            $tokenKind = $this->resolveIntegerOrFloatToken($match);
            $newTokens = [[$tokenKind, $match, $token[2]]];
            $numTokens = 1;
            $len = $tokenLen;
            while ($matchLen > $len) {
                $nextToken = $tokens[$i + $numTokens];
                $nextTokenText = \is_array($nextToken) ? $nextToken[1] : $nextToken;
                $nextTokenLen = \strlen($nextTokenText);
                $numTokens++;
                if ($matchLen < $len + $nextTokenLen) {
                    // Split trailing characters into a partial token.
                    \assert(\is_array($nextToken), "Partial token should be an array token");
                    $partialText = \substr($nextTokenText, $matchLen - $len);
                    $newTokens[] = [$nextToken[0], $partialText, $nextToken[2]];
                    break;
                }
                $len += $nextTokenLen;
            }
            \array_splice($tokens, $i, $numTokens, $newTokens);
            $c -= $numTokens - \count($newTokens);
            $codeOffset += $matchLen;
        }
        return $tokens;
    }
    private function resolveIntegerOrFloatToken(string $str) : int
    {
        $str = \str_replace('_', '', $str);
        if (\stripos($str, '0b') === 0) {
            $num = \bindec($str);
        } elseif (\stripos($str, '0x') === 0) {
            $num = \hexdec($str);
        } elseif (\stripos($str, '0') === 0 && \ctype_digit($str)) {
            $num = \octdec($str);
        } else {
            $num = +$str;
        }
        return \is_float($num) ? \T_DNUMBER : \T_LNUMBER;
    }
    public function reverseEmulate(string $code, array $tokens) : array
    {
        // Numeric separators were not legal code previously, don't bother.
        return $tokens;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

/**
 * Reverses emulation direction of the inner emulator.
 */
final class ReverseEmulator extends \PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator
{
    /** @var TokenEmulator Inner emulator */
    private $emulator;
    public function __construct(\PHPUnit\PhpParser\Lexer\TokenEmulator\TokenEmulator $emulator)
    {
        $this->emulator = $emulator;
    }
    public function getPhpVersion() : string
    {
        return $this->emulator->getPhpVersion();
    }
    public function isEmulationNeeded(string $code) : bool
    {
        return $this->emulator->isEmulationNeeded($code);
    }
    public function emulate(string $code, array $tokens) : array
    {
        return $this->emulator->reverseEmulate($code, $tokens);
    }
    public function reverseEmulate(string $code, array $tokens) : array
    {
        return $this->emulator->emulate($code, $tokens);
    }
    public function preprocessCode(string $code, array &$patches) : string
    {
        return $code;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Lexer\TokenEmulator;

/** @internal */
abstract class TokenEmulator
{
    public abstract function getPhpVersion() : string;
    public abstract function isEmulationNeeded(string $code) : bool;
    /**
     * @return array Modified Tokens
     */
    public abstract function emulate(string $code, array $tokens) : array;
    /**
     * @return array Modified Tokens
     */
    public abstract function reverseEmulate(string $code, array $tokens) : array;
    public function preprocessCode(string $code, array &$patches) : string
    {
        return $code;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Name\FullyQualified;
use PHPUnit\PhpParser\Node\Stmt;
class NameContext
{
    /** @var null|Name Current namespace */
    protected $namespace;
    /** @var Name[][] Map of format [aliasType => [aliasName => originalName]] */
    protected $aliases = [];
    /** @var Name[][] Same as $aliases but preserving original case */
    protected $origAliases = [];
    /** @var ErrorHandler Error handler */
    protected $errorHandler;
    /**
     * Create a name context.
     *
     * @param ErrorHandler $errorHandler Error handling used to report errors
     */
    public function __construct(\PHPUnit\PhpParser\ErrorHandler $errorHandler)
    {
        $this->errorHandler = $errorHandler;
    }
    /**
     * Start a new namespace.
     *
     * This also resets the alias table.
     *
     * @param Name|null $namespace Null is the global namespace
     */
    public function startNamespace(\PHPUnit\PhpParser\Node\Name $namespace = null)
    {
        $this->namespace = $namespace;
        $this->origAliases = $this->aliases = [\PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL => [], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION => [], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT => []];
    }
    /**
     * Add an alias / import.
     *
     * @param Name   $name        Original name
     * @param string $aliasName   Aliased name
     * @param int    $type        One of Stmt\Use_::TYPE_*
     * @param array  $errorAttrs Attributes to use to report an error
     */
    public function addAlias(\PHPUnit\PhpParser\Node\Name $name, string $aliasName, int $type, array $errorAttrs = [])
    {
        // Constant names are case sensitive, everything else case insensitive
        if ($type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT) {
            $aliasLookupName = $aliasName;
        } else {
            $aliasLookupName = \strtolower($aliasName);
        }
        if (isset($this->aliases[$type][$aliasLookupName])) {
            $typeStringMap = [\PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL => '', \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION => 'function ', \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT => 'const '];
            $this->errorHandler->handleError(new \PHPUnit\PhpParser\Error(\sprintf('Cannot use %s%s as %s because the name is already in use', $typeStringMap[$type], $name, $aliasName), $errorAttrs));
            return;
        }
        $this->aliases[$type][$aliasLookupName] = $name;
        $this->origAliases[$type][$aliasName] = $name;
    }
    /**
     * Get current namespace.
     *
     * @return null|Name Namespace (or null if global namespace)
     */
    public function getNamespace()
    {
        return $this->namespace;
    }
    /**
     * Get resolved name.
     *
     * @param Name $name Name to resolve
     * @param int  $type One of Stmt\Use_::TYPE_{FUNCTION|CONSTANT}
     *
     * @return null|Name Resolved name, or null if static resolution is not possible
     */
    public function getResolvedName(\PHPUnit\PhpParser\Node\Name $name, int $type)
    {
        // don't resolve special class names
        if ($type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL && $name->isSpecialClassName()) {
            if (!$name->isUnqualified()) {
                $this->errorHandler->handleError(new \PHPUnit\PhpParser\Error(\sprintf("'\\%s' is an invalid class name", $name->toString()), $name->getAttributes()));
            }
            return $name;
        }
        // fully qualified names are already resolved
        if ($name->isFullyQualified()) {
            return $name;
        }
        // Try to resolve aliases
        if (null !== ($resolvedName = $this->resolveAlias($name, $type))) {
            return $resolvedName;
        }
        if ($type !== \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL && $name->isUnqualified()) {
            if (null === $this->namespace) {
                // outside of a namespace unaliased unqualified is same as fully qualified
                return new \PHPUnit\PhpParser\Node\Name\FullyQualified($name, $name->getAttributes());
            }
            // Cannot resolve statically
            return null;
        }
        // if no alias exists prepend current namespace
        return \PHPUnit\PhpParser\Node\Name\FullyQualified::concat($this->namespace, $name, $name->getAttributes());
    }
    /**
     * Get resolved class name.
     *
     * @param Name $name Class ame to resolve
     *
     * @return Name Resolved name
     */
    public function getResolvedClassName(\PHPUnit\PhpParser\Node\Name $name) : \PHPUnit\PhpParser\Node\Name
    {
        return $this->getResolvedName($name, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL);
    }
    /**
     * Get possible ways of writing a fully qualified name (e.g., by making use of aliases).
     *
     * @param string $name Fully-qualified name (without leading namespace separator)
     * @param int    $type One of Stmt\Use_::TYPE_*
     *
     * @return Name[] Possible representations of the name
     */
    public function getPossibleNames(string $name, int $type) : array
    {
        $lcName = \strtolower($name);
        if ($type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL) {
            // self, parent and static must always be unqualified
            if ($lcName === "self" || $lcName === "parent" || $lcName === "static") {
                return [new \PHPUnit\PhpParser\Node\Name($name)];
            }
        }
        // Collect possible ways to write this name, starting with the fully-qualified name
        $possibleNames = [new \PHPUnit\PhpParser\Node\Name\FullyQualified($name)];
        if (null !== ($nsRelativeName = $this->getNamespaceRelativeName($name, $lcName, $type))) {
            // Make sure there is no alias that makes the normally namespace-relative name
            // into something else
            if (null === $this->resolveAlias($nsRelativeName, $type)) {
                $possibleNames[] = $nsRelativeName;
            }
        }
        // Check for relevant namespace use statements
        foreach ($this->origAliases[\PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL] as $alias => $orig) {
            $lcOrig = $orig->toLowerString();
            if (0 === \strpos($lcName, $lcOrig . '\\')) {
                $possibleNames[] = new \PHPUnit\PhpParser\Node\Name($alias . \substr($name, \strlen($lcOrig)));
            }
        }
        // Check for relevant type-specific use statements
        foreach ($this->origAliases[$type] as $alias => $orig) {
            if ($type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT) {
                // Constants are are complicated-sensitive
                $normalizedOrig = $this->normalizeConstName($orig->toString());
                if ($normalizedOrig === $this->normalizeConstName($name)) {
                    $possibleNames[] = new \PHPUnit\PhpParser\Node\Name($alias);
                }
            } else {
                // Everything else is case-insensitive
                if ($orig->toLowerString() === $lcName) {
                    $possibleNames[] = new \PHPUnit\PhpParser\Node\Name($alias);
                }
            }
        }
        return $possibleNames;
    }
    /**
     * Get shortest representation of this fully-qualified name.
     *
     * @param string $name Fully-qualified name (without leading namespace separator)
     * @param int    $type One of Stmt\Use_::TYPE_*
     *
     * @return Name Shortest representation
     */
    public function getShortName(string $name, int $type) : \PHPUnit\PhpParser\Node\Name
    {
        $possibleNames = $this->getPossibleNames($name, $type);
        // Find shortest name
        $shortestName = null;
        $shortestLength = \INF;
        foreach ($possibleNames as $possibleName) {
            $length = \strlen($possibleName->toCodeString());
            if ($length < $shortestLength) {
                $shortestName = $possibleName;
                $shortestLength = $length;
            }
        }
        return $shortestName;
    }
    private function resolveAlias(\PHPUnit\PhpParser\Node\Name $name, $type)
    {
        $firstPart = $name->getFirst();
        if ($name->isQualified()) {
            // resolve aliases for qualified names, always against class alias table
            $checkName = \strtolower($firstPart);
            if (isset($this->aliases[\PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL][$checkName])) {
                $alias = $this->aliases[\PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL][$checkName];
                return \PHPUnit\PhpParser\Node\Name\FullyQualified::concat($alias, $name->slice(1), $name->getAttributes());
            }
        } elseif ($name->isUnqualified()) {
            // constant aliases are case-sensitive, function aliases case-insensitive
            $checkName = $type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT ? $firstPart : \strtolower($firstPart);
            if (isset($this->aliases[$type][$checkName])) {
                // resolve unqualified aliases
                return new \PHPUnit\PhpParser\Node\Name\FullyQualified($this->aliases[$type][$checkName], $name->getAttributes());
            }
        }
        // No applicable aliases
        return null;
    }
    private function getNamespaceRelativeName(string $name, string $lcName, int $type)
    {
        if (null === $this->namespace) {
            return new \PHPUnit\PhpParser\Node\Name($name);
        }
        if ($type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT) {
            // The constants true/false/null always resolve to the global symbols, even inside a
            // namespace, so they may be used without qualification
            if ($lcName === "true" || $lcName === "false" || $lcName === "null") {
                return new \PHPUnit\PhpParser\Node\Name($name);
            }
        }
        $namespacePrefix = \strtolower($this->namespace . '\\');
        if (0 === \strpos($lcName, $namespacePrefix)) {
            return new \PHPUnit\PhpParser\Node\Name(\substr($name, \strlen($namespacePrefix)));
        }
        return null;
    }
    private function normalizeConstName(string $name)
    {
        $nsSep = \strrpos($name, '\\');
        if (\false === $nsSep) {
            return $name;
        }
        // Constants have case-insensitive namespace and case-sensitive short-name
        $ns = \substr($name, 0, $nsSep);
        $shortName = \substr($name, $nsSep + 1);
        return \strtolower($ns) . '\\' . $shortName;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

interface Node
{
    /**
     * Gets the type of the node.
     *
     * @return string Type of the node
     */
    public function getType() : string;
    /**
     * Gets the names of the sub nodes.
     *
     * @return array Names of sub nodes
     */
    public function getSubNodeNames() : array;
    /**
     * Gets line the node started in (alias of getStartLine).
     *
     * @return int Start line (or -1 if not available)
     */
    public function getLine() : int;
    /**
     * Gets line the node started in.
     *
     * Requires the 'startLine' attribute to be enabled in the lexer (enabled by default).
     *
     * @return int Start line (or -1 if not available)
     */
    public function getStartLine() : int;
    /**
     * Gets the line the node ended in.
     *
     * Requires the 'endLine' attribute to be enabled in the lexer (enabled by default).
     *
     * @return int End line (or -1 if not available)
     */
    public function getEndLine() : int;
    /**
     * Gets the token offset of the first token that is part of this node.
     *
     * The offset is an index into the array returned by Lexer::getTokens().
     *
     * Requires the 'startTokenPos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int Token start position (or -1 if not available)
     */
    public function getStartTokenPos() : int;
    /**
     * Gets the token offset of the last token that is part of this node.
     *
     * The offset is an index into the array returned by Lexer::getTokens().
     *
     * Requires the 'endTokenPos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int Token end position (or -1 if not available)
     */
    public function getEndTokenPos() : int;
    /**
     * Gets the file offset of the first character that is part of this node.
     *
     * Requires the 'startFilePos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int File start position (or -1 if not available)
     */
    public function getStartFilePos() : int;
    /**
     * Gets the file offset of the last character that is part of this node.
     *
     * Requires the 'endFilePos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int File end position (or -1 if not available)
     */
    public function getEndFilePos() : int;
    /**
     * Gets all comments directly preceding this node.
     *
     * The comments are also available through the "comments" attribute.
     *
     * @return Comment[]
     */
    public function getComments() : array;
    /**
     * Gets the doc comment of the node.
     *
     * @return null|Comment\Doc Doc comment object or null
     */
    public function getDocComment();
    /**
     * Sets the doc comment of the node.
     *
     * This will either replace an existing doc comment or add it to the comments array.
     *
     * @param Comment\Doc $docComment Doc comment to set
     */
    public function setDocComment(\PHPUnit\PhpParser\Comment\Doc $docComment);
    /**
     * Sets an attribute on a node.
     *
     * @param string $key
     * @param mixed  $value
     */
    public function setAttribute(string $key, $value);
    /**
     * Returns whether an attribute exists.
     *
     * @param string $key
     *
     * @return bool
     */
    public function hasAttribute(string $key) : bool;
    /**
     * Returns the value of an attribute.
     *
     * @param string $key
     * @param mixed  $default
     *
     * @return mixed
     */
    public function getAttribute(string $key, $default = null);
    /**
     * Returns all the attributes of this node.
     *
     * @return array
     */
    public function getAttributes() : array;
    /**
     * Replaces all the attributes of this node.
     *
     * @param array $attributes
     */
    public function setAttributes(array $attributes);
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
class Arg extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var Identifier|null Parameter name (for named parameters) */
    public $name;
    /** @var Expr Value to pass */
    public $value;
    /** @var bool Whether to pass by ref */
    public $byRef;
    /** @var bool Whether to unpack the argument */
    public $unpack;
    /**
     * Constructs a function call argument node.
     *
     * @param Expr  $value      Value to pass
     * @param bool  $byRef      Whether to pass by ref
     * @param bool  $unpack     Whether to unpack the argument
     * @param array $attributes Additional attributes
     * @param Identifier|null $name Parameter name (for named parameters)
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $value, bool $byRef = \false, bool $unpack = \false, array $attributes = [], \PHPUnit\PhpParser\Node\Identifier $name = null)
    {
        $this->attributes = $attributes;
        $this->name = $name;
        $this->value = $value;
        $this->byRef = $byRef;
        $this->unpack = $unpack;
    }
    public function getSubNodeNames() : array
    {
        return ['name', 'value', 'byRef', 'unpack'];
    }
    public function getType() : string
    {
        return 'Arg';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeAbstract;
class Attribute extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var Name Attribute name */
    public $name;
    /** @var Arg[] Attribute arguments */
    public $args;
    /**
     * @param Node\Name $name       Attribute name
     * @param Arg[]     $args       Attribute arguments
     * @param array     $attributes Additional node attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Name $name, array $args = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = $name;
        $this->args = $args;
    }
    public function getSubNodeNames() : array
    {
        return ['name', 'args'];
    }
    public function getType() : string
    {
        return 'Attribute';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeAbstract;
class AttributeGroup extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var Attribute[] Attributes */
    public $attrs;
    /**
     * @param Attribute[] $attrs PHP attributes
     * @param array $attributes Additional node attributes
     */
    public function __construct(array $attrs, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->attrs = $attrs;
    }
    public function getSubNodeNames() : array
    {
        return ['attrs'];
    }
    public function getType() : string
    {
        return 'AttributeGroup';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
/**
 * @property Name $namespacedName Namespaced name (for global constants, if using NameResolver)
 */
class Const_ extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var Identifier Name */
    public $name;
    /** @var Expr Value */
    public $value;
    /**
     * Constructs a const node for use in class const and const statements.
     *
     * @param string|Identifier $name       Name
     * @param Expr              $value      Value
     * @param array             $attributes Additional attributes
     */
    public function __construct($name, \PHPUnit\PhpParser\Node\Expr $value, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['name', 'value'];
    }
    public function getType() : string
    {
        return 'Const';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
abstract class Expr extends \PHPUnit\PhpParser\NodeAbstract
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class ArrayDimFetch extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable */
    public $var;
    /** @var null|Expr Array index / dim */
    public $dim;
    /**
     * Constructs an array index fetch node.
     *
     * @param Expr      $var        Variable
     * @param null|Expr $dim        Array index / dim
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, \PHPUnit\PhpParser\Node\Expr $dim = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->dim = $dim;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'dim'];
    }
    public function getType() : string
    {
        return 'Expr_ArrayDimFetch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class ArrayItem extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var null|Expr Key */
    public $key;
    /** @var Expr Value */
    public $value;
    /** @var bool Whether to assign by reference */
    public $byRef;
    /** @var bool Whether to unpack the argument */
    public $unpack;
    /**
     * Constructs an array item node.
     *
     * @param Expr      $value      Value
     * @param null|Expr $key        Key
     * @param bool      $byRef      Whether to assign by reference
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $value, \PHPUnit\PhpParser\Node\Expr $key = null, bool $byRef = \false, array $attributes = [], bool $unpack = \false)
    {
        $this->attributes = $attributes;
        $this->key = $key;
        $this->value = $value;
        $this->byRef = $byRef;
        $this->unpack = $unpack;
    }
    public function getSubNodeNames() : array
    {
        return ['key', 'value', 'byRef', 'unpack'];
    }
    public function getType() : string
    {
        return 'Expr_ArrayItem';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Array_ extends \PHPUnit\PhpParser\Node\Expr
{
    // For use in "kind" attribute
    const KIND_LONG = 1;
    // array() syntax
    const KIND_SHORT = 2;
    // [] syntax
    /** @var (ArrayItem|null)[] Items */
    public $items;
    /**
     * Constructs an array node.
     *
     * @param (ArrayItem|null)[] $items      Items of the array
     * @param array       $attributes Additional attributes
     */
    public function __construct(array $items = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->items = $items;
    }
    public function getSubNodeNames() : array
    {
        return ['items'];
    }
    public function getType() : string
    {
        return 'Expr_Array';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\FunctionLike;
class ArrowFunction extends \PHPUnit\PhpParser\Node\Expr implements \PHPUnit\PhpParser\Node\FunctionLike
{
    /** @var bool */
    public $static;
    /** @var bool */
    public $byRef;
    /** @var Node\Param[] */
    public $params = [];
    /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType */
    public $returnType;
    /** @var Expr */
    public $expr;
    /** @var Node\AttributeGroup[] */
    public $attrGroups;
    /**
     * @param array $subNodes   Array of the following optional subnodes:
     *                          'static'     => false   : Whether the closure is static
     *                          'byRef'      => false   : Whether to return by reference
     *                          'params'     => array() : Parameters
     *                          'returnType' => null    : Return type
     *                          'expr'       => Expr    : Expression body
     *                          'attrGroups' => array() : PHP attribute groups
     * @param array $attributes Additional attributes
     */
    public function __construct(array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->static = $subNodes['static'] ?? \false;
        $this->byRef = $subNodes['byRef'] ?? \false;
        $this->params = $subNodes['params'] ?? [];
        $returnType = $subNodes['returnType'] ?? null;
        $this->returnType = \is_string($returnType) ? new \PHPUnit\PhpParser\Node\Identifier($returnType) : $returnType;
        $this->expr = $subNodes['expr'] ?? null;
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'static', 'byRef', 'params', 'returnType', 'expr'];
    }
    public function returnsByRef() : bool
    {
        return $this->byRef;
    }
    public function getParams() : array
    {
        return $this->params;
    }
    public function getReturnType()
    {
        return $this->returnType;
    }
    public function getAttrGroups() : array
    {
        return $this->attrGroups;
    }
    /**
     * @return Node\Stmt\Return_[]
     */
    public function getStmts() : array
    {
        return [new \PHPUnit\PhpParser\Node\Stmt\Return_($this->expr)];
    }
    public function getType() : string
    {
        return 'Expr_ArrowFunction';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Assign extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable */
    public $var;
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs an assignment node.
     *
     * @param Expr  $var        Variable
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, \PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'expr'];
    }
    public function getType() : string
    {
        return 'Expr_Assign';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
abstract class AssignOp extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable */
    public $var;
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs a compound assignment operation node.
     *
     * @param Expr  $var        Variable
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, \PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'expr'];
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class BitwiseAnd extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_BitwiseAnd';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class BitwiseOr extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_BitwiseOr';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class BitwiseXor extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_BitwiseXor';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Coalesce extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Coalesce';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Concat extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Concat';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Div extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Div';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Minus extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Minus';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Mod extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Mod';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Mul extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Mul';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Plus extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Plus';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class Pow extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_Pow';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class ShiftLeft extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_ShiftLeft';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\AssignOp;

use PHPUnit\PhpParser\Node\Expr\AssignOp;
class ShiftRight extends \PHPUnit\PhpParser\Node\Expr\AssignOp
{
    public function getType() : string
    {
        return 'Expr_AssignOp_ShiftRight';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class AssignRef extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable reference is assigned to */
    public $var;
    /** @var Expr Variable which is referenced */
    public $expr;
    /**
     * Constructs an assignment node.
     *
     * @param Expr  $var        Variable
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, \PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'expr'];
    }
    public function getType() : string
    {
        return 'Expr_AssignRef';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
abstract class BinaryOp extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr The left hand side expression */
    public $left;
    /** @var Expr The right hand side expression */
    public $right;
    /**
     * Constructs a binary operator node.
     *
     * @param Expr  $left       The left hand side expression
     * @param Expr  $right      The right hand side expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $left, \PHPUnit\PhpParser\Node\Expr $right, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->left = $left;
        $this->right = $right;
    }
    public function getSubNodeNames() : array
    {
        return ['left', 'right'];
    }
    /**
     * Get the operator sigil for this binary operation.
     *
     * In the case there are multiple possible sigils for an operator, this method does not
     * necessarily return the one used in the parsed code.
     *
     * @return string
     */
    public abstract function getOperatorSigil() : string;
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class BitwiseAnd extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '&';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_BitwiseAnd';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class BitwiseOr extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '|';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_BitwiseOr';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class BitwiseXor extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '^';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_BitwiseXor';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class BooleanAnd extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '&&';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_BooleanAnd';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class BooleanOr extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '||';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_BooleanOr';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Coalesce extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '??';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Coalesce';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Concat extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '.';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Concat';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Div extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '/';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Div';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Equal extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '==';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Equal';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Greater extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '>';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Greater';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class GreaterOrEqual extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '>=';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_GreaterOrEqual';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Identical extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '===';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Identical';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class LogicalAnd extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return 'and';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_LogicalAnd';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class LogicalOr extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return 'or';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_LogicalOr';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class LogicalXor extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return 'xor';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_LogicalXor';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Minus extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '-';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Minus';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Mod extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '%';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Mod';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Mul extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '*';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Mul';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class NotEqual extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '!=';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_NotEqual';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class NotIdentical extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '!==';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_NotIdentical';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Plus extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '+';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Plus';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Pow extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '**';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Pow';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class ShiftLeft extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '<<';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_ShiftLeft';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class ShiftRight extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '>>';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_ShiftRight';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Smaller extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '<';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Smaller';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class SmallerOrEqual extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '<=';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_SmallerOrEqual';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\BinaryOp;

use PHPUnit\PhpParser\Node\Expr\BinaryOp;
class Spaceship extends \PHPUnit\PhpParser\Node\Expr\BinaryOp
{
    public function getOperatorSigil() : string
    {
        return '<=>';
    }
    public function getType() : string
    {
        return 'Expr_BinaryOp_Spaceship';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class BitwiseNot extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs a bitwise not node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_BitwiseNot';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class BooleanNot extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs a boolean not node.
     *
     * @param Expr $expr       Expression
     * @param array               $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_BooleanNot';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
abstract class Cast extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs a cast node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\Cast;

use PHPUnit\PhpParser\Node\Expr\Cast;
class Array_ extends \PHPUnit\PhpParser\Node\Expr\Cast
{
    public function getType() : string
    {
        return 'Expr_Cast_Array';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\Cast;

use PHPUnit\PhpParser\Node\Expr\Cast;
class Bool_ extends \PHPUnit\PhpParser\Node\Expr\Cast
{
    public function getType() : string
    {
        return 'Expr_Cast_Bool';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\Cast;

use PHPUnit\PhpParser\Node\Expr\Cast;
class Double extends \PHPUnit\PhpParser\Node\Expr\Cast
{
    // For use in "kind" attribute
    const KIND_DOUBLE = 1;
    // "double" syntax
    const KIND_FLOAT = 2;
    // "float" syntax
    const KIND_REAL = 3;
    // "real" syntax
    public function getType() : string
    {
        return 'Expr_Cast_Double';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\Cast;

use PHPUnit\PhpParser\Node\Expr\Cast;
class Int_ extends \PHPUnit\PhpParser\Node\Expr\Cast
{
    public function getType() : string
    {
        return 'Expr_Cast_Int';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\Cast;

use PHPUnit\PhpParser\Node\Expr\Cast;
class Object_ extends \PHPUnit\PhpParser\Node\Expr\Cast
{
    public function getType() : string
    {
        return 'Expr_Cast_Object';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\Cast;

use PHPUnit\PhpParser\Node\Expr\Cast;
class String_ extends \PHPUnit\PhpParser\Node\Expr\Cast
{
    public function getType() : string
    {
        return 'Expr_Cast_String';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr\Cast;

use PHPUnit\PhpParser\Node\Expr\Cast;
class Unset_ extends \PHPUnit\PhpParser\Node\Expr\Cast
{
    public function getType() : string
    {
        return 'Expr_Cast_Unset';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Name;
class ClassConstFetch extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Name|Expr Class name */
    public $class;
    /** @var Identifier|Error Constant name */
    public $name;
    /**
     * Constructs a class const fetch node.
     *
     * @param Name|Expr               $class      Class name
     * @param string|Identifier|Error $name       Constant name
     * @param array                   $attributes Additional attributes
     */
    public function __construct($class, $name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->class = $class;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
    }
    public function getSubNodeNames() : array
    {
        return ['class', 'name'];
    }
    public function getType() : string
    {
        return 'Expr_ClassConstFetch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Clone_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs a clone node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_Clone';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\FunctionLike;
class Closure extends \PHPUnit\PhpParser\Node\Expr implements \PHPUnit\PhpParser\Node\FunctionLike
{
    /** @var bool Whether the closure is static */
    public $static;
    /** @var bool Whether to return by reference */
    public $byRef;
    /** @var Node\Param[] Parameters */
    public $params;
    /** @var ClosureUse[] use()s */
    public $uses;
    /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType Return type */
    public $returnType;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /** @var Node\AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    /**
     * Constructs a lambda function node.
     *
     * @param array $subNodes   Array of the following optional subnodes:
     *                          'static'     => false  : Whether the closure is static
     *                          'byRef'      => false  : Whether to return by reference
     *                          'params'     => array(): Parameters
     *                          'uses'       => array(): use()s
     *                          'returnType' => null   : Return type
     *                          'stmts'      => array(): Statements
     *                          'attrGroups' => array(): PHP attributes groups
     * @param array $attributes Additional attributes
     */
    public function __construct(array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->static = $subNodes['static'] ?? \false;
        $this->byRef = $subNodes['byRef'] ?? \false;
        $this->params = $subNodes['params'] ?? [];
        $this->uses = $subNodes['uses'] ?? [];
        $returnType = $subNodes['returnType'] ?? null;
        $this->returnType = \is_string($returnType) ? new \PHPUnit\PhpParser\Node\Identifier($returnType) : $returnType;
        $this->stmts = $subNodes['stmts'] ?? [];
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'static', 'byRef', 'params', 'uses', 'returnType', 'stmts'];
    }
    public function returnsByRef() : bool
    {
        return $this->byRef;
    }
    public function getParams() : array
    {
        return $this->params;
    }
    public function getReturnType()
    {
        return $this->returnType;
    }
    /** @return Node\Stmt[] */
    public function getStmts() : array
    {
        return $this->stmts;
    }
    public function getAttrGroups() : array
    {
        return $this->attrGroups;
    }
    public function getType() : string
    {
        return 'Expr_Closure';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class ClosureUse extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr\Variable Variable to use */
    public $var;
    /** @var bool Whether to use by reference */
    public $byRef;
    /**
     * Constructs a closure use node.
     *
     * @param Expr\Variable $var        Variable to use
     * @param bool          $byRef      Whether to use by reference
     * @param array         $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr\Variable $var, bool $byRef = \false, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->byRef = $byRef;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'byRef'];
    }
    public function getType() : string
    {
        return 'Expr_ClosureUse';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Name;
class ConstFetch extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Name Constant name */
    public $name;
    /**
     * Constructs a const fetch node.
     *
     * @param Name  $name       Constant name
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Name $name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = $name;
    }
    public function getSubNodeNames() : array
    {
        return ['name'];
    }
    public function getType() : string
    {
        return 'Expr_ConstFetch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Empty_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs an empty() node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_Empty';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
/**
 * Error node used during parsing with error recovery.
 *
 * An error node may be placed at a position where an expression is required, but an error occurred.
 * Error nodes will not be present if the parser is run in throwOnError mode (the default).
 */
class Error extends \PHPUnit\PhpParser\Node\Expr
{
    /**
     * Constructs an error node.
     *
     * @param array $attributes Additional attributes
     */
    public function __construct(array $attributes = [])
    {
        $this->attributes = $attributes;
    }
    public function getSubNodeNames() : array
    {
        return [];
    }
    public function getType() : string
    {
        return 'Expr_Error';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class ErrorSuppress extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs an error suppress node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_ErrorSuppress';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Eval_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs an eval() node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_Eval';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Exit_ extends \PHPUnit\PhpParser\Node\Expr
{
    /* For use in "kind" attribute */
    const KIND_EXIT = 1;
    const KIND_DIE = 2;
    /** @var null|Expr Expression */
    public $expr;
    /**
     * Constructs an exit() node.
     *
     * @param null|Expr $expr       Expression
     * @param array                    $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_Exit';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
class FuncCall extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Node\Name|Expr Function name */
    public $name;
    /** @var Node\Arg[] Arguments */
    public $args;
    /**
     * Constructs a function call node.
     *
     * @param Node\Name|Expr $name       Function name
     * @param Node\Arg[]     $args       Arguments
     * @param array          $attributes Additional attributes
     */
    public function __construct($name, array $args = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = $name;
        $this->args = $args;
    }
    public function getSubNodeNames() : array
    {
        return ['name', 'args'];
    }
    public function getType() : string
    {
        return 'Expr_FuncCall';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Include_ extends \PHPUnit\PhpParser\Node\Expr
{
    const TYPE_INCLUDE = 1;
    const TYPE_INCLUDE_ONCE = 2;
    const TYPE_REQUIRE = 3;
    const TYPE_REQUIRE_ONCE = 4;
    /** @var Expr Expression */
    public $expr;
    /** @var int Type of include */
    public $type;
    /**
     * Constructs an include node.
     *
     * @param Expr  $expr       Expression
     * @param int   $type       Type of include
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, int $type, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
        $this->type = $type;
    }
    public function getSubNodeNames() : array
    {
        return ['expr', 'type'];
    }
    public function getType() : string
    {
        return 'Expr_Include';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Name;
class Instanceof_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /** @var Name|Expr Class name */
    public $class;
    /**
     * Constructs an instanceof check node.
     *
     * @param Expr      $expr       Expression
     * @param Name|Expr $class      Class name
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, $class, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
        $this->class = $class;
    }
    public function getSubNodeNames() : array
    {
        return ['expr', 'class'];
    }
    public function getType() : string
    {
        return 'Expr_Instanceof';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Isset_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr[] Variables */
    public $vars;
    /**
     * Constructs an array node.
     *
     * @param Expr[] $vars       Variables
     * @param array  $attributes Additional attributes
     */
    public function __construct(array $vars, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->vars = $vars;
    }
    public function getSubNodeNames() : array
    {
        return ['vars'];
    }
    public function getType() : string
    {
        return 'Expr_Isset';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class List_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var (ArrayItem|null)[] List of items to assign to */
    public $items;
    /**
     * Constructs a list() destructuring node.
     *
     * @param (ArrayItem|null)[] $items      List of items to assign to
     * @param array              $attributes Additional attributes
     */
    public function __construct(array $items, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->items = $items;
    }
    public function getSubNodeNames() : array
    {
        return ['items'];
    }
    public function getType() : string
    {
        return 'Expr_List';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\MatchArm;
class Match_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Node\Expr */
    public $cond;
    /** @var MatchArm[] */
    public $arms;
    /**
     * @param MatchArm[] $arms
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $cond, array $arms = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->arms = $arms;
    }
    public function getSubNodeNames() : array
    {
        return ['cond', 'arms'];
    }
    public function getType() : string
    {
        return 'Expr_Match';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Arg;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Identifier;
class MethodCall extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable holding object */
    public $var;
    /** @var Identifier|Expr Method name */
    public $name;
    /** @var Arg[] Arguments */
    public $args;
    /**
     * Constructs a function call node.
     *
     * @param Expr                   $var        Variable holding object
     * @param string|Identifier|Expr $name       Method name
     * @param Arg[]                  $args       Arguments
     * @param array                  $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, $name, array $args = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->args = $args;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'name', 'args'];
    }
    public function getType() : string
    {
        return 'Expr_MethodCall';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
class New_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Node\Name|Expr|Node\Stmt\Class_ Class name */
    public $class;
    /** @var Node\Arg[] Arguments */
    public $args;
    /**
     * Constructs a function call node.
     *
     * @param Node\Name|Expr|Node\Stmt\Class_ $class      Class name (or class node for anonymous classes)
     * @param Node\Arg[]                      $args       Arguments
     * @param array                           $attributes Additional attributes
     */
    public function __construct($class, array $args = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->class = $class;
        $this->args = $args;
    }
    public function getSubNodeNames() : array
    {
        return ['class', 'args'];
    }
    public function getType() : string
    {
        return 'Expr_New';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Arg;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Identifier;
class NullsafeMethodCall extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable holding object */
    public $var;
    /** @var Identifier|Expr Method name */
    public $name;
    /** @var Arg[] Arguments */
    public $args;
    /**
     * Constructs a nullsafe method call node.
     *
     * @param Expr                   $var        Variable holding object
     * @param string|Identifier|Expr $name       Method name
     * @param Arg[]                  $args       Arguments
     * @param array                  $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, $name, array $args = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->args = $args;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'name', 'args'];
    }
    public function getType() : string
    {
        return 'Expr_NullsafeMethodCall';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Identifier;
class NullsafePropertyFetch extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable holding object */
    public $var;
    /** @var Identifier|Expr Property name */
    public $name;
    /**
     * Constructs a nullsafe property fetch node.
     *
     * @param Expr                   $var        Variable holding object
     * @param string|Identifier|Expr $name       Property name
     * @param array                  $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, $name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'name'];
    }
    public function getType() : string
    {
        return 'Expr_NullsafePropertyFetch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class PostDec extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable */
    public $var;
    /**
     * Constructs a post decrement node.
     *
     * @param Expr  $var        Variable
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
    }
    public function getSubNodeNames() : array
    {
        return ['var'];
    }
    public function getType() : string
    {
        return 'Expr_PostDec';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class PostInc extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable */
    public $var;
    /**
     * Constructs a post increment node.
     *
     * @param Expr  $var        Variable
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
    }
    public function getSubNodeNames() : array
    {
        return ['var'];
    }
    public function getType() : string
    {
        return 'Expr_PostInc';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class PreDec extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable */
    public $var;
    /**
     * Constructs a pre decrement node.
     *
     * @param Expr  $var        Variable
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
    }
    public function getSubNodeNames() : array
    {
        return ['var'];
    }
    public function getType() : string
    {
        return 'Expr_PreDec';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class PreInc extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable */
    public $var;
    /**
     * Constructs a pre increment node.
     *
     * @param Expr  $var        Variable
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
    }
    public function getSubNodeNames() : array
    {
        return ['var'];
    }
    public function getType() : string
    {
        return 'Expr_PreInc';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Print_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs an print() node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_Print';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Identifier;
class PropertyFetch extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Variable holding object */
    public $var;
    /** @var Identifier|Expr Property name */
    public $name;
    /**
     * Constructs a function call node.
     *
     * @param Expr                   $var        Variable holding object
     * @param string|Identifier|Expr $name       Property name
     * @param array                  $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $var, $name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'name'];
    }
    public function getType() : string
    {
        return 'Expr_PropertyFetch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class ShellExec extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var array Encapsed string array */
    public $parts;
    /**
     * Constructs a shell exec (backtick) node.
     *
     * @param array $parts      Encapsed string array
     * @param array $attributes Additional attributes
     */
    public function __construct(array $parts, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->parts = $parts;
    }
    public function getSubNodeNames() : array
    {
        return ['parts'];
    }
    public function getType() : string
    {
        return 'Expr_ShellExec';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Identifier;
class StaticCall extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Node\Name|Expr Class name */
    public $class;
    /** @var Identifier|Expr Method name */
    public $name;
    /** @var Node\Arg[] Arguments */
    public $args;
    /**
     * Constructs a static method call node.
     *
     * @param Node\Name|Expr         $class      Class name
     * @param string|Identifier|Expr $name       Method name
     * @param Node\Arg[]             $args       Arguments
     * @param array                  $attributes Additional attributes
     */
    public function __construct($class, $name, array $args = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->class = $class;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->args = $args;
    }
    public function getSubNodeNames() : array
    {
        return ['class', 'name', 'args'];
    }
    public function getType() : string
    {
        return 'Expr_StaticCall';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\VarLikeIdentifier;
class StaticPropertyFetch extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Name|Expr Class name */
    public $class;
    /** @var VarLikeIdentifier|Expr Property name */
    public $name;
    /**
     * Constructs a static property fetch node.
     *
     * @param Name|Expr                     $class      Class name
     * @param string|VarLikeIdentifier|Expr $name       Property name
     * @param array                         $attributes Additional attributes
     */
    public function __construct($class, $name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->class = $class;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\VarLikeIdentifier($name) : $name;
    }
    public function getSubNodeNames() : array
    {
        return ['class', 'name'];
    }
    public function getType() : string
    {
        return 'Expr_StaticPropertyFetch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Ternary extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Condition */
    public $cond;
    /** @var null|Expr Expression for true */
    public $if;
    /** @var Expr Expression for false */
    public $else;
    /**
     * Constructs a ternary operator node.
     *
     * @param Expr      $cond       Condition
     * @param null|Expr $if         Expression for true
     * @param Expr      $else       Expression for false
     * @param array                    $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $cond, $if, \PHPUnit\PhpParser\Node\Expr $else, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->if = $if;
        $this->else = $else;
    }
    public function getSubNodeNames() : array
    {
        return ['cond', 'if', 'else'];
    }
    public function getType() : string
    {
        return 'Expr_Ternary';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node;
class Throw_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Node\Expr Expression */
    public $expr;
    /**
     * Constructs a throw expression node.
     *
     * @param Node\Expr $expr       Expression
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_Throw';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class UnaryMinus extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs a unary minus node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_UnaryMinus';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class UnaryPlus extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression */
    public $expr;
    /**
     * Constructs a unary plus node.
     *
     * @param Expr $expr       Expression
     * @param array               $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_UnaryPlus';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Variable extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var string|Expr Name */
    public $name;
    /**
     * Constructs a variable node.
     *
     * @param string|Expr $name       Name
     * @param array       $attributes Additional attributes
     */
    public function __construct($name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = $name;
    }
    public function getSubNodeNames() : array
    {
        return ['name'];
    }
    public function getType() : string
    {
        return 'Expr_Variable';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class YieldFrom extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var Expr Expression to yield from */
    public $expr;
    /**
     * Constructs an "yield from" node.
     *
     * @param Expr  $expr       Expression
     * @param array $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Expr_YieldFrom';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Expr;

use PHPUnit\PhpParser\Node\Expr;
class Yield_ extends \PHPUnit\PhpParser\Node\Expr
{
    /** @var null|Expr Key expression */
    public $key;
    /** @var null|Expr Value expression */
    public $value;
    /**
     * Constructs a yield expression node.
     *
     * @param null|Expr $value      Value expression
     * @param null|Expr $key        Key expression
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $value = null, \PHPUnit\PhpParser\Node\Expr $key = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->key = $key;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['key', 'value'];
    }
    public function getType() : string
    {
        return 'Expr_Yield';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\Node;
interface FunctionLike extends \PHPUnit\PhpParser\Node
{
    /**
     * Whether to return by reference
     *
     * @return bool
     */
    public function returnsByRef() : bool;
    /**
     * List of parameters
     *
     * @return Param[]
     */
    public function getParams() : array;
    /**
     * Get the declared return type or null
     *
     * @return null|Identifier|Name|NullableType|UnionType
     */
    public function getReturnType();
    /**
     * The function body
     *
     * @return Stmt[]|null
     */
    public function getStmts();
    /**
     * Get PHP attribute groups.
     *
     * @return AttributeGroup[]
     */
    public function getAttrGroups() : array;
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
/**
 * Represents a non-namespaced name. Namespaced names are represented using Name nodes.
 */
class Identifier extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var string Identifier as string */
    public $name;
    private static $specialClassNames = ['self' => \true, 'parent' => \true, 'static' => \true];
    /**
     * Constructs an identifier node.
     *
     * @param string $name       Identifier as string
     * @param array  $attributes Additional attributes
     */
    public function __construct(string $name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = $name;
    }
    public function getSubNodeNames() : array
    {
        return ['name'];
    }
    /**
     * Get identifier as string.
     *
     * @return string Identifier as string.
     */
    public function toString() : string
    {
        return $this->name;
    }
    /**
     * Get lowercased identifier as string.
     *
     * @return string Lowercased identifier as string
     */
    public function toLowerString() : string
    {
        return \strtolower($this->name);
    }
    /**
     * Checks whether the identifier is a special class name (self, parent or static).
     *
     * @return bool Whether identifier is a special class name
     */
    public function isSpecialClassName() : bool
    {
        return isset(self::$specialClassNames[\strtolower($this->name)]);
    }
    /**
     * Get identifier as string.
     *
     * @return string Identifier as string
     */
    public function __toString() : string
    {
        return $this->name;
    }
    public function getType() : string
    {
        return 'Identifier';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeAbstract;
class MatchArm extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var null|Node\Expr[] */
    public $conds;
    /** @var Node\Expr */
    public $body;
    /**
     * @param null|Node\Expr[] $conds
     */
    public function __construct($conds, \PHPUnit\PhpParser\Node\Expr $body, array $attributes = [])
    {
        $this->conds = $conds;
        $this->body = $body;
        $this->attributes = $attributes;
    }
    public function getSubNodeNames() : array
    {
        return ['conds', 'body'];
    }
    public function getType() : string
    {
        return 'MatchArm';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
class Name extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var string[] Parts of the name */
    public $parts;
    private static $specialClassNames = ['self' => \true, 'parent' => \true, 'static' => \true];
    /**
     * Constructs a name node.
     *
     * @param string|string[]|self $name       Name as string, part array or Name instance (copy ctor)
     * @param array                $attributes Additional attributes
     */
    public function __construct($name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->parts = self::prepareName($name);
    }
    public function getSubNodeNames() : array
    {
        return ['parts'];
    }
    /**
     * Gets the first part of the name, i.e. everything before the first namespace separator.
     *
     * @return string First part of the name
     */
    public function getFirst() : string
    {
        return $this->parts[0];
    }
    /**
     * Gets the last part of the name, i.e. everything after the last namespace separator.
     *
     * @return string Last part of the name
     */
    public function getLast() : string
    {
        return $this->parts[\count($this->parts) - 1];
    }
    /**
     * Checks whether the name is unqualified. (E.g. Name)
     *
     * @return bool Whether the name is unqualified
     */
    public function isUnqualified() : bool
    {
        return 1 === \count($this->parts);
    }
    /**
     * Checks whether the name is qualified. (E.g. Name\Name)
     *
     * @return bool Whether the name is qualified
     */
    public function isQualified() : bool
    {
        return 1 < \count($this->parts);
    }
    /**
     * Checks whether the name is fully qualified. (E.g. \Name)
     *
     * @return bool Whether the name is fully qualified
     */
    public function isFullyQualified() : bool
    {
        return \false;
    }
    /**
     * Checks whether the name is explicitly relative to the current namespace. (E.g. namespace\Name)
     *
     * @return bool Whether the name is relative
     */
    public function isRelative() : bool
    {
        return \false;
    }
    /**
     * Returns a string representation of the name itself, without taking the name type into
     * account (e.g., not including a leading backslash for fully qualified names).
     *
     * @return string String representation
     */
    public function toString() : string
    {
        return \implode('\\', $this->parts);
    }
    /**
     * Returns a string representation of the name as it would occur in code (e.g., including
     * leading backslash for fully qualified names.
     *
     * @return string String representation
     */
    public function toCodeString() : string
    {
        return $this->toString();
    }
    /**
     * Returns lowercased string representation of the name, without taking the name type into
     * account (e.g., no leading backslash for fully qualified names).
     *
     * @return string Lowercased string representation
     */
    public function toLowerString() : string
    {
        return \strtolower(\implode('\\', $this->parts));
    }
    /**
     * Checks whether the identifier is a special class name (self, parent or static).
     *
     * @return bool Whether identifier is a special class name
     */
    public function isSpecialClassName() : bool
    {
        return \count($this->parts) === 1 && isset(self::$specialClassNames[\strtolower($this->parts[0])]);
    }
    /**
     * Returns a string representation of the name by imploding the namespace parts with the
     * namespace separator.
     *
     * @return string String representation
     */
    public function __toString() : string
    {
        return \implode('\\', $this->parts);
    }
    /**
     * Gets a slice of a name (similar to array_slice).
     *
     * This method returns a new instance of the same type as the original and with the same
     * attributes.
     *
     * If the slice is empty, null is returned. The null value will be correctly handled in
     * concatenations using concat().
     *
     * Offset and length have the same meaning as in array_slice().
     *
     * @param int      $offset Offset to start the slice at (may be negative)
     * @param int|null $length Length of the slice (may be negative)
     *
     * @return static|null Sliced name
     */
    public function slice(int $offset, int $length = null)
    {
        $numParts = \count($this->parts);
        $realOffset = $offset < 0 ? $offset + $numParts : $offset;
        if ($realOffset < 0 || $realOffset > $numParts) {
            throw new \OutOfBoundsException(\sprintf('Offset %d is out of bounds', $offset));
        }
        if (null === $length) {
            $realLength = $numParts - $realOffset;
        } else {
            $realLength = $length < 0 ? $length + $numParts - $realOffset : $length;
            if ($realLength < 0 || $realLength > $numParts) {
                throw new \OutOfBoundsException(\sprintf('Length %d is out of bounds', $length));
            }
        }
        if ($realLength === 0) {
            // Empty slice is represented as null
            return null;
        }
        return new static(\array_slice($this->parts, $realOffset, $realLength), $this->attributes);
    }
    /**
     * Concatenate two names, yielding a new Name instance.
     *
     * The type of the generated instance depends on which class this method is called on, for
     * example Name\FullyQualified::concat() will yield a Name\FullyQualified instance.
     *
     * If one of the arguments is null, a new instance of the other name will be returned. If both
     * arguments are null, null will be returned. As such, writing
     *     Name::concat($namespace, $shortName)
     * where $namespace is a Name node or null will work as expected.
     *
     * @param string|string[]|self|null $name1      The first name
     * @param string|string[]|self|null $name2      The second name
     * @param array                     $attributes Attributes to assign to concatenated name
     *
     * @return static|null Concatenated name
     */
    public static function concat($name1, $name2, array $attributes = [])
    {
        if (null === $name1 && null === $name2) {
            return null;
        } elseif (null === $name1) {
            return new static(self::prepareName($name2), $attributes);
        } elseif (null === $name2) {
            return new static(self::prepareName($name1), $attributes);
        } else {
            return new static(\array_merge(self::prepareName($name1), self::prepareName($name2)), $attributes);
        }
    }
    /**
     * Prepares a (string, array or Name node) name for use in name changing methods by converting
     * it to an array.
     *
     * @param string|string[]|self $name Name to prepare
     *
     * @return string[] Prepared name
     */
    private static function prepareName($name) : array
    {
        if (\is_string($name)) {
            if ('' === $name) {
                throw new \InvalidArgumentException('Name cannot be empty');
            }
            return \explode('\\', $name);
        } elseif (\is_array($name)) {
            if (empty($name)) {
                throw new \InvalidArgumentException('Name cannot be empty');
            }
            return $name;
        } elseif ($name instanceof self) {
            return $name->parts;
        }
        throw new \InvalidArgumentException('Expected string, array of parts or Name instance');
    }
    public function getType() : string
    {
        return 'Name';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Name;

class FullyQualified extends \PHPUnit\PhpParser\Node\Name
{
    /**
     * Checks whether the name is unqualified. (E.g. Name)
     *
     * @return bool Whether the name is unqualified
     */
    public function isUnqualified() : bool
    {
        return \false;
    }
    /**
     * Checks whether the name is qualified. (E.g. Name\Name)
     *
     * @return bool Whether the name is qualified
     */
    public function isQualified() : bool
    {
        return \false;
    }
    /**
     * Checks whether the name is fully qualified. (E.g. \Name)
     *
     * @return bool Whether the name is fully qualified
     */
    public function isFullyQualified() : bool
    {
        return \true;
    }
    /**
     * Checks whether the name is explicitly relative to the current namespace. (E.g. namespace\Name)
     *
     * @return bool Whether the name is relative
     */
    public function isRelative() : bool
    {
        return \false;
    }
    public function toCodeString() : string
    {
        return '\\' . $this->toString();
    }
    public function getType() : string
    {
        return 'Name_FullyQualified';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Name;

class Relative extends \PHPUnit\PhpParser\Node\Name
{
    /**
     * Checks whether the name is unqualified. (E.g. Name)
     *
     * @return bool Whether the name is unqualified
     */
    public function isUnqualified() : bool
    {
        return \false;
    }
    /**
     * Checks whether the name is qualified. (E.g. Name\Name)
     *
     * @return bool Whether the name is qualified
     */
    public function isQualified() : bool
    {
        return \false;
    }
    /**
     * Checks whether the name is fully qualified. (E.g. \Name)
     *
     * @return bool Whether the name is fully qualified
     */
    public function isFullyQualified() : bool
    {
        return \false;
    }
    /**
     * Checks whether the name is explicitly relative to the current namespace. (E.g. namespace\Name)
     *
     * @return bool Whether the name is relative
     */
    public function isRelative() : bool
    {
        return \true;
    }
    public function toCodeString() : string
    {
        return 'namespace\\' . $this->toString();
    }
    public function getType() : string
    {
        return 'Name_Relative';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
class NullableType extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var Identifier|Name Type */
    public $type;
    /**
     * Constructs a nullable type (wrapping another type).
     *
     * @param string|Identifier|Name $type       Type
     * @param array                  $attributes Additional attributes
     */
    public function __construct($type, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->type = \is_string($type) ? new \PHPUnit\PhpParser\Node\Identifier($type) : $type;
    }
    public function getSubNodeNames() : array
    {
        return ['type'];
    }
    public function getType() : string
    {
        return 'NullableType';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
class Param extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var null|Identifier|Name|NullableType|UnionType Type declaration */
    public $type;
    /** @var bool Whether parameter is passed by reference */
    public $byRef;
    /** @var bool Whether this is a variadic argument */
    public $variadic;
    /** @var Expr\Variable|Expr\Error Parameter variable */
    public $var;
    /** @var null|Expr Default value */
    public $default;
    /** @var int */
    public $flags;
    /** @var AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    /**
     * Constructs a parameter node.
     *
     * @param Expr\Variable|Expr\Error                           $var        Parameter variable
     * @param null|Expr                                          $default    Default value
     * @param null|string|Identifier|Name|NullableType|UnionType $type       Type declaration
     * @param bool                                               $byRef      Whether is passed by reference
     * @param bool                                               $variadic   Whether this is a variadic argument
     * @param array                                              $attributes Additional attributes
     * @param int                                                $flags      Optional visibility flags
     * @param AttributeGroup[]                                   $attrGroups PHP attribute groups
     */
    public function __construct($var, \PHPUnit\PhpParser\Node\Expr $default = null, $type = null, bool $byRef = \false, bool $variadic = \false, array $attributes = [], int $flags = 0, array $attrGroups = [])
    {
        $this->attributes = $attributes;
        $this->type = \is_string($type) ? new \PHPUnit\PhpParser\Node\Identifier($type) : $type;
        $this->byRef = $byRef;
        $this->variadic = $variadic;
        $this->var = $var;
        $this->default = $default;
        $this->flags = $flags;
        $this->attrGroups = $attrGroups;
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'flags', 'type', 'byRef', 'variadic', 'var', 'default'];
    }
    public function getType() : string
    {
        return 'Param';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

abstract class Scalar extends \PHPUnit\PhpParser\Node\Expr
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar;

use PHPUnit\PhpParser\Node\Scalar;
class DNumber extends \PHPUnit\PhpParser\Node\Scalar
{
    /** @var float Number value */
    public $value;
    /**
     * Constructs a float number scalar node.
     *
     * @param float $value      Value of the number
     * @param array $attributes Additional attributes
     */
    public function __construct(float $value, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['value'];
    }
    /**
     * @internal
     *
     * Parses a DNUMBER token like PHP would.
     *
     * @param string $str A string number
     *
     * @return float The parsed number
     */
    public static function parse(string $str) : float
    {
        $str = \str_replace('_', '', $str);
        // if string contains any of .eE just cast it to float
        if (\false !== \strpbrk($str, '.eE')) {
            return (float) $str;
        }
        // otherwise it's an integer notation that overflowed into a float
        // if it starts with 0 it's one of the special integer notations
        if ('0' === $str[0]) {
            // hex
            if ('x' === $str[1] || 'X' === $str[1]) {
                return \hexdec($str);
            }
            // bin
            if ('b' === $str[1] || 'B' === $str[1]) {
                return \bindec($str);
            }
            // oct
            // substr($str, 0, strcspn($str, '89')) cuts the string at the first invalid digit (8 or 9)
            // so that only the digits before that are used
            return \octdec(\substr($str, 0, \strcspn($str, '89')));
        }
        // dec
        return (float) $str;
    }
    public function getType() : string
    {
        return 'Scalar_DNumber';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar;

use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Scalar;
class Encapsed extends \PHPUnit\PhpParser\Node\Scalar
{
    /** @var Expr[] list of string parts */
    public $parts;
    /**
     * Constructs an encapsed string node.
     *
     * @param Expr[] $parts      Encaps list
     * @param array  $attributes Additional attributes
     */
    public function __construct(array $parts, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->parts = $parts;
    }
    public function getSubNodeNames() : array
    {
        return ['parts'];
    }
    public function getType() : string
    {
        return 'Scalar_Encapsed';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar;

use PHPUnit\PhpParser\Node\Scalar;
class EncapsedStringPart extends \PHPUnit\PhpParser\Node\Scalar
{
    /** @var string String value */
    public $value;
    /**
     * Constructs a node representing a string part of an encapsed string.
     *
     * @param string $value      String value
     * @param array  $attributes Additional attributes
     */
    public function __construct(string $value, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['value'];
    }
    public function getType() : string
    {
        return 'Scalar_EncapsedStringPart';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Node\Scalar;
class LNumber extends \PHPUnit\PhpParser\Node\Scalar
{
    /* For use in "kind" attribute */
    const KIND_BIN = 2;
    const KIND_OCT = 8;
    const KIND_DEC = 10;
    const KIND_HEX = 16;
    /** @var int Number value */
    public $value;
    /**
     * Constructs an integer number scalar node.
     *
     * @param int   $value      Value of the number
     * @param array $attributes Additional attributes
     */
    public function __construct(int $value, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['value'];
    }
    /**
     * Constructs an LNumber node from a string number literal.
     *
     * @param string $str               String number literal (decimal, octal, hex or binary)
     * @param array  $attributes        Additional attributes
     * @param bool   $allowInvalidOctal Whether to allow invalid octal numbers (PHP 5)
     *
     * @return LNumber The constructed LNumber, including kind attribute
     */
    public static function fromString(string $str, array $attributes = [], bool $allowInvalidOctal = \false) : \PHPUnit\PhpParser\Node\Scalar\LNumber
    {
        $str = \str_replace('_', '', $str);
        if ('0' !== $str[0] || '0' === $str) {
            $attributes['kind'] = \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_DEC;
            return new \PHPUnit\PhpParser\Node\Scalar\LNumber((int) $str, $attributes);
        }
        if ('x' === $str[1] || 'X' === $str[1]) {
            $attributes['kind'] = \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_HEX;
            return new \PHPUnit\PhpParser\Node\Scalar\LNumber(\hexdec($str), $attributes);
        }
        if ('b' === $str[1] || 'B' === $str[1]) {
            $attributes['kind'] = \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_BIN;
            return new \PHPUnit\PhpParser\Node\Scalar\LNumber(\bindec($str), $attributes);
        }
        if (!$allowInvalidOctal && \strpbrk($str, '89')) {
            throw new \PHPUnit\PhpParser\Error('Invalid numeric literal', $attributes);
        }
        // use intval instead of octdec to get proper cutting behavior with malformed numbers
        $attributes['kind'] = \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_OCT;
        return new \PHPUnit\PhpParser\Node\Scalar\LNumber(\intval($str, 8), $attributes);
    }
    public function getType() : string
    {
        return 'Scalar_LNumber';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar;

use PHPUnit\PhpParser\Node\Scalar;
abstract class MagicConst extends \PHPUnit\PhpParser\Node\Scalar
{
    /**
     * Constructs a magic constant node.
     *
     * @param array $attributes Additional attributes
     */
    public function __construct(array $attributes = [])
    {
        $this->attributes = $attributes;
    }
    public function getSubNodeNames() : array
    {
        return [];
    }
    /**
     * Get name of magic constant.
     *
     * @return string Name of magic constant
     */
    public abstract function getName() : string;
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class Class_ extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__CLASS__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_Class';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class Dir extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__DIR__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_Dir';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class File extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__FILE__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_File';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class Function_ extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__FUNCTION__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_Function';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class Line extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__LINE__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_Line';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class Method extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__METHOD__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_Method';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class Namespace_ extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__NAMESPACE__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_Namespace';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar\MagicConst;

use PHPUnit\PhpParser\Node\Scalar\MagicConst;
class Trait_ extends \PHPUnit\PhpParser\Node\Scalar\MagicConst
{
    public function getName() : string
    {
        return '__TRAIT__';
    }
    public function getType() : string
    {
        return 'Scalar_MagicConst_Trait';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Scalar;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Node\Scalar;
class String_ extends \PHPUnit\PhpParser\Node\Scalar
{
    /* For use in "kind" attribute */
    const KIND_SINGLE_QUOTED = 1;
    const KIND_DOUBLE_QUOTED = 2;
    const KIND_HEREDOC = 3;
    const KIND_NOWDOC = 4;
    /** @var string String value */
    public $value;
    protected static $replacements = ['\\' => '\\', '$' => '$', 'n' => "\n", 'r' => "\r", 't' => "\t", 'f' => "\f", 'v' => "\v", 'e' => "\33"];
    /**
     * Constructs a string scalar node.
     *
     * @param string $value      Value of the string
     * @param array  $attributes Additional attributes
     */
    public function __construct(string $value, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['value'];
    }
    /**
     * @internal
     *
     * Parses a string token.
     *
     * @param string $str String token content
     * @param bool $parseUnicodeEscape Whether to parse PHP 7 \u escapes
     *
     * @return string The parsed string
     */
    public static function parse(string $str, bool $parseUnicodeEscape = \true) : string
    {
        $bLength = 0;
        if ('b' === $str[0] || 'B' === $str[0]) {
            $bLength = 1;
        }
        if ('\'' === $str[$bLength]) {
            return \str_replace(['\\\\', '\\\''], ['\\', '\''], \substr($str, $bLength + 1, -1));
        } else {
            return self::parseEscapeSequences(\substr($str, $bLength + 1, -1), '"', $parseUnicodeEscape);
        }
    }
    /**
     * @internal
     *
     * Parses escape sequences in strings (all string types apart from single quoted).
     *
     * @param string      $str   String without quotes
     * @param null|string $quote Quote type
     * @param bool $parseUnicodeEscape Whether to parse PHP 7 \u escapes
     *
     * @return string String with escape sequences parsed
     */
    public static function parseEscapeSequences(string $str, $quote, bool $parseUnicodeEscape = \true) : string
    {
        if (null !== $quote) {
            $str = \str_replace('\\' . $quote, $quote, $str);
        }
        $extra = '';
        if ($parseUnicodeEscape) {
            $extra = '|u\\{([0-9a-fA-F]+)\\}';
        }
        return \preg_replace_callback('~\\\\([\\\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}' . $extra . ')~', function ($matches) {
            $str = $matches[1];
            if (isset(self::$replacements[$str])) {
                return self::$replacements[$str];
            } elseif ('x' === $str[0] || 'X' === $str[0]) {
                return \chr(\hexdec(\substr($str, 1)));
            } elseif ('u' === $str[0]) {
                return self::codePointToUtf8(\hexdec($matches[2]));
            } else {
                return \chr(\octdec($str));
            }
        }, $str);
    }
    /**
     * Converts a Unicode code point to its UTF-8 encoded representation.
     *
     * @param int $num Code point
     *
     * @return string UTF-8 representation of code point
     */
    private static function codePointToUtf8(int $num) : string
    {
        if ($num <= 0x7f) {
            return \chr($num);
        }
        if ($num <= 0x7ff) {
            return \chr(($num >> 6) + 0xc0) . \chr(($num & 0x3f) + 0x80);
        }
        if ($num <= 0xffff) {
            return \chr(($num >> 12) + 0xe0) . \chr(($num >> 6 & 0x3f) + 0x80) . \chr(($num & 0x3f) + 0x80);
        }
        if ($num <= 0x1fffff) {
            return \chr(($num >> 18) + 0xf0) . \chr(($num >> 12 & 0x3f) + 0x80) . \chr(($num >> 6 & 0x3f) + 0x80) . \chr(($num & 0x3f) + 0x80);
        }
        throw new \PHPUnit\PhpParser\Error('Invalid UTF-8 codepoint escape sequence: Codepoint too large');
    }
    public function getType() : string
    {
        return 'Scalar_String';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
abstract class Stmt extends \PHPUnit\PhpParser\NodeAbstract
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Break_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var null|Node\Expr Number of loops to break */
    public $num;
    /**
     * Constructs a break node.
     *
     * @param null|Node\Expr $num        Number of loops to break
     * @param array          $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $num = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->num = $num;
    }
    public function getSubNodeNames() : array
    {
        return ['num'];
    }
    public function getType() : string
    {
        return 'Stmt_Break';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Case_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var null|Node\Expr Condition (null for default) */
    public $cond;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs a case node.
     *
     * @param null|Node\Expr $cond       Condition (null for default)
     * @param Node\Stmt[]    $stmts      Statements
     * @param array          $attributes Additional attributes
     */
    public function __construct($cond, array $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['cond', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Case';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
class Catch_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Name[] Types of exceptions to catch */
    public $types;
    /** @var Expr\Variable|null Variable for exception */
    public $var;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs a catch node.
     *
     * @param Node\Name[]           $types      Types of exceptions to catch
     * @param Expr\Variable|null    $var        Variable for exception
     * @param Node\Stmt[]           $stmts      Statements
     * @param array                 $attributes Additional attributes
     */
    public function __construct(array $types, \PHPUnit\PhpParser\Node\Expr\Variable $var = null, array $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->types = $types;
        $this->var = $var;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['types', 'var', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Catch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class ClassConst extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var int Modifiers */
    public $flags;
    /** @var Node\Const_[] Constant declarations */
    public $consts;
    /** @var Node\AttributeGroup[] */
    public $attrGroups;
    /**
     * Constructs a class const list node.
     *
     * @param Node\Const_[]         $consts     Constant declarations
     * @param int                   $flags      Modifiers
     * @param array                 $attributes Additional attributes
     * @param Node\AttributeGroup[] $attrGroups PHP attribute groups
     */
    public function __construct(array $consts, int $flags = 0, array $attributes = [], array $attrGroups = [])
    {
        $this->attributes = $attributes;
        $this->flags = $flags;
        $this->consts = $consts;
        $this->attrGroups = $attrGroups;
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'flags', 'consts'];
    }
    /**
     * Whether constant is explicitly or implicitly public.
     *
     * @return bool
     */
    public function isPublic() : bool
    {
        return ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC) !== 0 || ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::VISIBILITY_MODIFIER_MASK) === 0;
    }
    /**
     * Whether constant is protected.
     *
     * @return bool
     */
    public function isProtected() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED);
    }
    /**
     * Whether constant is private.
     *
     * @return bool
     */
    public function isPrivate() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE);
    }
    public function getType() : string
    {
        return 'Stmt_ClassConst';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
/**
 * @property Node\Name $namespacedName Namespaced name (if using NameResolver)
 */
abstract class ClassLike extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Identifier|null Name */
    public $name;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /** @var Node\AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    /**
     * @return TraitUse[]
     */
    public function getTraitUses() : array
    {
        $traitUses = [];
        foreach ($this->stmts as $stmt) {
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\TraitUse) {
                $traitUses[] = $stmt;
            }
        }
        return $traitUses;
    }
    /**
     * @return ClassConst[]
     */
    public function getConstants() : array
    {
        $constants = [];
        foreach ($this->stmts as $stmt) {
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\ClassConst) {
                $constants[] = $stmt;
            }
        }
        return $constants;
    }
    /**
     * @return Property[]
     */
    public function getProperties() : array
    {
        $properties = [];
        foreach ($this->stmts as $stmt) {
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Property) {
                $properties[] = $stmt;
            }
        }
        return $properties;
    }
    /**
     * Gets property with the given name defined directly in this class/interface/trait.
     *
     * @param string $name Name of the property
     *
     * @return Property|null Property node or null if the property does not exist
     */
    public function getProperty(string $name)
    {
        foreach ($this->stmts as $stmt) {
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Property) {
                foreach ($stmt->props as $prop) {
                    if ($prop instanceof \PHPUnit\PhpParser\Node\Stmt\PropertyProperty && $name === $prop->name->toString()) {
                        return $stmt;
                    }
                }
            }
        }
        return null;
    }
    /**
     * Gets all methods defined directly in this class/interface/trait
     *
     * @return ClassMethod[]
     */
    public function getMethods() : array
    {
        $methods = [];
        foreach ($this->stmts as $stmt) {
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod) {
                $methods[] = $stmt;
            }
        }
        return $methods;
    }
    /**
     * Gets method with the given name defined directly in this class/interface/trait.
     *
     * @param string $name Name of the method (compared case-insensitively)
     *
     * @return ClassMethod|null Method node or null if the method does not exist
     */
    public function getMethod(string $name)
    {
        $lowerName = \strtolower($name);
        foreach ($this->stmts as $stmt) {
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod && $lowerName === $stmt->name->toLowerString()) {
                return $stmt;
            }
        }
        return null;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\FunctionLike;
class ClassMethod extends \PHPUnit\PhpParser\Node\Stmt implements \PHPUnit\PhpParser\Node\FunctionLike
{
    /** @var int Flags */
    public $flags;
    /** @var bool Whether to return by reference */
    public $byRef;
    /** @var Node\Identifier Name */
    public $name;
    /** @var Node\Param[] Parameters */
    public $params;
    /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType Return type */
    public $returnType;
    /** @var Node\Stmt[]|null Statements */
    public $stmts;
    /** @var Node\AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    private static $magicNames = ['__construct' => \true, '__destruct' => \true, '__call' => \true, '__callstatic' => \true, '__get' => \true, '__set' => \true, '__isset' => \true, '__unset' => \true, '__sleep' => \true, '__wakeup' => \true, '__tostring' => \true, '__set_state' => \true, '__clone' => \true, '__invoke' => \true, '__debuginfo' => \true];
    /**
     * Constructs a class method node.
     *
     * @param string|Node\Identifier $name Name
     * @param array $subNodes   Array of the following optional subnodes:
     *                          'flags       => MODIFIER_PUBLIC: Flags
     *                          'byRef'      => false          : Whether to return by reference
     *                          'params'     => array()        : Parameters
     *                          'returnType' => null           : Return type
     *                          'stmts'      => array()        : Statements
     *                          'attrGroups' => array()        : PHP attribute groups
     * @param array $attributes Additional attributes
     */
    public function __construct($name, array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->flags = $subNodes['flags'] ?? $subNodes['type'] ?? 0;
        $this->byRef = $subNodes['byRef'] ?? \false;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->params = $subNodes['params'] ?? [];
        $returnType = $subNodes['returnType'] ?? null;
        $this->returnType = \is_string($returnType) ? new \PHPUnit\PhpParser\Node\Identifier($returnType) : $returnType;
        $this->stmts = \array_key_exists('stmts', $subNodes) ? $subNodes['stmts'] : [];
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'flags', 'byRef', 'name', 'params', 'returnType', 'stmts'];
    }
    public function returnsByRef() : bool
    {
        return $this->byRef;
    }
    public function getParams() : array
    {
        return $this->params;
    }
    public function getReturnType()
    {
        return $this->returnType;
    }
    public function getStmts()
    {
        return $this->stmts;
    }
    public function getAttrGroups() : array
    {
        return $this->attrGroups;
    }
    /**
     * Whether the method is explicitly or implicitly public.
     *
     * @return bool
     */
    public function isPublic() : bool
    {
        return ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC) !== 0 || ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::VISIBILITY_MODIFIER_MASK) === 0;
    }
    /**
     * Whether the method is protected.
     *
     * @return bool
     */
    public function isProtected() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED);
    }
    /**
     * Whether the method is private.
     *
     * @return bool
     */
    public function isPrivate() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE);
    }
    /**
     * Whether the method is abstract.
     *
     * @return bool
     */
    public function isAbstract() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT);
    }
    /**
     * Whether the method is final.
     *
     * @return bool
     */
    public function isFinal() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL);
    }
    /**
     * Whether the method is static.
     *
     * @return bool
     */
    public function isStatic() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC);
    }
    /**
     * Whether the method is magic.
     *
     * @return bool
     */
    public function isMagic() : bool
    {
        return isset(self::$magicNames[$this->name->toLowerString()]);
    }
    public function getType() : string
    {
        return 'Stmt_ClassMethod';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Node;
class Class_ extends \PHPUnit\PhpParser\Node\Stmt\ClassLike
{
    const MODIFIER_PUBLIC = 1;
    const MODIFIER_PROTECTED = 2;
    const MODIFIER_PRIVATE = 4;
    const MODIFIER_STATIC = 8;
    const MODIFIER_ABSTRACT = 16;
    const MODIFIER_FINAL = 32;
    const VISIBILITY_MODIFIER_MASK = 7;
    // 1 | 2 | 4
    /** @var int Type */
    public $flags;
    /** @var null|Node\Name Name of extended class */
    public $extends;
    /** @var Node\Name[] Names of implemented interfaces */
    public $implements;
    /**
     * Constructs a class node.
     *
     * @param string|Node\Identifier|null $name Name
     * @param array       $subNodes   Array of the following optional subnodes:
     *                                'flags'       => 0      : Flags
     *                                'extends'     => null   : Name of extended class
     *                                'implements'  => array(): Names of implemented interfaces
     *                                'stmts'       => array(): Statements
     *                                'attrGroups'  => array(): PHP attribute groups
     * @param array       $attributes Additional attributes
     */
    public function __construct($name, array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->flags = $subNodes['flags'] ?? $subNodes['type'] ?? 0;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->extends = $subNodes['extends'] ?? null;
        $this->implements = $subNodes['implements'] ?? [];
        $this->stmts = $subNodes['stmts'] ?? [];
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'flags', 'name', 'extends', 'implements', 'stmts'];
    }
    /**
     * Whether the class is explicitly abstract.
     *
     * @return bool
     */
    public function isAbstract() : bool
    {
        return (bool) ($this->flags & self::MODIFIER_ABSTRACT);
    }
    /**
     * Whether the class is final.
     *
     * @return bool
     */
    public function isFinal() : bool
    {
        return (bool) ($this->flags & self::MODIFIER_FINAL);
    }
    /**
     * Whether the class is anonymous.
     *
     * @return bool
     */
    public function isAnonymous() : bool
    {
        return null === $this->name;
    }
    /**
     * @internal
     */
    public static function verifyModifier($a, $b)
    {
        if ($a & self::VISIBILITY_MODIFIER_MASK && $b & self::VISIBILITY_MODIFIER_MASK) {
            throw new \PHPUnit\PhpParser\Error('Multiple access type modifiers are not allowed');
        }
        if ($a & self::MODIFIER_ABSTRACT && $b & self::MODIFIER_ABSTRACT) {
            throw new \PHPUnit\PhpParser\Error('Multiple abstract modifiers are not allowed');
        }
        if ($a & self::MODIFIER_STATIC && $b & self::MODIFIER_STATIC) {
            throw new \PHPUnit\PhpParser\Error('Multiple static modifiers are not allowed');
        }
        if ($a & self::MODIFIER_FINAL && $b & self::MODIFIER_FINAL) {
            throw new \PHPUnit\PhpParser\Error('Multiple final modifiers are not allowed');
        }
        if ($a & 48 && $b & 48) {
            throw new \PHPUnit\PhpParser\Error('Cannot use the final modifier on an abstract class member');
        }
    }
    public function getType() : string
    {
        return 'Stmt_Class';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Const_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Const_[] Constant declarations */
    public $consts;
    /**
     * Constructs a const list node.
     *
     * @param Node\Const_[] $consts     Constant declarations
     * @param array         $attributes Additional attributes
     */
    public function __construct(array $consts, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->consts = $consts;
    }
    public function getSubNodeNames() : array
    {
        return ['consts'];
    }
    public function getType() : string
    {
        return 'Stmt_Const';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Continue_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var null|Node\Expr Number of loops to continue */
    public $num;
    /**
     * Constructs a continue node.
     *
     * @param null|Node\Expr $num        Number of loops to continue
     * @param array          $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $num = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->num = $num;
    }
    public function getSubNodeNames() : array
    {
        return ['num'];
    }
    public function getType() : string
    {
        return 'Stmt_Continue';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class DeclareDeclare extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Identifier Key */
    public $key;
    /** @var Node\Expr Value */
    public $value;
    /**
     * Constructs a declare key=>value pair node.
     *
     * @param string|Node\Identifier $key        Key
     * @param Node\Expr              $value      Value
     * @param array                  $attributes Additional attributes
     */
    public function __construct($key, \PHPUnit\PhpParser\Node\Expr $value, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->key = \is_string($key) ? new \PHPUnit\PhpParser\Node\Identifier($key) : $key;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['key', 'value'];
    }
    public function getType() : string
    {
        return 'Stmt_DeclareDeclare';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Declare_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var DeclareDeclare[] List of declares */
    public $declares;
    /** @var Node\Stmt[]|null Statements */
    public $stmts;
    /**
     * Constructs a declare node.
     *
     * @param DeclareDeclare[] $declares   List of declares
     * @param Node\Stmt[]|null $stmts      Statements
     * @param array            $attributes Additional attributes
     */
    public function __construct(array $declares, array $stmts = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->declares = $declares;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['declares', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Declare';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Do_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /** @var Node\Expr Condition */
    public $cond;
    /**
     * Constructs a do while node.
     *
     * @param Node\Expr   $cond       Condition
     * @param Node\Stmt[] $stmts      Statements
     * @param array       $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $cond, array $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['stmts', 'cond'];
    }
    public function getType() : string
    {
        return 'Stmt_Do';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Echo_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr[] Expressions */
    public $exprs;
    /**
     * Constructs an echo node.
     *
     * @param Node\Expr[] $exprs      Expressions
     * @param array       $attributes Additional attributes
     */
    public function __construct(array $exprs, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->exprs = $exprs;
    }
    public function getSubNodeNames() : array
    {
        return ['exprs'];
    }
    public function getType() : string
    {
        return 'Stmt_Echo';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class ElseIf_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr Condition */
    public $cond;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs an elseif node.
     *
     * @param Node\Expr   $cond       Condition
     * @param Node\Stmt[] $stmts      Statements
     * @param array       $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $cond, array $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['cond', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_ElseIf';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Else_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs an else node.
     *
     * @param Node\Stmt[] $stmts      Statements
     * @param array       $attributes Additional attributes
     */
    public function __construct(array $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Else';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\AttributeGroup;
class EnumCase extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Identifier Enum case name */
    public $name;
    /** @var Node\Expr|null Enum case expression */
    public $expr;
    /** @var Node\AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    /**
     * @param string|Node\Identifier    $name       Enum case name
     * @param Node\Expr|null            $expr       Enum case expression
     * @param AttributeGroup[]          $attrGroups PHP attribute groups
     * @param array                     $attributes Additional attributes
     */
    public function __construct($name, \PHPUnit\PhpParser\Node\Expr $expr = null, array $attrGroups = [], array $attributes = [])
    {
        parent::__construct($attributes);
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->expr = $expr;
        $this->attrGroups = $attrGroups;
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'name', 'expr'];
    }
    public function getType() : string
    {
        return 'Stmt_EnumCase';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Enum_ extends \PHPUnit\PhpParser\Node\Stmt\ClassLike
{
    /** @var null|Node\Identifier Scalar Type */
    public $scalarType;
    /** @var Node\Name[] Names of implemented interfaces */
    public $implements;
    /**
     * @param string|Node\Identifier|null $name       Name
     * @param array                       $subNodes   Array of the following optional subnodes:
     *                                                'scalarType'  => null    : Scalar type
     *                                                'implements'  => array() : Names of implemented interfaces
     *                                                'stmts'       => array() : Statements
     *                                                'attrGroups'  => array() : PHP attribute groups
     * @param array                       $attributes Additional attributes
     */
    public function __construct($name, array $subNodes = [], array $attributes = [])
    {
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->scalarType = $subNodes['scalarType'] ?? null;
        $this->implements = $subNodes['implements'] ?? [];
        $this->stmts = $subNodes['stmts'] ?? [];
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
        parent::__construct($attributes);
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'name', 'scalarType', 'implements', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Enum';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
/**
 * Represents statements of type "expr;"
 */
class Expression extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr Expression */
    public $expr;
    /**
     * Constructs an expression statement.
     *
     * @param Node\Expr $expr       Expression
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Stmt_Expression';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Finally_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs a finally node.
     *
     * @param Node\Stmt[] $stmts      Statements
     * @param array       $attributes Additional attributes
     */
    public function __construct(array $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Finally';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class For_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr[] Init expressions */
    public $init;
    /** @var Node\Expr[] Loop conditions */
    public $cond;
    /** @var Node\Expr[] Loop expressions */
    public $loop;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs a for loop node.
     *
     * @param array $subNodes   Array of the following optional subnodes:
     *                          'init'  => array(): Init expressions
     *                          'cond'  => array(): Loop conditions
     *                          'loop'  => array(): Loop expressions
     *                          'stmts' => array(): Statements
     * @param array $attributes Additional attributes
     */
    public function __construct(array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->init = $subNodes['init'] ?? [];
        $this->cond = $subNodes['cond'] ?? [];
        $this->loop = $subNodes['loop'] ?? [];
        $this->stmts = $subNodes['stmts'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['init', 'cond', 'loop', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_For';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Foreach_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr Expression to iterate */
    public $expr;
    /** @var null|Node\Expr Variable to assign key to */
    public $keyVar;
    /** @var bool Whether to assign value by reference */
    public $byRef;
    /** @var Node\Expr Variable to assign value to */
    public $valueVar;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs a foreach node.
     *
     * @param Node\Expr $expr       Expression to iterate
     * @param Node\Expr $valueVar   Variable to assign value to
     * @param array     $subNodes   Array of the following optional subnodes:
     *                              'keyVar' => null   : Variable to assign key to
     *                              'byRef'  => false  : Whether to assign value by reference
     *                              'stmts'  => array(): Statements
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, \PHPUnit\PhpParser\Node\Expr $valueVar, array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
        $this->keyVar = $subNodes['keyVar'] ?? null;
        $this->byRef = $subNodes['byRef'] ?? \false;
        $this->valueVar = $valueVar;
        $this->stmts = $subNodes['stmts'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['expr', 'keyVar', 'byRef', 'valueVar', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Foreach';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\FunctionLike;
/**
 * @property Node\Name $namespacedName Namespaced name (if using NameResolver)
 */
class Function_ extends \PHPUnit\PhpParser\Node\Stmt implements \PHPUnit\PhpParser\Node\FunctionLike
{
    /** @var bool Whether function returns by reference */
    public $byRef;
    /** @var Node\Identifier Name */
    public $name;
    /** @var Node\Param[] Parameters */
    public $params;
    /** @var null|Node\Identifier|Node\Name|Node\NullableType|Node\UnionType Return type */
    public $returnType;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /** @var Node\AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    /**
     * Constructs a function node.
     *
     * @param string|Node\Identifier $name Name
     * @param array  $subNodes   Array of the following optional subnodes:
     *                           'byRef'      => false  : Whether to return by reference
     *                           'params'     => array(): Parameters
     *                           'returnType' => null   : Return type
     *                           'stmts'      => array(): Statements
     *                           'attrGroups' => array(): PHP attribute groups
     * @param array  $attributes Additional attributes
     */
    public function __construct($name, array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->byRef = $subNodes['byRef'] ?? \false;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->params = $subNodes['params'] ?? [];
        $returnType = $subNodes['returnType'] ?? null;
        $this->returnType = \is_string($returnType) ? new \PHPUnit\PhpParser\Node\Identifier($returnType) : $returnType;
        $this->stmts = $subNodes['stmts'] ?? [];
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'byRef', 'name', 'params', 'returnType', 'stmts'];
    }
    public function returnsByRef() : bool
    {
        return $this->byRef;
    }
    public function getParams() : array
    {
        return $this->params;
    }
    public function getReturnType()
    {
        return $this->returnType;
    }
    public function getAttrGroups() : array
    {
        return $this->attrGroups;
    }
    /** @return Node\Stmt[] */
    public function getStmts() : array
    {
        return $this->stmts;
    }
    public function getType() : string
    {
        return 'Stmt_Function';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Global_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr[] Variables */
    public $vars;
    /**
     * Constructs a global variables list node.
     *
     * @param Node\Expr[] $vars       Variables to unset
     * @param array       $attributes Additional attributes
     */
    public function __construct(array $vars, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->vars = $vars;
    }
    public function getSubNodeNames() : array
    {
        return ['vars'];
    }
    public function getType() : string
    {
        return 'Stmt_Global';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Stmt;
class Goto_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Identifier Name of label to jump to */
    public $name;
    /**
     * Constructs a goto node.
     *
     * @param string|Identifier $name       Name of label to jump to
     * @param array             $attributes Additional attributes
     */
    public function __construct($name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
    }
    public function getSubNodeNames() : array
    {
        return ['name'];
    }
    public function getType() : string
    {
        return 'Stmt_Goto';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Stmt;
class GroupUse extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var int Type of group use */
    public $type;
    /** @var Name Prefix for uses */
    public $prefix;
    /** @var UseUse[] Uses */
    public $uses;
    /**
     * Constructs a group use node.
     *
     * @param Name     $prefix     Prefix for uses
     * @param UseUse[] $uses       Uses
     * @param int      $type       Type of group use
     * @param array    $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Name $prefix, array $uses, int $type = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->type = $type;
        $this->prefix = $prefix;
        $this->uses = $uses;
    }
    public function getSubNodeNames() : array
    {
        return ['type', 'prefix', 'uses'];
    }
    public function getType() : string
    {
        return 'Stmt_GroupUse';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node\Stmt;
class HaltCompiler extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var string Remaining text after halt compiler statement. */
    public $remaining;
    /**
     * Constructs a __halt_compiler node.
     *
     * @param string $remaining  Remaining text after halt compiler statement.
     * @param array  $attributes Additional attributes
     */
    public function __construct(string $remaining, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->remaining = $remaining;
    }
    public function getSubNodeNames() : array
    {
        return ['remaining'];
    }
    public function getType() : string
    {
        return 'Stmt_HaltCompiler';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class If_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr Condition expression */
    public $cond;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /** @var ElseIf_[] Elseif clauses */
    public $elseifs;
    /** @var null|Else_ Else clause */
    public $else;
    /**
     * Constructs an if node.
     *
     * @param Node\Expr $cond       Condition
     * @param array     $subNodes   Array of the following optional subnodes:
     *                              'stmts'   => array(): Statements
     *                              'elseifs' => array(): Elseif clauses
     *                              'else'    => null   : Else clause
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $cond, array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->stmts = $subNodes['stmts'] ?? [];
        $this->elseifs = $subNodes['elseifs'] ?? [];
        $this->else = $subNodes['else'] ?? null;
    }
    public function getSubNodeNames() : array
    {
        return ['cond', 'stmts', 'elseifs', 'else'];
    }
    public function getType() : string
    {
        return 'Stmt_If';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node\Stmt;
class InlineHTML extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var string String */
    public $value;
    /**
     * Constructs an inline HTML node.
     *
     * @param string $value      String
     * @param array  $attributes Additional attributes
     */
    public function __construct(string $value, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->value = $value;
    }
    public function getSubNodeNames() : array
    {
        return ['value'];
    }
    public function getType() : string
    {
        return 'Stmt_InlineHTML';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Interface_ extends \PHPUnit\PhpParser\Node\Stmt\ClassLike
{
    /** @var Node\Name[] Extended interfaces */
    public $extends;
    /**
     * Constructs a class node.
     *
     * @param string|Node\Identifier $name Name
     * @param array  $subNodes   Array of the following optional subnodes:
     *                           'extends'    => array(): Name of extended interfaces
     *                           'stmts'      => array(): Statements
     *                           'attrGroups' => array(): PHP attribute groups
     * @param array  $attributes Additional attributes
     */
    public function __construct($name, array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->extends = $subNodes['extends'] ?? [];
        $this->stmts = $subNodes['stmts'] ?? [];
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'name', 'extends', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Interface';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Stmt;
class Label extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Identifier Name */
    public $name;
    /**
     * Constructs a label node.
     *
     * @param string|Identifier $name       Name
     * @param array             $attributes Additional attributes
     */
    public function __construct($name, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
    }
    public function getSubNodeNames() : array
    {
        return ['name'];
    }
    public function getType() : string
    {
        return 'Stmt_Label';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Namespace_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /* For use in the "kind" attribute */
    const KIND_SEMICOLON = 1;
    const KIND_BRACED = 2;
    /** @var null|Node\Name Name */
    public $name;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs a namespace node.
     *
     * @param null|Node\Name   $name       Name
     * @param null|Node\Stmt[] $stmts      Statements
     * @param array            $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Name $name = null, $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = $name;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['name', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Namespace';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
/** Nop/empty statement (;). */
class Nop extends \PHPUnit\PhpParser\Node\Stmt
{
    public function getSubNodeNames() : array
    {
        return [];
    }
    public function getType() : string
    {
        return 'Stmt_Nop';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\NullableType;
use PHPUnit\PhpParser\Node\UnionType;
class Property extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var int Modifiers */
    public $flags;
    /** @var PropertyProperty[] Properties */
    public $props;
    /** @var null|Identifier|Name|NullableType|UnionType Type declaration */
    public $type;
    /** @var Node\AttributeGroup[] PHP attribute groups */
    public $attrGroups;
    /**
     * Constructs a class property list node.
     *
     * @param int                                                $flags      Modifiers
     * @param PropertyProperty[]                                 $props      Properties
     * @param array                                              $attributes Additional attributes
     * @param null|string|Identifier|Name|NullableType|UnionType $type       Type declaration
     * @param Node\AttributeGroup[]                              $attrGroups PHP attribute groups
     */
    public function __construct(int $flags, array $props, array $attributes = [], $type = null, array $attrGroups = [])
    {
        $this->attributes = $attributes;
        $this->flags = $flags;
        $this->props = $props;
        $this->type = \is_string($type) ? new \PHPUnit\PhpParser\Node\Identifier($type) : $type;
        $this->attrGroups = $attrGroups;
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'flags', 'type', 'props'];
    }
    /**
     * Whether the property is explicitly or implicitly public.
     *
     * @return bool
     */
    public function isPublic() : bool
    {
        return ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC) !== 0 || ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::VISIBILITY_MODIFIER_MASK) === 0;
    }
    /**
     * Whether the property is protected.
     *
     * @return bool
     */
    public function isProtected() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED);
    }
    /**
     * Whether the property is private.
     *
     * @return bool
     */
    public function isPrivate() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE);
    }
    /**
     * Whether the property is static.
     *
     * @return bool
     */
    public function isStatic() : bool
    {
        return (bool) ($this->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC);
    }
    public function getType() : string
    {
        return 'Stmt_Property';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class PropertyProperty extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\VarLikeIdentifier Name */
    public $name;
    /** @var null|Node\Expr Default */
    public $default;
    /**
     * Constructs a class property node.
     *
     * @param string|Node\VarLikeIdentifier $name       Name
     * @param null|Node\Expr                $default    Default value
     * @param array                         $attributes Additional attributes
     */
    public function __construct($name, \PHPUnit\PhpParser\Node\Expr $default = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\VarLikeIdentifier($name) : $name;
        $this->default = $default;
    }
    public function getSubNodeNames() : array
    {
        return ['name', 'default'];
    }
    public function getType() : string
    {
        return 'Stmt_PropertyProperty';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Return_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var null|Node\Expr Expression */
    public $expr;
    /**
     * Constructs a return node.
     *
     * @param null|Node\Expr $expr       Expression
     * @param array          $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Stmt_Return';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
class StaticVar extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Expr\Variable Variable */
    public $var;
    /** @var null|Node\Expr Default value */
    public $default;
    /**
     * Constructs a static variable node.
     *
     * @param Expr\Variable  $var         Name
     * @param null|Node\Expr $default    Default value
     * @param array          $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr\Variable $var, \PHPUnit\PhpParser\Node\Expr $default = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->var = $var;
        $this->default = $default;
    }
    public function getSubNodeNames() : array
    {
        return ['var', 'default'];
    }
    public function getType() : string
    {
        return 'Stmt_StaticVar';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node\Stmt;
class Static_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var StaticVar[] Variable definitions */
    public $vars;
    /**
     * Constructs a static variables list node.
     *
     * @param StaticVar[] $vars       Variable definitions
     * @param array       $attributes Additional attributes
     */
    public function __construct(array $vars, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->vars = $vars;
    }
    public function getSubNodeNames() : array
    {
        return ['vars'];
    }
    public function getType() : string
    {
        return 'Stmt_Static';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Switch_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr Condition */
    public $cond;
    /** @var Case_[] Case list */
    public $cases;
    /**
     * Constructs a case node.
     *
     * @param Node\Expr $cond       Condition
     * @param Case_[]   $cases      Case list
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $cond, array $cases, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->cases = $cases;
    }
    public function getSubNodeNames() : array
    {
        return ['cond', 'cases'];
    }
    public function getType() : string
    {
        return 'Stmt_Switch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Throw_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr Expression */
    public $expr;
    /**
     * Constructs a legacy throw statement node.
     *
     * @param Node\Expr $expr       Expression
     * @param array     $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $expr, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->expr = $expr;
    }
    public function getSubNodeNames() : array
    {
        return ['expr'];
    }
    public function getType() : string
    {
        return 'Stmt_Throw';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class TraitUse extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Name[] Traits */
    public $traits;
    /** @var TraitUseAdaptation[] Adaptations */
    public $adaptations;
    /**
     * Constructs a trait use node.
     *
     * @param Node\Name[]          $traits      Traits
     * @param TraitUseAdaptation[] $adaptations Adaptations
     * @param array                $attributes  Additional attributes
     */
    public function __construct(array $traits, array $adaptations = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->traits = $traits;
        $this->adaptations = $adaptations;
    }
    public function getSubNodeNames() : array
    {
        return ['traits', 'adaptations'];
    }
    public function getType() : string
    {
        return 'Stmt_TraitUse';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
abstract class TraitUseAdaptation extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Name|null Trait name */
    public $trait;
    /** @var Node\Identifier Method name */
    public $method;
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation;

use PHPUnit\PhpParser\Node;
class Alias extends \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation
{
    /** @var null|int New modifier */
    public $newModifier;
    /** @var null|Node\Identifier New name */
    public $newName;
    /**
     * Constructs a trait use precedence adaptation node.
     *
     * @param null|Node\Name              $trait       Trait name
     * @param string|Node\Identifier      $method      Method name
     * @param null|int                    $newModifier New modifier
     * @param null|string|Node\Identifier $newName     New name
     * @param array                       $attributes  Additional attributes
     */
    public function __construct($trait, $method, $newModifier, $newName, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->trait = $trait;
        $this->method = \is_string($method) ? new \PHPUnit\PhpParser\Node\Identifier($method) : $method;
        $this->newModifier = $newModifier;
        $this->newName = \is_string($newName) ? new \PHPUnit\PhpParser\Node\Identifier($newName) : $newName;
    }
    public function getSubNodeNames() : array
    {
        return ['trait', 'method', 'newModifier', 'newName'];
    }
    public function getType() : string
    {
        return 'Stmt_TraitUseAdaptation_Alias';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation;

use PHPUnit\PhpParser\Node;
class Precedence extends \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation
{
    /** @var Node\Name[] Overwritten traits */
    public $insteadof;
    /**
     * Constructs a trait use precedence adaptation node.
     *
     * @param Node\Name              $trait       Trait name
     * @param string|Node\Identifier $method      Method name
     * @param Node\Name[]            $insteadof   Overwritten traits
     * @param array                  $attributes  Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Name $trait, $method, array $insteadof, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->trait = $trait;
        $this->method = \is_string($method) ? new \PHPUnit\PhpParser\Node\Identifier($method) : $method;
        $this->insteadof = $insteadof;
    }
    public function getSubNodeNames() : array
    {
        return ['trait', 'method', 'insteadof'];
    }
    public function getType() : string
    {
        return 'Stmt_TraitUseAdaptation_Precedence';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Trait_ extends \PHPUnit\PhpParser\Node\Stmt\ClassLike
{
    /**
     * Constructs a trait node.
     *
     * @param string|Node\Identifier $name Name
     * @param array  $subNodes   Array of the following optional subnodes:
     *                           'stmts'      => array(): Statements
     *                           'attrGroups' => array(): PHP attribute groups
     * @param array  $attributes Additional attributes
     */
    public function __construct($name, array $subNodes = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->name = \is_string($name) ? new \PHPUnit\PhpParser\Node\Identifier($name) : $name;
        $this->stmts = $subNodes['stmts'] ?? [];
        $this->attrGroups = $subNodes['attrGroups'] ?? [];
    }
    public function getSubNodeNames() : array
    {
        return ['attrGroups', 'name', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_Trait';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class TryCatch extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /** @var Catch_[] Catches */
    public $catches;
    /** @var null|Finally_ Optional finally node */
    public $finally;
    /**
     * Constructs a try catch node.
     *
     * @param Node\Stmt[]   $stmts      Statements
     * @param Catch_[]      $catches    Catches
     * @param null|Finally_ $finally    Optional finally node
     * @param array         $attributes Additional attributes
     */
    public function __construct(array $stmts, array $catches, \PHPUnit\PhpParser\Node\Stmt\Finally_ $finally = null, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->stmts = $stmts;
        $this->catches = $catches;
        $this->finally = $finally;
    }
    public function getSubNodeNames() : array
    {
        return ['stmts', 'catches', 'finally'];
    }
    public function getType() : string
    {
        return 'Stmt_TryCatch';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class Unset_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr[] Variables to unset */
    public $vars;
    /**
     * Constructs an unset node.
     *
     * @param Node\Expr[] $vars       Variables to unset
     * @param array       $attributes Additional attributes
     */
    public function __construct(array $vars, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->vars = $vars;
    }
    public function getSubNodeNames() : array
    {
        return ['vars'];
    }
    public function getType() : string
    {
        return 'Stmt_Unset';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Identifier;
class UseUse extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var int One of the Stmt\Use_::TYPE_* constants. Will only differ from TYPE_UNKNOWN for mixed group uses */
    public $type;
    /** @var Node\Name Namespace, class, function or constant to alias */
    public $name;
    /** @var Identifier|null Alias */
    public $alias;
    /**
     * Constructs an alias (use) node.
     *
     * @param Node\Name              $name       Namespace/Class to alias
     * @param null|string|Identifier $alias      Alias
     * @param int                    $type       Type of the use element (for mixed group use only)
     * @param array                  $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Name $name, $alias = null, int $type = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->type = $type;
        $this->name = $name;
        $this->alias = \is_string($alias) ? new \PHPUnit\PhpParser\Node\Identifier($alias) : $alias;
    }
    public function getSubNodeNames() : array
    {
        return ['type', 'name', 'alias'];
    }
    /**
     * Get alias. If not explicitly given this is the last component of the used name.
     *
     * @return Identifier
     */
    public function getAlias() : \PHPUnit\PhpParser\Node\Identifier
    {
        if (null !== $this->alias) {
            return $this->alias;
        }
        return new \PHPUnit\PhpParser\Node\Identifier($this->name->getLast());
    }
    public function getType() : string
    {
        return 'Stmt_UseUse';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node\Stmt;
class Use_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /**
     * Unknown type. Both Stmt\Use_ / Stmt\GroupUse and Stmt\UseUse have a $type property, one of them will always be
     * TYPE_UNKNOWN while the other has one of the three other possible types. For normal use statements the type on the
     * Stmt\UseUse is unknown. It's only the other way around for mixed group use declarations.
     */
    const TYPE_UNKNOWN = 0;
    /** Class or namespace import */
    const TYPE_NORMAL = 1;
    /** Function import */
    const TYPE_FUNCTION = 2;
    /** Constant import */
    const TYPE_CONSTANT = 3;
    /** @var int Type of alias */
    public $type;
    /** @var UseUse[] Aliases */
    public $uses;
    /**
     * Constructs an alias (use) list node.
     *
     * @param UseUse[] $uses       Aliases
     * @param int      $type       Type of alias
     * @param array    $attributes Additional attributes
     */
    public function __construct(array $uses, int $type = self::TYPE_NORMAL, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->type = $type;
        $this->uses = $uses;
    }
    public function getSubNodeNames() : array
    {
        return ['type', 'uses'];
    }
    public function getType() : string
    {
        return 'Stmt_Use';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node\Stmt;

use PHPUnit\PhpParser\Node;
class While_ extends \PHPUnit\PhpParser\Node\Stmt
{
    /** @var Node\Expr Condition */
    public $cond;
    /** @var Node\Stmt[] Statements */
    public $stmts;
    /**
     * Constructs a while node.
     *
     * @param Node\Expr   $cond       Condition
     * @param Node\Stmt[] $stmts      Statements
     * @param array       $attributes Additional attributes
     */
    public function __construct(\PHPUnit\PhpParser\Node\Expr $cond, array $stmts = [], array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->cond = $cond;
        $this->stmts = $stmts;
    }
    public function getSubNodeNames() : array
    {
        return ['cond', 'stmts'];
    }
    public function getType() : string
    {
        return 'Stmt_While';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

use PHPUnit\PhpParser\NodeAbstract;
class UnionType extends \PHPUnit\PhpParser\NodeAbstract
{
    /** @var (Identifier|Name)[] Types */
    public $types;
    /**
     * Constructs a union type.
     *
     * @param (Identifier|Name)[] $types      Types
     * @param array               $attributes Additional attributes
     */
    public function __construct(array $types, array $attributes = [])
    {
        $this->attributes = $attributes;
        $this->types = $types;
    }
    public function getSubNodeNames() : array
    {
        return ['types'];
    }
    public function getType() : string
    {
        return 'UnionType';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Node;

/**
 * Represents a name that is written in source code with a leading dollar,
 * but is not a proper variable. The leading dollar is not stored as part of the name.
 *
 * Examples: Names in property declarations are formatted as variables. Names in static property
 * lookups are also formatted as variables.
 */
class VarLikeIdentifier extends \PHPUnit\PhpParser\Node\Identifier
{
    public function getType() : string
    {
        return 'VarLikeIdentifier';
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

abstract class NodeAbstract implements \PHPUnit\PhpParser\Node, \JsonSerializable
{
    protected $attributes;
    /**
     * Creates a Node.
     *
     * @param array $attributes Array of attributes
     */
    public function __construct(array $attributes = [])
    {
        $this->attributes = $attributes;
    }
    /**
     * Gets line the node started in (alias of getStartLine).
     *
     * @return int Start line (or -1 if not available)
     */
    public function getLine() : int
    {
        return $this->attributes['startLine'] ?? -1;
    }
    /**
     * Gets line the node started in.
     *
     * Requires the 'startLine' attribute to be enabled in the lexer (enabled by default).
     *
     * @return int Start line (or -1 if not available)
     */
    public function getStartLine() : int
    {
        return $this->attributes['startLine'] ?? -1;
    }
    /**
     * Gets the line the node ended in.
     *
     * Requires the 'endLine' attribute to be enabled in the lexer (enabled by default).
     *
     * @return int End line (or -1 if not available)
     */
    public function getEndLine() : int
    {
        return $this->attributes['endLine'] ?? -1;
    }
    /**
     * Gets the token offset of the first token that is part of this node.
     *
     * The offset is an index into the array returned by Lexer::getTokens().
     *
     * Requires the 'startTokenPos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int Token start position (or -1 if not available)
     */
    public function getStartTokenPos() : int
    {
        return $this->attributes['startTokenPos'] ?? -1;
    }
    /**
     * Gets the token offset of the last token that is part of this node.
     *
     * The offset is an index into the array returned by Lexer::getTokens().
     *
     * Requires the 'endTokenPos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int Token end position (or -1 if not available)
     */
    public function getEndTokenPos() : int
    {
        return $this->attributes['endTokenPos'] ?? -1;
    }
    /**
     * Gets the file offset of the first character that is part of this node.
     *
     * Requires the 'startFilePos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int File start position (or -1 if not available)
     */
    public function getStartFilePos() : int
    {
        return $this->attributes['startFilePos'] ?? -1;
    }
    /**
     * Gets the file offset of the last character that is part of this node.
     *
     * Requires the 'endFilePos' attribute to be enabled in the lexer (DISABLED by default).
     *
     * @return int File end position (or -1 if not available)
     */
    public function getEndFilePos() : int
    {
        return $this->attributes['endFilePos'] ?? -1;
    }
    /**
     * Gets all comments directly preceding this node.
     *
     * The comments are also available through the "comments" attribute.
     *
     * @return Comment[]
     */
    public function getComments() : array
    {
        return $this->attributes['comments'] ?? [];
    }
    /**
     * Gets the doc comment of the node.
     *
     * @return null|Comment\Doc Doc comment object or null
     */
    public function getDocComment()
    {
        $comments = $this->getComments();
        for ($i = \count($comments) - 1; $i >= 0; $i--) {
            $comment = $comments[$i];
            if ($comment instanceof \PHPUnit\PhpParser\Comment\Doc) {
                return $comment;
            }
        }
        return null;
    }
    /**
     * Sets the doc comment of the node.
     *
     * This will either replace an existing doc comment or add it to the comments array.
     *
     * @param Comment\Doc $docComment Doc comment to set
     */
    public function setDocComment(\PHPUnit\PhpParser\Comment\Doc $docComment)
    {
        $comments = $this->getComments();
        for ($i = \count($comments) - 1; $i >= 0; $i--) {
            if ($comments[$i] instanceof \PHPUnit\PhpParser\Comment\Doc) {
                // Replace existing doc comment.
                $comments[$i] = $docComment;
                $this->setAttribute('comments', $comments);
                return;
            }
        }
        // Append new doc comment.
        $comments[] = $docComment;
        $this->setAttribute('comments', $comments);
    }
    public function setAttribute(string $key, $value)
    {
        $this->attributes[$key] = $value;
    }
    public function hasAttribute(string $key) : bool
    {
        return \array_key_exists($key, $this->attributes);
    }
    public function getAttribute(string $key, $default = null)
    {
        if (\array_key_exists($key, $this->attributes)) {
            return $this->attributes[$key];
        }
        return $default;
    }
    public function getAttributes() : array
    {
        return $this->attributes;
    }
    public function setAttributes(array $attributes)
    {
        $this->attributes = $attributes;
    }
    /**
     * @return array
     */
    public function jsonSerialize() : array
    {
        return ['nodeType' => $this->getType()] + \get_object_vars($this);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\Node\Expr\Include_;
use PHPUnit\PhpParser\Node\Stmt\Class_;
use PHPUnit\PhpParser\Node\Stmt\GroupUse;
use PHPUnit\PhpParser\Node\Stmt\Use_;
use PHPUnit\PhpParser\Node\Stmt\UseUse;
class NodeDumper
{
    private $dumpComments;
    private $dumpPositions;
    private $code;
    /**
     * Constructs a NodeDumper.
     *
     * Supported options:
     *  * bool dumpComments: Whether comments should be dumped.
     *  * bool dumpPositions: Whether line/offset information should be dumped. To dump offset
     *                        information, the code needs to be passed to dump().
     *
     * @param array $options Options (see description)
     */
    public function __construct(array $options = [])
    {
        $this->dumpComments = !empty($options['dumpComments']);
        $this->dumpPositions = !empty($options['dumpPositions']);
    }
    /**
     * Dumps a node or array.
     *
     * @param array|Node  $node Node or array to dump
     * @param string|null $code Code corresponding to dumped AST. This only needs to be passed if
     *                          the dumpPositions option is enabled and the dumping of node offsets
     *                          is desired.
     *
     * @return string Dumped value
     */
    public function dump($node, string $code = null) : string
    {
        $this->code = $code;
        return $this->dumpRecursive($node);
    }
    protected function dumpRecursive($node)
    {
        if ($node instanceof \PHPUnit\PhpParser\Node) {
            $r = $node->getType();
            if ($this->dumpPositions && null !== ($p = $this->dumpPosition($node))) {
                $r .= $p;
            }
            $r .= '(';
            foreach ($node->getSubNodeNames() as $key) {
                $r .= "\n    " . $key . ': ';
                $value = $node->{$key};
                if (null === $value) {
                    $r .= 'null';
                } elseif (\false === $value) {
                    $r .= 'false';
                } elseif (\true === $value) {
                    $r .= 'true';
                } elseif (\is_scalar($value)) {
                    if ('flags' === $key || 'newModifier' === $key) {
                        $r .= $this->dumpFlags($value);
                    } elseif ('type' === $key && $node instanceof \PHPUnit\PhpParser\Node\Expr\Include_) {
                        $r .= $this->dumpIncludeType($value);
                    } elseif ('type' === $key && ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Use_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\UseUse || $node instanceof \PHPUnit\PhpParser\Node\Stmt\GroupUse)) {
                        $r .= $this->dumpUseType($value);
                    } else {
                        $r .= $value;
                    }
                } else {
                    $r .= \str_replace("\n", "\n    ", $this->dumpRecursive($value));
                }
            }
            if ($this->dumpComments && ($comments = $node->getComments())) {
                $r .= "\n    comments: " . \str_replace("\n", "\n    ", $this->dumpRecursive($comments));
            }
        } elseif (\is_array($node)) {
            $r = 'array(';
            foreach ($node as $key => $value) {
                $r .= "\n    " . $key . ': ';
                if (null === $value) {
                    $r .= 'null';
                } elseif (\false === $value) {
                    $r .= 'false';
                } elseif (\true === $value) {
                    $r .= 'true';
                } elseif (\is_scalar($value)) {
                    $r .= $value;
                } else {
                    $r .= \str_replace("\n", "\n    ", $this->dumpRecursive($value));
                }
            }
        } elseif ($node instanceof \PHPUnit\PhpParser\Comment) {
            return $node->getReformattedText();
        } else {
            throw new \InvalidArgumentException('Can only dump nodes and arrays.');
        }
        return $r . "\n)";
    }
    protected function dumpFlags($flags)
    {
        $strs = [];
        if ($flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC) {
            $strs[] = 'MODIFIER_PUBLIC';
        }
        if ($flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED) {
            $strs[] = 'MODIFIER_PROTECTED';
        }
        if ($flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE) {
            $strs[] = 'MODIFIER_PRIVATE';
        }
        if ($flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT) {
            $strs[] = 'MODIFIER_ABSTRACT';
        }
        if ($flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC) {
            $strs[] = 'MODIFIER_STATIC';
        }
        if ($flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL) {
            $strs[] = 'MODIFIER_FINAL';
        }
        if ($strs) {
            return \implode(' | ', $strs) . ' (' . $flags . ')';
        } else {
            return $flags;
        }
    }
    protected function dumpIncludeType($type)
    {
        $map = [\PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE => 'TYPE_INCLUDE', \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE_ONCE => 'TYPE_INCLUDE_ONCE', \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE => 'TYPE_REQUIRE', \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE_ONCE => 'TYPE_REQUIRE_ONCE'];
        if (!isset($map[$type])) {
            return $type;
        }
        return $map[$type] . ' (' . $type . ')';
    }
    protected function dumpUseType($type)
    {
        $map = [\PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN => 'TYPE_UNKNOWN', \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL => 'TYPE_NORMAL', \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION => 'TYPE_FUNCTION', \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT => 'TYPE_CONSTANT'];
        if (!isset($map[$type])) {
            return $type;
        }
        return $map[$type] . ' (' . $type . ')';
    }
    /**
     * Dump node position, if possible.
     *
     * @param Node $node Node for which to dump position
     *
     * @return string|null Dump of position, or null if position information not available
     */
    protected function dumpPosition(\PHPUnit\PhpParser\Node $node)
    {
        if (!$node->hasAttribute('startLine') || !$node->hasAttribute('endLine')) {
            return null;
        }
        $start = $node->getStartLine();
        $end = $node->getEndLine();
        if ($node->hasAttribute('startFilePos') && $node->hasAttribute('endFilePos') && null !== $this->code) {
            $start .= ':' . $this->toColumn($this->code, $node->getStartFilePos());
            $end .= ':' . $this->toColumn($this->code, $node->getEndFilePos());
        }
        return "[{$start} - {$end}]";
    }
    // Copied from Error class
    private function toColumn($code, $pos)
    {
        if ($pos > \strlen($code)) {
            throw new \RuntimeException('Invalid position information');
        }
        $lineStartPos = \strrpos($code, "\n", $pos - \strlen($code));
        if (\false === $lineStartPos) {
            $lineStartPos = -1;
        }
        return $pos - $lineStartPos;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\NodeVisitor\FindingVisitor;
use PHPUnit\PhpParser\NodeVisitor\FirstFindingVisitor;
class NodeFinder
{
    /**
     * Find all nodes satisfying a filter callback.
     *
     * @param Node|Node[] $nodes  Single node or array of nodes to search in
     * @param callable    $filter Filter callback: function(Node $node) : bool
     *
     * @return Node[] Found nodes satisfying the filter callback
     */
    public function find($nodes, callable $filter) : array
    {
        if (!\is_array($nodes)) {
            $nodes = [$nodes];
        }
        $visitor = new \PHPUnit\PhpParser\NodeVisitor\FindingVisitor($filter);
        $traverser = new \PHPUnit\PhpParser\NodeTraverser();
        $traverser->addVisitor($visitor);
        $traverser->traverse($nodes);
        return $visitor->getFoundNodes();
    }
    /**
     * Find all nodes that are instances of a certain class.
     *
     * @param Node|Node[] $nodes Single node or array of nodes to search in
     * @param string      $class Class name
     *
     * @return Node[] Found nodes (all instances of $class)
     */
    public function findInstanceOf($nodes, string $class) : array
    {
        return $this->find($nodes, function ($node) use($class) {
            return $node instanceof $class;
        });
    }
    /**
     * Find first node satisfying a filter callback.
     *
     * @param Node|Node[] $nodes  Single node or array of nodes to search in
     * @param callable    $filter Filter callback: function(Node $node) : bool
     *
     * @return null|Node Found node (or null if none found)
     */
    public function findFirst($nodes, callable $filter)
    {
        if (!\is_array($nodes)) {
            $nodes = [$nodes];
        }
        $visitor = new \PHPUnit\PhpParser\NodeVisitor\FirstFindingVisitor($filter);
        $traverser = new \PHPUnit\PhpParser\NodeTraverser();
        $traverser->addVisitor($visitor);
        $traverser->traverse($nodes);
        return $visitor->getFoundNode();
    }
    /**
     * Find first node that is an instance of a certain class.
     *
     * @param Node|Node[] $nodes  Single node or array of nodes to search in
     * @param string      $class Class name
     *
     * @return null|Node Found node, which is an instance of $class (or null if none found)
     */
    public function findFirstInstanceOf($nodes, string $class)
    {
        return $this->findFirst($nodes, function ($node) use($class) {
            return $node instanceof $class;
        });
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

class NodeTraverser implements \PHPUnit\PhpParser\NodeTraverserInterface
{
    /**
     * If NodeVisitor::enterNode() returns DONT_TRAVERSE_CHILDREN, child nodes
     * of the current node will not be traversed for any visitors.
     *
     * For subsequent visitors enterNode() will still be called on the current
     * node and leaveNode() will also be invoked for the current node.
     */
    const DONT_TRAVERSE_CHILDREN = 1;
    /**
     * If NodeVisitor::enterNode() or NodeVisitor::leaveNode() returns
     * STOP_TRAVERSAL, traversal is aborted.
     *
     * The afterTraverse() method will still be invoked.
     */
    const STOP_TRAVERSAL = 2;
    /**
     * If NodeVisitor::leaveNode() returns REMOVE_NODE for a node that occurs
     * in an array, it will be removed from the array.
     *
     * For subsequent visitors leaveNode() will still be invoked for the
     * removed node.
     */
    const REMOVE_NODE = 3;
    /**
     * If NodeVisitor::enterNode() returns DONT_TRAVERSE_CURRENT_AND_CHILDREN, child nodes
     * of the current node will not be traversed for any visitors.
     *
     * For subsequent visitors enterNode() will not be called as well.
     * leaveNode() will be invoked for visitors that has enterNode() method invoked.
     */
    const DONT_TRAVERSE_CURRENT_AND_CHILDREN = 4;
    /** @var NodeVisitor[] Visitors */
    protected $visitors = [];
    /** @var bool Whether traversal should be stopped */
    protected $stopTraversal;
    public function __construct()
    {
        // for BC
    }
    /**
     * Adds a visitor.
     *
     * @param NodeVisitor $visitor Visitor to add
     */
    public function addVisitor(\PHPUnit\PhpParser\NodeVisitor $visitor)
    {
        $this->visitors[] = $visitor;
    }
    /**
     * Removes an added visitor.
     *
     * @param NodeVisitor $visitor
     */
    public function removeVisitor(\PHPUnit\PhpParser\NodeVisitor $visitor)
    {
        foreach ($this->visitors as $index => $storedVisitor) {
            if ($storedVisitor === $visitor) {
                unset($this->visitors[$index]);
                break;
            }
        }
    }
    /**
     * Traverses an array of nodes using the registered visitors.
     *
     * @param Node[] $nodes Array of nodes
     *
     * @return Node[] Traversed array of nodes
     */
    public function traverse(array $nodes) : array
    {
        $this->stopTraversal = \false;
        foreach ($this->visitors as $visitor) {
            if (null !== ($return = $visitor->beforeTraverse($nodes))) {
                $nodes = $return;
            }
        }
        $nodes = $this->traverseArray($nodes);
        foreach ($this->visitors as $visitor) {
            if (null !== ($return = $visitor->afterTraverse($nodes))) {
                $nodes = $return;
            }
        }
        return $nodes;
    }
    /**
     * Recursively traverse a node.
     *
     * @param Node $node Node to traverse.
     *
     * @return Node Result of traversal (may be original node or new one)
     */
    protected function traverseNode(\PHPUnit\PhpParser\Node $node) : \PHPUnit\PhpParser\Node
    {
        foreach ($node->getSubNodeNames() as $name) {
            $subNode =& $node->{$name};
            if (\is_array($subNode)) {
                $subNode = $this->traverseArray($subNode);
                if ($this->stopTraversal) {
                    break;
                }
            } elseif ($subNode instanceof \PHPUnit\PhpParser\Node) {
                $traverseChildren = \true;
                $breakVisitorIndex = null;
                foreach ($this->visitors as $visitorIndex => $visitor) {
                    $return = $visitor->enterNode($subNode);
                    if (null !== $return) {
                        if ($return instanceof \PHPUnit\PhpParser\Node) {
                            $this->ensureReplacementReasonable($subNode, $return);
                            $subNode = $return;
                        } elseif (self::DONT_TRAVERSE_CHILDREN === $return) {
                            $traverseChildren = \false;
                        } elseif (self::DONT_TRAVERSE_CURRENT_AND_CHILDREN === $return) {
                            $traverseChildren = \false;
                            $breakVisitorIndex = $visitorIndex;
                            break;
                        } elseif (self::STOP_TRAVERSAL === $return) {
                            $this->stopTraversal = \true;
                            break 2;
                        } else {
                            throw new \LogicException('enterNode() returned invalid value of type ' . \gettype($return));
                        }
                    }
                }
                if ($traverseChildren) {
                    $subNode = $this->traverseNode($subNode);
                    if ($this->stopTraversal) {
                        break;
                    }
                }
                foreach ($this->visitors as $visitorIndex => $visitor) {
                    $return = $visitor->leaveNode($subNode);
                    if (null !== $return) {
                        if ($return instanceof \PHPUnit\PhpParser\Node) {
                            $this->ensureReplacementReasonable($subNode, $return);
                            $subNode = $return;
                        } elseif (self::STOP_TRAVERSAL === $return) {
                            $this->stopTraversal = \true;
                            break 2;
                        } elseif (\is_array($return)) {
                            throw new \LogicException('leaveNode() may only return an array ' . 'if the parent structure is an array');
                        } else {
                            throw new \LogicException('leaveNode() returned invalid value of type ' . \gettype($return));
                        }
                    }
                    if ($breakVisitorIndex === $visitorIndex) {
                        break;
                    }
                }
            }
        }
        return $node;
    }
    /**
     * Recursively traverse array (usually of nodes).
     *
     * @param array $nodes Array to traverse
     *
     * @return array Result of traversal (may be original array or changed one)
     */
    protected function traverseArray(array $nodes) : array
    {
        $doNodes = [];
        foreach ($nodes as $i => &$node) {
            if ($node instanceof \PHPUnit\PhpParser\Node) {
                $traverseChildren = \true;
                $breakVisitorIndex = null;
                foreach ($this->visitors as $visitorIndex => $visitor) {
                    $return = $visitor->enterNode($node);
                    if (null !== $return) {
                        if ($return instanceof \PHPUnit\PhpParser\Node) {
                            $this->ensureReplacementReasonable($node, $return);
                            $node = $return;
                        } elseif (self::DONT_TRAVERSE_CHILDREN === $return) {
                            $traverseChildren = \false;
                        } elseif (self::DONT_TRAVERSE_CURRENT_AND_CHILDREN === $return) {
                            $traverseChildren = \false;
                            $breakVisitorIndex = $visitorIndex;
                            break;
                        } elseif (self::STOP_TRAVERSAL === $return) {
                            $this->stopTraversal = \true;
                            break 2;
                        } else {
                            throw new \LogicException('enterNode() returned invalid value of type ' . \gettype($return));
                        }
                    }
                }
                if ($traverseChildren) {
                    $node = $this->traverseNode($node);
                    if ($this->stopTraversal) {
                        break;
                    }
                }
                foreach ($this->visitors as $visitorIndex => $visitor) {
                    $return = $visitor->leaveNode($node);
                    if (null !== $return) {
                        if ($return instanceof \PHPUnit\PhpParser\Node) {
                            $this->ensureReplacementReasonable($node, $return);
                            $node = $return;
                        } elseif (\is_array($return)) {
                            $doNodes[] = [$i, $return];
                            break;
                        } elseif (self::REMOVE_NODE === $return) {
                            $doNodes[] = [$i, []];
                            break;
                        } elseif (self::STOP_TRAVERSAL === $return) {
                            $this->stopTraversal = \true;
                            break 2;
                        } elseif (\false === $return) {
                            throw new \LogicException('bool(false) return from leaveNode() no longer supported. ' . 'Return NodeTraverser::REMOVE_NODE instead');
                        } else {
                            throw new \LogicException('leaveNode() returned invalid value of type ' . \gettype($return));
                        }
                    }
                    if ($breakVisitorIndex === $visitorIndex) {
                        break;
                    }
                }
            } elseif (\is_array($node)) {
                throw new \LogicException('Invalid node structure: Contains nested arrays');
            }
        }
        if (!empty($doNodes)) {
            while (list($i, $replace) = \array_pop($doNodes)) {
                \array_splice($nodes, $i, 1, $replace);
            }
        }
        return $nodes;
    }
    private function ensureReplacementReasonable($old, $new)
    {
        if ($old instanceof \PHPUnit\PhpParser\Node\Stmt && $new instanceof \PHPUnit\PhpParser\Node\Expr) {
            throw new \LogicException("Trying to replace statement ({$old->getType()}) " . "with expression ({$new->getType()}). Are you missing a " . "Stmt_Expression wrapper?");
        }
        if ($old instanceof \PHPUnit\PhpParser\Node\Expr && $new instanceof \PHPUnit\PhpParser\Node\Stmt) {
            throw new \LogicException("Trying to replace expression ({$old->getType()}) " . "with statement ({$new->getType()})");
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

interface NodeTraverserInterface
{
    /**
     * Adds a visitor.
     *
     * @param NodeVisitor $visitor Visitor to add
     */
    public function addVisitor(\PHPUnit\PhpParser\NodeVisitor $visitor);
    /**
     * Removes an added visitor.
     *
     * @param NodeVisitor $visitor
     */
    public function removeVisitor(\PHPUnit\PhpParser\NodeVisitor $visitor);
    /**
     * Traverses an array of nodes using the registered visitors.
     *
     * @param Node[] $nodes Array of nodes
     *
     * @return Node[] Traversed array of nodes
     */
    public function traverse(array $nodes) : array;
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

interface NodeVisitor
{
    /**
     * Called once before traversal.
     *
     * Return value semantics:
     *  * null:      $nodes stays as-is
     *  * otherwise: $nodes is set to the return value
     *
     * @param Node[] $nodes Array of nodes
     *
     * @return null|Node[] Array of nodes
     */
    public function beforeTraverse(array $nodes);
    /**
     * Called when entering a node.
     *
     * Return value semantics:
     *  * null
     *        => $node stays as-is
     *  * NodeTraverser::DONT_TRAVERSE_CHILDREN
     *        => Children of $node are not traversed. $node stays as-is
     *  * NodeTraverser::STOP_TRAVERSAL
     *        => Traversal is aborted. $node stays as-is
     *  * otherwise
     *        => $node is set to the return value
     *
     * @param Node $node Node
     *
     * @return null|int|Node Replacement node (or special return value)
     */
    public function enterNode(\PHPUnit\PhpParser\Node $node);
    /**
     * Called when leaving a node.
     *
     * Return value semantics:
     *  * null
     *        => $node stays as-is
     *  * NodeTraverser::REMOVE_NODE
     *        => $node is removed from the parent array
     *  * NodeTraverser::STOP_TRAVERSAL
     *        => Traversal is aborted. $node stays as-is
     *  * array (of Nodes)
     *        => The return value is merged into the parent array (at the position of the $node)
     *  * otherwise
     *        => $node is set to the return value
     *
     * @param Node $node Node
     *
     * @return null|int|Node|Node[] Replacement node (or special return value)
     */
    public function leaveNode(\PHPUnit\PhpParser\Node $node);
    /**
     * Called once after traversal.
     *
     * Return value semantics:
     *  * null:      $nodes stays as-is
     *  * otherwise: $nodes is set to the return value
     *
     * @param Node[] $nodes Array of nodes
     *
     * @return null|Node[] Array of nodes
     */
    public function afterTraverse(array $nodes);
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\NodeVisitor;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeVisitorAbstract;
/**
 * Visitor cloning all nodes and linking to the original nodes using an attribute.
 *
 * This visitor is required to perform format-preserving pretty prints.
 */
class CloningVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    public function enterNode(\PHPUnit\PhpParser\Node $origNode)
    {
        $node = clone $origNode;
        $node->setAttribute('origNode', $origNode);
        return $node;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\NodeVisitor;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeVisitorAbstract;
/**
 * This visitor can be used to find and collect all nodes satisfying some criterion determined by
 * a filter callback.
 */
class FindingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /** @var callable Filter callback */
    protected $filterCallback;
    /** @var Node[] Found nodes */
    protected $foundNodes;
    public function __construct(callable $filterCallback)
    {
        $this->filterCallback = $filterCallback;
    }
    /**
     * Get found nodes satisfying the filter callback.
     *
     * Nodes are returned in pre-order.
     *
     * @return Node[] Found nodes
     */
    public function getFoundNodes() : array
    {
        return $this->foundNodes;
    }
    public function beforeTraverse(array $nodes)
    {
        $this->foundNodes = [];
        return null;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node)
    {
        $filterCallback = $this->filterCallback;
        if ($filterCallback($node)) {
            $this->foundNodes[] = $node;
        }
        return null;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\NodeVisitor;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\NodeVisitorAbstract;
/**
 * This visitor can be used to find the first node satisfying some criterion determined by
 * a filter callback.
 */
class FirstFindingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /** @var callable Filter callback */
    protected $filterCallback;
    /** @var null|Node Found node */
    protected $foundNode;
    public function __construct(callable $filterCallback)
    {
        $this->filterCallback = $filterCallback;
    }
    /**
     * Get found node satisfying the filter callback.
     *
     * Returns null if no node satisfies the filter callback.
     *
     * @return null|Node Found node (or null if not found)
     */
    public function getFoundNode()
    {
        return $this->foundNode;
    }
    public function beforeTraverse(array $nodes)
    {
        $this->foundNode = null;
        return null;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node)
    {
        $filterCallback = $this->filterCallback;
        if ($filterCallback($node)) {
            $this->foundNode = $node;
            return \PHPUnit\PhpParser\NodeTraverser::STOP_TRAVERSAL;
        }
        return null;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\NodeVisitor;

use PHPUnit\PhpParser\ErrorHandler;
use PHPUnit\PhpParser\NameContext;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Name\FullyQualified;
use PHPUnit\PhpParser\Node\Stmt;
use PHPUnit\PhpParser\NodeVisitorAbstract;
class NameResolver extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /** @var NameContext Naming context */
    protected $nameContext;
    /** @var bool Whether to preserve original names */
    protected $preserveOriginalNames;
    /** @var bool Whether to replace resolved nodes in place, or to add resolvedNode attributes */
    protected $replaceNodes;
    /**
     * Constructs a name resolution visitor.
     *
     * Options:
     *  * preserveOriginalNames (default false): An "originalName" attribute will be added to
     *    all name nodes that underwent resolution.
     *  * replaceNodes (default true): Resolved names are replaced in-place. Otherwise, a
     *    resolvedName attribute is added. (Names that cannot be statically resolved receive a
     *    namespacedName attribute, as usual.)
     *
     * @param ErrorHandler|null $errorHandler Error handler
     * @param array $options Options
     */
    public function __construct(\PHPUnit\PhpParser\ErrorHandler $errorHandler = null, array $options = [])
    {
        $this->nameContext = new \PHPUnit\PhpParser\NameContext($errorHandler ?? new \PHPUnit\PhpParser\ErrorHandler\Throwing());
        $this->preserveOriginalNames = $options['preserveOriginalNames'] ?? \false;
        $this->replaceNodes = $options['replaceNodes'] ?? \true;
    }
    /**
     * Get name resolution context.
     *
     * @return NameContext
     */
    public function getNameContext() : \PHPUnit\PhpParser\NameContext
    {
        return $this->nameContext;
    }
    public function beforeTraverse(array $nodes)
    {
        $this->nameContext->startNamespace();
        return null;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node)
    {
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Namespace_) {
            $this->nameContext->startNamespace($node->name);
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Use_) {
            foreach ($node->uses as $use) {
                $this->addAlias($use, $node->type, null);
            }
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\GroupUse) {
            foreach ($node->uses as $use) {
                $this->addAlias($use, $node->type, $node->prefix);
            }
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Class_) {
            if (null !== $node->extends) {
                $node->extends = $this->resolveClassName($node->extends);
            }
            foreach ($node->implements as &$interface) {
                $interface = $this->resolveClassName($interface);
            }
            $this->resolveAttrGroups($node);
            if (null !== $node->name) {
                $this->addNamespacedName($node);
            }
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Interface_) {
            foreach ($node->extends as &$interface) {
                $interface = $this->resolveClassName($interface);
            }
            $this->resolveAttrGroups($node);
            $this->addNamespacedName($node);
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Trait_) {
            $this->resolveAttrGroups($node);
            $this->addNamespacedName($node);
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Function_) {
            $this->resolveSignature($node);
            $this->resolveAttrGroups($node);
            $this->addNamespacedName($node);
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod || $node instanceof \PHPUnit\PhpParser\Node\Expr\Closure || $node instanceof \PHPUnit\PhpParser\Node\Expr\ArrowFunction) {
            $this->resolveSignature($node);
            $this->resolveAttrGroups($node);
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Property) {
            if (null !== $node->type) {
                $node->type = $this->resolveType($node->type);
            }
            $this->resolveAttrGroups($node);
        } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Const_) {
            foreach ($node->consts as $const) {
                $this->addNamespacedName($const);
            }
        } else {
            if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassConst) {
                $this->resolveAttrGroups($node);
            } elseif ($node instanceof \PHPUnit\PhpParser\Node\Expr\StaticCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\ClassConstFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\New_ || $node instanceof \PHPUnit\PhpParser\Node\Expr\Instanceof_) {
                if ($node->class instanceof \PHPUnit\PhpParser\Node\Name) {
                    $node->class = $this->resolveClassName($node->class);
                }
            } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Catch_) {
                foreach ($node->types as &$type) {
                    $type = $this->resolveClassName($type);
                }
            } elseif ($node instanceof \PHPUnit\PhpParser\Node\Expr\FuncCall) {
                if ($node->name instanceof \PHPUnit\PhpParser\Node\Name) {
                    $node->name = $this->resolveName($node->name, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION);
                }
            } elseif ($node instanceof \PHPUnit\PhpParser\Node\Expr\ConstFetch) {
                $node->name = $this->resolveName($node->name, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT);
            } elseif ($node instanceof \PHPUnit\PhpParser\Node\Stmt\TraitUse) {
                foreach ($node->traits as &$trait) {
                    $trait = $this->resolveClassName($trait);
                }
                foreach ($node->adaptations as $adaptation) {
                    if (null !== $adaptation->trait) {
                        $adaptation->trait = $this->resolveClassName($adaptation->trait);
                    }
                    if ($adaptation instanceof \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Precedence) {
                        foreach ($adaptation->insteadof as &$insteadof) {
                            $insteadof = $this->resolveClassName($insteadof);
                        }
                    }
                }
            }
        }
        return null;
    }
    private function addAlias(\PHPUnit\PhpParser\Node\Stmt\UseUse $use, $type, \PHPUnit\PhpParser\Node\Name $prefix = null)
    {
        // Add prefix for group uses
        $name = $prefix ? \PHPUnit\PhpParser\Node\Name::concat($prefix, $use->name) : $use->name;
        // Type is determined either by individual element or whole use declaration
        $type |= $use->type;
        $this->nameContext->addAlias($name, (string) $use->getAlias(), $type, $use->getAttributes());
    }
    /** @param Stmt\Function_|Stmt\ClassMethod|Expr\Closure $node */
    private function resolveSignature($node)
    {
        foreach ($node->params as $param) {
            $param->type = $this->resolveType($param->type);
            $this->resolveAttrGroups($param);
        }
        $node->returnType = $this->resolveType($node->returnType);
    }
    private function resolveType($node)
    {
        if ($node instanceof \PHPUnit\PhpParser\Node\Name) {
            return $this->resolveClassName($node);
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\NullableType) {
            $node->type = $this->resolveType($node->type);
            return $node;
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\UnionType) {
            foreach ($node->types as &$type) {
                $type = $this->resolveType($type);
            }
            return $node;
        }
        return $node;
    }
    /**
     * Resolve name, according to name resolver options.
     *
     * @param Name $name Function or constant name to resolve
     * @param int  $type One of Stmt\Use_::TYPE_*
     *
     * @return Name Resolved name, or original name with attribute
     */
    protected function resolveName(\PHPUnit\PhpParser\Node\Name $name, int $type) : \PHPUnit\PhpParser\Node\Name
    {
        if (!$this->replaceNodes) {
            $resolvedName = $this->nameContext->getResolvedName($name, $type);
            if (null !== $resolvedName) {
                $name->setAttribute('resolvedName', $resolvedName);
            } else {
                $name->setAttribute('namespacedName', \PHPUnit\PhpParser\Node\Name\FullyQualified::concat($this->nameContext->getNamespace(), $name, $name->getAttributes()));
            }
            return $name;
        }
        if ($this->preserveOriginalNames) {
            // Save the original name
            $originalName = $name;
            $name = clone $originalName;
            $name->setAttribute('originalName', $originalName);
        }
        $resolvedName = $this->nameContext->getResolvedName($name, $type);
        if (null !== $resolvedName) {
            return $resolvedName;
        }
        // unqualified names inside a namespace cannot be resolved at compile-time
        // add the namespaced version of the name as an attribute
        $name->setAttribute('namespacedName', \PHPUnit\PhpParser\Node\Name\FullyQualified::concat($this->nameContext->getNamespace(), $name, $name->getAttributes()));
        return $name;
    }
    protected function resolveClassName(\PHPUnit\PhpParser\Node\Name $name)
    {
        return $this->resolveName($name, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL);
    }
    protected function addNamespacedName(\PHPUnit\PhpParser\Node $node)
    {
        $node->namespacedName = \PHPUnit\PhpParser\Node\Name::concat($this->nameContext->getNamespace(), (string) $node->name);
    }
    protected function resolveAttrGroups(\PHPUnit\PhpParser\Node $node)
    {
        foreach ($node->attrGroups as $attrGroup) {
            foreach ($attrGroup->attrs as $attr) {
                $attr->name = $this->resolveClassName($attr->name);
            }
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\NodeVisitor;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeVisitorAbstract;
/**
 * Visitor that connects a child node to its parent node
 * as well as its sibling nodes.
 *
 * On the child node, the parent node can be accessed through
 * <code>$node->getAttribute('parent')</code>, the previous
 * node can be accessed through <code>$node->getAttribute('previous')</code>,
 * and the next node can be accessed through <code>$node->getAttribute('next')</code>.
 */
final class NodeConnectingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /**
     * @var Node[]
     */
    private $stack = [];
    /**
     * @var ?Node
     */
    private $previous;
    public function beforeTraverse(array $nodes)
    {
        $this->stack = [];
        $this->previous = null;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node)
    {
        if (!empty($this->stack)) {
            $node->setAttribute('parent', $this->stack[\count($this->stack) - 1]);
        }
        if ($this->previous !== null && $this->previous->getAttribute('parent') === $node->getAttribute('parent')) {
            $node->setAttribute('previous', $this->previous);
            $this->previous->setAttribute('next', $node);
        }
        $this->stack[] = $node;
    }
    public function leaveNode(\PHPUnit\PhpParser\Node $node)
    {
        $this->previous = $node;
        \array_pop($this->stack);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\NodeVisitor;

use function array_pop;
use function count;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeVisitorAbstract;
/**
 * Visitor that connects a child node to its parent node.
 *
 * On the child node, the parent node can be accessed through
 * <code>$node->getAttribute('parent')</code>.
 */
final class ParentConnectingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /**
     * @var Node[]
     */
    private $stack = [];
    public function beforeTraverse(array $nodes)
    {
        $this->stack = [];
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node)
    {
        if (!empty($this->stack)) {
            $node->setAttribute('parent', $this->stack[\count($this->stack) - 1]);
        }
        $this->stack[] = $node;
    }
    public function leaveNode(\PHPUnit\PhpParser\Node $node)
    {
        \array_pop($this->stack);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

/**
 * @codeCoverageIgnore
 */
class NodeVisitorAbstract implements \PHPUnit\PhpParser\NodeVisitor
{
    public function beforeTraverse(array $nodes)
    {
        return null;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node)
    {
        return null;
    }
    public function leaveNode(\PHPUnit\PhpParser\Node $node)
    {
        return null;
    }
    public function afterTraverse(array $nodes)
    {
        return null;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

interface Parser
{
    /**
     * Parses PHP code into a node tree.
     *
     * @param string $code The source code to parse
     * @param ErrorHandler|null $errorHandler Error handler to use for lexer/parser errors, defaults
     *                                        to ErrorHandler\Throwing.
     *
     * @return Node\Stmt[]|null Array of statements (or null non-throwing error handler is used and
     *                          the parser was unable to recover from an error).
     */
    public function parse(string $code, \PHPUnit\PhpParser\ErrorHandler $errorHandler = null);
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\Parser;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\ErrorHandler;
use PHPUnit\PhpParser\Parser;
class Multiple implements \PHPUnit\PhpParser\Parser
{
    /** @var Parser[] List of parsers to try, in order of preference */
    private $parsers;
    /**
     * Create a parser which will try multiple parsers in an order of preference.
     *
     * Parsers will be invoked in the order they're provided to the constructor. If one of the
     * parsers runs without throwing, it's output is returned. Otherwise the exception that the
     * first parser generated is thrown.
     *
     * @param Parser[] $parsers
     */
    public function __construct(array $parsers)
    {
        $this->parsers = $parsers;
    }
    public function parse(string $code, \PHPUnit\PhpParser\ErrorHandler $errorHandler = null)
    {
        if (null === $errorHandler) {
            $errorHandler = new \PHPUnit\PhpParser\ErrorHandler\Throwing();
        }
        list($firstStmts, $firstError) = $this->tryParse($this->parsers[0], $errorHandler, $code);
        if ($firstError === null) {
            return $firstStmts;
        }
        for ($i = 1, $c = \count($this->parsers); $i < $c; ++$i) {
            list($stmts, $error) = $this->tryParse($this->parsers[$i], $errorHandler, $code);
            if ($error === null) {
                return $stmts;
            }
        }
        throw $firstError;
    }
    private function tryParse(\PHPUnit\PhpParser\Parser $parser, \PHPUnit\PhpParser\ErrorHandler $errorHandler, $code)
    {
        $stmts = null;
        $error = null;
        try {
            $stmts = $parser->parse($code, $errorHandler);
        } catch (\PHPUnit\PhpParser\Error $error) {
        }
        return [$stmts, $error];
    }
}
<?php

namespace PHPUnit\PhpParser\Parser;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Scalar;
use PHPUnit\PhpParser\Node\Stmt;
/* This is an automatically GENERATED file, which should not be manually edited.
 * Instead edit one of the following:
 *  * the grammar files grammar/php5.y or grammar/php7.y
 *  * the skeleton file grammar/parser.template
 *  * the preprocessing script grammar/rebuildParsers.php
 */
class Php5 extends \PHPUnit\PhpParser\ParserAbstract
{
    protected $tokenToSymbolMapSize = 393;
    protected $actionTableSize = 1069;
    protected $gotoTableSize = 580;
    protected $invalidSymbol = 166;
    protected $errorSymbol = 1;
    protected $defaultAction = -32766;
    protected $unexpectedTokenRule = 32767;
    protected $YY2TBLSTATE = 405;
    protected $numNonLeafStates = 658;
    protected $symbolToName = array("EOF", "error", "T_THROW", "T_INCLUDE", "T_INCLUDE_ONCE", "T_EVAL", "T_REQUIRE", "T_REQUIRE_ONCE", "','", "T_LOGICAL_OR", "T_LOGICAL_XOR", "T_LOGICAL_AND", "T_PRINT", "T_YIELD", "T_DOUBLE_ARROW", "T_YIELD_FROM", "'='", "T_PLUS_EQUAL", "T_MINUS_EQUAL", "T_MUL_EQUAL", "T_DIV_EQUAL", "T_CONCAT_EQUAL", "T_MOD_EQUAL", "T_AND_EQUAL", "T_OR_EQUAL", "T_XOR_EQUAL", "T_SL_EQUAL", "T_SR_EQUAL", "T_POW_EQUAL", "T_COALESCE_EQUAL", "'?'", "':'", "T_COALESCE", "T_BOOLEAN_OR", "T_BOOLEAN_AND", "'|'", "'^'", "'&'", "T_IS_EQUAL", "T_IS_NOT_EQUAL", "T_IS_IDENTICAL", "T_IS_NOT_IDENTICAL", "T_SPACESHIP", "'<'", "T_IS_SMALLER_OR_EQUAL", "'>'", "T_IS_GREATER_OR_EQUAL", "T_SL", "T_SR", "'+'", "'-'", "'.'", "'*'", "'/'", "'%'", "'!'", "T_INSTANCEOF", "'~'", "T_INC", "T_DEC", "T_INT_CAST", "T_DOUBLE_CAST", "T_STRING_CAST", "T_ARRAY_CAST", "T_OBJECT_CAST", "T_BOOL_CAST", "T_UNSET_CAST", "'@'", "T_POW", "'['", "T_NEW", "T_CLONE", "T_EXIT", "T_IF", "T_ELSEIF", "T_ELSE", "T_ENDIF", "T_LNUMBER", "T_DNUMBER", "T_STRING", "T_STRING_VARNAME", "T_VARIABLE", "T_NUM_STRING", "T_INLINE_HTML", "T_ENCAPSED_AND_WHITESPACE", "T_CONSTANT_ENCAPSED_STRING", "T_ECHO", "T_DO", "T_WHILE", "T_ENDWHILE", "T_FOR", "T_ENDFOR", "T_FOREACH", "T_ENDFOREACH", "T_DECLARE", "T_ENDDECLARE", "T_AS", "T_SWITCH", "T_MATCH", "T_ENDSWITCH", "T_CASE", "T_DEFAULT", "T_BREAK", "T_CONTINUE", "T_GOTO", "T_FUNCTION", "T_FN", "T_CONST", "T_RETURN", "T_TRY", "T_CATCH", "T_FINALLY", "T_USE", "T_INSTEADOF", "T_GLOBAL", "T_STATIC", "T_ABSTRACT", "T_FINAL", "T_PRIVATE", "T_PROTECTED", "T_PUBLIC", "T_VAR", "T_UNSET", "T_ISSET", "T_EMPTY", "T_HALT_COMPILER", "T_CLASS", "T_TRAIT", "T_INTERFACE", "T_EXTENDS", "T_IMPLEMENTS", "T_OBJECT_OPERATOR", "T_LIST", "T_ARRAY", "T_CALLABLE", "T_CLASS_C", "T_TRAIT_C", "T_METHOD_C", "T_FUNC_C", "T_LINE", "T_FILE", "T_START_HEREDOC", "T_END_HEREDOC", "T_DOLLAR_OPEN_CURLY_BRACES", "T_CURLY_OPEN", "T_PAAMAYIM_NEKUDOTAYIM", "T_NAMESPACE", "T_NS_C", "T_DIR", "T_NS_SEPARATOR", "T_ELLIPSIS", "T_NAME_FULLY_QUALIFIED", "T_NAME_QUALIFIED", "T_NAME_RELATIVE", "';'", "'{'", "'}'", "'('", "')'", "'\$'", "'`'", "']'", "'\"'", "T_ENUM", "T_NULLSAFE_OBJECT_OPERATOR", "T_ATTRIBUTE");
    protected $tokenToSymbol = array(0, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 55, 162, 166, 159, 54, 37, 166, 157, 158, 52, 49, 8, 50, 51, 53, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 31, 154, 43, 16, 45, 30, 67, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 69, 166, 161, 36, 166, 160, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 155, 35, 156, 57, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 38, 39, 40, 41, 42, 44, 46, 47, 48, 56, 58, 59, 60, 61, 62, 63, 64, 65, 66, 68, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 163, 129, 130, 131, 164, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 165);
    protected $action = array(693, 663, 664, 665, 666, 667, 282, 668, 669, 670, 706, 707, 221, 222, 223, 224, 225, 226, 227, 228, 229, 0, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, -32766, -32766, -32766, -32766, -32766, -32766, -32766, -32766, -32767, -32767, -32767, -32767, 27, 242, 243, -32766, -32766, -32766, -32766, -32766, 671, -32766, 333, -32766, -32766, -32766, -32766, -32766, -32766, -32767, -32767, -32767, -32767, -32767, 672, 673, 674, 675, 676, 677, 678, 1034, 816, 740, 941, 942, 943, 940, 939, 938, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 709, 732, 710, 711, 712, 713, 701, 702, 703, 731, 704, 705, 690, 691, 692, 694, 695, 696, 734, 735, 736, 737, 738, 739, 697, 698, 699, 700, 730, 721, 719, 720, 716, 717, 437, 708, 714, 715, 722, 723, 725, 724, 726, 727, 55, 56, 417, 57, 58, 718, 729, 728, 28, 59, 60, -220, 61, -32766, -32766, -32766, -32766, -32766, -32766, -32766, -32766, -32766, 36, -32767, -32767, -32767, -32767, 1034, 35, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, -32766, -32766, -32766, -32766, 62, 63, 1034, 125, 285, 292, 64, 748, 65, 290, 291, 66, 67, 68, 69, 70, 71, 72, 73, 763, 25, 298, 74, 409, 973, 975, 294, 294, 1086, 1087, 1064, 796, 748, 218, 219, 220, 465, -32766, -32766, -32766, 742, 864, 817, 54, 807, 9, -32766, -32766, -32766, 760, 320, 761, 410, 10, 202, 246, 428, 209, -32766, 933, -32766, -32766, -32766, -32766, -32766, -32766, 488, -32766, 438, -32766, -32766, -32766, -32766, -32766, 473, 474, 941, 942, 943, 940, 939, 938, -32766, 475, 476, 337, 1092, 1093, 1094, 1095, 1089, 1090, 315, 1214, -255, 747, 1215, -505, 1096, 1091, 888, 889, 1066, 1065, 1067, 218, 219, 220, 41, 414, 337, 330, 895, 332, 418, -126, -126, -126, 75, 52, 464, -4, 817, 54, 805, -224, 202, 40, 21, 419, -126, 466, -126, 467, -126, 468, -126, 359, 420, 128, 128, 748, 1171, 31, 32, 421, 422, 1034, 894, 33, 469, -32766, -32766, -32766, 1186, 351, 352, 470, 471, -32766, -32766, -32766, 309, 472, 865, 323, 788, 835, 423, 424, -32767, -32767, -32767, -32767, 97, 98, 99, 100, 101, 615, -32766, 313, -32766, -32766, -32766, -32766, 354, 1185, 1171, 218, 219, 220, 475, 748, 418, 819, 629, -126, 297, 915, 464, 817, 54, -32766, 805, 124, 748, 40, 21, 419, 202, 466, 48, 467, 534, 468, 129, 429, 420, 337, 341, 888, 889, 31, 32, 421, 422, 416, 405, 33, 469, -32766, -32766, 311, 298, 351, 352, 470, 471, -32766, -32766, -32766, 748, 472, 412, 748, 752, 835, 423, 424, 338, 1066, 1065, 1067, 219, 220, 919, 1136, 296, 20, -32766, 576, -32766, -32766, -32766, 742, 341, 342, 413, 429, 1064, 337, 512, 418, 202, 819, 629, -4, 1034, 464, 817, 54, 49, 805, 337, 762, 40, 21, 419, 51, 466, 1034, 467, 475, 468, 340, 748, 420, 120, -205, -205, -205, 31, 32, 421, 422, 1062, -32766, 33, 469, -32766, -32766, -32766, 744, 351, 352, 470, 471, 429, 1098, 337, 429, 472, 337, 1034, 788, 835, 423, 424, 415, 1098, -32766, 802, -32766, -32766, 102, 103, 104, 1137, 303, 202, 130, 1066, 1065, 1067, 337, 123, 239, 240, 241, 748, 105, 418, 1205, 819, 629, -205, 440, 464, -32766, -32766, -32766, 805, 242, 243, 40, 21, 419, 121, 466, 126, 467, 429, 468, 337, 122, 420, 1052, -204, -204, -204, 31, 32, 421, 422, 1034, 745, 33, 469, 220, 759, 817, 54, 351, 352, 470, 471, 218, 219, 220, 119, 472, 244, 127, 788, 835, 423, 424, 202, -32766, -32766, -32766, 30, 293, 803, 79, 80, 81, 202, 798, 210, 632, 99, 100, 101, 236, 237, 238, 817, 54, -32766, 211, 800, 819, 629, -204, 34, 1034, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 286, 303, 418, 1034, 817, 54, -32766, -32766, 464, 218, 219, 220, 805, 105, 914, 40, 21, 419, 78, 466, 212, 467, 337, 468, 133, 247, 420, 295, 567, 248, 202, 31, 32, 421, 633, 242, 243, 33, 469, 418, 249, 817, 54, 351, 352, 464, 760, -84, 761, 805, 310, 472, 40, 21, 419, -32766, 466, 640, 467, 643, 468, 447, 22, 420, 815, 452, 584, 132, 31, 32, 421, 637, 134, 364, 33, 469, 418, 303, 817, 54, 351, 352, 464, 819, 629, 828, 805, 43, 472, 40, 21, 419, 44, 466, 45, 467, 46, 468, 591, 592, 420, 753, 635, 930, 649, 31, 32, 421, 641, 918, 657, 33, 469, 418, 105, 817, 54, 351, 352, 464, 819, 629, 47, 805, 50, 472, 40, 21, 419, 53, 466, 131, 467, 298, 468, 599, 742, 420, -32766, -274, 516, 570, 31, 32, 421, 646, 748, 946, 33, 469, 418, 589, 436, -32766, 351, 352, 464, 819, 629, 623, 805, 836, 472, 40, 21, 419, 611, 466, -82, 467, 603, 468, 11, 573, 420, 439, 456, 281, 318, 31, 32, 421, 588, 432, 321, 33, 469, 418, -414, 458, 322, 351, 352, 464, 851, 629, 837, 805, -505, 472, 40, 21, 419, 654, 466, 38, 467, 24, 468, 0, 0, 420, 319, 0, -405, 0, 31, 32, 421, 245, 312, 314, 33, 469, -506, 0, 0, 1097, 351, 352, 1143, 819, 629, 0, 0, 527, 472, 213, 214, 6, 7, 12, 14, 215, 363, 216, -415, 558, 789, -221, 830, 0, 0, 747, 0, 0, 0, 207, 39, 652, 653, 758, 806, 814, 793, 1086, 1087, 808, 819, 629, 213, 214, 867, 1088, 858, 859, 215, 791, 216, 852, 849, 847, 925, 926, 923, 813, 797, 799, 801, 804, 207, 922, 756, 757, 924, 287, 78, 331, 1086, 1087, 353, 630, 634, 636, 638, 639, 1088, 642, 644, 645, 647, 648, 631, 1142, 1211, 1213, 755, 834, 754, 833, 1212, 554, 832, 1092, 1093, 1094, 1095, 1089, 1090, 388, 1048, 824, 1036, 831, 1037, 1096, 1091, 822, 931, 856, 857, 451, 1210, 1179, 0, 217, 1177, 1162, 1175, 1077, 906, 1183, 1173, 0, 554, 26, 1092, 1093, 1094, 1095, 1089, 1090, 388, 29, 37, 42, 76, 77, 1096, 1091, 208, 284, 288, 289, 304, 305, 306, 307, 217, 335, 406, 408, 0, -220, 16, 17, 18, 383, 448, 455, 457, 462, 548, 620, 1039, 1042, 896, 1102, 1038, 1014, 559, 1013, 1079, 0, 0, -424, 1032, 0, 1043, 1045, 1044, 1047, 1046, 1061, 1176, 1161, 1157, 1174, 1076, 1208, 1103, 1156, 595);
    protected $actionCheck = array(2, 3, 4, 5, 6, 7, 14, 9, 10, 11, 12, 13, 33, 34, 35, 36, 37, 38, 39, 40, 41, 0, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 9, 10, 11, 33, 34, 35, 36, 37, 38, 39, 40, 41, 8, 68, 69, 33, 34, 35, 36, 37, 56, 30, 8, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 70, 71, 72, 73, 74, 75, 76, 13, 1, 79, 115, 116, 117, 118, 119, 120, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 31, 132, 133, 134, 135, 136, 137, 138, 139, 140, 3, 4, 5, 6, 7, 146, 147, 148, 8, 12, 13, 158, 15, 33, 34, 35, 36, 37, 38, 39, 40, 41, 14, 43, 44, 45, 46, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 33, 34, 35, 36, 49, 50, 13, 8, 8, 37, 55, 81, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 156, 69, 70, 71, 72, 58, 59, 37, 37, 77, 78, 79, 154, 81, 9, 10, 11, 85, 9, 10, 11, 79, 31, 1, 2, 154, 107, 9, 10, 11, 105, 112, 107, 126, 8, 30, 31, 105, 8, 30, 121, 32, 33, 34, 35, 36, 37, 115, 30, 155, 32, 33, 34, 35, 36, 123, 124, 115, 116, 117, 118, 119, 120, 115, 132, 133, 159, 135, 136, 137, 138, 139, 140, 141, 79, 156, 151, 82, 131, 147, 148, 133, 134, 151, 152, 153, 9, 10, 11, 157, 8, 159, 160, 158, 162, 73, 74, 75, 76, 150, 69, 79, 0, 1, 2, 83, 158, 30, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 8, 97, 150, 150, 81, 81, 102, 103, 104, 105, 13, 158, 108, 109, 9, 10, 11, 158, 114, 115, 116, 117, 9, 10, 11, 8, 122, 154, 8, 125, 126, 127, 128, 43, 44, 45, 46, 47, 48, 49, 50, 51, 79, 30, 131, 32, 33, 34, 35, 8, 1, 81, 9, 10, 11, 132, 81, 73, 154, 155, 156, 37, 154, 79, 1, 2, 115, 83, 155, 81, 86, 87, 88, 30, 90, 69, 92, 80, 94, 155, 157, 97, 159, 159, 133, 134, 102, 103, 104, 105, 8, 107, 108, 109, 9, 10, 112, 70, 114, 115, 116, 117, 9, 10, 11, 81, 122, 8, 81, 125, 126, 127, 128, 8, 151, 152, 153, 10, 11, 156, 161, 8, 158, 30, 84, 32, 33, 34, 79, 159, 146, 8, 157, 79, 159, 84, 73, 30, 154, 155, 156, 13, 79, 1, 2, 69, 83, 159, 156, 86, 87, 88, 69, 90, 13, 92, 132, 94, 69, 81, 97, 155, 99, 100, 101, 102, 103, 104, 105, 115, 9, 108, 109, 9, 10, 11, 79, 114, 115, 116, 117, 157, 142, 159, 157, 122, 159, 13, 125, 126, 127, 128, 8, 142, 30, 154, 32, 33, 52, 53, 54, 158, 56, 30, 155, 151, 152, 153, 159, 14, 52, 53, 54, 81, 68, 73, 84, 154, 155, 156, 131, 79, 33, 34, 35, 83, 68, 69, 86, 87, 88, 155, 90, 155, 92, 157, 94, 159, 155, 97, 158, 99, 100, 101, 102, 103, 104, 105, 13, 152, 108, 109, 11, 154, 1, 2, 114, 115, 116, 117, 9, 10, 11, 16, 122, 14, 31, 125, 126, 127, 128, 30, 9, 10, 11, 143, 144, 154, 9, 10, 11, 30, 154, 16, 31, 49, 50, 51, 49, 50, 51, 1, 2, 30, 16, 154, 154, 155, 156, 30, 13, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 37, 56, 73, 13, 1, 2, 33, 34, 79, 9, 10, 11, 83, 68, 154, 86, 87, 88, 155, 90, 16, 92, 159, 94, 155, 16, 97, 37, 159, 16, 30, 102, 103, 104, 31, 68, 69, 108, 109, 73, 16, 1, 2, 114, 115, 79, 105, 31, 107, 83, 31, 122, 86, 87, 88, 33, 90, 31, 92, 31, 94, 74, 75, 97, 31, 74, 75, 31, 102, 103, 104, 31, 100, 101, 108, 109, 73, 56, 1, 2, 114, 115, 79, 154, 155, 37, 83, 69, 122, 86, 87, 88, 69, 90, 69, 92, 69, 94, 110, 111, 97, 154, 155, 154, 155, 102, 103, 104, 31, 154, 155, 108, 109, 73, 68, 1, 2, 114, 115, 79, 154, 155, 69, 83, 69, 122, 86, 87, 88, 69, 90, 69, 92, 70, 94, 76, 79, 97, 84, 81, 84, 89, 102, 103, 104, 31, 81, 81, 108, 109, 73, 112, 88, 115, 114, 115, 79, 154, 155, 91, 83, 126, 122, 86, 87, 88, 93, 90, 96, 92, 95, 94, 96, 99, 97, 96, 96, 96, 129, 102, 103, 104, 99, 105, 113, 108, 109, 73, 145, 105, 129, 114, 115, 79, 154, 155, 126, 83, 131, 122, 86, 87, 88, 156, 90, 154, 92, 157, 94, -1, -1, 97, 130, -1, 145, -1, 102, 103, 104, 31, 131, 131, 108, 109, 131, -1, -1, 142, 114, 115, 142, 154, 155, -1, -1, 149, 122, 49, 50, 145, 145, 145, 145, 55, 145, 57, 145, 149, 156, 158, 150, -1, -1, 151, -1, -1, -1, 69, 154, 154, 154, 154, 154, 154, 154, 77, 78, 154, 154, 155, 49, 50, 154, 85, 154, 154, 55, 154, 57, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 69, 154, 154, 154, 154, 159, 155, 155, 77, 78, 155, 155, 155, 155, 155, 155, 85, 155, 155, 155, 155, 155, 155, 162, 156, 156, 156, 156, 156, 156, 156, 133, 156, 135, 136, 137, 138, 139, 140, 141, 156, 156, 156, 156, 156, 147, 148, 156, 156, 156, 156, 156, 156, 156, -1, 157, 156, 156, 156, 156, 156, 156, 156, -1, 133, 157, 135, 136, 137, 138, 139, 140, 141, 157, 157, 157, 157, 157, 147, 148, 157, 157, 157, 157, 157, 157, 157, 157, 157, 157, 157, 157, -1, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, 158, -1, -1, 160, 160, -1, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161);
    protected $actionBase = array(0, 226, 306, 385, 464, 285, 246, 246, 786, -2, -2, 146, -2, -2, -2, 649, 723, 760, 723, 575, 686, 612, 612, 612, 175, 153, 153, 153, 174, 890, 319, 62, 450, 463, 557, 609, 636, 496, 496, 496, 496, 136, 136, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 195, 75, 777, 517, 147, 778, 779, 780, 886, 727, 887, 832, 833, 682, 836, 837, 838, 839, 840, 831, 841, 907, 842, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 483, 573, 365, 209, 281, 407, 646, 646, 646, 646, 646, 646, 646, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 327, 429, 834, 585, 585, 585, 563, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 495, 486, -21, -21, 415, 668, 335, 619, 222, 511, 213, 25, 25, 25, 25, 25, 148, 16, 4, 4, 4, 4, 151, 312, 312, 312, 312, 119, 119, 119, 119, 346, 346, 123, 245, 245, 349, 400, 297, 297, 297, 297, 297, 297, 297, 297, 297, 297, 111, 558, 558, 561, 561, 310, 152, 152, 152, 152, 704, 273, 273, 129, 371, 371, 371, 373, 734, 797, 376, 376, 376, 376, 376, 376, 468, 468, 468, 480, 480, 480, 702, 587, 454, 587, 454, 684, 748, 509, 748, 700, 199, 515, 803, 398, 720, 829, 729, 830, 601, 747, 235, 782, 724, 419, 782, 633, 637, 634, 419, 419, 715, 98, 863, 292, 195, 595, 405, 667, 781, 421, 732, 784, 363, 445, 411, 593, 328, 286, 744, 785, 888, 889, 181, 739, 667, 667, 667, 139, 362, 328, -8, 613, 613, 613, 613, 48, 613, 613, 613, 613, 314, 230, 506, 404, 783, 703, 703, 712, 694, 852, 696, 696, 703, 711, 703, 712, 694, 854, 854, 854, 854, 703, 694, 703, 703, 703, 696, 696, 694, 709, 696, 38, 694, 695, 707, 707, 854, 751, 752, 703, 703, 728, 696, 696, 696, 728, 694, 854, 685, 746, 234, 696, 854, 665, 711, 665, 703, 685, 694, 665, 711, 711, 665, 21, 662, 664, 853, 855, 869, 792, 681, 716, 861, 862, 856, 860, 844, 679, 753, 754, 569, 669, 671, 673, 699, 740, 701, 735, 724, 692, 692, 692, 713, 741, 713, 692, 692, 692, 692, 692, 692, 692, 692, 893, 689, 745, 736, 710, 755, 589, 600, 793, 731, 738, 882, 875, 891, 892, 863, 880, 713, 894, 697, 180, 650, 864, 693, 788, 713, 865, 713, 794, 713, 883, 804, 708, 805, 806, 692, 884, 895, 896, 897, 898, 899, 900, 901, 902, 706, 903, 756, 698, 876, 339, 859, 715, 742, 725, 791, 759, 807, 342, 904, 808, 713, 713, 795, 787, 713, 796, 764, 750, 872, 766, 877, 905, 731, 726, 878, 713, 730, 809, 906, 342, 672, 705, 737, 721, 767, 870, 885, 868, 798, 655, 659, 810, 812, 820, 674, 769, 873, 874, 871, 771, 799, 670, 800, 719, 821, 801, 866, 772, 822, 823, 881, 718, 743, 717, 722, 714, 802, 824, 879, 773, 774, 775, 827, 776, 828, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 136, 136, 136, 136, -2, -2, -2, -2, 0, 0, -2, 0, 0, 0, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 0, 0, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 591, -21, -21, -21, -21, 591, -21, -21, -21, -21, -21, -21, -21, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, 591, -21, 376, 591, 591, 591, -21, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, -21, 591, 0, 0, 591, -21, 591, -21, 591, -21, 591, 591, 591, 591, 591, 591, -21, -21, -21, -21, -21, -21, 0, 468, 468, 468, 468, -21, -21, -21, -21, 376, 376, -37, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 376, 468, 468, 480, 480, 376, 376, 376, 376, 376, -37, 376, 376, 419, 711, 711, 711, 454, 454, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 454, 419, 0, 419, 0, 376, 419, 711, 419, 454, 711, 711, 419, 696, 618, 618, 618, 618, 342, 328, 0, 711, 711, 0, 711, 0, 0, 0, 0, 0, 696, 0, 703, 0, 0, 0, 0, 692, 180, 0, 725, 427, 0, 0, 0, 0, 0, 0, 725, 427, 435, 435, 0, 706, 692, 692, 692, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342);
    protected $actionDefault = array(3, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 534, 534, 489, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 293, 293, 293, 32767, 32767, 32767, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 32767, 32767, 32767, 32767, 32767, 32767, 376, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 382, 539, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 357, 358, 360, 361, 292, 542, 523, 241, 383, 538, 291, 243, 321, 493, 32767, 32767, 32767, 323, 120, 252, 197, 492, 123, 290, 228, 375, 377, 322, 297, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 296, 449, 32767, 354, 353, 352, 451, 486, 486, 489, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 450, 319, 477, 476, 320, 447, 324, 448, 326, 452, 325, 342, 343, 340, 341, 344, 454, 453, 470, 471, 468, 469, 295, 345, 346, 347, 348, 472, 473, 474, 475, 32767, 32767, 276, 533, 533, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 333, 334, 461, 462, 32767, 232, 232, 232, 232, 277, 232, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 328, 329, 327, 456, 457, 455, 423, 32767, 32767, 32767, 425, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 494, 32767, 32767, 32767, 32767, 32767, 507, 412, 32767, 404, 32767, 32767, 216, 218, 165, 32767, 32767, 480, 32767, 32767, 32767, 32767, 32767, 512, 338, 32767, 32767, 114, 32767, 32767, 32767, 549, 32767, 507, 32767, 114, 32767, 32767, 32767, 32767, 351, 330, 331, 332, 32767, 32767, 511, 505, 464, 465, 466, 467, 32767, 458, 459, 460, 463, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 169, 420, 426, 426, 32767, 32767, 32767, 32767, 169, 32767, 32767, 32767, 32767, 32767, 169, 32767, 32767, 32767, 510, 509, 169, 32767, 405, 488, 169, 182, 180, 180, 32767, 202, 202, 32767, 32767, 184, 481, 500, 32767, 184, 169, 32767, 393, 171, 488, 32767, 32767, 234, 32767, 234, 32767, 393, 169, 234, 32767, 32767, 234, 32767, 406, 430, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 372, 373, 483, 496, 32767, 497, 32767, 404, 336, 337, 339, 316, 32767, 318, 362, 363, 364, 365, 366, 367, 368, 370, 32767, 410, 32767, 413, 32767, 32767, 32767, 251, 32767, 547, 32767, 32767, 300, 547, 32767, 32767, 32767, 541, 32767, 32767, 294, 32767, 32767, 32767, 32767, 247, 32767, 167, 32767, 531, 32767, 548, 32767, 505, 32767, 335, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 506, 32767, 32767, 32767, 32767, 223, 32767, 443, 32767, 114, 32767, 32767, 32767, 183, 32767, 32767, 298, 242, 32767, 32767, 540, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 112, 32767, 168, 32767, 32767, 32767, 185, 32767, 32767, 505, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 289, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 505, 32767, 32767, 227, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 406, 32767, 270, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 125, 125, 3, 125, 125, 254, 3, 254, 125, 254, 254, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 210, 213, 202, 202, 162, 125, 125, 262);
    protected $goto = array(165, 139, 139, 139, 165, 143, 146, 140, 141, 142, 148, 186, 167, 162, 162, 162, 162, 143, 143, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 137, 158, 159, 160, 161, 183, 138, 184, 489, 490, 367, 491, 495, 496, 497, 498, 499, 500, 501, 502, 959, 163, 144, 145, 147, 170, 175, 185, 203, 251, 254, 256, 258, 260, 261, 262, 263, 264, 265, 273, 274, 275, 276, 299, 300, 324, 325, 326, 384, 385, 386, 538, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 149, 150, 151, 166, 152, 168, 153, 204, 169, 154, 155, 156, 205, 157, 135, 616, 556, 574, 578, 622, 624, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 1099, 515, 345, 571, 600, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 1099, 504, 1202, 1202, 1075, 1074, 504, 540, 541, 542, 543, 544, 545, 546, 547, 549, 582, 3, 4, 173, 1202, 844, 844, 844, 844, 839, 845, 176, 177, 178, 391, 392, 393, 394, 172, 201, 206, 250, 255, 257, 259, 266, 267, 268, 269, 270, 271, 277, 278, 279, 280, 301, 302, 327, 328, 329, 396, 397, 398, 399, 174, 179, 252, 253, 180, 181, 182, 493, 493, 750, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 493, 505, 929, 442, 444, 627, 505, 751, 779, 1100, 610, 927, 880, 880, 765, 1190, 1190, 1168, 555, 775, 764, 743, 1168, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 555, 390, 602, 746, 532, 532, 564, 528, 530, 530, 492, 494, 520, 536, 565, 568, 579, 586, 810, 606, 506, 346, 347, 609, 850, 506, 365, 537, 746, 533, 746, 563, 430, 430, 375, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 430, 1063, 581, 957, 596, 597, 1063, 887, 887, 887, 887, 1160, 887, 887, 1182, 1182, 1182, 376, 376, 376, 749, 1063, 1063, 1063, 1063, 1063, 1063, 334, 1056, 317, 374, 374, 374, 866, 848, 846, 848, 650, 461, 507, 875, 870, 376, 1194, 368, 374, 389, 374, 898, 374, 1080, 583, 348, 404, 374, 1216, 590, 601, 1017, 19, 15, 361, 1148, 1187, 525, 936, 904, 510, 526, 904, 651, 551, 381, 1201, 1201, 587, 1007, 550, 877, 607, 608, 873, 612, 613, 619, 621, 626, 628, 23, 884, 937, 1201, 336, 598, 1059, 1060, 1204, 378, 1056, 557, 539, 893, 768, 766, 379, 514, 902, 509, 524, 655, 1057, 1159, 1057, 776, 509, 1167, 524, 514, 514, 1058, 1167, 1049, 907, 508, 1054, 511, 433, 434, 510, 1184, 1184, 1184, 854, 445, 945, 569, 1145, 459, 362, 0, 0, 773, 1209, 0, 518, 0, 519, 0, 529, 0, 0, 0, 0, 0, 1166, 0, 0, 0, 771, 0, 0, 0, 449, 0, 0, 0, 0, 0, 0, 605, 0, 0, 0, 0, 13, 1055, 614);
    protected $gotoCheck = array(42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 56, 66, 59, 59, 59, 8, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 124, 99, 69, 39, 39, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 66, 140, 140, 122, 122, 66, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 29, 29, 26, 140, 66, 66, 66, 66, 66, 66, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 115, 115, 14, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 7, 7, 7, 7, 115, 15, 28, 7, 7, 7, 74, 74, 22, 74, 74, 116, 56, 22, 22, 5, 116, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 50, 50, 10, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 49, 60, 120, 69, 69, 60, 32, 120, 60, 2, 10, 107, 10, 2, 56, 56, 10, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 64, 99, 64, 64, 56, 56, 56, 56, 56, 79, 56, 56, 8, 8, 8, 121, 121, 121, 13, 56, 56, 56, 56, 56, 56, 123, 79, 123, 12, 12, 12, 13, 13, 13, 13, 13, 56, 13, 13, 13, 121, 138, 45, 12, 121, 12, 81, 12, 33, 67, 67, 67, 12, 12, 125, 48, 33, 33, 33, 33, 129, 136, 8, 95, 12, 12, 31, 12, 31, 31, 47, 139, 139, 31, 100, 33, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 33, 76, 95, 139, 17, 33, 79, 79, 139, 11, 79, 11, 46, 78, 24, 23, 16, 46, 82, 8, 8, 71, 79, 79, 79, 25, 8, 117, 8, 46, 46, 79, 117, 111, 83, 8, 113, 8, 8, 8, 12, 117, 117, 117, 68, 62, 97, 63, 128, 106, 57, -1, -1, 8, 8, -1, 57, -1, 99, -1, 57, -1, -1, -1, -1, -1, 117, -1, -1, -1, 8, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, 57, 12, 12);
    protected $gotoBase = array(0, 0, -249, 0, 0, 300, 0, 287, 105, 0, 47, 164, 118, 421, 274, 295, 171, 184, 0, 0, 0, 0, -49, 168, 172, 104, 24, 0, 288, -431, 0, -159, 359, 44, 0, 0, 0, 0, 0, 125, 0, 0, -24, 0, 0, 407, 479, 186, 178, 355, 75, 0, 0, 0, 0, 0, 106, 119, 0, -192, -81, 0, 101, 93, -231, 0, -90, 135, 121, -276, 0, 148, 0, 0, 21, 0, 183, 0, 194, 71, 0, 423, 155, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 185, 0, 122, 0, 120, 176, 0, 0, 0, 0, 0, 83, 358, 170, 0, 0, 113, 0, 111, 0, -7, 9, 220, 0, 0, 77, 108, -102, 100, -42, 251, 0, 0, 89, 256, 0, 0, 0, 0, 0, 0, 181, 0, 419, 160, -107, 0, 0);
    protected $gotoDefault = array(-32768, 463, 659, 2, 660, 733, 741, 593, 477, 625, 577, 370, 1178, 785, 786, 787, 371, 358, 478, 369, 400, 395, 774, 767, 769, 777, 171, 401, 780, 1, 782, 513, 818, 1008, 355, 790, 356, 585, 792, 522, 794, 795, 136, 372, 373, 523, 479, 380, 572, 809, 272, 377, 811, 357, 812, 821, 360, 460, 454, 552, 604, 425, 441, 566, 560, 531, 1072, 561, 853, 344, 861, 656, 869, 872, 480, 553, 883, 446, 891, 1085, 387, 897, 903, 908, 283, 911, 407, 402, 580, 916, 917, 5, 921, 617, 618, 8, 308, 944, 594, 958, 411, 1027, 1029, 481, 482, 517, 453, 503, 521, 483, 1050, 435, 403, 1053, 484, 485, 426, 427, 1069, 350, 1153, 349, 443, 316, 1140, 575, 1104, 450, 1193, 1149, 343, 486, 487, 366, 1172, 382, 1188, 431, 1195, 1203, 339, 535, 562);
    protected $ruleToNonTerminal = array(0, 1, 3, 3, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 9, 10, 10, 11, 11, 12, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 17, 17, 18, 18, 20, 20, 16, 16, 21, 21, 22, 22, 23, 23, 24, 24, 19, 19, 25, 27, 27, 28, 29, 29, 31, 30, 30, 30, 30, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 13, 13, 53, 53, 55, 54, 54, 47, 47, 57, 57, 58, 58, 14, 15, 15, 15, 61, 61, 61, 62, 62, 65, 65, 63, 63, 67, 67, 40, 40, 49, 49, 52, 52, 52, 51, 51, 68, 41, 41, 41, 41, 69, 69, 70, 70, 71, 71, 38, 38, 34, 34, 72, 36, 36, 73, 35, 35, 37, 37, 48, 48, 48, 59, 59, 75, 75, 76, 76, 78, 78, 78, 77, 77, 60, 60, 79, 79, 79, 80, 80, 81, 81, 81, 43, 43, 82, 82, 82, 44, 44, 83, 83, 84, 84, 64, 85, 85, 85, 85, 90, 90, 91, 91, 92, 92, 92, 92, 92, 93, 94, 94, 89, 89, 86, 86, 88, 88, 96, 96, 95, 95, 95, 95, 95, 95, 87, 87, 98, 97, 97, 45, 45, 39, 39, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 33, 33, 46, 46, 103, 103, 104, 104, 104, 104, 110, 99, 99, 106, 106, 112, 112, 113, 114, 114, 114, 114, 114, 114, 66, 66, 56, 56, 56, 56, 100, 100, 118, 118, 115, 115, 119, 119, 119, 119, 101, 101, 101, 105, 105, 105, 111, 111, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 26, 26, 26, 26, 26, 26, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, 109, 109, 102, 102, 102, 102, 125, 125, 128, 128, 127, 127, 129, 129, 50, 50, 50, 50, 131, 131, 130, 130, 130, 130, 130, 132, 132, 117, 117, 120, 120, 116, 116, 134, 133, 133, 133, 133, 121, 121, 121, 121, 108, 108, 122, 122, 122, 122, 74, 135, 135, 136, 136, 136, 107, 107, 137, 137, 138, 138, 138, 138, 138, 123, 123, 123, 123, 140, 141, 139, 139, 139, 139, 139, 139, 139, 142, 142, 142);
    protected $ruleToLength = array(1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 5, 4, 3, 4, 2, 3, 1, 1, 7, 6, 3, 1, 3, 1, 3, 1, 1, 3, 1, 3, 1, 2, 3, 1, 3, 3, 1, 3, 2, 0, 1, 1, 1, 1, 1, 3, 5, 8, 3, 5, 9, 3, 2, 3, 2, 3, 2, 3, 3, 3, 3, 1, 2, 2, 5, 7, 9, 5, 6, 3, 3, 2, 2, 1, 1, 1, 0, 2, 8, 0, 4, 1, 3, 0, 1, 0, 1, 10, 7, 6, 5, 1, 2, 2, 0, 2, 0, 2, 0, 2, 1, 3, 1, 4, 1, 4, 1, 1, 4, 1, 3, 3, 3, 4, 4, 5, 0, 2, 4, 3, 1, 1, 1, 4, 0, 2, 3, 0, 2, 4, 0, 2, 0, 3, 1, 2, 1, 1, 0, 1, 3, 4, 6, 1, 1, 1, 0, 1, 0, 2, 2, 3, 3, 1, 3, 1, 2, 2, 3, 1, 1, 2, 4, 3, 1, 1, 3, 2, 0, 1, 3, 3, 9, 3, 1, 3, 0, 2, 4, 5, 4, 4, 4, 3, 1, 1, 1, 3, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 3, 3, 1, 0, 1, 1, 3, 3, 4, 4, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 5, 4, 3, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 3, 2, 1, 2, 10, 11, 3, 3, 2, 4, 4, 3, 4, 4, 4, 4, 7, 3, 2, 0, 4, 1, 3, 2, 2, 4, 6, 2, 2, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 4, 4, 0, 2, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 1, 3, 1, 4, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 4, 4, 3, 1, 3, 1, 1, 3, 3, 0, 2, 0, 1, 3, 1, 3, 1, 1, 1, 1, 1, 6, 4, 3, 4, 2, 4, 4, 1, 3, 1, 2, 1, 1, 4, 1, 1, 3, 6, 4, 4, 4, 4, 1, 4, 0, 1, 1, 3, 1, 1, 4, 3, 1, 1, 1, 0, 0, 2, 3, 1, 3, 1, 4, 2, 2, 2, 2, 1, 2, 1, 1, 1, 4, 3, 3, 3, 6, 3, 1, 1, 1);
    protected function initReduceCallbacks()
    {
        $this->reduceCallbacks = [0 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 1 => function ($stackPos) {
            $this->semValue = $this->handleNamespaces($this->semStack[$stackPos - (1 - 1)]);
        }, 2 => function ($stackPos) {
            if (\is_array($this->semStack[$stackPos - (2 - 2)])) {
                $this->semValue = \array_merge($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)]);
            } else {
                $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
                $this->semValue = $this->semStack[$stackPos - (2 - 1)];
            }
        }, 3 => function ($stackPos) {
            $this->semValue = array();
        }, 4 => function ($stackPos) {
            $startAttributes = $this->lookaheadStartAttributes;
            if (isset($startAttributes['comments'])) {
                $nop = new \PHPUnit\PhpParser\Node\Stmt\Nop($this->createCommentNopAttributes($startAttributes['comments']));
            } else {
                $nop = null;
            }
            if ($nop !== null) {
                $this->semStack[$stackPos - (1 - 1)][] = $nop;
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 5 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 6 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 7 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 8 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 9 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 10 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 11 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 12 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 13 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 14 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 15 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 16 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 17 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 18 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 19 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 20 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 21 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 22 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 23 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 24 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 25 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 26 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 27 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 28 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 29 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 30 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 31 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 32 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 33 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 34 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 35 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 36 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 37 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 38 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 39 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 40 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 41 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 42 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 43 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 44 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 45 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 46 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 47 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 48 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 49 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 50 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 51 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 52 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 53 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 54 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 55 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 56 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 57 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 58 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 59 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 60 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 61 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 62 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 63 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 64 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 65 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 66 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 67 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 68 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 69 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 70 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 71 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 72 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 73 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 74 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 75 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 76 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 77 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 78 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 79 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 80 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 81 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 82 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 83 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 84 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 85 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 86 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 87 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 88 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 89 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 90 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 91 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 92 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 93 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 94 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\HaltCompiler($this->lexer->handleHaltCompiler(), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 95 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Namespace_($this->semStack[$stackPos - (3 - 2)], null, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->semValue->setAttribute('kind', \PHPUnit\PhpParser\Node\Stmt\Namespace_::KIND_SEMICOLON);
            $this->checkNamespace($this->semValue);
        }, 96 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Namespace_($this->semStack[$stackPos - (5 - 2)], $this->semStack[$stackPos - (5 - 4)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
            $this->semValue->setAttribute('kind', \PHPUnit\PhpParser\Node\Stmt\Namespace_::KIND_BRACED);
            $this->checkNamespace($this->semValue);
        }, 97 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Namespace_(null, $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
            $this->semValue->setAttribute('kind', \PHPUnit\PhpParser\Node\Stmt\Namespace_::KIND_BRACED);
            $this->checkNamespace($this->semValue);
        }, 98 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Use_($this->semStack[$stackPos - (3 - 2)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 99 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Use_($this->semStack[$stackPos - (4 - 3)], $this->semStack[$stackPos - (4 - 2)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 100 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 101 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Const_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 102 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION;
        }, 103 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT;
        }, 104 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\GroupUse($this->semStack[$stackPos - (7 - 3)], $this->semStack[$stackPos - (7 - 6)], $this->semStack[$stackPos - (7 - 2)], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
        }, 105 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\GroupUse($this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 5)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 106 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 107 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 108 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 109 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 110 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 111 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 112 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (1 - 1)], null, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (1 - 1));
        }, 113 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (3 - 3));
        }, 114 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (1 - 1)], null, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (1 - 1));
        }, 115 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (3 - 3));
        }, 116 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
            $this->semValue->type = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL;
        }, 117 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue->type = $this->semStack[$stackPos - (2 - 1)];
        }, 118 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 119 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 120 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Const_($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 121 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 122 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 123 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Const_($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 124 => function ($stackPos) {
            if (\is_array($this->semStack[$stackPos - (2 - 2)])) {
                $this->semValue = \array_merge($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)]);
            } else {
                $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
                $this->semValue = $this->semStack[$stackPos - (2 - 1)];
            }
        }, 125 => function ($stackPos) {
            $this->semValue = array();
        }, 126 => function ($stackPos) {
            $startAttributes = $this->lookaheadStartAttributes;
            if (isset($startAttributes['comments'])) {
                $nop = new \PHPUnit\PhpParser\Node\Stmt\Nop($this->createCommentNopAttributes($startAttributes['comments']));
            } else {
                $nop = null;
            }
            if ($nop !== null) {
                $this->semStack[$stackPos - (1 - 1)][] = $nop;
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 127 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 128 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 129 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 130 => function ($stackPos) {
            throw new \PHPUnit\PhpParser\Error('__HALT_COMPILER() can only be used from the outermost scope', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 131 => function ($stackPos) {
            if ($this->semStack[$stackPos - (3 - 2)]) {
                $this->semValue = $this->semStack[$stackPos - (3 - 2)];
                $attrs = $this->startAttributeStack[$stackPos - (3 - 1)];
                $stmts = $this->semValue;
                if (!empty($attrs['comments'])) {
                    $stmts[0]->setAttribute('comments', \array_merge($attrs['comments'], $stmts[0]->getAttribute('comments', [])));
                }
            } else {
                $startAttributes = $this->startAttributeStack[$stackPos - (3 - 1)];
                if (isset($startAttributes['comments'])) {
                    $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Nop($startAttributes + $this->endAttributes);
                } else {
                    $this->semValue = null;
                }
                if (null === $this->semValue) {
                    $this->semValue = array();
                }
            }
        }, 132 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\If_($this->semStack[$stackPos - (5 - 2)], ['stmts' => \is_array($this->semStack[$stackPos - (5 - 3)]) ? $this->semStack[$stackPos - (5 - 3)] : array($this->semStack[$stackPos - (5 - 3)]), 'elseifs' => $this->semStack[$stackPos - (5 - 4)], 'else' => $this->semStack[$stackPos - (5 - 5)]], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 133 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\If_($this->semStack[$stackPos - (8 - 2)], ['stmts' => $this->semStack[$stackPos - (8 - 4)], 'elseifs' => $this->semStack[$stackPos - (8 - 5)], 'else' => $this->semStack[$stackPos - (8 - 6)]], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
        }, 134 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\While_($this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 135 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Do_($this->semStack[$stackPos - (5 - 4)], \is_array($this->semStack[$stackPos - (5 - 2)]) ? $this->semStack[$stackPos - (5 - 2)] : array($this->semStack[$stackPos - (5 - 2)]), $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 136 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\For_(['init' => $this->semStack[$stackPos - (9 - 3)], 'cond' => $this->semStack[$stackPos - (9 - 5)], 'loop' => $this->semStack[$stackPos - (9 - 7)], 'stmts' => $this->semStack[$stackPos - (9 - 9)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 137 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Switch_($this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 138 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Break_(null, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 139 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Break_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 140 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Continue_(null, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 141 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Continue_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 142 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Return_(null, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 143 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Return_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 144 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Global_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 145 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Static_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 146 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Echo_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 147 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\InlineHTML($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 148 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Expression($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 149 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Expression($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 150 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Unset_($this->semStack[$stackPos - (5 - 3)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 151 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Foreach_($this->semStack[$stackPos - (7 - 3)], $this->semStack[$stackPos - (7 - 5)][0], ['keyVar' => null, 'byRef' => $this->semStack[$stackPos - (7 - 5)][1], 'stmts' => $this->semStack[$stackPos - (7 - 7)]], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
        }, 152 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Foreach_($this->semStack[$stackPos - (9 - 3)], $this->semStack[$stackPos - (9 - 7)][0], ['keyVar' => $this->semStack[$stackPos - (9 - 5)], 'byRef' => $this->semStack[$stackPos - (9 - 7)][1], 'stmts' => $this->semStack[$stackPos - (9 - 9)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 153 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Declare_($this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 5)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 154 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TryCatch($this->semStack[$stackPos - (6 - 3)], $this->semStack[$stackPos - (6 - 5)], $this->semStack[$stackPos - (6 - 6)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
            $this->checkTryCatch($this->semValue);
        }, 155 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Throw_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 156 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Goto_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 157 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Label($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 158 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Expression($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 159 => function ($stackPos) {
            $this->semValue = array();
            /* means: no statement */
        }, 160 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 161 => function ($stackPos) {
            $startAttributes = $this->startAttributeStack[$stackPos - (1 - 1)];
            if (isset($startAttributes['comments'])) {
                $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Nop($startAttributes + $this->endAttributes);
            } else {
                $this->semValue = null;
            }
            if ($this->semValue === null) {
                $this->semValue = array();
            }
            /* means: no statement */
        }, 162 => function ($stackPos) {
            $this->semValue = array();
        }, 163 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 164 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Catch_(array($this->semStack[$stackPos - (8 - 3)]), $this->semStack[$stackPos - (8 - 4)], $this->semStack[$stackPos - (8 - 7)], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
        }, 165 => function ($stackPos) {
            $this->semValue = null;
        }, 166 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Finally_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 167 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 168 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 169 => function ($stackPos) {
            $this->semValue = \false;
        }, 170 => function ($stackPos) {
            $this->semValue = \true;
        }, 171 => function ($stackPos) {
            $this->semValue = \false;
        }, 172 => function ($stackPos) {
            $this->semValue = \true;
        }, 173 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Function_($this->semStack[$stackPos - (10 - 3)], ['byRef' => $this->semStack[$stackPos - (10 - 2)], 'params' => $this->semStack[$stackPos - (10 - 5)], 'returnType' => $this->semStack[$stackPos - (10 - 7)], 'stmts' => $this->semStack[$stackPos - (10 - 9)]], $this->startAttributeStack[$stackPos - (10 - 1)] + $this->endAttributes);
        }, 174 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Class_($this->semStack[$stackPos - (7 - 2)], ['type' => $this->semStack[$stackPos - (7 - 1)], 'extends' => $this->semStack[$stackPos - (7 - 3)], 'implements' => $this->semStack[$stackPos - (7 - 4)], 'stmts' => $this->semStack[$stackPos - (7 - 6)]], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
            $this->checkClass($this->semValue, $stackPos - (7 - 2));
        }, 175 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Interface_($this->semStack[$stackPos - (6 - 2)], ['extends' => $this->semStack[$stackPos - (6 - 3)], 'stmts' => $this->semStack[$stackPos - (6 - 5)]], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
            $this->checkInterface($this->semValue, $stackPos - (6 - 2));
        }, 176 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Trait_($this->semStack[$stackPos - (5 - 2)], ['stmts' => $this->semStack[$stackPos - (5 - 4)]], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 177 => function ($stackPos) {
            $this->semValue = 0;
        }, 178 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT;
        }, 179 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL;
        }, 180 => function ($stackPos) {
            $this->semValue = null;
        }, 181 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 182 => function ($stackPos) {
            $this->semValue = array();
        }, 183 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 184 => function ($stackPos) {
            $this->semValue = array();
        }, 185 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 186 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 187 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 188 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 189 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 190 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 191 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 192 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 193 => function ($stackPos) {
            $this->semValue = null;
        }, 194 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 195 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 196 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 197 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\DeclareDeclare($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 198 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 199 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 3)];
        }, 200 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 201 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (5 - 3)];
        }, 202 => function ($stackPos) {
            $this->semValue = array();
        }, 203 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 204 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Case_($this->semStack[$stackPos - (4 - 2)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 205 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Case_(null, $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 206 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 207 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 208 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 209 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 210 => function ($stackPos) {
            $this->semValue = array();
        }, 211 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 212 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ElseIf_($this->semStack[$stackPos - (3 - 2)], \is_array($this->semStack[$stackPos - (3 - 3)]) ? $this->semStack[$stackPos - (3 - 3)] : array($this->semStack[$stackPos - (3 - 3)]), $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 213 => function ($stackPos) {
            $this->semValue = array();
        }, 214 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 215 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ElseIf_($this->semStack[$stackPos - (4 - 2)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 216 => function ($stackPos) {
            $this->semValue = null;
        }, 217 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Else_(\is_array($this->semStack[$stackPos - (2 - 2)]) ? $this->semStack[$stackPos - (2 - 2)] : array($this->semStack[$stackPos - (2 - 2)]), $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 218 => function ($stackPos) {
            $this->semValue = null;
        }, 219 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Else_($this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 220 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)], \false);
        }, 221 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (2 - 2)], \true);
        }, 222 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)], \false);
        }, 223 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 224 => function ($stackPos) {
            $this->semValue = array();
        }, 225 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 226 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 227 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Param($this->semStack[$stackPos - (4 - 4)], null, $this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 2)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
            $this->checkParam($this->semValue);
        }, 228 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Param($this->semStack[$stackPos - (6 - 4)], $this->semStack[$stackPos - (6 - 6)], $this->semStack[$stackPos - (6 - 1)], $this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 3)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
            $this->checkParam($this->semValue);
        }, 229 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 230 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier('array', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 231 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier('callable', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 232 => function ($stackPos) {
            $this->semValue = null;
        }, 233 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 234 => function ($stackPos) {
            $this->semValue = null;
        }, 235 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 236 => function ($stackPos) {
            $this->semValue = array();
        }, 237 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 238 => function ($stackPos) {
            $this->semValue = array(new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (3 - 2)], \false, \false, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes));
        }, 239 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 240 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 241 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (1 - 1)], \false, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 242 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (2 - 2)], \true, \false, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 243 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (2 - 2)], \false, \true, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 244 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 245 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 246 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 247 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 248 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 249 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 250 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 251 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\StaticVar($this->semStack[$stackPos - (1 - 1)], null, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 252 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\StaticVar($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 253 => function ($stackPos) {
            if ($this->semStack[$stackPos - (2 - 2)] !== null) {
                $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
                $this->semValue = $this->semStack[$stackPos - (2 - 1)];
            }
        }, 254 => function ($stackPos) {
            $this->semValue = array();
        }, 255 => function ($stackPos) {
            $startAttributes = $this->lookaheadStartAttributes;
            if (isset($startAttributes['comments'])) {
                $nop = new \PHPUnit\PhpParser\Node\Stmt\Nop($this->createCommentNopAttributes($startAttributes['comments']));
            } else {
                $nop = null;
            }
            if ($nop !== null) {
                $this->semStack[$stackPos - (1 - 1)][] = $nop;
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 256 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Property($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->checkProperty($this->semValue, $stackPos - (3 - 1));
        }, 257 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ClassConst($this->semStack[$stackPos - (3 - 2)], 0, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 258 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ClassMethod($this->semStack[$stackPos - (9 - 4)], ['type' => $this->semStack[$stackPos - (9 - 1)], 'byRef' => $this->semStack[$stackPos - (9 - 3)], 'params' => $this->semStack[$stackPos - (9 - 6)], 'returnType' => $this->semStack[$stackPos - (9 - 8)], 'stmts' => $this->semStack[$stackPos - (9 - 9)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
            $this->checkClassMethod($this->semValue, $stackPos - (9 - 1));
        }, 259 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUse($this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 260 => function ($stackPos) {
            $this->semValue = array();
        }, 261 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 262 => function ($stackPos) {
            $this->semValue = array();
        }, 263 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 264 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Precedence($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 265 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (5 - 1)][0], $this->semStack[$stackPos - (5 - 1)][1], $this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 4)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 266 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], $this->semStack[$stackPos - (4 - 3)], null, $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 267 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], null, $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 268 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], null, $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 269 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)]);
        }, 270 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 271 => function ($stackPos) {
            $this->semValue = array(null, $this->semStack[$stackPos - (1 - 1)]);
        }, 272 => function ($stackPos) {
            $this->semValue = null;
        }, 273 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 274 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 275 => function ($stackPos) {
            $this->semValue = 0;
        }, 276 => function ($stackPos) {
            $this->semValue = 0;
        }, 277 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 278 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 279 => function ($stackPos) {
            $this->checkModifier($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $stackPos - (2 - 2));
            $this->semValue = $this->semStack[$stackPos - (2 - 1)] | $this->semStack[$stackPos - (2 - 2)];
        }, 280 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC;
        }, 281 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED;
        }, 282 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE;
        }, 283 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC;
        }, 284 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT;
        }, 285 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL;
        }, 286 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 287 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 288 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\VarLikeIdentifier(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 289 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\PropertyProperty($this->semStack[$stackPos - (1 - 1)], null, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 290 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\PropertyProperty($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 291 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 292 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 293 => function ($stackPos) {
            $this->semValue = array();
        }, 294 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 295 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 296 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Assign($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 297 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Assign($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 298 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignRef($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 299 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignRef($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 300 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 301 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Clone_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 302 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Plus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 303 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Minus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 304 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Mul($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 305 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Div($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 306 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Concat($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 307 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Mod($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 308 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 309 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 310 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 311 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftLeft($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 312 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftRight($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 313 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Pow($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 314 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Coalesce($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 315 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PostInc($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 316 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PreInc($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 317 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PostDec($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 318 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PreDec($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 319 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 320 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 321 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 322 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 323 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 324 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 325 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 326 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 327 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 328 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Plus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 329 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Minus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 330 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mul($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 331 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Div($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 332 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mod($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 333 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftLeft($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 334 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftRight($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 335 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Pow($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 336 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\UnaryPlus($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 337 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\UnaryMinus($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 338 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BooleanNot($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 339 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BitwiseNot($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 340 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Identical($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 341 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotIdentical($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 342 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Equal($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 343 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 344 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Spaceship($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 345 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Smaller($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 346 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 347 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Greater($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 348 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 349 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Instanceof_($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 350 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 351 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 352 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Ternary($this->semStack[$stackPos - (5 - 1)], $this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 5)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 353 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Ternary($this->semStack[$stackPos - (4 - 1)], null, $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 354 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Coalesce($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 355 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Isset_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 356 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Empty_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 357 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 358 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE_ONCE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 359 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Eval_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 360 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 361 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE_ONCE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 362 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Int_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 363 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes;
            $attrs['kind'] = $this->getFloatCastKind($this->semStack[$stackPos - (2 - 1)]);
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Double($this->semStack[$stackPos - (2 - 2)], $attrs);
        }, 364 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\String_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 365 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Array_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 366 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Object_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 367 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Bool_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 368 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Unset_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 369 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes;
            $attrs['kind'] = \strtolower($this->semStack[$stackPos - (2 - 1)]) === 'exit' ? \PHPUnit\PhpParser\Node\Expr\Exit_::KIND_EXIT : \PHPUnit\PhpParser\Node\Expr\Exit_::KIND_DIE;
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Exit_($this->semStack[$stackPos - (2 - 2)], $attrs);
        }, 370 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ErrorSuppress($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 371 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 372 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 373 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 374 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ShellExec($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 375 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Print_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 376 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Yield_(null, null, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 377 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\YieldFrom($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 378 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Closure(['static' => \false, 'byRef' => $this->semStack[$stackPos - (10 - 2)], 'params' => $this->semStack[$stackPos - (10 - 4)], 'uses' => $this->semStack[$stackPos - (10 - 6)], 'returnType' => $this->semStack[$stackPos - (10 - 7)], 'stmts' => $this->semStack[$stackPos - (10 - 9)]], $this->startAttributeStack[$stackPos - (10 - 1)] + $this->endAttributes);
        }, 379 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Closure(['static' => \true, 'byRef' => $this->semStack[$stackPos - (11 - 3)], 'params' => $this->semStack[$stackPos - (11 - 5)], 'uses' => $this->semStack[$stackPos - (11 - 7)], 'returnType' => $this->semStack[$stackPos - (11 - 8)], 'stmts' => $this->semStack[$stackPos - (11 - 10)]], $this->startAttributeStack[$stackPos - (11 - 1)] + $this->endAttributes);
        }, 380 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 381 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 382 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Yield_($this->semStack[$stackPos - (2 - 2)], null, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 383 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Yield_($this->semStack[$stackPos - (4 - 4)], $this->semStack[$stackPos - (4 - 2)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 384 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes;
            $attrs['kind'] = \PHPUnit\PhpParser\Node\Expr\Array_::KIND_LONG;
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Array_($this->semStack[$stackPos - (4 - 3)], $attrs);
        }, 385 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes;
            $attrs['kind'] = \PHPUnit\PhpParser\Node\Expr\Array_::KIND_SHORT;
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Array_($this->semStack[$stackPos - (3 - 2)], $attrs);
        }, 386 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 387 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes;
            $attrs['kind'] = $this->semStack[$stackPos - (4 - 1)][0] === "'" || $this->semStack[$stackPos - (4 - 1)][1] === "'" && ($this->semStack[$stackPos - (4 - 1)][0] === 'b' || $this->semStack[$stackPos - (4 - 1)][0] === 'B') ? \PHPUnit\PhpParser\Node\Scalar\String_::KIND_SINGLE_QUOTED : \PHPUnit\PhpParser\Node\Scalar\String_::KIND_DOUBLE_QUOTED;
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch(new \PHPUnit\PhpParser\Node\Scalar\String_(\PHPUnit\PhpParser\Node\Scalar\String_::parse($this->semStack[$stackPos - (4 - 1)]), $attrs), $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 388 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 389 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 390 => function ($stackPos) {
            $this->semValue = array(new \PHPUnit\PhpParser\Node\Stmt\Class_(null, ['type' => 0, 'extends' => $this->semStack[$stackPos - (7 - 3)], 'implements' => $this->semStack[$stackPos - (7 - 4)], 'stmts' => $this->semStack[$stackPos - (7 - 6)]], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes), $this->semStack[$stackPos - (7 - 2)]);
            $this->checkClass($this->semValue[0], -1);
        }, 391 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\New_($this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 392 => function ($stackPos) {
            list($class, $ctorArgs) = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\New_($class, $ctorArgs, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 393 => function ($stackPos) {
            $this->semValue = array();
        }, 394 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 3)];
        }, 395 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 396 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 397 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ClosureUse($this->semStack[$stackPos - (2 - 2)], $this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 398 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\FuncCall($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 399 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticCall($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 400 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticCall($this->semStack[$stackPos - (6 - 1)], $this->semStack[$stackPos - (6 - 4)], $this->semStack[$stackPos - (6 - 6)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 401 => function ($stackPos) {
            $this->semValue = $this->fixupPhp5StaticPropCall($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 402 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\FuncCall($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 403 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 404 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 405 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 406 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 407 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 408 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name\FullyQualified(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 409 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name\Relative(\substr($this->semStack[$stackPos - (1 - 1)], 10), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 410 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 411 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 412 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 413 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 414 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 415 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 416 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 417 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 418 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 419 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 420 => function ($stackPos) {
            $this->semValue = null;
        }, 421 => function ($stackPos) {
            $this->semValue = null;
        }, 422 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 423 => function ($stackPos) {
            $this->semValue = array();
        }, 424 => function ($stackPos) {
            $this->semValue = array(new \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart(\PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($this->semStack[$stackPos - (1 - 1)], '`', \false), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes));
        }, 425 => function ($stackPos) {
            foreach ($this->semStack[$stackPos - (1 - 1)] as $s) {
                if ($s instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart) {
                    $s->value = \PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($s->value, '`', \false);
                }
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 426 => function ($stackPos) {
            $this->semValue = array();
        }, 427 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 428 => function ($stackPos) {
            $this->semValue = $this->parseLNumber($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes, \true);
        }, 429 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\DNumber(\PHPUnit\PhpParser\Node\Scalar\DNumber::parse($this->semStack[$stackPos - (1 - 1)]), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 430 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes;
            $attrs['kind'] = $this->semStack[$stackPos - (1 - 1)][0] === "'" || $this->semStack[$stackPos - (1 - 1)][1] === "'" && ($this->semStack[$stackPos - (1 - 1)][0] === 'b' || $this->semStack[$stackPos - (1 - 1)][0] === 'B') ? \PHPUnit\PhpParser\Node\Scalar\String_::KIND_SINGLE_QUOTED : \PHPUnit\PhpParser\Node\Scalar\String_::KIND_DOUBLE_QUOTED;
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\String_(\PHPUnit\PhpParser\Node\Scalar\String_::parse($this->semStack[$stackPos - (1 - 1)], \false), $attrs);
        }, 431 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Line($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 432 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\File($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 433 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Dir($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 434 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Class_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 435 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Trait_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 436 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Method($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 437 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Function_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 438 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Namespace_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 439 => function ($stackPos) {
            $this->semValue = $this->parseDocString($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes, $this->startAttributeStack[$stackPos - (3 - 3)] + $this->endAttributeStack[$stackPos - (3 - 3)], \false);
        }, 440 => function ($stackPos) {
            $this->semValue = $this->parseDocString($this->semStack[$stackPos - (2 - 1)], '', $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes, $this->startAttributeStack[$stackPos - (2 - 2)] + $this->endAttributeStack[$stackPos - (2 - 2)], \false);
        }, 441 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 442 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ClassConstFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 443 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ConstFetch($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 444 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Array_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 445 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Array_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 446 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 447 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 448 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 449 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 450 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 451 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 452 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 453 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 454 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 455 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 456 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Plus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 457 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Minus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 458 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mul($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 459 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Div($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 460 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mod($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 461 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftLeft($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 462 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftRight($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 463 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Pow($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 464 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\UnaryPlus($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 465 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\UnaryMinus($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 466 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BooleanNot($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 467 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BitwiseNot($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 468 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Identical($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 469 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotIdentical($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 470 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Equal($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 471 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 472 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Smaller($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 473 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 474 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Greater($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 475 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 476 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Ternary($this->semStack[$stackPos - (5 - 1)], $this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 5)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 477 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Ternary($this->semStack[$stackPos - (4 - 1)], null, $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 478 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 479 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 480 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ConstFetch($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 481 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ClassConstFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 482 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 483 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 484 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes;
            $attrs['kind'] = \PHPUnit\PhpParser\Node\Scalar\String_::KIND_DOUBLE_QUOTED;
            foreach ($this->semStack[$stackPos - (3 - 2)] as $s) {
                if ($s instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart) {
                    $s->value = \PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($s->value, '"', \true);
                }
            }
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\Encapsed($this->semStack[$stackPos - (3 - 2)], $attrs);
        }, 485 => function ($stackPos) {
            $this->semValue = $this->parseDocString($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes, $this->startAttributeStack[$stackPos - (3 - 3)] + $this->endAttributeStack[$stackPos - (3 - 3)], \true);
        }, 486 => function ($stackPos) {
            $this->semValue = array();
        }, 487 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 488 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 489 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 490 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 491 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 492 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (3 - 3)], $this->semStack[$stackPos - (3 - 1)], \false, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 493 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (1 - 1)], null, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 494 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 495 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 496 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 497 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 498 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 5)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 499 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 500 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 501 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\MethodCall($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 502 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\FuncCall($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 503 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 504 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 505 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 506 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 507 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 508 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 509 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 510 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 511 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 512 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 513 => function ($stackPos) {
            $var = \substr($this->semStack[$stackPos - (1 - 1)], 1);
            $this->semValue = \is_string($var) ? new \PHPUnit\PhpParser\Node\VarLikeIdentifier($var, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes) : $var;
        }, 514 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 515 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch($this->semStack[$stackPos - (6 - 1)], $this->semStack[$stackPos - (6 - 5)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 516 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 517 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 518 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 519 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 520 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 521 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 522 => function ($stackPos) {
            $this->semValue = null;
        }, 523 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 524 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 525 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 526 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 527 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Error($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
            $this->errorState = 2;
        }, 528 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\List_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 529 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 530 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 531 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (1 - 1)], null, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 532 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (1 - 1)], null, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 533 => function ($stackPos) {
            $this->semValue = null;
        }, 534 => function ($stackPos) {
            $this->semValue = array();
        }, 535 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 536 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 537 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 538 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (3 - 3)], $this->semStack[$stackPos - (3 - 1)], \false, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 539 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (1 - 1)], null, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 540 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (4 - 4)], $this->semStack[$stackPos - (4 - 1)], \true, $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 541 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (2 - 2)], null, \true, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 542 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (2 - 2)], null, \false, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes, \true, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 543 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 544 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 545 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 546 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)]);
        }, 547 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 548 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 549 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 550 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 551 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 552 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 553 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 554 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 4)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 555 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 556 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\String_($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 557 => function ($stackPos) {
            $this->semValue = $this->parseNumString($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 558 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }];
    }
}
<?php

namespace PHPUnit\PhpParser\Parser;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Scalar;
use PHPUnit\PhpParser\Node\Stmt;
/* This is an automatically GENERATED file, which should not be manually edited.
 * Instead edit one of the following:
 *  * the grammar files grammar/php5.y or grammar/php7.y
 *  * the skeleton file grammar/parser.template
 *  * the preprocessing script grammar/rebuildParsers.php
 */
class Php7 extends \PHPUnit\PhpParser\ParserAbstract
{
    protected $tokenToSymbolMapSize = 393;
    protected $actionTableSize = 1178;
    protected $gotoTableSize = 582;
    protected $invalidSymbol = 166;
    protected $errorSymbol = 1;
    protected $defaultAction = -32766;
    protected $unexpectedTokenRule = 32767;
    protected $YY2TBLSTATE = 401;
    protected $numNonLeafStates = 700;
    protected $symbolToName = array("EOF", "error", "T_THROW", "T_INCLUDE", "T_INCLUDE_ONCE", "T_EVAL", "T_REQUIRE", "T_REQUIRE_ONCE", "','", "T_LOGICAL_OR", "T_LOGICAL_XOR", "T_LOGICAL_AND", "T_PRINT", "T_YIELD", "T_DOUBLE_ARROW", "T_YIELD_FROM", "'='", "T_PLUS_EQUAL", "T_MINUS_EQUAL", "T_MUL_EQUAL", "T_DIV_EQUAL", "T_CONCAT_EQUAL", "T_MOD_EQUAL", "T_AND_EQUAL", "T_OR_EQUAL", "T_XOR_EQUAL", "T_SL_EQUAL", "T_SR_EQUAL", "T_POW_EQUAL", "T_COALESCE_EQUAL", "'?'", "':'", "T_COALESCE", "T_BOOLEAN_OR", "T_BOOLEAN_AND", "'|'", "'^'", "'&'", "T_IS_EQUAL", "T_IS_NOT_EQUAL", "T_IS_IDENTICAL", "T_IS_NOT_IDENTICAL", "T_SPACESHIP", "'<'", "T_IS_SMALLER_OR_EQUAL", "'>'", "T_IS_GREATER_OR_EQUAL", "T_SL", "T_SR", "'+'", "'-'", "'.'", "'*'", "'/'", "'%'", "'!'", "T_INSTANCEOF", "'~'", "T_INC", "T_DEC", "T_INT_CAST", "T_DOUBLE_CAST", "T_STRING_CAST", "T_ARRAY_CAST", "T_OBJECT_CAST", "T_BOOL_CAST", "T_UNSET_CAST", "'@'", "T_POW", "'['", "T_NEW", "T_CLONE", "T_EXIT", "T_IF", "T_ELSEIF", "T_ELSE", "T_ENDIF", "T_LNUMBER", "T_DNUMBER", "T_STRING", "T_STRING_VARNAME", "T_VARIABLE", "T_NUM_STRING", "T_INLINE_HTML", "T_ENCAPSED_AND_WHITESPACE", "T_CONSTANT_ENCAPSED_STRING", "T_ECHO", "T_DO", "T_WHILE", "T_ENDWHILE", "T_FOR", "T_ENDFOR", "T_FOREACH", "T_ENDFOREACH", "T_DECLARE", "T_ENDDECLARE", "T_AS", "T_SWITCH", "T_MATCH", "T_ENDSWITCH", "T_CASE", "T_DEFAULT", "T_BREAK", "T_CONTINUE", "T_GOTO", "T_FUNCTION", "T_FN", "T_CONST", "T_RETURN", "T_TRY", "T_CATCH", "T_FINALLY", "T_USE", "T_INSTEADOF", "T_GLOBAL", "T_STATIC", "T_ABSTRACT", "T_FINAL", "T_PRIVATE", "T_PROTECTED", "T_PUBLIC", "T_VAR", "T_UNSET", "T_ISSET", "T_EMPTY", "T_HALT_COMPILER", "T_CLASS", "T_TRAIT", "T_INTERFACE", "T_ENUM", "T_EXTENDS", "T_IMPLEMENTS", "T_OBJECT_OPERATOR", "T_NULLSAFE_OBJECT_OPERATOR", "T_LIST", "T_ARRAY", "T_CALLABLE", "T_CLASS_C", "T_TRAIT_C", "T_METHOD_C", "T_FUNC_C", "T_LINE", "T_FILE", "T_START_HEREDOC", "T_END_HEREDOC", "T_DOLLAR_OPEN_CURLY_BRACES", "T_CURLY_OPEN", "T_PAAMAYIM_NEKUDOTAYIM", "T_NAMESPACE", "T_NS_C", "T_DIR", "T_NS_SEPARATOR", "T_ELLIPSIS", "T_NAME_FULLY_QUALIFIED", "T_NAME_QUALIFIED", "T_NAME_RELATIVE", "T_ATTRIBUTE", "';'", "']'", "'{'", "'}'", "'('", "')'", "'`'", "'\"'", "'\$'");
    protected $tokenToSymbol = array(0, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 55, 164, 166, 165, 54, 37, 166, 161, 162, 52, 49, 8, 50, 51, 53, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 31, 157, 43, 16, 45, 30, 67, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 69, 166, 158, 36, 166, 163, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 159, 35, 160, 57, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 166, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 33, 34, 38, 39, 40, 41, 42, 44, 46, 47, 48, 56, 58, 59, 60, 61, 62, 63, 64, 65, 66, 68, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156);
    protected $action = array(130, 131, 132, 561, 133, 134, 0, 710, 711, 712, 135, 36, 896, 537, 538, -32766, 1231, -32766, -32766, -32766, -558, 1164, 785, 907, 434, 435, 436, -558, -32766, -32766, -32766, -299, -32766, 973, -32766, 247, -32766, -190, -32766, -32766, -32766, -32766, -32766, 465, -32766, -32766, -32766, -32766, -32766, -32766, -32766, -32766, 124, 796, 713, -32766, -32766, 392, 1043, 1044, 1045, 1042, 1041, 1040, -32766, -32766, -32766, -32766, 263, 136, 375, 717, 718, 719, 720, 980, 981, 401, 1043, 1044, 1045, 1042, 1041, 1040, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 751, 562, 752, 753, 754, 755, 743, 744, 376, 377, 746, 747, 732, 733, 734, 736, 737, 738, 336, 778, 779, 780, 781, 782, 739, 740, 563, 564, 772, 763, 761, 762, 775, 758, 759, -189, 978, 565, 566, 757, 567, 568, 569, 570, 571, 572, 533, -555, -509, -32766, -32766, 760, 573, 574, -555, 137, 980, 981, 313, 130, 131, 132, 561, 133, 134, 994, 710, 711, 712, 135, 36, -32766, -32766, -32766, -32766, 687, -32766, -32766, -32766, 80, 1164, 553, -558, 629, 24, 312, -558, -32766, -32766, -32766, -299, -32766, -32766, -32766, 247, -32766, -190, -32766, -32766, -32766, -32766, -32766, -32766, -32766, -32766, -32766, 1203, 432, 433, -32766, -32766, -509, -509, 713, 795, -32766, 392, 395, -32766, -32766, -32766, 443, 444, -32766, 438, 433, -509, 263, 136, 375, 717, 718, 719, 720, 395, -83, 401, 237, -509, -32766, -515, -32766, -32766, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 751, 562, 752, 753, 754, 755, 743, 744, 376, 377, 746, 747, 732, 733, 734, 736, 737, 738, 336, 778, 779, 780, 781, 782, 739, 740, 563, 564, 772, 763, 761, 762, 775, 758, 759, -189, 2, 565, 566, 757, 567, 568, 569, 570, 571, 572, -83, 81, 82, 83, -555, 760, 573, 574, -555, 137, 735, 705, 706, 707, 708, 709, 1251, 710, 711, 712, 748, 749, 33, 1250, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 12, 265, -32766, -32766, -32766, 104, 105, 106, 31, 265, 970, 969, 968, 107, 101, 102, 103, 713, -32766, -32766, -32766, 107, 459, -32766, 583, -32766, -32766, -32766, -32766, -32766, -32766, 714, 715, 716, 717, 718, 719, 720, -259, -32766, 783, -32766, -32766, -32766, -32766, -32766, 126, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 751, 774, 752, 753, 754, 755, 743, 744, 745, 773, 746, 747, 732, 733, 734, 736, 737, 738, 777, 778, 779, 780, 781, 782, 739, 740, 741, 742, 772, 763, 761, 762, 775, 758, 759, 142, 938, 750, 756, 757, 764, 765, 767, 766, 768, 769, -549, -32766, -32766, -32766, -549, 760, 771, 770, 48, 49, 50, 492, 51, 52, 790, 236, 589, -510, 53, 54, 249, 55, -32766, 993, -32766, -32766, -32766, -32766, -32766, -32766, -32767, -32767, -32767, -32767, -32767, 296, -32767, -32767, -32767, -32767, 99, 100, 101, 102, 103, 1276, 460, 787, 1277, 821, 298, 822, 274, 482, 1191, 56, 57, -337, 310, -337, -508, 58, 1171, 59, 242, 243, 60, 61, 62, 63, 64, 65, 66, 67, 1035, 26, 264, 68, 416, 493, -510, -510, 325, 1197, 1198, 494, 349, 794, 1171, 791, 353, 1195, 40, 23, 495, -510, 496, 793, 497, 487, 498, 11, 358, 499, 500, 645, 646, -510, 42, 43, 417, 421, 419, 878, 44, 501, 939, 401, -14, 360, 348, 324, 789, -508, -508, 412, -507, 675, 502, 503, 504, 427, 428, 47, 794, 146, 380, 978, -508, 413, 505, 506, 794, 1185, 1186, 1187, 1188, 1182, 1183, 284, -508, 414, -514, 1247, 415, 1189, 1184, 980, 981, 1166, 1165, 1167, 285, 821, 878, 822, 800, 69, 794, 308, 309, 312, 34, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, -150, -150, -150, -507, -507, 1166, 1165, 1167, 678, 868, 288, 289, 1021, -32766, 1020, -150, 698, -150, -507, -150, 147, -150, 244, 445, 446, 352, 138, -108, 1079, 1081, -507, 418, 312, 621, 622, 148, 73, 125, 150, -507, 312, 151, -108, -108, 152, 785, -85, 154, 35, -49, -77, 854, -108, -108, -108, -108, 121, 285, -32766, 122, 868, 127, 73, 128, 1164, 141, 312, 155, 878, 156, 157, -32766, -32766, -32766, 158, -32766, 277, -32766, 878, -32766, 107, -73, -32766, 880, 878, 673, -150, -32766, -32766, -32766, -71, -32766, -70, -32766, -32766, -69, 129, 1164, 679, -32766, 392, -512, -507, -507, -32766, -32766, -32766, -32766, -32766, -68, -32766, 878, -32766, -67, 680, -32766, -66, -507, -65, -64, -32766, -32766, -32766, 1171, -45, 139, -32766, -32766, 878, -507, -16, 312, -32766, 392, 880, 246, 673, 72, -32766, 145, -32766, 682, 1164, 266, 1164, 273, 688, -4, 878, 691, 868, -32766, -32766, -32766, 877, -32766, 144, -32766, 689, -32766, 868, -32766, -32766, 275, -512, -512, 868, -32766, -32766, -32766, 892, -32766, 248, -32766, -32766, 276, 278, 1164, 1162, -32766, 392, 980, 981, 279, -32766, -32766, -32766, -32766, -32766, 318, -32766, -512, -32766, 868, 265, -32766, 653, 794, 46, 143, -32766, -32766, -32766, 794, 666, 785, -32766, -32766, -32766, 541, 868, -32766, -32766, 392, 1164, 1049, 1166, 1165, 1167, 1278, -32766, -32766, -32766, -32766, 880, -32766, 673, -32766, -32766, -32766, 868, 630, -32766, 250, 880, 535, 673, -32766, -32766, -32766, 924, 635, 673, -32766, -32766, 648, 13, 290, -108, -32766, 392, 440, 418, 794, 406, 470, 1266, -32766, 293, 283, 636, 286, 287, -108, -108, 26, 878, 880, 649, 673, 619, -473, 813, -108, -108, -108, -108, 794, 285, -32766, 878, 1195, 411, 73, 880, 1164, 673, 312, 123, 908, 909, 291, -32766, -32766, -32766, 9, -32766, 297, -32766, 285, -32766, 1202, 793, -32766, 880, 894, 673, -4, -32766, -32766, -32766, 0, 1019, -463, -32766, -32766, 547, 32, 245, 1204, -32766, 392, 587, 7, 15, 351, 1192, 38, -32766, 0, 505, 506, 805, 1185, 1186, 1187, 1188, 1182, 1183, 39, 695, 696, 859, 948, 925, 1189, 1184, 932, 868, 922, 933, 857, 920, -262, 1024, 1027, 1028, 71, 1025, 1026, 309, 312, 868, 1217, -237, -237, -237, 1032, 30, 1235, 418, 1269, 624, -543, 307, 350, 674, 677, -236, -236, -236, -108, -108, 681, 418, 26, 683, 684, 685, 686, 854, -108, -108, -108, -108, -108, -108, 794, 690, 676, -260, 1195, 692, 855, 854, -108, -108, -108, -108, 1273, 1275, -108, 816, 815, 824, 901, -108, 940, -108, 823, 1274, 900, 880, 292, 673, -237, -108, -108, -108, -108, -108, -108, -108, 902, 899, 1150, 880, 887, 673, -236, 895, 885, 930, 931, 1272, 1229, 1218, 1236, 1242, 1245, 0, 506, -541, 1185, 1186, 1187, 1188, 1182, 1183, -515, -514, -513, 1, 27, 28, 1189, 1184, 37, 41, 45, 70, -313, -259, 74, 75, 76, 77, 71, 78, 79, 309, 312, 140, 149, 153, 241, 314, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 407, 408, 0, 17, 18, 19, 20, 22, 379, 461, 462, 469, 472, 473, 474, 475, 479, 480, 481, 490, 660, 1175, 1118, 1193, 995, 1154, -264, -100, 16, 21, 25, 282, 378, 580, 584, 611, 665, 1122, 1170, 1119, 1248, 0, -477, 1135, 0, 1196, 0, 312);
    protected $actionCheck = array(2, 3, 4, 5, 6, 7, 0, 9, 10, 11, 12, 13, 1, 116, 117, 73, 1, 9, 10, 11, 1, 79, 79, 126, 127, 128, 129, 8, 86, 87, 88, 8, 90, 1, 92, 37, 94, 8, 30, 97, 32, 33, 34, 101, 102, 103, 104, 9, 10, 11, 108, 109, 14, 1, 56, 115, 114, 115, 115, 116, 117, 118, 119, 120, 122, 9, 10, 11, 70, 71, 72, 73, 74, 75, 76, 135, 136, 79, 115, 116, 117, 118, 119, 120, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 8, 115, 134, 135, 136, 137, 138, 139, 140, 141, 142, 84, 1, 69, 9, 10, 148, 149, 150, 8, 152, 135, 136, 69, 2, 3, 4, 5, 6, 7, 162, 9, 10, 11, 12, 13, 9, 10, 11, 73, 159, 9, 10, 11, 159, 79, 80, 158, 74, 75, 165, 162, 86, 87, 88, 162, 90, 30, 92, 37, 94, 162, 30, 97, 32, 33, 34, 35, 102, 103, 104, 144, 105, 106, 108, 109, 132, 133, 56, 157, 114, 115, 115, 9, 10, 11, 132, 133, 122, 105, 106, 147, 70, 71, 72, 73, 74, 75, 76, 115, 31, 79, 14, 159, 30, 161, 32, 33, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 162, 8, 134, 135, 136, 137, 138, 139, 140, 141, 142, 96, 9, 10, 11, 158, 148, 149, 150, 162, 152, 2, 3, 4, 5, 6, 7, 1, 9, 10, 11, 12, 13, 30, 8, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 8, 56, 9, 10, 11, 52, 53, 54, 8, 56, 118, 119, 120, 68, 49, 50, 51, 56, 9, 10, 11, 68, 31, 30, 1, 32, 33, 34, 35, 36, 37, 70, 71, 72, 73, 74, 75, 76, 162, 30, 79, 32, 33, 34, 35, 36, 8, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 8, 31, 134, 135, 136, 137, 138, 139, 140, 141, 142, 158, 9, 10, 11, 162, 148, 149, 150, 2, 3, 4, 5, 6, 7, 79, 96, 50, 69, 12, 13, 8, 15, 30, 1, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 8, 43, 44, 45, 46, 47, 48, 49, 50, 51, 79, 159, 79, 82, 105, 8, 107, 30, 100, 1, 49, 50, 105, 8, 107, 69, 55, 1, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 121, 69, 70, 71, 72, 73, 132, 133, 8, 77, 78, 79, 8, 81, 1, 154, 8, 85, 86, 87, 88, 147, 90, 153, 92, 105, 94, 107, 8, 97, 98, 74, 75, 159, 102, 103, 104, 105, 106, 1, 108, 109, 157, 79, 31, 8, 114, 115, 154, 132, 133, 8, 69, 159, 122, 123, 124, 105, 106, 69, 81, 100, 101, 115, 147, 8, 134, 135, 81, 137, 138, 139, 140, 141, 142, 143, 159, 8, 161, 1, 8, 149, 150, 135, 136, 153, 154, 155, 156, 105, 1, 107, 8, 161, 81, 163, 164, 165, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 74, 75, 76, 132, 133, 153, 154, 155, 31, 83, 132, 133, 160, 9, 157, 89, 159, 91, 147, 93, 14, 95, 37, 105, 106, 147, 159, 126, 58, 59, 159, 105, 165, 110, 111, 14, 161, 159, 14, 69, 165, 14, 116, 117, 14, 79, 31, 14, 14, 31, 31, 125, 126, 127, 128, 129, 16, 156, 73, 16, 83, 16, 161, 16, 79, 16, 165, 16, 1, 16, 16, 86, 87, 88, 16, 90, 30, 92, 1, 94, 68, 31, 97, 157, 1, 159, 160, 102, 103, 104, 31, 73, 31, 108, 109, 31, 31, 79, 31, 114, 115, 69, 132, 133, 86, 87, 88, 122, 90, 31, 92, 1, 94, 31, 31, 97, 31, 147, 31, 31, 102, 103, 104, 1, 31, 159, 108, 109, 1, 159, 31, 165, 114, 115, 157, 37, 159, 152, 73, 31, 122, 31, 79, 31, 79, 31, 31, 0, 1, 31, 83, 86, 87, 88, 31, 90, 31, 92, 31, 94, 83, 115, 97, 35, 132, 133, 83, 102, 103, 104, 37, 73, 37, 108, 109, 35, 35, 79, 115, 114, 115, 135, 136, 35, 86, 87, 88, 122, 90, 35, 92, 159, 94, 83, 56, 97, 76, 81, 69, 69, 102, 103, 104, 81, 91, 79, 108, 109, 73, 88, 83, 115, 114, 115, 79, 81, 153, 154, 155, 82, 122, 86, 87, 88, 157, 90, 159, 92, 84, 94, 83, 89, 97, 37, 157, 84, 159, 102, 103, 104, 157, 95, 159, 108, 109, 93, 96, 130, 126, 114, 115, 96, 105, 81, 107, 96, 84, 122, 113, 112, 99, 132, 133, 116, 117, 69, 1, 157, 99, 159, 112, 147, 125, 126, 127, 128, 129, 81, 156, 73, 1, 85, 126, 161, 157, 79, 159, 165, 159, 126, 126, 131, 86, 87, 88, 148, 90, 130, 92, 156, 94, 144, 153, 97, 157, 152, 159, 160, 102, 103, 104, -1, 1, 147, 108, 109, 151, 145, 146, 144, 114, 115, 151, 147, 147, 147, 158, 157, 122, -1, 134, 135, 158, 137, 138, 139, 140, 141, 142, 157, 157, 157, 157, 157, 157, 149, 150, 157, 83, 157, 157, 157, 157, 162, 157, 157, 157, 161, 157, 157, 164, 165, 83, 158, 99, 100, 101, 157, 159, 158, 105, 158, 158, 161, 159, 159, 159, 159, 99, 100, 101, 116, 117, 159, 105, 69, 159, 159, 159, 159, 125, 126, 127, 128, 129, 116, 117, 81, 159, 159, 162, 85, 160, 160, 125, 126, 127, 128, 129, 160, 160, 100, 160, 160, 160, 160, 105, 160, 107, 160, 160, 160, 157, 112, 159, 160, 115, 116, 117, 118, 119, 120, 121, 160, 160, 160, 157, 160, 159, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, -1, 135, 161, 137, 138, 139, 140, 141, 142, 161, 161, 161, 161, 161, 161, 149, 150, 161, 161, 161, 161, 160, 162, 161, 161, 161, 161, 161, 161, 161, 164, 165, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, 161, -1, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, -1, 163, 163, -1, 164, -1, 165);
    protected $actionBase = array(0, -2, 152, 558, 779, 897, 911, 499, 484, 414, 834, 303, 303, -57, 303, 303, 699, 742, 742, 759, 742, 609, 715, 709, 709, 709, 617, 617, 617, 617, -58, -58, 96, 697, 730, 767, 650, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 838, 52, 405, 365, 666, 999, 1005, 1001, 1006, 997, 996, 1000, 1002, 1007, 916, 917, 757, 918, 919, 920, 921, 1003, 846, 998, 1004, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 636, 38, 135, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 157, 157, 157, 204, 828, 828, 8, 602, 162, 948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 351, 335, 438, 438, 438, 438, 438, 943, 439, 439, 439, 439, 533, 754, 507, 468, 399, 398, 307, 307, 678, 678, 16, 16, 16, 16, -60, -60, -60, -103, 74, 437, 390, 57, 695, 598, 598, 598, 598, 695, 695, 695, 695, 807, 1011, 695, 695, 695, 394, 503, 503, 510, 295, 295, 295, 503, 504, 783, 804, 504, 804, 15, 412, 728, 97, 114, 288, 728, 664, 761, 141, 19, 781, 472, 781, 776, 842, 872, 1008, 234, 793, 914, 801, 915, 84, 651, 994, 994, 994, 994, 994, 994, 994, 994, 994, 994, 994, 1012, 995, 381, 1012, 1012, 1012, 555, 381, 104, 477, 381, 786, 995, 52, 798, 52, 52, 52, 52, 958, 52, 52, 52, 52, 52, 52, 963, 731, 725, 682, 333, 52, 405, 11, 11, 489, 32, 11, 11, 11, 11, 52, 52, 52, 472, 770, 797, 550, 803, 122, 770, 770, 770, 199, 23, 218, 29, 440, 758, 758, 765, 766, 933, 933, 758, 748, 758, 766, 940, 758, 765, 765, 933, 765, 775, 380, 563, 520, 528, 765, 765, 577, 933, 473, 765, 765, 758, 758, 758, 758, 765, 589, 758, 458, 427, 758, 758, 765, 765, 749, 746, 799, 277, 933, 933, 933, 799, 524, 792, 792, 792, 815, 816, 790, 744, 496, 488, 604, 342, 765, 744, 744, 758, 540, 790, 744, 790, 744, 785, 744, 744, 744, 790, 744, 758, 748, 557, 744, 683, 765, 592, 334, 744, 6, 941, 944, 647, 945, 938, 946, 969, 947, 949, 849, 956, 939, 950, 935, 934, 755, 672, 675, 808, 756, 932, 644, 644, 644, 930, 644, 644, 644, 644, 644, 644, 644, 644, 672, 800, 810, 788, 753, 959, 677, 679, 789, 875, 1009, 1010, 795, 796, 958, 989, 953, 802, 681, 975, 960, 874, 847, 961, 962, 976, 990, 991, 881, 762, 882, 884, 806, 964, 850, 644, 941, 949, 939, 950, 935, 934, 720, 719, 714, 717, 710, 696, 691, 693, 740, 923, 844, 837, 963, 931, 672, 843, 971, 841, 977, 978, 848, 787, 769, 845, 885, 965, 966, 967, 856, 992, 814, 972, 823, 979, 791, 886, 980, 981, 982, 983, 887, 859, 860, 861, 817, 774, 870, 778, 889, 638, 773, 780, 970, 653, 957, 862, 891, 892, 984, 985, 986, 893, 954, 818, 973, 784, 974, 942, 819, 822, 656, 760, 772, 659, 662, 905, 906, 907, 955, 747, 752, 824, 825, 993, 909, 665, 826, 685, 912, 988, 686, 690, 745, 871, 809, 777, 782, 968, 750, 827, 913, 829, 830, 831, 987, 833, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 452, 452, 452, 452, 452, 452, 303, 303, 303, 303, 0, 0, 303, 0, 0, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 452, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 695, 695, 287, 0, 287, 695, 695, 695, 695, 695, 695, 695, 695, 695, 695, 287, 287, 287, 287, 287, 287, 287, 775, 295, 295, 295, 295, 695, 695, 695, 695, -37, -37, 295, 295, 695, 695, 695, 695, 695, 695, 695, 695, 695, 0, 0, 0, 381, 804, 0, 748, 748, 748, 748, 0, 0, 0, 0, 804, 804, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 381, 804, 0, 381, 0, 748, 748, 695, 775, 775, 310, 695, 0, 0, 0, 0, 381, 748, 381, 804, 11, 52, 310, 0, 481, 481, 481, 481, 0, 472, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 748, 775, 0, 748, 748, 748, 0, 0, 0, 0, 0, 748, 765, 0, 933, 0, 0, 0, 0, 758, 0, 0, 0, 0, 0, 0, 758, 940, 765, 765, 0, 0, 0, 0, 0, 0, 748, 0, 0, 0, 0, 0, 0, 0, 0, 644, 787, 0, 787, 0, 644, 644, 644);
    protected $actionDefault = array(3, 32767, 100, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 98, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 561, 561, 561, 561, 241, 100, 32767, 32767, 32767, 32767, 437, 356, 356, 356, 32767, 32767, 505, 505, 505, 505, 505, 505, 32767, 32767, 32767, 32767, 32767, 32767, 437, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 98, 32767, 32767, 32767, 35, 5, 6, 8, 9, 48, 15, 32767, 32767, 32767, 32767, 32767, 100, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 554, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 441, 420, 421, 423, 424, 355, 506, 560, 298, 557, 354, 143, 310, 300, 229, 301, 245, 442, 246, 443, 446, 447, 206, 272, 351, 147, 385, 438, 387, 436, 440, 386, 361, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 359, 360, 439, 417, 416, 415, 383, 32767, 32767, 384, 358, 388, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 100, 32767, 390, 389, 406, 407, 404, 405, 408, 32767, 409, 410, 411, 412, 32767, 32767, 32767, 32767, 336, 334, 397, 398, 289, 289, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 499, 414, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 100, 32767, 98, 501, 380, 382, 469, 392, 393, 391, 362, 32767, 476, 32767, 100, 478, 32767, 32767, 32767, 109, 32767, 32767, 32767, 500, 32767, 507, 507, 32767, 462, 98, 32767, 32767, 32767, 32767, 267, 32767, 32767, 32767, 32767, 568, 462, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 108, 32767, 108, 32767, 32767, 32767, 98, 186, 32767, 255, 257, 100, 522, 191, 32767, 481, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 474, 191, 191, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 462, 402, 136, 32767, 136, 507, 394, 395, 396, 464, 507, 507, 507, 32767, 32767, 32767, 191, 32767, 479, 479, 98, 98, 98, 98, 474, 32767, 191, 191, 32767, 191, 109, 97, 97, 97, 97, 191, 191, 97, 101, 99, 191, 191, 32767, 32767, 32767, 32767, 191, 97, 32767, 99, 99, 32767, 32767, 191, 191, 212, 203, 210, 99, 32767, 526, 527, 210, 99, 214, 214, 214, 234, 234, 453, 291, 99, 97, 99, 99, 191, 291, 291, 32767, 99, 453, 291, 453, 291, 193, 291, 291, 291, 453, 291, 32767, 32767, 99, 291, 205, 191, 97, 97, 291, 32767, 32767, 32767, 464, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 494, 32767, 511, 524, 400, 401, 403, 509, 425, 426, 427, 428, 429, 430, 431, 433, 556, 32767, 468, 32767, 32767, 32767, 32767, 309, 566, 32767, 566, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 567, 32767, 507, 32767, 32767, 32767, 32767, 399, 7, 74, 41, 42, 50, 56, 485, 486, 487, 488, 482, 483, 489, 484, 32767, 490, 532, 32767, 32767, 508, 559, 32767, 32767, 32767, 32767, 32767, 32767, 136, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 494, 32767, 134, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 507, 32767, 32767, 32767, 286, 288, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 507, 32767, 32767, 32767, 274, 276, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 271, 32767, 32767, 350, 32767, 32767, 32767, 32767, 330, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 149, 149, 3, 3, 312, 149, 149, 149, 312, 149, 312, 312, 312, 149, 149, 149, 149, 149, 149, 181, 249, 252, 234, 234, 149, 322, 149);
    protected $goto = array(191, 191, 661, 403, 634, 453, 1237, 1238, 397, 300, 301, 321, 555, 306, 402, 322, 404, 613, 1038, 1039, 669, 315, 315, 315, 315, 162, 162, 162, 162, 188, 188, 172, 174, 215, 192, 210, 188, 188, 188, 188, 188, 189, 189, 189, 189, 189, 189, 183, 184, 185, 186, 187, 212, 210, 213, 513, 514, 393, 515, 517, 518, 519, 520, 521, 522, 523, 524, 1065, 163, 164, 165, 190, 166, 167, 168, 161, 169, 170, 171, 173, 209, 211, 214, 232, 235, 238, 240, 251, 252, 253, 254, 255, 256, 257, 259, 260, 261, 262, 269, 270, 303, 304, 305, 398, 399, 400, 560, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 175, 231, 176, 193, 194, 195, 233, 183, 184, 185, 186, 187, 212, 1065, 196, 177, 178, 179, 197, 193, 180, 234, 198, 160, 199, 200, 181, 201, 202, 203, 182, 204, 205, 206, 207, 208, 814, 586, 600, 603, 604, 605, 606, 625, 626, 627, 671, 811, 599, 599, 539, 530, 577, 1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194, 1194, 280, 280, 280, 280, 997, 332, 819, 812, 867, 862, 863, 876, 845, 820, 864, 817, 865, 866, 818, 597, 631, 1144, 897, 788, 870, 1145, 1148, 898, 1149, 367, 530, 871, 539, 872, 1018, 1014, 1015, 792, 548, 549, 617, 617, 786, 374, 558, 1159, 987, 984, 985, 579, 915, 383, 668, 1212, 1212, 923, 593, 594, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 1212, 904, 975, 982, 983, 1163, 1163, 1163, 979, 552, 792, 476, 792, 979, 979, 979, 979, 979, 979, 979, 979, 979, 329, 396, 422, 588, 5, 1163, 6, 422, 422, 14, 1163, 1163, 1163, 1163, 1160, 1252, 1163, 1163, 1163, 1244, 1244, 1244, 1244, 944, 802, 363, 335, 546, 551, 311, 295, 694, 612, 614, 883, 632, 335, 335, 884, 651, 655, 958, 659, 667, 954, 1161, 1220, 1221, 1239, 1240, 335, 335, 633, 335, 1113, 1279, 365, 369, 540, 578, 582, 323, 1262, 1262, 1210, 1210, 532, 804, 335, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1210, 1262, 409, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 832, 422, 1265, 373, 525, 525, 525, 525, 545, 1223, 829, 516, 516, 581, 966, 592, 516, 516, 516, 516, 516, 516, 516, 516, 516, 516, 609, 610, 381, 382, 807, 807, 1156, 640, 654, 641, 1003, 385, 386, 387, 628, 652, 642, 643, 644, 388, 697, 531, 543, 454, 327, 1263, 1263, 531, 841, 543, 442, 442, 366, 333, 334, 556, 591, 532, 1234, 1234, 1234, 442, 1263, 527, 527, 527, 1007, 1048, 267, 559, 447, 448, 449, 528, 528, 837, 928, 0, 1270, 1271, 458, 1246, 1246, 1246, 1246, 430, 477, 0, 478, 0, 917, 917, 917, 917, 485, 827, 430, 911, 918, 810, 839, 0, 0, 826, 0, 835, 0, 1230, 0, 0, 0, 947, 921, 921, 919, 921, 693, 486, 529, 956, 951, 840, 828, 1002, 0, 0, 1006, 1158, 888, 1053, 0, 807, 0, 0, 0, 0, 926, 596, 0, 0, 0, 0, 963, 1005, 0, 0, 1232, 1232, 1005, 0, 831, 0, 637, 942, 0, 0, 0, 0, 825, 576, 1031, 916, 672, 658, 658, 0, 664, 1029, 0, 0, 0, 1155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1046, 844, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 961, 961);
    protected $gotoCheck = array(41, 41, 71, 64, 64, 160, 160, 160, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 130, 130, 8, 22, 22, 22, 22, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 14, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 25, 102, 102, 74, 74, 116, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 23, 23, 23, 23, 113, 91, 14, 26, 14, 14, 14, 14, 44, 14, 14, 14, 14, 14, 14, 54, 54, 76, 76, 6, 14, 76, 76, 76, 76, 74, 74, 63, 74, 63, 14, 14, 14, 11, 74, 74, 109, 109, 5, 74, 74, 19, 109, 109, 109, 74, 87, 87, 87, 154, 154, 48, 74, 74, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 85, 85, 85, 85, 71, 71, 71, 71, 156, 11, 74, 11, 71, 71, 71, 71, 71, 71, 71, 71, 71, 163, 12, 22, 12, 45, 71, 45, 22, 22, 74, 71, 71, 71, 71, 19, 165, 71, 71, 71, 8, 8, 8, 8, 97, 19, 60, 13, 47, 98, 153, 153, 47, 47, 47, 71, 47, 13, 13, 71, 47, 47, 47, 47, 47, 47, 19, 19, 19, 162, 162, 13, 13, 62, 13, 137, 13, 57, 57, 57, 57, 57, 28, 166, 166, 155, 155, 13, 17, 13, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 166, 106, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 38, 22, 166, 27, 101, 101, 101, 101, 8, 13, 36, 157, 157, 101, 104, 8, 157, 157, 157, 157, 157, 157, 157, 157, 157, 157, 81, 81, 78, 78, 21, 21, 146, 78, 13, 78, 115, 78, 78, 78, 82, 78, 82, 82, 82, 78, 93, 8, 8, 143, 78, 167, 167, 8, 40, 8, 135, 135, 8, 91, 91, 2, 2, 13, 116, 116, 116, 135, 167, 18, 18, 18, 118, 133, 23, 8, 8, 8, 8, 23, 23, 8, 90, -1, 8, 8, 80, 116, 116, 116, 116, 18, 141, -1, 141, -1, 18, 18, 18, 18, 141, 34, 18, 18, 18, 24, 34, -1, -1, 34, -1, 8, -1, 116, -1, -1, -1, 24, 24, 24, 24, 24, 24, 8, 24, 24, 24, 15, 15, 15, -1, -1, 15, 13, 16, 16, -1, 21, -1, -1, -1, -1, 15, 16, -1, -1, -1, -1, 16, 116, -1, -1, 116, 116, 116, -1, 16, -1, 16, 16, -1, -1, -1, -1, 16, 7, 7, 15, 7, 7, 7, -1, 7, 7, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 101, 101);
    protected $gotoBase = array(0, 0, -248, 0, 0, 214, 199, 524, 7, 0, 0, -61, -48, 16, -170, 69, 59, 45, 172, -132, 0, 81, 18, 182, 467, 165, 188, 46, 52, 0, 0, 0, 0, 0, 117, 0, 51, 0, 56, 0, 8, -1, 0, 0, 185, -419, 0, -373, 218, 0, 0, 0, 0, 0, 166, 0, 0, 287, 0, 0, 259, 0, 89, 198, -233, 0, 0, 0, 0, 0, 0, -6, 0, 0, -204, 0, -175, -179, -74, 0, -2, -65, -275, 0, 0, -20, 0, -56, 0, 0, 34, -270, 0, 32, 0, 0, 0, 266, 261, 0, 0, 344, -66, 0, 31, 0, 82, 0, 0, -46, 0, 0, 0, 187, 0, 49, 167, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -249, 0, 0, 24, 0, 392, 0, 63, 0, 0, 0, -14, 0, 4, 0, 0, -10, 0, 0, 0, 0, 0, 0, -5, 2, 102, 234, 141, 0, 0, -282, 0, -29, 246, 0, 260, 42, 123, 0, 0);
    protected $gotoDefault = array(-32768, 491, 701, 4, 702, 776, 784, 575, 507, 670, 328, 601, 394, 1228, 869, 1052, 557, 803, 1172, 1180, 431, 806, 316, 330, 851, 852, 853, 370, 355, 361, 368, 623, 602, 471, 838, 425, 830, 463, 833, 424, 842, 159, 391, 489, 846, 3, 848, 534, 879, 356, 856, 357, 647, 858, 542, 860, 861, 364, 371, 372, 1057, 550, 598, 873, 239, 544, 874, 354, 875, 882, 359, 362, 656, 441, 483, 384, 1033, 585, 620, 437, 457, 608, 607, 595, 456, 638, 389, 913, 464, 439, 927, 331, 935, 699, 1064, 615, 466, 943, 616, 950, 953, 508, 509, 455, 965, 271, 467, 992, 639, 977, 618, 990, 450, 996, 426, 1004, 1216, 429, 1008, 258, 1011, 272, 390, 405, 1016, 1017, 8, 1023, 662, 663, 10, 268, 488, 1047, 657, 423, 1063, 410, 1132, 1134, 536, 468, 1152, 1151, 650, 484, 1157, 1219, 420, 510, 451, 302, 511, 294, 319, 299, 526, 281, 320, 512, 452, 1225, 1233, 317, 29, 1253, 1264, 326, 554, 590);
    protected $ruleToNonTerminal = array(0, 1, 3, 3, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 9, 10, 10, 10, 11, 11, 12, 12, 13, 14, 14, 15, 15, 16, 16, 17, 17, 20, 20, 21, 22, 22, 23, 23, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 28, 28, 29, 29, 31, 33, 33, 27, 35, 35, 32, 37, 37, 34, 34, 36, 36, 38, 38, 30, 39, 39, 40, 42, 43, 43, 44, 45, 45, 47, 46, 46, 46, 46, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 24, 24, 67, 67, 70, 70, 69, 68, 68, 61, 73, 73, 74, 74, 75, 75, 76, 76, 25, 25, 26, 26, 26, 26, 84, 84, 86, 86, 79, 79, 79, 80, 80, 83, 83, 81, 81, 87, 88, 88, 55, 55, 63, 63, 66, 66, 66, 65, 89, 89, 90, 56, 56, 56, 56, 91, 91, 92, 92, 93, 93, 94, 95, 95, 96, 96, 97, 97, 53, 53, 49, 49, 99, 51, 51, 100, 50, 50, 52, 52, 62, 62, 62, 62, 77, 77, 103, 103, 105, 105, 105, 105, 104, 104, 104, 107, 107, 107, 85, 85, 109, 109, 109, 108, 108, 110, 110, 111, 111, 111, 106, 106, 78, 78, 78, 19, 19, 112, 112, 113, 113, 113, 113, 58, 114, 114, 115, 59, 117, 117, 118, 118, 119, 119, 82, 120, 120, 120, 120, 120, 120, 125, 125, 126, 126, 127, 127, 127, 127, 127, 128, 129, 129, 124, 124, 121, 121, 123, 123, 131, 131, 130, 130, 130, 130, 130, 130, 122, 132, 132, 134, 133, 133, 60, 98, 135, 135, 54, 54, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 142, 136, 136, 141, 141, 144, 145, 145, 146, 147, 147, 147, 18, 18, 71, 71, 71, 71, 137, 137, 137, 137, 149, 149, 138, 138, 140, 140, 140, 143, 143, 154, 154, 154, 154, 154, 154, 154, 154, 154, 155, 155, 102, 157, 157, 157, 157, 139, 139, 139, 139, 139, 139, 139, 139, 57, 57, 152, 152, 152, 152, 158, 158, 148, 148, 148, 159, 159, 159, 159, 159, 159, 72, 72, 64, 64, 64, 64, 116, 116, 116, 116, 162, 161, 151, 151, 151, 151, 151, 151, 151, 150, 150, 150, 160, 160, 160, 160, 101, 156, 164, 164, 163, 163, 165, 165, 165, 165, 165, 165, 165, 165, 153, 153, 153, 153, 167, 168, 166, 166, 166, 166, 166, 166, 166, 166, 169, 169, 169, 169);
    protected $ruleToLength = array(1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 2, 1, 3, 4, 1, 2, 0, 1, 1, 1, 1, 1, 3, 5, 4, 3, 4, 2, 3, 1, 1, 7, 6, 2, 3, 1, 2, 3, 1, 2, 3, 1, 1, 3, 1, 3, 1, 2, 2, 3, 1, 3, 2, 3, 1, 3, 2, 0, 1, 1, 1, 1, 1, 3, 7, 10, 5, 7, 9, 5, 3, 3, 3, 3, 3, 3, 1, 2, 5, 7, 9, 6, 5, 6, 3, 2, 1, 1, 1, 0, 2, 1, 3, 8, 0, 4, 2, 1, 3, 0, 1, 0, 1, 3, 1, 8, 9, 8, 7, 6, 8, 0, 2, 0, 2, 1, 2, 2, 0, 2, 0, 2, 0, 2, 2, 1, 3, 1, 4, 1, 4, 1, 1, 4, 2, 1, 3, 3, 3, 4, 4, 5, 0, 2, 4, 3, 1, 1, 7, 0, 2, 1, 3, 3, 4, 1, 4, 0, 2, 5, 0, 2, 6, 0, 2, 0, 3, 1, 2, 1, 1, 2, 0, 1, 3, 0, 1, 1, 1, 6, 8, 6, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 2, 1, 0, 1, 0, 2, 2, 2, 4, 1, 3, 1, 2, 2, 3, 2, 3, 1, 1, 2, 3, 1, 1, 3, 2, 0, 1, 5, 5, 10, 3, 5, 1, 1, 3, 0, 2, 4, 5, 4, 4, 4, 3, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 3, 1, 1, 3, 2, 2, 3, 1, 0, 1, 1, 3, 3, 3, 4, 1, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 4, 3, 4, 4, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 2, 1, 2, 4, 2, 2, 8, 9, 8, 9, 9, 10, 9, 10, 8, 3, 2, 0, 4, 2, 1, 3, 2, 2, 2, 4, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 0, 3, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 4, 1, 1, 3, 1, 1, 1, 1, 1, 3, 2, 3, 0, 1, 1, 3, 1, 1, 1, 1, 1, 3, 1, 1, 4, 4, 1, 4, 4, 0, 1, 1, 1, 3, 3, 1, 4, 2, 2, 1, 3, 1, 4, 4, 3, 3, 3, 3, 1, 3, 1, 1, 3, 1, 1, 4, 1, 1, 1, 3, 1, 1, 2, 1, 3, 4, 3, 2, 0, 2, 2, 1, 2, 1, 1, 1, 4, 3, 3, 3, 3, 6, 3, 1, 1, 2, 1);
    protected function initReduceCallbacks()
    {
        $this->reduceCallbacks = [0 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 1 => function ($stackPos) {
            $this->semValue = $this->handleNamespaces($this->semStack[$stackPos - (1 - 1)]);
        }, 2 => function ($stackPos) {
            if (\is_array($this->semStack[$stackPos - (2 - 2)])) {
                $this->semValue = \array_merge($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)]);
            } else {
                $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
                $this->semValue = $this->semStack[$stackPos - (2 - 1)];
            }
        }, 3 => function ($stackPos) {
            $this->semValue = array();
        }, 4 => function ($stackPos) {
            $startAttributes = $this->lookaheadStartAttributes;
            if (isset($startAttributes['comments'])) {
                $nop = new \PHPUnit\PhpParser\Node\Stmt\Nop($this->createCommentNopAttributes($startAttributes['comments']));
            } else {
                $nop = null;
            }
            if ($nop !== null) {
                $this->semStack[$stackPos - (1 - 1)][] = $nop;
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 5 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 6 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 7 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 8 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 9 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 10 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 11 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 12 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 13 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 14 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 15 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 16 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 17 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 18 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 19 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 20 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 21 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 22 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 23 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 24 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 25 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 26 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 27 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 28 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 29 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 30 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 31 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 32 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 33 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 34 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 35 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 36 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 37 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 38 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 39 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 40 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 41 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 42 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 43 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 44 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 45 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 46 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 47 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 48 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 49 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 50 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 51 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 52 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 53 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 54 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 55 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 56 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 57 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 58 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 59 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 60 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 61 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 62 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 63 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 64 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 65 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 66 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 67 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 68 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 69 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 70 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 71 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 72 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 73 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 74 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 75 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 76 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 77 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 78 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 79 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 80 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 81 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 82 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 83 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 84 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 85 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 86 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 87 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 88 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 89 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 90 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 91 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 92 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 93 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 94 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 95 => function ($stackPos) {
            /* nothing */
        }, 96 => function ($stackPos) {
            /* nothing */
        }, 97 => function ($stackPos) {
            /* nothing */
        }, 98 => function ($stackPos) {
            $this->emitError(new \PHPUnit\PhpParser\Error('A trailing comma is not allowed here', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes));
        }, 99 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 100 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 101 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Attribute($this->semStack[$stackPos - (1 - 1)], [], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 102 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Attribute($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 103 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 104 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 105 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\AttributeGroup($this->semStack[$stackPos - (4 - 2)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 106 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 107 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 108 => function ($stackPos) {
            $this->semValue = [];
        }, 109 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 110 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 111 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 112 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 113 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\HaltCompiler($this->lexer->handleHaltCompiler(), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 114 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Namespace_($this->semStack[$stackPos - (3 - 2)], null, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->semValue->setAttribute('kind', \PHPUnit\PhpParser\Node\Stmt\Namespace_::KIND_SEMICOLON);
            $this->checkNamespace($this->semValue);
        }, 115 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Namespace_($this->semStack[$stackPos - (5 - 2)], $this->semStack[$stackPos - (5 - 4)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
            $this->semValue->setAttribute('kind', \PHPUnit\PhpParser\Node\Stmt\Namespace_::KIND_BRACED);
            $this->checkNamespace($this->semValue);
        }, 116 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Namespace_(null, $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
            $this->semValue->setAttribute('kind', \PHPUnit\PhpParser\Node\Stmt\Namespace_::KIND_BRACED);
            $this->checkNamespace($this->semValue);
        }, 117 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Use_($this->semStack[$stackPos - (3 - 2)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 118 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Use_($this->semStack[$stackPos - (4 - 3)], $this->semStack[$stackPos - (4 - 2)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 119 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 120 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Const_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 121 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION;
        }, 122 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT;
        }, 123 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\GroupUse($this->semStack[$stackPos - (7 - 3)], $this->semStack[$stackPos - (7 - 6)], $this->semStack[$stackPos - (7 - 2)], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
        }, 124 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\GroupUse($this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 5)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 125 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 126 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 127 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 128 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 129 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 130 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 131 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 132 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 133 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 134 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (1 - 1)], null, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (1 - 1));
        }, 135 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (3 - 3));
        }, 136 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (1 - 1)], null, \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (1 - 1));
        }, 137 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\UseUse($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_UNKNOWN, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->checkUseUse($this->semValue, $stackPos - (3 - 3));
        }, 138 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
            $this->semValue->type = \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_NORMAL;
        }, 139 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue->type = $this->semStack[$stackPos - (2 - 1)];
        }, 140 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 141 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 142 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 143 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Const_($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 144 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 145 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 146 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 147 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Const_($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 148 => function ($stackPos) {
            if (\is_array($this->semStack[$stackPos - (2 - 2)])) {
                $this->semValue = \array_merge($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)]);
            } else {
                $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
                $this->semValue = $this->semStack[$stackPos - (2 - 1)];
            }
        }, 149 => function ($stackPos) {
            $this->semValue = array();
        }, 150 => function ($stackPos) {
            $startAttributes = $this->lookaheadStartAttributes;
            if (isset($startAttributes['comments'])) {
                $nop = new \PHPUnit\PhpParser\Node\Stmt\Nop($this->createCommentNopAttributes($startAttributes['comments']));
            } else {
                $nop = null;
            }
            if ($nop !== null) {
                $this->semStack[$stackPos - (1 - 1)][] = $nop;
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 151 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 152 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 153 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 154 => function ($stackPos) {
            throw new \PHPUnit\PhpParser\Error('__HALT_COMPILER() can only be used from the outermost scope', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 155 => function ($stackPos) {
            if ($this->semStack[$stackPos - (3 - 2)]) {
                $this->semValue = $this->semStack[$stackPos - (3 - 2)];
                $attrs = $this->startAttributeStack[$stackPos - (3 - 1)];
                $stmts = $this->semValue;
                if (!empty($attrs['comments'])) {
                    $stmts[0]->setAttribute('comments', \array_merge($attrs['comments'], $stmts[0]->getAttribute('comments', [])));
                }
            } else {
                $startAttributes = $this->startAttributeStack[$stackPos - (3 - 1)];
                if (isset($startAttributes['comments'])) {
                    $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Nop($startAttributes + $this->endAttributes);
                } else {
                    $this->semValue = null;
                }
                if (null === $this->semValue) {
                    $this->semValue = array();
                }
            }
        }, 156 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\If_($this->semStack[$stackPos - (7 - 3)], ['stmts' => \is_array($this->semStack[$stackPos - (7 - 5)]) ? $this->semStack[$stackPos - (7 - 5)] : array($this->semStack[$stackPos - (7 - 5)]), 'elseifs' => $this->semStack[$stackPos - (7 - 6)], 'else' => $this->semStack[$stackPos - (7 - 7)]], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
        }, 157 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\If_($this->semStack[$stackPos - (10 - 3)], ['stmts' => $this->semStack[$stackPos - (10 - 6)], 'elseifs' => $this->semStack[$stackPos - (10 - 7)], 'else' => $this->semStack[$stackPos - (10 - 8)]], $this->startAttributeStack[$stackPos - (10 - 1)] + $this->endAttributes);
        }, 158 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\While_($this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 5)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 159 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Do_($this->semStack[$stackPos - (7 - 5)], \is_array($this->semStack[$stackPos - (7 - 2)]) ? $this->semStack[$stackPos - (7 - 2)] : array($this->semStack[$stackPos - (7 - 2)]), $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
        }, 160 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\For_(['init' => $this->semStack[$stackPos - (9 - 3)], 'cond' => $this->semStack[$stackPos - (9 - 5)], 'loop' => $this->semStack[$stackPos - (9 - 7)], 'stmts' => $this->semStack[$stackPos - (9 - 9)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 161 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Switch_($this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 5)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 162 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Break_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 163 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Continue_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 164 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Return_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 165 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Global_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 166 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Static_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 167 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Echo_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 168 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\InlineHTML($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 169 => function ($stackPos) {
            $e = $this->semStack[$stackPos - (2 - 1)];
            if ($e instanceof \PHPUnit\PhpParser\Node\Expr\Throw_) {
                // For backwards-compatibility reasons, convert throw in statement position into
                // Stmt\Throw_ rather than Stmt\Expression(Expr\Throw_).
                $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Throw_($e->expr, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
            } else {
                $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Expression($e, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
            }
        }, 170 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Unset_($this->semStack[$stackPos - (5 - 3)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 171 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Foreach_($this->semStack[$stackPos - (7 - 3)], $this->semStack[$stackPos - (7 - 5)][0], ['keyVar' => null, 'byRef' => $this->semStack[$stackPos - (7 - 5)][1], 'stmts' => $this->semStack[$stackPos - (7 - 7)]], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
        }, 172 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Foreach_($this->semStack[$stackPos - (9 - 3)], $this->semStack[$stackPos - (9 - 7)][0], ['keyVar' => $this->semStack[$stackPos - (9 - 5)], 'byRef' => $this->semStack[$stackPos - (9 - 7)][1], 'stmts' => $this->semStack[$stackPos - (9 - 9)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 173 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Foreach_($this->semStack[$stackPos - (6 - 3)], new \PHPUnit\PhpParser\Node\Expr\Error($this->startAttributeStack[$stackPos - (6 - 4)] + $this->endAttributeStack[$stackPos - (6 - 4)]), ['stmts' => $this->semStack[$stackPos - (6 - 6)]], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 174 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Declare_($this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 5)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 175 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TryCatch($this->semStack[$stackPos - (6 - 3)], $this->semStack[$stackPos - (6 - 5)], $this->semStack[$stackPos - (6 - 6)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
            $this->checkTryCatch($this->semValue);
        }, 176 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Goto_($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 177 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Label($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 178 => function ($stackPos) {
            $this->semValue = array();
            /* means: no statement */
        }, 179 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 180 => function ($stackPos) {
            $startAttributes = $this->startAttributeStack[$stackPos - (1 - 1)];
            if (isset($startAttributes['comments'])) {
                $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Nop($startAttributes + $this->endAttributes);
            } else {
                $this->semValue = null;
            }
            if ($this->semValue === null) {
                $this->semValue = array();
            }
            /* means: no statement */
        }, 181 => function ($stackPos) {
            $this->semValue = array();
        }, 182 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 183 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 184 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 185 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Catch_($this->semStack[$stackPos - (8 - 3)], $this->semStack[$stackPos - (8 - 4)], $this->semStack[$stackPos - (8 - 7)], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
        }, 186 => function ($stackPos) {
            $this->semValue = null;
        }, 187 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Finally_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 188 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 189 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 190 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 191 => function ($stackPos) {
            $this->semValue = \false;
        }, 192 => function ($stackPos) {
            $this->semValue = \true;
        }, 193 => function ($stackPos) {
            $this->semValue = \false;
        }, 194 => function ($stackPos) {
            $this->semValue = \true;
        }, 195 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 196 => function ($stackPos) {
            $this->semValue = [];
        }, 197 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Function_($this->semStack[$stackPos - (8 - 3)], ['byRef' => $this->semStack[$stackPos - (8 - 2)], 'params' => $this->semStack[$stackPos - (8 - 5)], 'returnType' => $this->semStack[$stackPos - (8 - 7)], 'stmts' => $this->semStack[$stackPos - (8 - 8)], 'attrGroups' => []], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
        }, 198 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Function_($this->semStack[$stackPos - (9 - 4)], ['byRef' => $this->semStack[$stackPos - (9 - 3)], 'params' => $this->semStack[$stackPos - (9 - 6)], 'returnType' => $this->semStack[$stackPos - (9 - 8)], 'stmts' => $this->semStack[$stackPos - (9 - 9)], 'attrGroups' => $this->semStack[$stackPos - (9 - 1)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 199 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Class_($this->semStack[$stackPos - (8 - 3)], ['type' => $this->semStack[$stackPos - (8 - 2)], 'extends' => $this->semStack[$stackPos - (8 - 4)], 'implements' => $this->semStack[$stackPos - (8 - 5)], 'stmts' => $this->semStack[$stackPos - (8 - 7)], 'attrGroups' => $this->semStack[$stackPos - (8 - 1)]], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
            $this->checkClass($this->semValue, $stackPos - (8 - 3));
        }, 200 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Interface_($this->semStack[$stackPos - (7 - 3)], ['extends' => $this->semStack[$stackPos - (7 - 4)], 'stmts' => $this->semStack[$stackPos - (7 - 6)], 'attrGroups' => $this->semStack[$stackPos - (7 - 1)]], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
            $this->checkInterface($this->semValue, $stackPos - (7 - 3));
        }, 201 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Trait_($this->semStack[$stackPos - (6 - 3)], ['stmts' => $this->semStack[$stackPos - (6 - 5)], 'attrGroups' => $this->semStack[$stackPos - (6 - 1)]], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 202 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Enum_($this->semStack[$stackPos - (8 - 3)], ['scalarType' => $this->semStack[$stackPos - (8 - 4)], 'implements' => $this->semStack[$stackPos - (8 - 5)], 'stmts' => $this->semStack[$stackPos - (8 - 7)], 'attrGroups' => $this->semStack[$stackPos - (8 - 1)]], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
            $this->checkEnum($this->semValue, $stackPos - (8 - 3));
        }, 203 => function ($stackPos) {
            $this->semValue = null;
        }, 204 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 205 => function ($stackPos) {
            $this->semValue = null;
        }, 206 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 207 => function ($stackPos) {
            $this->semValue = 0;
        }, 208 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT;
        }, 209 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL;
        }, 210 => function ($stackPos) {
            $this->semValue = null;
        }, 211 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 212 => function ($stackPos) {
            $this->semValue = array();
        }, 213 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 214 => function ($stackPos) {
            $this->semValue = array();
        }, 215 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 216 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 217 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 218 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 219 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 220 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 221 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 222 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 223 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 224 => function ($stackPos) {
            $this->semValue = null;
        }, 225 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 226 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 227 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 228 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 229 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\DeclareDeclare($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 230 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 231 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 3)];
        }, 232 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 233 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (5 - 3)];
        }, 234 => function ($stackPos) {
            $this->semValue = array();
        }, 235 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 236 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Case_($this->semStack[$stackPos - (4 - 2)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 237 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Case_(null, $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 238 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 239 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 240 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Match_($this->semStack[$stackPos - (7 - 3)], $this->semStack[$stackPos - (7 - 6)], $this->startAttributeStack[$stackPos - (7 - 1)] + $this->endAttributes);
        }, 241 => function ($stackPos) {
            $this->semValue = [];
        }, 242 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 243 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 244 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 245 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\MatchArm($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 246 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\MatchArm(null, $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 247 => function ($stackPos) {
            $this->semValue = \is_array($this->semStack[$stackPos - (1 - 1)]) ? $this->semStack[$stackPos - (1 - 1)] : array($this->semStack[$stackPos - (1 - 1)]);
        }, 248 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 249 => function ($stackPos) {
            $this->semValue = array();
        }, 250 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 251 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ElseIf_($this->semStack[$stackPos - (5 - 3)], \is_array($this->semStack[$stackPos - (5 - 5)]) ? $this->semStack[$stackPos - (5 - 5)] : array($this->semStack[$stackPos - (5 - 5)]), $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 252 => function ($stackPos) {
            $this->semValue = array();
        }, 253 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 254 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ElseIf_($this->semStack[$stackPos - (6 - 3)], $this->semStack[$stackPos - (6 - 6)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 255 => function ($stackPos) {
            $this->semValue = null;
        }, 256 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Else_(\is_array($this->semStack[$stackPos - (2 - 2)]) ? $this->semStack[$stackPos - (2 - 2)] : array($this->semStack[$stackPos - (2 - 2)]), $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 257 => function ($stackPos) {
            $this->semValue = null;
        }, 258 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Else_($this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 259 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)], \false);
        }, 260 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (2 - 2)], \true);
        }, 261 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)], \false);
        }, 262 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)], \false);
        }, 263 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 264 => function ($stackPos) {
            $this->semValue = array();
        }, 265 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 266 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 267 => function ($stackPos) {
            $this->semValue = 0;
        }, 268 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC;
        }, 269 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED;
        }, 270 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE;
        }, 271 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Param($this->semStack[$stackPos - (6 - 6)], null, $this->semStack[$stackPos - (6 - 3)], $this->semStack[$stackPos - (6 - 4)], $this->semStack[$stackPos - (6 - 5)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes, $this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 1)]);
            $this->checkParam($this->semValue);
        }, 272 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Param($this->semStack[$stackPos - (8 - 6)], $this->semStack[$stackPos - (8 - 8)], $this->semStack[$stackPos - (8 - 3)], $this->semStack[$stackPos - (8 - 4)], $this->semStack[$stackPos - (8 - 5)], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes, $this->semStack[$stackPos - (8 - 2)], $this->semStack[$stackPos - (8 - 1)]);
            $this->checkParam($this->semValue);
        }, 273 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Param(new \PHPUnit\PhpParser\Node\Expr\Error($this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes), null, $this->semStack[$stackPos - (6 - 3)], $this->semStack[$stackPos - (6 - 4)], $this->semStack[$stackPos - (6 - 5)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes, $this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 1)]);
        }, 274 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 275 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\NullableType($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 276 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\UnionType($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 277 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 278 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name('static', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 279 => function ($stackPos) {
            $this->semValue = $this->handleBuiltinTypes($this->semStack[$stackPos - (1 - 1)]);
        }, 280 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier('array', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 281 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Identifier('callable', $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 282 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)]);
        }, 283 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 284 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)]);
        }, 285 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 286 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 287 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\NullableType($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 288 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\UnionType($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 289 => function ($stackPos) {
            $this->semValue = null;
        }, 290 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 291 => function ($stackPos) {
            $this->semValue = null;
        }, 292 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 2)];
        }, 293 => function ($stackPos) {
            $this->semValue = null;
        }, 294 => function ($stackPos) {
            $this->semValue = array();
        }, 295 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 2)];
        }, 296 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 297 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 298 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (1 - 1)], \false, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 299 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (2 - 2)], \true, \false, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 300 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (2 - 2)], \false, \true, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 301 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Arg($this->semStack[$stackPos - (3 - 3)], \false, \false, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes, $this->semStack[$stackPos - (3 - 1)]);
        }, 302 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 303 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 304 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 305 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 306 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 307 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 308 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 309 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\StaticVar($this->semStack[$stackPos - (1 - 1)], null, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 310 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\StaticVar($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 311 => function ($stackPos) {
            if ($this->semStack[$stackPos - (2 - 2)] !== null) {
                $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
                $this->semValue = $this->semStack[$stackPos - (2 - 1)];
            }
        }, 312 => function ($stackPos) {
            $this->semValue = array();
        }, 313 => function ($stackPos) {
            $startAttributes = $this->lookaheadStartAttributes;
            if (isset($startAttributes['comments'])) {
                $nop = new \PHPUnit\PhpParser\Node\Stmt\Nop($this->createCommentNopAttributes($startAttributes['comments']));
            } else {
                $nop = null;
            }
            if ($nop !== null) {
                $this->semStack[$stackPos - (1 - 1)][] = $nop;
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 314 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\Property($this->semStack[$stackPos - (5 - 2)], $this->semStack[$stackPos - (5 - 4)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes, $this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 1)]);
            $this->checkProperty($this->semValue, $stackPos - (5 - 2));
        }, 315 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ClassConst($this->semStack[$stackPos - (5 - 4)], $this->semStack[$stackPos - (5 - 2)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes, $this->semStack[$stackPos - (5 - 1)]);
            $this->checkClassConst($this->semValue, $stackPos - (5 - 2));
        }, 316 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\ClassMethod($this->semStack[$stackPos - (10 - 5)], ['type' => $this->semStack[$stackPos - (10 - 2)], 'byRef' => $this->semStack[$stackPos - (10 - 4)], 'params' => $this->semStack[$stackPos - (10 - 7)], 'returnType' => $this->semStack[$stackPos - (10 - 9)], 'stmts' => $this->semStack[$stackPos - (10 - 10)], 'attrGroups' => $this->semStack[$stackPos - (10 - 1)]], $this->startAttributeStack[$stackPos - (10 - 1)] + $this->endAttributes);
            $this->checkClassMethod($this->semValue, $stackPos - (10 - 2));
        }, 317 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUse($this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 318 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\EnumCase($this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 4)], $this->semStack[$stackPos - (5 - 1)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 319 => function ($stackPos) {
            $this->semValue = null;
            /* will be skipped */
        }, 320 => function ($stackPos) {
            $this->semValue = array();
        }, 321 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 322 => function ($stackPos) {
            $this->semValue = array();
        }, 323 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 324 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Precedence($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 325 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (5 - 1)][0], $this->semStack[$stackPos - (5 - 1)][1], $this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 4)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 326 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], $this->semStack[$stackPos - (4 - 3)], null, $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 327 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], null, $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 328 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias($this->semStack[$stackPos - (4 - 1)][0], $this->semStack[$stackPos - (4 - 1)][1], null, $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 329 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)]);
        }, 330 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 331 => function ($stackPos) {
            $this->semValue = array(null, $this->semStack[$stackPos - (1 - 1)]);
        }, 332 => function ($stackPos) {
            $this->semValue = null;
        }, 333 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 334 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 335 => function ($stackPos) {
            $this->semValue = 0;
        }, 336 => function ($stackPos) {
            $this->semValue = 0;
        }, 337 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 338 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 339 => function ($stackPos) {
            $this->checkModifier($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $stackPos - (2 - 2));
            $this->semValue = $this->semStack[$stackPos - (2 - 1)] | $this->semStack[$stackPos - (2 - 2)];
        }, 340 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC;
        }, 341 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED;
        }, 342 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE;
        }, 343 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC;
        }, 344 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT;
        }, 345 => function ($stackPos) {
            $this->semValue = \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL;
        }, 346 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 347 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 348 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 349 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\VarLikeIdentifier(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 350 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\PropertyProperty($this->semStack[$stackPos - (1 - 1)], null, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 351 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Stmt\PropertyProperty($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 352 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 353 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 354 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 355 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 356 => function ($stackPos) {
            $this->semValue = array();
        }, 357 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 358 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 359 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Assign($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 360 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Assign($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 361 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Assign($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 362 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignRef($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 363 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 364 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 365 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Clone_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 366 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Plus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 367 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Minus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 368 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Mul($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 369 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Div($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 370 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Concat($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 371 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Mod($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 372 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 373 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 374 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 375 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftLeft($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 376 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftRight($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 377 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Pow($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 378 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\AssignOp\Coalesce($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 379 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PostInc($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 380 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PreInc($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 381 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PostDec($this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 382 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PreDec($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 383 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 384 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 385 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 386 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 387 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 388 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseOr($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 389 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseAnd($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 390 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseXor($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 391 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 392 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Plus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 393 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Minus($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 394 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mul($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 395 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Div($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 396 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mod($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 397 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftLeft($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 398 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftRight($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 399 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Pow($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 400 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\UnaryPlus($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 401 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\UnaryMinus($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 402 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BooleanNot($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 403 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BitwiseNot($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 404 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Identical($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 405 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotIdentical($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 406 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Equal($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 407 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 408 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Spaceship($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 409 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Smaller($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 410 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 411 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Greater($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 412 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 413 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Instanceof_($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 414 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 415 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Ternary($this->semStack[$stackPos - (5 - 1)], $this->semStack[$stackPos - (5 - 3)], $this->semStack[$stackPos - (5 - 5)], $this->startAttributeStack[$stackPos - (5 - 1)] + $this->endAttributes);
        }, 416 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Ternary($this->semStack[$stackPos - (4 - 1)], null, $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 417 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\BinaryOp\Coalesce($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 418 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Isset_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 419 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Empty_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 420 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 421 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE_ONCE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 422 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Eval_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 423 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 424 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Include_($this->semStack[$stackPos - (2 - 2)], \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE_ONCE, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 425 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Int_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 426 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes;
            $attrs['kind'] = $this->getFloatCastKind($this->semStack[$stackPos - (2 - 1)]);
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Double($this->semStack[$stackPos - (2 - 2)], $attrs);
        }, 427 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\String_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 428 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Array_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 429 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Object_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 430 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Bool_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 431 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Cast\Unset_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 432 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes;
            $attrs['kind'] = \strtolower($this->semStack[$stackPos - (2 - 1)]) === 'exit' ? \PHPUnit\PhpParser\Node\Expr\Exit_::KIND_EXIT : \PHPUnit\PhpParser\Node\Expr\Exit_::KIND_DIE;
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Exit_($this->semStack[$stackPos - (2 - 2)], $attrs);
        }, 433 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ErrorSuppress($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 434 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 435 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ShellExec($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 436 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Print_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 437 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Yield_(null, null, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 438 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Yield_($this->semStack[$stackPos - (2 - 2)], null, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 439 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Yield_($this->semStack[$stackPos - (4 - 4)], $this->semStack[$stackPos - (4 - 2)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 440 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\YieldFrom($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 441 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Throw_($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 442 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrowFunction(['static' => \false, 'byRef' => $this->semStack[$stackPos - (8 - 2)], 'params' => $this->semStack[$stackPos - (8 - 4)], 'returnType' => $this->semStack[$stackPos - (8 - 6)], 'expr' => $this->semStack[$stackPos - (8 - 8)], 'attrGroups' => []], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
        }, 443 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrowFunction(['static' => \true, 'byRef' => $this->semStack[$stackPos - (9 - 3)], 'params' => $this->semStack[$stackPos - (9 - 5)], 'returnType' => $this->semStack[$stackPos - (9 - 7)], 'expr' => $this->semStack[$stackPos - (9 - 9)], 'attrGroups' => []], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 444 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Closure(['static' => \false, 'byRef' => $this->semStack[$stackPos - (8 - 2)], 'params' => $this->semStack[$stackPos - (8 - 4)], 'uses' => $this->semStack[$stackPos - (8 - 6)], 'returnType' => $this->semStack[$stackPos - (8 - 7)], 'stmts' => $this->semStack[$stackPos - (8 - 8)], 'attrGroups' => []], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes);
        }, 445 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Closure(['static' => \true, 'byRef' => $this->semStack[$stackPos - (9 - 3)], 'params' => $this->semStack[$stackPos - (9 - 5)], 'uses' => $this->semStack[$stackPos - (9 - 7)], 'returnType' => $this->semStack[$stackPos - (9 - 8)], 'stmts' => $this->semStack[$stackPos - (9 - 9)], 'attrGroups' => []], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 446 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrowFunction(['static' => \false, 'byRef' => $this->semStack[$stackPos - (9 - 3)], 'params' => $this->semStack[$stackPos - (9 - 5)], 'returnType' => $this->semStack[$stackPos - (9 - 7)], 'expr' => $this->semStack[$stackPos - (9 - 9)], 'attrGroups' => $this->semStack[$stackPos - (9 - 1)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 447 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrowFunction(['static' => \true, 'byRef' => $this->semStack[$stackPos - (10 - 4)], 'params' => $this->semStack[$stackPos - (10 - 6)], 'returnType' => $this->semStack[$stackPos - (10 - 8)], 'expr' => $this->semStack[$stackPos - (10 - 10)], 'attrGroups' => $this->semStack[$stackPos - (10 - 1)]], $this->startAttributeStack[$stackPos - (10 - 1)] + $this->endAttributes);
        }, 448 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Closure(['static' => \false, 'byRef' => $this->semStack[$stackPos - (9 - 3)], 'params' => $this->semStack[$stackPos - (9 - 5)], 'uses' => $this->semStack[$stackPos - (9 - 7)], 'returnType' => $this->semStack[$stackPos - (9 - 8)], 'stmts' => $this->semStack[$stackPos - (9 - 9)], 'attrGroups' => $this->semStack[$stackPos - (9 - 1)]], $this->startAttributeStack[$stackPos - (9 - 1)] + $this->endAttributes);
        }, 449 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Closure(['static' => \true, 'byRef' => $this->semStack[$stackPos - (10 - 4)], 'params' => $this->semStack[$stackPos - (10 - 6)], 'uses' => $this->semStack[$stackPos - (10 - 8)], 'returnType' => $this->semStack[$stackPos - (10 - 9)], 'stmts' => $this->semStack[$stackPos - (10 - 10)], 'attrGroups' => $this->semStack[$stackPos - (10 - 1)]], $this->startAttributeStack[$stackPos - (10 - 1)] + $this->endAttributes);
        }, 450 => function ($stackPos) {
            $this->semValue = array(new \PHPUnit\PhpParser\Node\Stmt\Class_(null, ['type' => 0, 'extends' => $this->semStack[$stackPos - (8 - 4)], 'implements' => $this->semStack[$stackPos - (8 - 5)], 'stmts' => $this->semStack[$stackPos - (8 - 7)], 'attrGroups' => $this->semStack[$stackPos - (8 - 1)]], $this->startAttributeStack[$stackPos - (8 - 1)] + $this->endAttributes), $this->semStack[$stackPos - (8 - 3)]);
            $this->checkClass($this->semValue[0], -1);
        }, 451 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\New_($this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 452 => function ($stackPos) {
            list($class, $ctorArgs) = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\New_($class, $ctorArgs, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 453 => function ($stackPos) {
            $this->semValue = array();
        }, 454 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (4 - 3)];
        }, 455 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 456 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 457 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 458 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ClosureUse($this->semStack[$stackPos - (2 - 2)], $this->semStack[$stackPos - (2 - 1)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 459 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\FuncCall($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 460 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\FuncCall($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 461 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticCall($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 462 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 463 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 464 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 465 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 466 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name\FullyQualified(\substr($this->semStack[$stackPos - (1 - 1)], 1), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 467 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Name\Relative(\substr($this->semStack[$stackPos - (1 - 1)], 10), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 468 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 469 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 470 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 471 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Error($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
            $this->errorState = 2;
        }, 472 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 473 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 474 => function ($stackPos) {
            $this->semValue = null;
        }, 475 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 476 => function ($stackPos) {
            $this->semValue = array();
        }, 477 => function ($stackPos) {
            $this->semValue = array(new \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart(\PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($this->semStack[$stackPos - (1 - 1)], '`'), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes));
        }, 478 => function ($stackPos) {
            foreach ($this->semStack[$stackPos - (1 - 1)] as $s) {
                if ($s instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart) {
                    $s->value = \PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($s->value, '`', \true);
                }
            }
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 479 => function ($stackPos) {
            $this->semValue = array();
        }, 480 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 481 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ConstFetch($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 482 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Line($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 483 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\File($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 484 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Dir($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 485 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Class_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 486 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Trait_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 487 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Method($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 488 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Function_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 489 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\MagicConst\Namespace_($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 490 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ClassConstFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 491 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ClassConstFetch($this->semStack[$stackPos - (3 - 1)], new \PHPUnit\PhpParser\Node\Expr\Error($this->startAttributeStack[$stackPos - (3 - 3)] + $this->endAttributeStack[$stackPos - (3 - 3)]), $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
            $this->errorState = 2;
        }, 492 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes;
            $attrs['kind'] = \PHPUnit\PhpParser\Node\Expr\Array_::KIND_SHORT;
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Array_($this->semStack[$stackPos - (3 - 2)], $attrs);
        }, 493 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes;
            $attrs['kind'] = \PHPUnit\PhpParser\Node\Expr\Array_::KIND_LONG;
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Array_($this->semStack[$stackPos - (4 - 3)], $attrs);
        }, 494 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 495 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes;
            $attrs['kind'] = $this->semStack[$stackPos - (1 - 1)][0] === "'" || $this->semStack[$stackPos - (1 - 1)][1] === "'" && ($this->semStack[$stackPos - (1 - 1)][0] === 'b' || $this->semStack[$stackPos - (1 - 1)][0] === 'B') ? \PHPUnit\PhpParser\Node\Scalar\String_::KIND_SINGLE_QUOTED : \PHPUnit\PhpParser\Node\Scalar\String_::KIND_DOUBLE_QUOTED;
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\String_(\PHPUnit\PhpParser\Node\Scalar\String_::parse($this->semStack[$stackPos - (1 - 1)]), $attrs);
        }, 496 => function ($stackPos) {
            $attrs = $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes;
            $attrs['kind'] = \PHPUnit\PhpParser\Node\Scalar\String_::KIND_DOUBLE_QUOTED;
            foreach ($this->semStack[$stackPos - (3 - 2)] as $s) {
                if ($s instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart) {
                    $s->value = \PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($s->value, '"', \true);
                }
            }
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\Encapsed($this->semStack[$stackPos - (3 - 2)], $attrs);
        }, 497 => function ($stackPos) {
            $this->semValue = $this->parseLNumber($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 498 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\DNumber(\PHPUnit\PhpParser\Node\Scalar\DNumber::parse($this->semStack[$stackPos - (1 - 1)]), $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 499 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 500 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 501 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 502 => function ($stackPos) {
            $this->semValue = $this->parseDocString($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes, $this->startAttributeStack[$stackPos - (3 - 3)] + $this->endAttributeStack[$stackPos - (3 - 3)], \true);
        }, 503 => function ($stackPos) {
            $this->semValue = $this->parseDocString($this->semStack[$stackPos - (2 - 1)], '', $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes, $this->startAttributeStack[$stackPos - (2 - 2)] + $this->endAttributeStack[$stackPos - (2 - 2)], \true);
        }, 504 => function ($stackPos) {
            $this->semValue = $this->parseDocString($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 2)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes, $this->startAttributeStack[$stackPos - (3 - 3)] + $this->endAttributeStack[$stackPos - (3 - 3)], \true);
        }, 505 => function ($stackPos) {
            $this->semValue = null;
        }, 506 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 507 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 508 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 509 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 510 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 511 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 512 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 513 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 514 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 515 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 516 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 517 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 518 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 519 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 520 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\MethodCall($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 521 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\NullsafeMethodCall($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->semStack[$stackPos - (4 - 4)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 522 => function ($stackPos) {
            $this->semValue = null;
        }, 523 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 524 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 525 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 526 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 527 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\NullsafePropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 528 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 529 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 530 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 531 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable(new \PHPUnit\PhpParser\Node\Expr\Error($this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes), $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
            $this->errorState = 2;
        }, 532 => function ($stackPos) {
            $var = $this->semStack[$stackPos - (1 - 1)]->name;
            $this->semValue = \is_string($var) ? new \PHPUnit\PhpParser\Node\VarLikeIdentifier($var, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes) : $var;
        }, 533 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 534 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 535 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 536 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 537 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 538 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\NullsafePropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 539 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 540 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 541 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 542 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 543 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 544 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 545 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 546 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 547 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Error($this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
            $this->errorState = 2;
        }, 548 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\List_($this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 549 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
            $end = \count($this->semValue) - 1;
            if ($this->semValue[$end] === null) {
                \array_pop($this->semValue);
            }
        }, 550 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos];
        }, 551 => function ($stackPos) {
            /* do nothing -- prevent default action of $$=$this->semStack[$1]. See $551. */
        }, 552 => function ($stackPos) {
            $this->semStack[$stackPos - (3 - 1)][] = $this->semStack[$stackPos - (3 - 3)];
            $this->semValue = $this->semStack[$stackPos - (3 - 1)];
        }, 553 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 554 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (1 - 1)], null, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 555 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (2 - 2)], null, \true, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 556 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (1 - 1)], null, \false, $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 557 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (3 - 3)], $this->semStack[$stackPos - (3 - 1)], \false, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 558 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (4 - 4)], $this->semStack[$stackPos - (4 - 1)], \true, $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 559 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (3 - 3)], $this->semStack[$stackPos - (3 - 1)], \false, $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 560 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayItem($this->semStack[$stackPos - (2 - 2)], null, \false, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes, \true, $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 561 => function ($stackPos) {
            $this->semValue = null;
        }, 562 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 563 => function ($stackPos) {
            $this->semStack[$stackPos - (2 - 1)][] = $this->semStack[$stackPos - (2 - 2)];
            $this->semValue = $this->semStack[$stackPos - (2 - 1)];
        }, 564 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (1 - 1)]);
        }, 565 => function ($stackPos) {
            $this->semValue = array($this->semStack[$stackPos - (2 - 1)], $this->semStack[$stackPos - (2 - 2)]);
        }, 566 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 567 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 568 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }, 569 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (4 - 1)], $this->semStack[$stackPos - (4 - 3)], $this->startAttributeStack[$stackPos - (4 - 1)] + $this->endAttributes);
        }, 570 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\PropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 571 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\NullsafePropertyFetch($this->semStack[$stackPos - (3 - 1)], $this->semStack[$stackPos - (3 - 3)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 572 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 573 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\Variable($this->semStack[$stackPos - (3 - 2)], $this->startAttributeStack[$stackPos - (3 - 1)] + $this->endAttributes);
        }, 574 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch($this->semStack[$stackPos - (6 - 2)], $this->semStack[$stackPos - (6 - 4)], $this->startAttributeStack[$stackPos - (6 - 1)] + $this->endAttributes);
        }, 575 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (3 - 2)];
        }, 576 => function ($stackPos) {
            $this->semValue = new \PHPUnit\PhpParser\Node\Scalar\String_($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 577 => function ($stackPos) {
            $this->semValue = $this->parseNumString($this->semStack[$stackPos - (1 - 1)], $this->startAttributeStack[$stackPos - (1 - 1)] + $this->endAttributes);
        }, 578 => function ($stackPos) {
            $this->semValue = $this->parseNumString('-' . $this->semStack[$stackPos - (2 - 2)], $this->startAttributeStack[$stackPos - (2 - 1)] + $this->endAttributes);
        }, 579 => function ($stackPos) {
            $this->semValue = $this->semStack[$stackPos - (1 - 1)];
        }];
    }
}
<?php

namespace PHPUnit\PhpParser\Parser;

/* GENERATED file based on grammar/tokens.y */
final class Tokens
{
    const YYERRTOK = 256;
    const T_THROW = 257;
    const T_INCLUDE = 258;
    const T_INCLUDE_ONCE = 259;
    const T_EVAL = 260;
    const T_REQUIRE = 261;
    const T_REQUIRE_ONCE = 262;
    const T_LOGICAL_OR = 263;
    const T_LOGICAL_XOR = 264;
    const T_LOGICAL_AND = 265;
    const T_PRINT = 266;
    const T_YIELD = 267;
    const T_DOUBLE_ARROW = 268;
    const T_YIELD_FROM = 269;
    const T_PLUS_EQUAL = 270;
    const T_MINUS_EQUAL = 271;
    const T_MUL_EQUAL = 272;
    const T_DIV_EQUAL = 273;
    const T_CONCAT_EQUAL = 274;
    const T_MOD_EQUAL = 275;
    const T_AND_EQUAL = 276;
    const T_OR_EQUAL = 277;
    const T_XOR_EQUAL = 278;
    const T_SL_EQUAL = 279;
    const T_SR_EQUAL = 280;
    const T_POW_EQUAL = 281;
    const T_COALESCE_EQUAL = 282;
    const T_COALESCE = 283;
    const T_BOOLEAN_OR = 284;
    const T_BOOLEAN_AND = 285;
    const T_IS_EQUAL = 286;
    const T_IS_NOT_EQUAL = 287;
    const T_IS_IDENTICAL = 288;
    const T_IS_NOT_IDENTICAL = 289;
    const T_SPACESHIP = 290;
    const T_IS_SMALLER_OR_EQUAL = 291;
    const T_IS_GREATER_OR_EQUAL = 292;
    const T_SL = 293;
    const T_SR = 294;
    const T_INSTANCEOF = 295;
    const T_INC = 296;
    const T_DEC = 297;
    const T_INT_CAST = 298;
    const T_DOUBLE_CAST = 299;
    const T_STRING_CAST = 300;
    const T_ARRAY_CAST = 301;
    const T_OBJECT_CAST = 302;
    const T_BOOL_CAST = 303;
    const T_UNSET_CAST = 304;
    const T_POW = 305;
    const T_NEW = 306;
    const T_CLONE = 307;
    const T_EXIT = 308;
    const T_IF = 309;
    const T_ELSEIF = 310;
    const T_ELSE = 311;
    const T_ENDIF = 312;
    const T_LNUMBER = 313;
    const T_DNUMBER = 314;
    const T_STRING = 315;
    const T_STRING_VARNAME = 316;
    const T_VARIABLE = 317;
    const T_NUM_STRING = 318;
    const T_INLINE_HTML = 319;
    const T_ENCAPSED_AND_WHITESPACE = 320;
    const T_CONSTANT_ENCAPSED_STRING = 321;
    const T_ECHO = 322;
    const T_DO = 323;
    const T_WHILE = 324;
    const T_ENDWHILE = 325;
    const T_FOR = 326;
    const T_ENDFOR = 327;
    const T_FOREACH = 328;
    const T_ENDFOREACH = 329;
    const T_DECLARE = 330;
    const T_ENDDECLARE = 331;
    const T_AS = 332;
    const T_SWITCH = 333;
    const T_MATCH = 334;
    const T_ENDSWITCH = 335;
    const T_CASE = 336;
    const T_DEFAULT = 337;
    const T_BREAK = 338;
    const T_CONTINUE = 339;
    const T_GOTO = 340;
    const T_FUNCTION = 341;
    const T_FN = 342;
    const T_CONST = 343;
    const T_RETURN = 344;
    const T_TRY = 345;
    const T_CATCH = 346;
    const T_FINALLY = 347;
    const T_USE = 348;
    const T_INSTEADOF = 349;
    const T_GLOBAL = 350;
    const T_STATIC = 351;
    const T_ABSTRACT = 352;
    const T_FINAL = 353;
    const T_PRIVATE = 354;
    const T_PROTECTED = 355;
    const T_PUBLIC = 356;
    const T_VAR = 357;
    const T_UNSET = 358;
    const T_ISSET = 359;
    const T_EMPTY = 360;
    const T_HALT_COMPILER = 361;
    const T_CLASS = 362;
    const T_TRAIT = 363;
    const T_INTERFACE = 364;
    const T_ENUM = 365;
    const T_EXTENDS = 366;
    const T_IMPLEMENTS = 367;
    const T_OBJECT_OPERATOR = 368;
    const T_NULLSAFE_OBJECT_OPERATOR = 369;
    const T_LIST = 370;
    const T_ARRAY = 371;
    const T_CALLABLE = 372;
    const T_CLASS_C = 373;
    const T_TRAIT_C = 374;
    const T_METHOD_C = 375;
    const T_FUNC_C = 376;
    const T_LINE = 377;
    const T_FILE = 378;
    const T_START_HEREDOC = 379;
    const T_END_HEREDOC = 380;
    const T_DOLLAR_OPEN_CURLY_BRACES = 381;
    const T_CURLY_OPEN = 382;
    const T_PAAMAYIM_NEKUDOTAYIM = 383;
    const T_NAMESPACE = 384;
    const T_NS_C = 385;
    const T_DIR = 386;
    const T_NS_SEPARATOR = 387;
    const T_ELLIPSIS = 388;
    const T_NAME_FULLY_QUALIFIED = 389;
    const T_NAME_QUALIFIED = 390;
    const T_NAME_RELATIVE = 391;
    const T_ATTRIBUTE = 392;
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

/*
 * This parser is based on a skeleton written by Moriyoshi Koizumi, which in
 * turn is based on work by Masato Bito.
 */
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Expr\Cast\Double;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Param;
use PHPUnit\PhpParser\Node\Scalar\Encapsed;
use PHPUnit\PhpParser\Node\Scalar\LNumber;
use PHPUnit\PhpParser\Node\Scalar\String_;
use PHPUnit\PhpParser\Node\Stmt\Class_;
use PHPUnit\PhpParser\Node\Stmt\ClassConst;
use PHPUnit\PhpParser\Node\Stmt\ClassMethod;
use PHPUnit\PhpParser\Node\Stmt\Enum_;
use PHPUnit\PhpParser\Node\Stmt\Interface_;
use PHPUnit\PhpParser\Node\Stmt\Namespace_;
use PHPUnit\PhpParser\Node\Stmt\Property;
use PHPUnit\PhpParser\Node\Stmt\TryCatch;
use PHPUnit\PhpParser\Node\Stmt\UseUse;
use PHPUnit\PhpParser\Node\VarLikeIdentifier;
abstract class ParserAbstract implements \PHPUnit\PhpParser\Parser
{
    const SYMBOL_NONE = -1;
    /*
     * The following members will be filled with generated parsing data:
     */
    /** @var int Size of $tokenToSymbol map */
    protected $tokenToSymbolMapSize;
    /** @var int Size of $action table */
    protected $actionTableSize;
    /** @var int Size of $goto table */
    protected $gotoTableSize;
    /** @var int Symbol number signifying an invalid token */
    protected $invalidSymbol;
    /** @var int Symbol number of error recovery token */
    protected $errorSymbol;
    /** @var int Action number signifying default action */
    protected $defaultAction;
    /** @var int Rule number signifying that an unexpected token was encountered */
    protected $unexpectedTokenRule;
    protected $YY2TBLSTATE;
    /** @var int Number of non-leaf states */
    protected $numNonLeafStates;
    /** @var int[] Map of lexer tokens to internal symbols */
    protected $tokenToSymbol;
    /** @var string[] Map of symbols to their names */
    protected $symbolToName;
    /** @var array Names of the production rules (only necessary for debugging) */
    protected $productions;
    /** @var int[] Map of states to a displacement into the $action table. The corresponding action for this
     *             state/symbol pair is $action[$actionBase[$state] + $symbol]. If $actionBase[$state] is 0, the
     *             action is defaulted, i.e. $actionDefault[$state] should be used instead. */
    protected $actionBase;
    /** @var int[] Table of actions. Indexed according to $actionBase comment. */
    protected $action;
    /** @var int[] Table indexed analogously to $action. If $actionCheck[$actionBase[$state] + $symbol] != $symbol
     *             then the action is defaulted, i.e. $actionDefault[$state] should be used instead. */
    protected $actionCheck;
    /** @var int[] Map of states to their default action */
    protected $actionDefault;
    /** @var callable[] Semantic action callbacks */
    protected $reduceCallbacks;
    /** @var int[] Map of non-terminals to a displacement into the $goto table. The corresponding goto state for this
     *             non-terminal/state pair is $goto[$gotoBase[$nonTerminal] + $state] (unless defaulted) */
    protected $gotoBase;
    /** @var int[] Table of states to goto after reduction. Indexed according to $gotoBase comment. */
    protected $goto;
    /** @var int[] Table indexed analogously to $goto. If $gotoCheck[$gotoBase[$nonTerminal] + $state] != $nonTerminal
     *             then the goto state is defaulted, i.e. $gotoDefault[$nonTerminal] should be used. */
    protected $gotoCheck;
    /** @var int[] Map of non-terminals to the default state to goto after their reduction */
    protected $gotoDefault;
    /** @var int[] Map of rules to the non-terminal on their left-hand side, i.e. the non-terminal to use for
     *             determining the state to goto after reduction. */
    protected $ruleToNonTerminal;
    /** @var int[] Map of rules to the length of their right-hand side, which is the number of elements that have to
     *             be popped from the stack(s) on reduction. */
    protected $ruleToLength;
    /*
     * The following members are part of the parser state:
     */
    /** @var Lexer Lexer that is used when parsing */
    protected $lexer;
    /** @var mixed Temporary value containing the result of last semantic action (reduction) */
    protected $semValue;
    /** @var array Semantic value stack (contains values of tokens and semantic action results) */
    protected $semStack;
    /** @var array[] Start attribute stack */
    protected $startAttributeStack;
    /** @var array[] End attribute stack */
    protected $endAttributeStack;
    /** @var array End attributes of last *shifted* token */
    protected $endAttributes;
    /** @var array Start attributes of last *read* token */
    protected $lookaheadStartAttributes;
    /** @var ErrorHandler Error handler */
    protected $errorHandler;
    /** @var int Error state, used to avoid error floods */
    protected $errorState;
    /**
     * Initialize $reduceCallbacks map.
     */
    protected abstract function initReduceCallbacks();
    /**
     * Creates a parser instance.
     *
     * Options: Currently none.
     *
     * @param Lexer $lexer A lexer
     * @param array $options Options array.
     */
    public function __construct(\PHPUnit\PhpParser\Lexer $lexer, array $options = [])
    {
        $this->lexer = $lexer;
        if (isset($options['throwOnError'])) {
            throw new \LogicException('"throwOnError" is no longer supported, use "errorHandler" instead');
        }
        $this->initReduceCallbacks();
    }
    /**
     * Parses PHP code into a node tree.
     *
     * If a non-throwing error handler is used, the parser will continue parsing after an error
     * occurred and attempt to build a partial AST.
     *
     * @param string $code The source code to parse
     * @param ErrorHandler|null $errorHandler Error handler to use for lexer/parser errors, defaults
     *                                        to ErrorHandler\Throwing.
     *
     * @return Node\Stmt[]|null Array of statements (or null non-throwing error handler is used and
     *                          the parser was unable to recover from an error).
     */
    public function parse(string $code, \PHPUnit\PhpParser\ErrorHandler $errorHandler = null)
    {
        $this->errorHandler = $errorHandler ?: new \PHPUnit\PhpParser\ErrorHandler\Throwing();
        $this->lexer->startLexing($code, $this->errorHandler);
        $result = $this->doParse();
        // Clear out some of the interior state, so we don't hold onto unnecessary
        // memory between uses of the parser
        $this->startAttributeStack = [];
        $this->endAttributeStack = [];
        $this->semStack = [];
        $this->semValue = null;
        return $result;
    }
    protected function doParse()
    {
        // We start off with no lookahead-token
        $symbol = self::SYMBOL_NONE;
        // The attributes for a node are taken from the first and last token of the node.
        // From the first token only the startAttributes are taken and from the last only
        // the endAttributes. Both are merged using the array union operator (+).
        $startAttributes = [];
        $endAttributes = [];
        $this->endAttributes = $endAttributes;
        // Keep stack of start and end attributes
        $this->startAttributeStack = [];
        $this->endAttributeStack = [$endAttributes];
        // Start off in the initial state and keep a stack of previous states
        $state = 0;
        $stateStack = [$state];
        // Semantic value stack (contains values of tokens and semantic action results)
        $this->semStack = [];
        // Current position in the stack(s)
        $stackPos = 0;
        $this->errorState = 0;
        for (;;) {
            //$this->traceNewState($state, $symbol);
            if ($this->actionBase[$state] === 0) {
                $rule = $this->actionDefault[$state];
            } else {
                if ($symbol === self::SYMBOL_NONE) {
                    // Fetch the next token id from the lexer and fetch additional info by-ref.
                    // The end attributes are fetched into a temporary variable and only set once the token is really
                    // shifted (not during read). Otherwise you would sometimes get off-by-one errors, when a rule is
                    // reduced after a token was read but not yet shifted.
                    $tokenId = $this->lexer->getNextToken($tokenValue, $startAttributes, $endAttributes);
                    // map the lexer token id to the internally used symbols
                    $symbol = $tokenId >= 0 && $tokenId < $this->tokenToSymbolMapSize ? $this->tokenToSymbol[$tokenId] : $this->invalidSymbol;
                    if ($symbol === $this->invalidSymbol) {
                        throw new \RangeException(\sprintf('The lexer returned an invalid token (id=%d, value=%s)', $tokenId, $tokenValue));
                    }
                    // Allow productions to access the start attributes of the lookahead token.
                    $this->lookaheadStartAttributes = $startAttributes;
                    //$this->traceRead($symbol);
                }
                $idx = $this->actionBase[$state] + $symbol;
                if (($idx >= 0 && $idx < $this->actionTableSize && $this->actionCheck[$idx] === $symbol || $state < $this->YY2TBLSTATE && ($idx = $this->actionBase[$state + $this->numNonLeafStates] + $symbol) >= 0 && $idx < $this->actionTableSize && $this->actionCheck[$idx] === $symbol) && ($action = $this->action[$idx]) !== $this->defaultAction) {
                    /*
                     * >= numNonLeafStates: shift and reduce
                     * > 0: shift
                     * = 0: accept
                     * < 0: reduce
                     * = -YYUNEXPECTED: error
                     */
                    if ($action > 0) {
                        /* shift */
                        //$this->traceShift($symbol);
                        ++$stackPos;
                        $stateStack[$stackPos] = $state = $action;
                        $this->semStack[$stackPos] = $tokenValue;
                        $this->startAttributeStack[$stackPos] = $startAttributes;
                        $this->endAttributeStack[$stackPos] = $endAttributes;
                        $this->endAttributes = $endAttributes;
                        $symbol = self::SYMBOL_NONE;
                        if ($this->errorState) {
                            --$this->errorState;
                        }
                        if ($action < $this->numNonLeafStates) {
                            continue;
                        }
                        /* $yyn >= numNonLeafStates means shift-and-reduce */
                        $rule = $action - $this->numNonLeafStates;
                    } else {
                        $rule = -$action;
                    }
                } else {
                    $rule = $this->actionDefault[$state];
                }
            }
            for (;;) {
                if ($rule === 0) {
                    /* accept */
                    //$this->traceAccept();
                    return $this->semValue;
                } elseif ($rule !== $this->unexpectedTokenRule) {
                    /* reduce */
                    //$this->traceReduce($rule);
                    try {
                        $this->reduceCallbacks[$rule]($stackPos);
                    } catch (\PHPUnit\PhpParser\Error $e) {
                        if (-1 === $e->getStartLine() && isset($startAttributes['startLine'])) {
                            $e->setStartLine($startAttributes['startLine']);
                        }
                        $this->emitError($e);
                        // Can't recover from this type of error
                        return null;
                    }
                    /* Goto - shift nonterminal */
                    $lastEndAttributes = $this->endAttributeStack[$stackPos];
                    $ruleLength = $this->ruleToLength[$rule];
                    $stackPos -= $ruleLength;
                    $nonTerminal = $this->ruleToNonTerminal[$rule];
                    $idx = $this->gotoBase[$nonTerminal] + $stateStack[$stackPos];
                    if ($idx >= 0 && $idx < $this->gotoTableSize && $this->gotoCheck[$idx] === $nonTerminal) {
                        $state = $this->goto[$idx];
                    } else {
                        $state = $this->gotoDefault[$nonTerminal];
                    }
                    ++$stackPos;
                    $stateStack[$stackPos] = $state;
                    $this->semStack[$stackPos] = $this->semValue;
                    $this->endAttributeStack[$stackPos] = $lastEndAttributes;
                    if ($ruleLength === 0) {
                        // Empty productions use the start attributes of the lookahead token.
                        $this->startAttributeStack[$stackPos] = $this->lookaheadStartAttributes;
                    }
                } else {
                    /* error */
                    switch ($this->errorState) {
                        case 0:
                            $msg = $this->getErrorMessage($symbol, $state);
                            $this->emitError(new \PHPUnit\PhpParser\Error($msg, $startAttributes + $endAttributes));
                        // Break missing intentionally
                        case 1:
                        case 2:
                            $this->errorState = 3;
                            // Pop until error-expecting state uncovered
                            while (!(($idx = $this->actionBase[$state] + $this->errorSymbol) >= 0 && $idx < $this->actionTableSize && $this->actionCheck[$idx] === $this->errorSymbol || $state < $this->YY2TBLSTATE && ($idx = $this->actionBase[$state + $this->numNonLeafStates] + $this->errorSymbol) >= 0 && $idx < $this->actionTableSize && $this->actionCheck[$idx] === $this->errorSymbol) || ($action = $this->action[$idx]) === $this->defaultAction) {
                                // Not totally sure about this
                                if ($stackPos <= 0) {
                                    // Could not recover from error
                                    return null;
                                }
                                $state = $stateStack[--$stackPos];
                                //$this->tracePop($state);
                            }
                            //$this->traceShift($this->errorSymbol);
                            ++$stackPos;
                            $stateStack[$stackPos] = $state = $action;
                            // We treat the error symbol as being empty, so we reset the end attributes
                            // to the end attributes of the last non-error symbol
                            $this->startAttributeStack[$stackPos] = $this->lookaheadStartAttributes;
                            $this->endAttributeStack[$stackPos] = $this->endAttributeStack[$stackPos - 1];
                            $this->endAttributes = $this->endAttributeStack[$stackPos - 1];
                            break;
                        case 3:
                            if ($symbol === 0) {
                                // Reached EOF without recovering from error
                                return null;
                            }
                            //$this->traceDiscard($symbol);
                            $symbol = self::SYMBOL_NONE;
                            break 2;
                    }
                }
                if ($state < $this->numNonLeafStates) {
                    break;
                }
                /* >= numNonLeafStates means shift-and-reduce */
                $rule = $state - $this->numNonLeafStates;
            }
        }
        throw new \RuntimeException('Reached end of parser loop');
    }
    protected function emitError(\PHPUnit\PhpParser\Error $error)
    {
        $this->errorHandler->handleError($error);
    }
    /**
     * Format error message including expected tokens.
     *
     * @param int $symbol Unexpected symbol
     * @param int $state  State at time of error
     *
     * @return string Formatted error message
     */
    protected function getErrorMessage(int $symbol, int $state) : string
    {
        $expectedString = '';
        if ($expected = $this->getExpectedTokens($state)) {
            $expectedString = ', expecting ' . \implode(' or ', $expected);
        }
        return 'Syntax error, unexpected ' . $this->symbolToName[$symbol] . $expectedString;
    }
    /**
     * Get limited number of expected tokens in given state.
     *
     * @param int $state State
     *
     * @return string[] Expected tokens. If too many, an empty array is returned.
     */
    protected function getExpectedTokens(int $state) : array
    {
        $expected = [];
        $base = $this->actionBase[$state];
        foreach ($this->symbolToName as $symbol => $name) {
            $idx = $base + $symbol;
            if ($idx >= 0 && $idx < $this->actionTableSize && $this->actionCheck[$idx] === $symbol || $state < $this->YY2TBLSTATE && ($idx = $this->actionBase[$state + $this->numNonLeafStates] + $symbol) >= 0 && $idx < $this->actionTableSize && $this->actionCheck[$idx] === $symbol) {
                if ($this->action[$idx] !== $this->unexpectedTokenRule && $this->action[$idx] !== $this->defaultAction && $symbol !== $this->errorSymbol) {
                    if (\count($expected) === 4) {
                        /* Too many expected tokens */
                        return [];
                    }
                    $expected[] = $name;
                }
            }
        }
        return $expected;
    }
    /*
     * Tracing functions used for debugging the parser.
     */
    /*
    protected function traceNewState($state, $symbol) {
        echo '% State ' . $state
            . ', Lookahead ' . ($symbol == self::SYMBOL_NONE ? '--none--' : $this->symbolToName[$symbol]) . "\n";
    }
    
    protected function traceRead($symbol) {
        echo '% Reading ' . $this->symbolToName[$symbol] . "\n";
    }
    
    protected function traceShift($symbol) {
        echo '% Shift ' . $this->symbolToName[$symbol] . "\n";
    }
    
    protected function traceAccept() {
        echo "% Accepted.\n";
    }
    
    protected function traceReduce($n) {
        echo '% Reduce by (' . $n . ') ' . $this->productions[$n] . "\n";
    }
    
    protected function tracePop($state) {
        echo '% Recovering, uncovered state ' . $state . "\n";
    }
    
    protected function traceDiscard($symbol) {
        echo '% Discard ' . $this->symbolToName[$symbol] . "\n";
    }
    */
    /*
     * Helper functions invoked by semantic actions
     */
    /**
     * Moves statements of semicolon-style namespaces into $ns->stmts and checks various error conditions.
     *
     * @param Node\Stmt[] $stmts
     * @return Node\Stmt[]
     */
    protected function handleNamespaces(array $stmts) : array
    {
        $hasErrored = \false;
        $style = $this->getNamespacingStyle($stmts);
        if (null === $style) {
            // not namespaced, nothing to do
            return $stmts;
        } elseif ('brace' === $style) {
            // For braced namespaces we only have to check that there are no invalid statements between the namespaces
            $afterFirstNamespace = \false;
            foreach ($stmts as $stmt) {
                if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Namespace_) {
                    $afterFirstNamespace = \true;
                } elseif (!$stmt instanceof \PHPUnit\PhpParser\Node\Stmt\HaltCompiler && !$stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Nop && $afterFirstNamespace && !$hasErrored) {
                    $this->emitError(new \PHPUnit\PhpParser\Error('No code may exist outside of namespace {}', $stmt->getAttributes()));
                    $hasErrored = \true;
                    // Avoid one error for every statement
                }
            }
            return $stmts;
        } else {
            // For semicolon namespaces we have to move the statements after a namespace declaration into ->stmts
            $resultStmts = [];
            $targetStmts =& $resultStmts;
            $lastNs = null;
            foreach ($stmts as $stmt) {
                if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Namespace_) {
                    if ($lastNs !== null) {
                        $this->fixupNamespaceAttributes($lastNs);
                    }
                    if ($stmt->stmts === null) {
                        $stmt->stmts = [];
                        $targetStmts =& $stmt->stmts;
                        $resultStmts[] = $stmt;
                    } else {
                        // This handles the invalid case of mixed style namespaces
                        $resultStmts[] = $stmt;
                        $targetStmts =& $resultStmts;
                    }
                    $lastNs = $stmt;
                } elseif ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\HaltCompiler) {
                    // __halt_compiler() is not moved into the namespace
                    $resultStmts[] = $stmt;
                } else {
                    $targetStmts[] = $stmt;
                }
            }
            if ($lastNs !== null) {
                $this->fixupNamespaceAttributes($lastNs);
            }
            return $resultStmts;
        }
    }
    private function fixupNamespaceAttributes(\PHPUnit\PhpParser\Node\Stmt\Namespace_ $stmt)
    {
        // We moved the statements into the namespace node, as such the end of the namespace node
        // needs to be extended to the end of the statements.
        if (empty($stmt->stmts)) {
            return;
        }
        // We only move the builtin end attributes here. This is the best we can do with the
        // knowledge we have.
        $endAttributes = ['endLine', 'endFilePos', 'endTokenPos'];
        $lastStmt = $stmt->stmts[\count($stmt->stmts) - 1];
        foreach ($endAttributes as $endAttribute) {
            if ($lastStmt->hasAttribute($endAttribute)) {
                $stmt->setAttribute($endAttribute, $lastStmt->getAttribute($endAttribute));
            }
        }
    }
    /**
     * Determine namespacing style (semicolon or brace)
     *
     * @param Node[] $stmts Top-level statements.
     *
     * @return null|string One of "semicolon", "brace" or null (no namespaces)
     */
    private function getNamespacingStyle(array $stmts)
    {
        $style = null;
        $hasNotAllowedStmts = \false;
        foreach ($stmts as $i => $stmt) {
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Namespace_) {
                $currentStyle = null === $stmt->stmts ? 'semicolon' : 'brace';
                if (null === $style) {
                    $style = $currentStyle;
                    if ($hasNotAllowedStmts) {
                        $this->emitError(new \PHPUnit\PhpParser\Error('Namespace declaration statement has to be the very first statement in the script', $stmt->getLine()));
                    }
                } elseif ($style !== $currentStyle) {
                    $this->emitError(new \PHPUnit\PhpParser\Error('Cannot mix bracketed namespace declarations with unbracketed namespace declarations', $stmt->getLine()));
                    // Treat like semicolon style for namespace normalization
                    return 'semicolon';
                }
                continue;
            }
            /* declare(), __halt_compiler() and nops can be used before a namespace declaration */
            if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Declare_ || $stmt instanceof \PHPUnit\PhpParser\Node\Stmt\HaltCompiler || $stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Nop) {
                continue;
            }
            /* There may be a hashbang line at the very start of the file */
            if ($i === 0 && $stmt instanceof \PHPUnit\PhpParser\Node\Stmt\InlineHTML && \preg_match('/\\A#!.*\\r?\\n\\z/', $stmt->value)) {
                continue;
            }
            /* Everything else if forbidden before namespace declarations */
            $hasNotAllowedStmts = \true;
        }
        return $style;
    }
    /**
     * Fix up parsing of static property calls in PHP 5.
     *
     * In PHP 5 A::$b[c][d] and A::$b[c][d]() have very different interpretation. The former is
     * interpreted as (A::$b)[c][d], while the latter is the same as A::{$b[c][d]}(). We parse the
     * latter as the former initially and this method fixes the AST into the correct form when we
     * encounter the "()".
     *
     * @param  Node\Expr\StaticPropertyFetch|Node\Expr\ArrayDimFetch $prop
     * @param  Node\Arg[] $args
     * @param  array      $attributes
     *
     * @return Expr\StaticCall
     */
    protected function fixupPhp5StaticPropCall($prop, array $args, array $attributes) : \PHPUnit\PhpParser\Node\Expr\StaticCall
    {
        if ($prop instanceof \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch) {
            $name = $prop->name instanceof \PHPUnit\PhpParser\Node\VarLikeIdentifier ? $prop->name->toString() : $prop->name;
            $var = new \PHPUnit\PhpParser\Node\Expr\Variable($name, $prop->name->getAttributes());
            return new \PHPUnit\PhpParser\Node\Expr\StaticCall($prop->class, $var, $args, $attributes);
        } elseif ($prop instanceof \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch) {
            $tmp = $prop;
            while ($tmp->var instanceof \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch) {
                $tmp = $tmp->var;
            }
            /** @var Expr\StaticPropertyFetch $staticProp */
            $staticProp = $tmp->var;
            // Set start attributes to attributes of innermost node
            $tmp = $prop;
            $this->fixupStartAttributes($tmp, $staticProp->name);
            while ($tmp->var instanceof \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch) {
                $tmp = $tmp->var;
                $this->fixupStartAttributes($tmp, $staticProp->name);
            }
            $name = $staticProp->name instanceof \PHPUnit\PhpParser\Node\VarLikeIdentifier ? $staticProp->name->toString() : $staticProp->name;
            $tmp->var = new \PHPUnit\PhpParser\Node\Expr\Variable($name, $staticProp->name->getAttributes());
            return new \PHPUnit\PhpParser\Node\Expr\StaticCall($staticProp->class, $prop, $args, $attributes);
        } else {
            throw new \Exception();
        }
    }
    protected function fixupStartAttributes(\PHPUnit\PhpParser\Node $to, \PHPUnit\PhpParser\Node $from)
    {
        $startAttributes = ['startLine', 'startFilePos', 'startTokenPos'];
        foreach ($startAttributes as $startAttribute) {
            if ($from->hasAttribute($startAttribute)) {
                $to->setAttribute($startAttribute, $from->getAttribute($startAttribute));
            }
        }
    }
    protected function handleBuiltinTypes(\PHPUnit\PhpParser\Node\Name $name)
    {
        $builtinTypes = ['bool' => \true, 'int' => \true, 'float' => \true, 'string' => \true, 'iterable' => \true, 'void' => \true, 'object' => \true, 'null' => \true, 'false' => \true, 'mixed' => \true, 'never' => \true];
        if (!$name->isUnqualified()) {
            return $name;
        }
        $lowerName = $name->toLowerString();
        if (!isset($builtinTypes[$lowerName])) {
            return $name;
        }
        return new \PHPUnit\PhpParser\Node\Identifier($lowerName, $name->getAttributes());
    }
    /**
     * Get combined start and end attributes at a stack location
     *
     * @param int $pos Stack location
     *
     * @return array Combined start and end attributes
     */
    protected function getAttributesAt(int $pos) : array
    {
        return $this->startAttributeStack[$pos] + $this->endAttributeStack[$pos];
    }
    protected function getFloatCastKind(string $cast) : int
    {
        $cast = \strtolower($cast);
        if (\strpos($cast, 'float') !== \false) {
            return \PHPUnit\PhpParser\Node\Expr\Cast\Double::KIND_FLOAT;
        }
        if (\strpos($cast, 'real') !== \false) {
            return \PHPUnit\PhpParser\Node\Expr\Cast\Double::KIND_REAL;
        }
        return \PHPUnit\PhpParser\Node\Expr\Cast\Double::KIND_DOUBLE;
    }
    protected function parseLNumber($str, $attributes, $allowInvalidOctal = \false)
    {
        try {
            return \PHPUnit\PhpParser\Node\Scalar\LNumber::fromString($str, $attributes, $allowInvalidOctal);
        } catch (\PHPUnit\PhpParser\Error $error) {
            $this->emitError($error);
            // Use dummy value
            return new \PHPUnit\PhpParser\Node\Scalar\LNumber(0, $attributes);
        }
    }
    /**
     * Parse a T_NUM_STRING token into either an integer or string node.
     *
     * @param string $str        Number string
     * @param array  $attributes Attributes
     *
     * @return LNumber|String_ Integer or string node.
     */
    protected function parseNumString(string $str, array $attributes)
    {
        if (!\preg_match('/^(?:0|-?[1-9][0-9]*)$/', $str)) {
            return new \PHPUnit\PhpParser\Node\Scalar\String_($str, $attributes);
        }
        $num = +$str;
        if (!\is_int($num)) {
            return new \PHPUnit\PhpParser\Node\Scalar\String_($str, $attributes);
        }
        return new \PHPUnit\PhpParser\Node\Scalar\LNumber($num, $attributes);
    }
    protected function stripIndentation(string $string, int $indentLen, string $indentChar, bool $newlineAtStart, bool $newlineAtEnd, array $attributes)
    {
        if ($indentLen === 0) {
            return $string;
        }
        $start = $newlineAtStart ? '(?:(?<=\\n)|\\A)' : '(?<=\\n)';
        $end = $newlineAtEnd ? '(?:(?=[\\r\\n])|\\z)' : '(?=[\\r\\n])';
        $regex = '/' . $start . '([ \\t]*)(' . $end . ')?/';
        return \preg_replace_callback($regex, function ($matches) use($indentLen, $indentChar, $attributes) {
            $prefix = \substr($matches[1], 0, $indentLen);
            if (\false !== \strpos($prefix, $indentChar === " " ? "\t" : " ")) {
                $this->emitError(new \PHPUnit\PhpParser\Error('Invalid indentation - tabs and spaces cannot be mixed', $attributes));
            } elseif (\strlen($prefix) < $indentLen && !isset($matches[2])) {
                $this->emitError(new \PHPUnit\PhpParser\Error('Invalid body indentation level ' . '(expecting an indentation level of at least ' . $indentLen . ')', $attributes));
            }
            return \substr($matches[0], \strlen($prefix));
        }, $string);
    }
    protected function parseDocString(string $startToken, $contents, string $endToken, array $attributes, array $endTokenAttributes, bool $parseUnicodeEscape)
    {
        $kind = \strpos($startToken, "'") === \false ? \PHPUnit\PhpParser\Node\Scalar\String_::KIND_HEREDOC : \PHPUnit\PhpParser\Node\Scalar\String_::KIND_NOWDOC;
        $regex = '/\\A[bB]?<<<[ \\t]*[\'"]?([a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*)[\'"]?(?:\\r\\n|\\n|\\r)\\z/';
        $result = \preg_match($regex, $startToken, $matches);
        \assert($result === 1);
        $label = $matches[1];
        $result = \preg_match('/\\A[ \\t]*/', $endToken, $matches);
        \assert($result === 1);
        $indentation = $matches[0];
        $attributes['kind'] = $kind;
        $attributes['docLabel'] = $label;
        $attributes['docIndentation'] = $indentation;
        $indentHasSpaces = \false !== \strpos($indentation, " ");
        $indentHasTabs = \false !== \strpos($indentation, "\t");
        if ($indentHasSpaces && $indentHasTabs) {
            $this->emitError(new \PHPUnit\PhpParser\Error('Invalid indentation - tabs and spaces cannot be mixed', $endTokenAttributes));
            // Proceed processing as if this doc string is not indented
            $indentation = '';
        }
        $indentLen = \strlen($indentation);
        $indentChar = $indentHasSpaces ? " " : "\t";
        if (\is_string($contents)) {
            if ($contents === '') {
                return new \PHPUnit\PhpParser\Node\Scalar\String_('', $attributes);
            }
            $contents = $this->stripIndentation($contents, $indentLen, $indentChar, \true, \true, $attributes);
            $contents = \preg_replace('~(\\r\\n|\\n|\\r)\\z~', '', $contents);
            if ($kind === \PHPUnit\PhpParser\Node\Scalar\String_::KIND_HEREDOC) {
                $contents = \PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($contents, null, $parseUnicodeEscape);
            }
            return new \PHPUnit\PhpParser\Node\Scalar\String_($contents, $attributes);
        } else {
            \assert(\count($contents) > 0);
            if (!$contents[0] instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart) {
                // If there is no leading encapsed string part, pretend there is an empty one
                $this->stripIndentation('', $indentLen, $indentChar, \true, \false, $contents[0]->getAttributes());
            }
            $newContents = [];
            foreach ($contents as $i => $part) {
                if ($part instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart) {
                    $isLast = $i === \count($contents) - 1;
                    $part->value = $this->stripIndentation($part->value, $indentLen, $indentChar, $i === 0, $isLast, $part->getAttributes());
                    $part->value = \PHPUnit\PhpParser\Node\Scalar\String_::parseEscapeSequences($part->value, null, $parseUnicodeEscape);
                    if ($isLast) {
                        $part->value = \preg_replace('~(\\r\\n|\\n|\\r)\\z~', '', $part->value);
                    }
                    if ('' === $part->value) {
                        continue;
                    }
                }
                $newContents[] = $part;
            }
            return new \PHPUnit\PhpParser\Node\Scalar\Encapsed($newContents, $attributes);
        }
    }
    /**
     * Create attributes for a zero-length common-capturing nop.
     *
     * @param Comment[] $comments
     * @return array
     */
    protected function createCommentNopAttributes(array $comments)
    {
        $comment = $comments[\count($comments) - 1];
        $commentEndLine = $comment->getEndLine();
        $commentEndFilePos = $comment->getEndFilePos();
        $commentEndTokenPos = $comment->getEndTokenPos();
        $attributes = ['comments' => $comments];
        if (-1 !== $commentEndLine) {
            $attributes['startLine'] = $commentEndLine;
            $attributes['endLine'] = $commentEndLine;
        }
        if (-1 !== $commentEndFilePos) {
            $attributes['startFilePos'] = $commentEndFilePos + 1;
            $attributes['endFilePos'] = $commentEndFilePos;
        }
        if (-1 !== $commentEndTokenPos) {
            $attributes['startTokenPos'] = $commentEndTokenPos + 1;
            $attributes['endTokenPos'] = $commentEndTokenPos;
        }
        return $attributes;
    }
    protected function checkModifier($a, $b, $modifierPos)
    {
        // Jumping through some hoops here because verifyModifier() is also used elsewhere
        try {
            \PHPUnit\PhpParser\Node\Stmt\Class_::verifyModifier($a, $b);
        } catch (\PHPUnit\PhpParser\Error $error) {
            $error->setAttributes($this->getAttributesAt($modifierPos));
            $this->emitError($error);
        }
    }
    protected function checkParam(\PHPUnit\PhpParser\Node\Param $node)
    {
        if ($node->variadic && null !== $node->default) {
            $this->emitError(new \PHPUnit\PhpParser\Error('Variadic parameter cannot have a default value', $node->default->getAttributes()));
        }
    }
    protected function checkTryCatch(\PHPUnit\PhpParser\Node\Stmt\TryCatch $node)
    {
        if (empty($node->catches) && null === $node->finally) {
            $this->emitError(new \PHPUnit\PhpParser\Error('Cannot use try without catch or finally', $node->getAttributes()));
        }
    }
    protected function checkNamespace(\PHPUnit\PhpParser\Node\Stmt\Namespace_ $node)
    {
        if (null !== $node->stmts) {
            foreach ($node->stmts as $stmt) {
                if ($stmt instanceof \PHPUnit\PhpParser\Node\Stmt\Namespace_) {
                    $this->emitError(new \PHPUnit\PhpParser\Error('Namespace declarations cannot be nested', $stmt->getAttributes()));
                }
            }
        }
    }
    private function checkClassName($name, $namePos)
    {
        if (null !== $name && $name->isSpecialClassName()) {
            $this->emitError(new \PHPUnit\PhpParser\Error(\sprintf('Cannot use \'%s\' as class name as it is reserved', $name), $this->getAttributesAt($namePos)));
        }
    }
    private function checkImplementedInterfaces(array $interfaces)
    {
        foreach ($interfaces as $interface) {
            if ($interface->isSpecialClassName()) {
                $this->emitError(new \PHPUnit\PhpParser\Error(\sprintf('Cannot use \'%s\' as interface name as it is reserved', $interface), $interface->getAttributes()));
            }
        }
    }
    protected function checkClass(\PHPUnit\PhpParser\Node\Stmt\Class_ $node, $namePos)
    {
        $this->checkClassName($node->name, $namePos);
        if ($node->extends && $node->extends->isSpecialClassName()) {
            $this->emitError(new \PHPUnit\PhpParser\Error(\sprintf('Cannot use \'%s\' as class name as it is reserved', $node->extends), $node->extends->getAttributes()));
        }
        $this->checkImplementedInterfaces($node->implements);
    }
    protected function checkInterface(\PHPUnit\PhpParser\Node\Stmt\Interface_ $node, $namePos)
    {
        $this->checkClassName($node->name, $namePos);
        $this->checkImplementedInterfaces($node->extends);
    }
    protected function checkEnum(\PHPUnit\PhpParser\Node\Stmt\Enum_ $node, $namePos)
    {
        $this->checkClassName($node->name, $namePos);
        $this->checkImplementedInterfaces($node->implements);
    }
    protected function checkClassMethod(\PHPUnit\PhpParser\Node\Stmt\ClassMethod $node, $modifierPos)
    {
        if ($node->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC) {
            switch ($node->name->toLowerString()) {
                case '__construct':
                    $this->emitError(new \PHPUnit\PhpParser\Error(\sprintf('Constructor %s() cannot be static', $node->name), $this->getAttributesAt($modifierPos)));
                    break;
                case '__destruct':
                    $this->emitError(new \PHPUnit\PhpParser\Error(\sprintf('Destructor %s() cannot be static', $node->name), $this->getAttributesAt($modifierPos)));
                    break;
                case '__clone':
                    $this->emitError(new \PHPUnit\PhpParser\Error(\sprintf('Clone method %s() cannot be static', $node->name), $this->getAttributesAt($modifierPos)));
                    break;
            }
        }
    }
    protected function checkClassConst(\PHPUnit\PhpParser\Node\Stmt\ClassConst $node, $modifierPos)
    {
        if ($node->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC) {
            $this->emitError(new \PHPUnit\PhpParser\Error("Cannot use 'static' as constant modifier", $this->getAttributesAt($modifierPos)));
        }
        if ($node->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT) {
            $this->emitError(new \PHPUnit\PhpParser\Error("Cannot use 'abstract' as constant modifier", $this->getAttributesAt($modifierPos)));
        }
        if ($node->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL) {
            $this->emitError(new \PHPUnit\PhpParser\Error("Cannot use 'final' as constant modifier", $this->getAttributesAt($modifierPos)));
        }
    }
    protected function checkProperty(\PHPUnit\PhpParser\Node\Stmt\Property $node, $modifierPos)
    {
        if ($node->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT) {
            $this->emitError(new \PHPUnit\PhpParser\Error('Properties cannot be declared abstract', $this->getAttributesAt($modifierPos)));
        }
        if ($node->flags & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL) {
            $this->emitError(new \PHPUnit\PhpParser\Error('Properties cannot be declared final', $this->getAttributesAt($modifierPos)));
        }
    }
    protected function checkUseUse(\PHPUnit\PhpParser\Node\Stmt\UseUse $node, $namePos)
    {
        if ($node->alias && $node->alias->isSpecialClassName()) {
            $this->emitError(new \PHPUnit\PhpParser\Error(\sprintf('Cannot use %s as %s because \'%2$s\' is a special class name', $node->name, $node->alias), $this->getAttributesAt($namePos)));
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

class ParserFactory
{
    const PREFER_PHP7 = 1;
    const PREFER_PHP5 = 2;
    const ONLY_PHP7 = 3;
    const ONLY_PHP5 = 4;
    /**
     * Creates a Parser instance, according to the provided kind.
     *
     * @param int        $kind  One of ::PREFER_PHP7, ::PREFER_PHP5, ::ONLY_PHP7 or ::ONLY_PHP5
     * @param Lexer|null $lexer Lexer to use. Defaults to emulative lexer when not specified
     * @param array      $parserOptions Parser options. See ParserAbstract::__construct() argument
     *
     * @return Parser The parser instance
     */
    public function create(int $kind, \PHPUnit\PhpParser\Lexer $lexer = null, array $parserOptions = []) : \PHPUnit\PhpParser\Parser
    {
        if (null === $lexer) {
            $lexer = new \PHPUnit\PhpParser\Lexer\Emulative();
        }
        switch ($kind) {
            case self::PREFER_PHP7:
                return new \PHPUnit\PhpParser\Parser\Multiple([new \PHPUnit\PhpParser\Parser\Php7($lexer, $parserOptions), new \PHPUnit\PhpParser\Parser\Php5($lexer, $parserOptions)]);
            case self::PREFER_PHP5:
                return new \PHPUnit\PhpParser\Parser\Multiple([new \PHPUnit\PhpParser\Parser\Php5($lexer, $parserOptions), new \PHPUnit\PhpParser\Parser\Php7($lexer, $parserOptions)]);
            case self::ONLY_PHP7:
                return new \PHPUnit\PhpParser\Parser\Php7($lexer, $parserOptions);
            case self::ONLY_PHP5:
                return new \PHPUnit\PhpParser\Parser\Php5($lexer, $parserOptions);
            default:
                throw new \LogicException('Kind must be one of ::PREFER_PHP7, ::PREFER_PHP5, ::ONLY_PHP7 or ::ONLY_PHP5');
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser\PrettyPrinter;

use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Expr\AssignOp;
use PHPUnit\PhpParser\Node\Expr\BinaryOp;
use PHPUnit\PhpParser\Node\Expr\Cast;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Scalar;
use PHPUnit\PhpParser\Node\Scalar\MagicConst;
use PHPUnit\PhpParser\Node\Stmt;
use PHPUnit\PhpParser\PrettyPrinterAbstract;
class Standard extends \PHPUnit\PhpParser\PrettyPrinterAbstract
{
    // Special nodes
    protected function pParam(\PHPUnit\PhpParser\Node\Param $node)
    {
        return $this->pAttrGroups($node->attrGroups, \true) . $this->pModifiers($node->flags) . ($node->type ? $this->p($node->type) . ' ' : '') . ($node->byRef ? '&' : '') . ($node->variadic ? '...' : '') . $this->p($node->var) . ($node->default ? ' = ' . $this->p($node->default) : '');
    }
    protected function pArg(\PHPUnit\PhpParser\Node\Arg $node)
    {
        return ($node->name ? $node->name->toString() . ': ' : '') . ($node->byRef ? '&' : '') . ($node->unpack ? '...' : '') . $this->p($node->value);
    }
    protected function pConst(\PHPUnit\PhpParser\Node\Const_ $node)
    {
        return $node->name . ' = ' . $this->p($node->value);
    }
    protected function pNullableType(\PHPUnit\PhpParser\Node\NullableType $node)
    {
        return '?' . $this->p($node->type);
    }
    protected function pUnionType(\PHPUnit\PhpParser\Node\UnionType $node)
    {
        return $this->pImplode($node->types, '|');
    }
    protected function pIdentifier(\PHPUnit\PhpParser\Node\Identifier $node)
    {
        return $node->name;
    }
    protected function pVarLikeIdentifier(\PHPUnit\PhpParser\Node\VarLikeIdentifier $node)
    {
        return '$' . $node->name;
    }
    protected function pAttribute(\PHPUnit\PhpParser\Node\Attribute $node)
    {
        return $this->p($node->name) . ($node->args ? '(' . $this->pCommaSeparated($node->args) . ')' : '');
    }
    protected function pAttributeGroup(\PHPUnit\PhpParser\Node\AttributeGroup $node)
    {
        return '#[' . $this->pCommaSeparated($node->attrs) . ']';
    }
    // Names
    protected function pName(\PHPUnit\PhpParser\Node\Name $node)
    {
        return \implode('\\', $node->parts);
    }
    protected function pName_FullyQualified(\PHPUnit\PhpParser\Node\Name\FullyQualified $node)
    {
        return '\\' . \implode('\\', $node->parts);
    }
    protected function pName_Relative(\PHPUnit\PhpParser\Node\Name\Relative $node)
    {
        return 'namespace\\' . \implode('\\', $node->parts);
    }
    // Magic Constants
    protected function pScalar_MagicConst_Class(\PHPUnit\PhpParser\Node\Scalar\MagicConst\Class_ $node)
    {
        return '__CLASS__';
    }
    protected function pScalar_MagicConst_Dir(\PHPUnit\PhpParser\Node\Scalar\MagicConst\Dir $node)
    {
        return '__DIR__';
    }
    protected function pScalar_MagicConst_File(\PHPUnit\PhpParser\Node\Scalar\MagicConst\File $node)
    {
        return '__FILE__';
    }
    protected function pScalar_MagicConst_Function(\PHPUnit\PhpParser\Node\Scalar\MagicConst\Function_ $node)
    {
        return '__FUNCTION__';
    }
    protected function pScalar_MagicConst_Line(\PHPUnit\PhpParser\Node\Scalar\MagicConst\Line $node)
    {
        return '__LINE__';
    }
    protected function pScalar_MagicConst_Method(\PHPUnit\PhpParser\Node\Scalar\MagicConst\Method $node)
    {
        return '__METHOD__';
    }
    protected function pScalar_MagicConst_Namespace(\PHPUnit\PhpParser\Node\Scalar\MagicConst\Namespace_ $node)
    {
        return '__NAMESPACE__';
    }
    protected function pScalar_MagicConst_Trait(\PHPUnit\PhpParser\Node\Scalar\MagicConst\Trait_ $node)
    {
        return '__TRAIT__';
    }
    // Scalars
    protected function pScalar_String(\PHPUnit\PhpParser\Node\Scalar\String_ $node)
    {
        $kind = $node->getAttribute('kind', \PHPUnit\PhpParser\Node\Scalar\String_::KIND_SINGLE_QUOTED);
        switch ($kind) {
            case \PHPUnit\PhpParser\Node\Scalar\String_::KIND_NOWDOC:
                $label = $node->getAttribute('docLabel');
                if ($label && !$this->containsEndLabel($node->value, $label)) {
                    if ($node->value === '') {
                        return "<<<'{$label}'\n{$label}" . $this->docStringEndToken;
                    }
                    return "<<<'{$label}'\n{$node->value}\n{$label}" . $this->docStringEndToken;
                }
            /* break missing intentionally */
            case \PHPUnit\PhpParser\Node\Scalar\String_::KIND_SINGLE_QUOTED:
                return $this->pSingleQuotedString($node->value);
            case \PHPUnit\PhpParser\Node\Scalar\String_::KIND_HEREDOC:
                $label = $node->getAttribute('docLabel');
                if ($label && !$this->containsEndLabel($node->value, $label)) {
                    if ($node->value === '') {
                        return "<<<{$label}\n{$label}" . $this->docStringEndToken;
                    }
                    $escaped = $this->escapeString($node->value, null);
                    return "<<<{$label}\n" . $escaped . "\n{$label}" . $this->docStringEndToken;
                }
            /* break missing intentionally */
            case \PHPUnit\PhpParser\Node\Scalar\String_::KIND_DOUBLE_QUOTED:
                return '"' . $this->escapeString($node->value, '"') . '"';
        }
        throw new \Exception('Invalid string kind');
    }
    protected function pScalar_Encapsed(\PHPUnit\PhpParser\Node\Scalar\Encapsed $node)
    {
        if ($node->getAttribute('kind') === \PHPUnit\PhpParser\Node\Scalar\String_::KIND_HEREDOC) {
            $label = $node->getAttribute('docLabel');
            if ($label && !$this->encapsedContainsEndLabel($node->parts, $label)) {
                if (\count($node->parts) === 1 && $node->parts[0] instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart && $node->parts[0]->value === '') {
                    return "<<<{$label}\n{$label}" . $this->docStringEndToken;
                }
                return "<<<{$label}\n" . $this->pEncapsList($node->parts, null) . "\n{$label}" . $this->docStringEndToken;
            }
        }
        return '"' . $this->pEncapsList($node->parts, '"') . '"';
    }
    protected function pScalar_LNumber(\PHPUnit\PhpParser\Node\Scalar\LNumber $node)
    {
        if ($node->value === -\PHP_INT_MAX - 1) {
            // PHP_INT_MIN cannot be represented as a literal,
            // because the sign is not part of the literal
            return '(-' . \PHP_INT_MAX . '-1)';
        }
        $kind = $node->getAttribute('kind', \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_DEC);
        if (\PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_DEC === $kind) {
            return (string) $node->value;
        }
        if ($node->value < 0) {
            $sign = '-';
            $str = (string) -$node->value;
        } else {
            $sign = '';
            $str = (string) $node->value;
        }
        switch ($kind) {
            case \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_BIN:
                return $sign . '0b' . \base_convert($str, 10, 2);
            case \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_OCT:
                return $sign . '0' . \base_convert($str, 10, 8);
            case \PHPUnit\PhpParser\Node\Scalar\LNumber::KIND_HEX:
                return $sign . '0x' . \base_convert($str, 10, 16);
        }
        throw new \Exception('Invalid number kind');
    }
    protected function pScalar_DNumber(\PHPUnit\PhpParser\Node\Scalar\DNumber $node)
    {
        if (!\is_finite($node->value)) {
            if ($node->value === \INF) {
                return '\\INF';
            } elseif ($node->value === -\INF) {
                return '-\\INF';
            } else {
                return '\\NAN';
            }
        }
        // Try to find a short full-precision representation
        $stringValue = \sprintf('%.16G', $node->value);
        if ($node->value !== (double) $stringValue) {
            $stringValue = \sprintf('%.17G', $node->value);
        }
        // %G is locale dependent and there exists no locale-independent alternative. We don't want
        // mess with switching locales here, so let's assume that a comma is the only non-standard
        // decimal separator we may encounter...
        $stringValue = \str_replace(',', '.', $stringValue);
        // ensure that number is really printed as float
        return \preg_match('/^-?[0-9]+$/', $stringValue) ? $stringValue . '.0' : $stringValue;
    }
    protected function pScalar_EncapsedStringPart(\PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart $node)
    {
        throw new \LogicException('Cannot directly print EncapsedStringPart');
    }
    // Assignments
    protected function pExpr_Assign(\PHPUnit\PhpParser\Node\Expr\Assign $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\Assign::class, $node->var, ' = ', $node->expr);
    }
    protected function pExpr_AssignRef(\PHPUnit\PhpParser\Node\Expr\AssignRef $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignRef::class, $node->var, ' =& ', $node->expr);
    }
    protected function pExpr_AssignOp_Plus(\PHPUnit\PhpParser\Node\Expr\AssignOp\Plus $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Plus::class, $node->var, ' += ', $node->expr);
    }
    protected function pExpr_AssignOp_Minus(\PHPUnit\PhpParser\Node\Expr\AssignOp\Minus $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Minus::class, $node->var, ' -= ', $node->expr);
    }
    protected function pExpr_AssignOp_Mul(\PHPUnit\PhpParser\Node\Expr\AssignOp\Mul $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Mul::class, $node->var, ' *= ', $node->expr);
    }
    protected function pExpr_AssignOp_Div(\PHPUnit\PhpParser\Node\Expr\AssignOp\Div $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Div::class, $node->var, ' /= ', $node->expr);
    }
    protected function pExpr_AssignOp_Concat(\PHPUnit\PhpParser\Node\Expr\AssignOp\Concat $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Concat::class, $node->var, ' .= ', $node->expr);
    }
    protected function pExpr_AssignOp_Mod(\PHPUnit\PhpParser\Node\Expr\AssignOp\Mod $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Mod::class, $node->var, ' %= ', $node->expr);
    }
    protected function pExpr_AssignOp_BitwiseAnd(\PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseAnd $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseAnd::class, $node->var, ' &= ', $node->expr);
    }
    protected function pExpr_AssignOp_BitwiseOr(\PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseOr $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseOr::class, $node->var, ' |= ', $node->expr);
    }
    protected function pExpr_AssignOp_BitwiseXor(\PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseXor $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseXor::class, $node->var, ' ^= ', $node->expr);
    }
    protected function pExpr_AssignOp_ShiftLeft(\PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftLeft $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftLeft::class, $node->var, ' <<= ', $node->expr);
    }
    protected function pExpr_AssignOp_ShiftRight(\PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftRight $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftRight::class, $node->var, ' >>= ', $node->expr);
    }
    protected function pExpr_AssignOp_Pow(\PHPUnit\PhpParser\Node\Expr\AssignOp\Pow $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Pow::class, $node->var, ' **= ', $node->expr);
    }
    protected function pExpr_AssignOp_Coalesce(\PHPUnit\PhpParser\Node\Expr\AssignOp\Coalesce $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\AssignOp\Coalesce::class, $node->var, ' ??= ', $node->expr);
    }
    // Binary expressions
    protected function pExpr_BinaryOp_Plus(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Plus $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Plus::class, $node->left, ' + ', $node->right);
    }
    protected function pExpr_BinaryOp_Minus(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Minus $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Minus::class, $node->left, ' - ', $node->right);
    }
    protected function pExpr_BinaryOp_Mul(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Mul $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Mul::class, $node->left, ' * ', $node->right);
    }
    protected function pExpr_BinaryOp_Div(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Div $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Div::class, $node->left, ' / ', $node->right);
    }
    protected function pExpr_BinaryOp_Concat(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat::class, $node->left, ' . ', $node->right);
    }
    protected function pExpr_BinaryOp_Mod(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Mod $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Mod::class, $node->left, ' % ', $node->right);
    }
    protected function pExpr_BinaryOp_BooleanAnd(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd::class, $node->left, ' && ', $node->right);
    }
    protected function pExpr_BinaryOp_BooleanOr(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr::class, $node->left, ' || ', $node->right);
    }
    protected function pExpr_BinaryOp_BitwiseAnd(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseAnd $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseAnd::class, $node->left, ' & ', $node->right);
    }
    protected function pExpr_BinaryOp_BitwiseOr(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseOr $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseOr::class, $node->left, ' | ', $node->right);
    }
    protected function pExpr_BinaryOp_BitwiseXor(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseXor $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseXor::class, $node->left, ' ^ ', $node->right);
    }
    protected function pExpr_BinaryOp_ShiftLeft(\PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftLeft $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftLeft::class, $node->left, ' << ', $node->right);
    }
    protected function pExpr_BinaryOp_ShiftRight(\PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftRight $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftRight::class, $node->left, ' >> ', $node->right);
    }
    protected function pExpr_BinaryOp_Pow(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Pow $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Pow::class, $node->left, ' ** ', $node->right);
    }
    protected function pExpr_BinaryOp_LogicalAnd(\PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd::class, $node->left, ' and ', $node->right);
    }
    protected function pExpr_BinaryOp_LogicalOr(\PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr::class, $node->left, ' or ', $node->right);
    }
    protected function pExpr_BinaryOp_LogicalXor(\PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalXor $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalXor::class, $node->left, ' xor ', $node->right);
    }
    protected function pExpr_BinaryOp_Equal(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Equal $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Equal::class, $node->left, ' == ', $node->right);
    }
    protected function pExpr_BinaryOp_NotEqual(\PHPUnit\PhpParser\Node\Expr\BinaryOp\NotEqual $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\NotEqual::class, $node->left, ' != ', $node->right);
    }
    protected function pExpr_BinaryOp_Identical(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Identical $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Identical::class, $node->left, ' === ', $node->right);
    }
    protected function pExpr_BinaryOp_NotIdentical(\PHPUnit\PhpParser\Node\Expr\BinaryOp\NotIdentical $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\NotIdentical::class, $node->left, ' !== ', $node->right);
    }
    protected function pExpr_BinaryOp_Spaceship(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Spaceship $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Spaceship::class, $node->left, ' <=> ', $node->right);
    }
    protected function pExpr_BinaryOp_Greater(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Greater $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Greater::class, $node->left, ' > ', $node->right);
    }
    protected function pExpr_BinaryOp_GreaterOrEqual(\PHPUnit\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual::class, $node->left, ' >= ', $node->right);
    }
    protected function pExpr_BinaryOp_Smaller(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Smaller $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Smaller::class, $node->left, ' < ', $node->right);
    }
    protected function pExpr_BinaryOp_SmallerOrEqual(\PHPUnit\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual::class, $node->left, ' <= ', $node->right);
    }
    protected function pExpr_BinaryOp_Coalesce(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Coalesce $node)
    {
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\BinaryOp\Coalesce::class, $node->left, ' ?? ', $node->right);
    }
    protected function pExpr_Instanceof(\PHPUnit\PhpParser\Node\Expr\Instanceof_ $node)
    {
        list($precedence, $associativity) = $this->precedenceMap[\PHPUnit\PhpParser\Node\Expr\Instanceof_::class];
        return $this->pPrec($node->expr, $precedence, $associativity, -1) . ' instanceof ' . $this->pNewVariable($node->class);
    }
    // Unary expressions
    protected function pExpr_BooleanNot(\PHPUnit\PhpParser\Node\Expr\BooleanNot $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\BooleanNot::class, '!', $node->expr);
    }
    protected function pExpr_BitwiseNot(\PHPUnit\PhpParser\Node\Expr\BitwiseNot $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\BitwiseNot::class, '~', $node->expr);
    }
    protected function pExpr_UnaryMinus(\PHPUnit\PhpParser\Node\Expr\UnaryMinus $node)
    {
        if ($node->expr instanceof \PHPUnit\PhpParser\Node\Expr\UnaryMinus || $node->expr instanceof \PHPUnit\PhpParser\Node\Expr\PreDec) {
            // Enforce -(-$expr) instead of --$expr
            return '-(' . $this->p($node->expr) . ')';
        }
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\UnaryMinus::class, '-', $node->expr);
    }
    protected function pExpr_UnaryPlus(\PHPUnit\PhpParser\Node\Expr\UnaryPlus $node)
    {
        if ($node->expr instanceof \PHPUnit\PhpParser\Node\Expr\UnaryPlus || $node->expr instanceof \PHPUnit\PhpParser\Node\Expr\PreInc) {
            // Enforce +(+$expr) instead of ++$expr
            return '+(' . $this->p($node->expr) . ')';
        }
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\UnaryPlus::class, '+', $node->expr);
    }
    protected function pExpr_PreInc(\PHPUnit\PhpParser\Node\Expr\PreInc $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\PreInc::class, '++', $node->var);
    }
    protected function pExpr_PreDec(\PHPUnit\PhpParser\Node\Expr\PreDec $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\PreDec::class, '--', $node->var);
    }
    protected function pExpr_PostInc(\PHPUnit\PhpParser\Node\Expr\PostInc $node)
    {
        return $this->pPostfixOp(\PHPUnit\PhpParser\Node\Expr\PostInc::class, $node->var, '++');
    }
    protected function pExpr_PostDec(\PHPUnit\PhpParser\Node\Expr\PostDec $node)
    {
        return $this->pPostfixOp(\PHPUnit\PhpParser\Node\Expr\PostDec::class, $node->var, '--');
    }
    protected function pExpr_ErrorSuppress(\PHPUnit\PhpParser\Node\Expr\ErrorSuppress $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\ErrorSuppress::class, '@', $node->expr);
    }
    protected function pExpr_YieldFrom(\PHPUnit\PhpParser\Node\Expr\YieldFrom $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\YieldFrom::class, 'yield from ', $node->expr);
    }
    protected function pExpr_Print(\PHPUnit\PhpParser\Node\Expr\Print_ $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Print_::class, 'print ', $node->expr);
    }
    // Casts
    protected function pExpr_Cast_Int(\PHPUnit\PhpParser\Node\Expr\Cast\Int_ $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Cast\Int_::class, '(int) ', $node->expr);
    }
    protected function pExpr_Cast_Double(\PHPUnit\PhpParser\Node\Expr\Cast\Double $node)
    {
        $kind = $node->getAttribute('kind', \PHPUnit\PhpParser\Node\Expr\Cast\Double::KIND_DOUBLE);
        if ($kind === \PHPUnit\PhpParser\Node\Expr\Cast\Double::KIND_DOUBLE) {
            $cast = '(double)';
        } elseif ($kind === \PHPUnit\PhpParser\Node\Expr\Cast\Double::KIND_FLOAT) {
            $cast = '(float)';
        } elseif ($kind === \PHPUnit\PhpParser\Node\Expr\Cast\Double::KIND_REAL) {
            $cast = '(real)';
        }
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Cast\Double::class, $cast . ' ', $node->expr);
    }
    protected function pExpr_Cast_String(\PHPUnit\PhpParser\Node\Expr\Cast\String_ $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Cast\String_::class, '(string) ', $node->expr);
    }
    protected function pExpr_Cast_Array(\PHPUnit\PhpParser\Node\Expr\Cast\Array_ $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Cast\Array_::class, '(array) ', $node->expr);
    }
    protected function pExpr_Cast_Object(\PHPUnit\PhpParser\Node\Expr\Cast\Object_ $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Cast\Object_::class, '(object) ', $node->expr);
    }
    protected function pExpr_Cast_Bool(\PHPUnit\PhpParser\Node\Expr\Cast\Bool_ $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Cast\Bool_::class, '(bool) ', $node->expr);
    }
    protected function pExpr_Cast_Unset(\PHPUnit\PhpParser\Node\Expr\Cast\Unset_ $node)
    {
        return $this->pPrefixOp(\PHPUnit\PhpParser\Node\Expr\Cast\Unset_::class, '(unset) ', $node->expr);
    }
    // Function calls and similar constructs
    protected function pExpr_FuncCall(\PHPUnit\PhpParser\Node\Expr\FuncCall $node)
    {
        return $this->pCallLhs($node->name) . '(' . $this->pMaybeMultiline($node->args) . ')';
    }
    protected function pExpr_MethodCall(\PHPUnit\PhpParser\Node\Expr\MethodCall $node)
    {
        return $this->pDereferenceLhs($node->var) . '->' . $this->pObjectProperty($node->name) . '(' . $this->pMaybeMultiline($node->args) . ')';
    }
    protected function pExpr_NullsafeMethodCall(\PHPUnit\PhpParser\Node\Expr\NullsafeMethodCall $node)
    {
        return $this->pDereferenceLhs($node->var) . '?->' . $this->pObjectProperty($node->name) . '(' . $this->pMaybeMultiline($node->args) . ')';
    }
    protected function pExpr_StaticCall(\PHPUnit\PhpParser\Node\Expr\StaticCall $node)
    {
        return $this->pDereferenceLhs($node->class) . '::' . ($node->name instanceof \PHPUnit\PhpParser\Node\Expr ? $node->name instanceof \PHPUnit\PhpParser\Node\Expr\Variable ? $this->p($node->name) : '{' . $this->p($node->name) . '}' : $node->name) . '(' . $this->pMaybeMultiline($node->args) . ')';
    }
    protected function pExpr_Empty(\PHPUnit\PhpParser\Node\Expr\Empty_ $node)
    {
        return 'empty(' . $this->p($node->expr) . ')';
    }
    protected function pExpr_Isset(\PHPUnit\PhpParser\Node\Expr\Isset_ $node)
    {
        return 'isset(' . $this->pCommaSeparated($node->vars) . ')';
    }
    protected function pExpr_Eval(\PHPUnit\PhpParser\Node\Expr\Eval_ $node)
    {
        return 'eval(' . $this->p($node->expr) . ')';
    }
    protected function pExpr_Include(\PHPUnit\PhpParser\Node\Expr\Include_ $node)
    {
        static $map = [\PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE => 'include', \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_INCLUDE_ONCE => 'include_once', \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE => 'require', \PHPUnit\PhpParser\Node\Expr\Include_::TYPE_REQUIRE_ONCE => 'require_once'];
        return $map[$node->type] . ' ' . $this->p($node->expr);
    }
    protected function pExpr_List(\PHPUnit\PhpParser\Node\Expr\List_ $node)
    {
        return 'list(' . $this->pCommaSeparated($node->items) . ')';
    }
    // Other
    protected function pExpr_Error(\PHPUnit\PhpParser\Node\Expr\Error $node)
    {
        throw new \LogicException('Cannot pretty-print AST with Error nodes');
    }
    protected function pExpr_Variable(\PHPUnit\PhpParser\Node\Expr\Variable $node)
    {
        if ($node->name instanceof \PHPUnit\PhpParser\Node\Expr) {
            return '${' . $this->p($node->name) . '}';
        } else {
            return '$' . $node->name;
        }
    }
    protected function pExpr_Array(\PHPUnit\PhpParser\Node\Expr\Array_ $node)
    {
        $syntax = $node->getAttribute('kind', $this->options['shortArraySyntax'] ? \PHPUnit\PhpParser\Node\Expr\Array_::KIND_SHORT : \PHPUnit\PhpParser\Node\Expr\Array_::KIND_LONG);
        if ($syntax === \PHPUnit\PhpParser\Node\Expr\Array_::KIND_SHORT) {
            return '[' . $this->pMaybeMultiline($node->items, \true) . ']';
        } else {
            return 'array(' . $this->pMaybeMultiline($node->items, \true) . ')';
        }
    }
    protected function pExpr_ArrayItem(\PHPUnit\PhpParser\Node\Expr\ArrayItem $node)
    {
        return (null !== $node->key ? $this->p($node->key) . ' => ' : '') . ($node->byRef ? '&' : '') . ($node->unpack ? '...' : '') . $this->p($node->value);
    }
    protected function pExpr_ArrayDimFetch(\PHPUnit\PhpParser\Node\Expr\ArrayDimFetch $node)
    {
        return $this->pDereferenceLhs($node->var) . '[' . (null !== $node->dim ? $this->p($node->dim) : '') . ']';
    }
    protected function pExpr_ConstFetch(\PHPUnit\PhpParser\Node\Expr\ConstFetch $node)
    {
        return $this->p($node->name);
    }
    protected function pExpr_ClassConstFetch(\PHPUnit\PhpParser\Node\Expr\ClassConstFetch $node)
    {
        return $this->pDereferenceLhs($node->class) . '::' . $this->p($node->name);
    }
    protected function pExpr_PropertyFetch(\PHPUnit\PhpParser\Node\Expr\PropertyFetch $node)
    {
        return $this->pDereferenceLhs($node->var) . '->' . $this->pObjectProperty($node->name);
    }
    protected function pExpr_NullsafePropertyFetch(\PHPUnit\PhpParser\Node\Expr\NullsafePropertyFetch $node)
    {
        return $this->pDereferenceLhs($node->var) . '?->' . $this->pObjectProperty($node->name);
    }
    protected function pExpr_StaticPropertyFetch(\PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch $node)
    {
        return $this->pDereferenceLhs($node->class) . '::$' . $this->pObjectProperty($node->name);
    }
    protected function pExpr_ShellExec(\PHPUnit\PhpParser\Node\Expr\ShellExec $node)
    {
        return '`' . $this->pEncapsList($node->parts, '`') . '`';
    }
    protected function pExpr_Closure(\PHPUnit\PhpParser\Node\Expr\Closure $node)
    {
        return $this->pAttrGroups($node->attrGroups, \true) . ($node->static ? 'static ' : '') . 'function ' . ($node->byRef ? '&' : '') . '(' . $this->pCommaSeparated($node->params) . ')' . (!empty($node->uses) ? ' use(' . $this->pCommaSeparated($node->uses) . ')' : '') . (null !== $node->returnType ? ' : ' . $this->p($node->returnType) : '') . ' {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pExpr_Match(\PHPUnit\PhpParser\Node\Expr\Match_ $node)
    {
        return 'match (' . $this->p($node->cond) . ') {' . $this->pCommaSeparatedMultiline($node->arms, \true) . $this->nl . '}';
    }
    protected function pMatchArm(\PHPUnit\PhpParser\Node\MatchArm $node)
    {
        return ($node->conds ? $this->pCommaSeparated($node->conds) : 'default') . ' => ' . $this->p($node->body);
    }
    protected function pExpr_ArrowFunction(\PHPUnit\PhpParser\Node\Expr\ArrowFunction $node)
    {
        return $this->pAttrGroups($node->attrGroups, \true) . ($node->static ? 'static ' : '') . 'fn' . ($node->byRef ? '&' : '') . '(' . $this->pCommaSeparated($node->params) . ')' . (null !== $node->returnType ? ': ' . $this->p($node->returnType) : '') . ' => ' . $this->p($node->expr);
    }
    protected function pExpr_ClosureUse(\PHPUnit\PhpParser\Node\Expr\ClosureUse $node)
    {
        return ($node->byRef ? '&' : '') . $this->p($node->var);
    }
    protected function pExpr_New(\PHPUnit\PhpParser\Node\Expr\New_ $node)
    {
        if ($node->class instanceof \PHPUnit\PhpParser\Node\Stmt\Class_) {
            $args = $node->args ? '(' . $this->pMaybeMultiline($node->args) . ')' : '';
            return 'new ' . $this->pClassCommon($node->class, $args);
        }
        return 'new ' . $this->pNewVariable($node->class) . '(' . $this->pMaybeMultiline($node->args) . ')';
    }
    protected function pExpr_Clone(\PHPUnit\PhpParser\Node\Expr\Clone_ $node)
    {
        return 'clone ' . $this->p($node->expr);
    }
    protected function pExpr_Ternary(\PHPUnit\PhpParser\Node\Expr\Ternary $node)
    {
        // a bit of cheating: we treat the ternary as a binary op where the ?...: part is the operator.
        // this is okay because the part between ? and : never needs parentheses.
        return $this->pInfixOp(\PHPUnit\PhpParser\Node\Expr\Ternary::class, $node->cond, ' ?' . (null !== $node->if ? ' ' . $this->p($node->if) . ' ' : '') . ': ', $node->else);
    }
    protected function pExpr_Exit(\PHPUnit\PhpParser\Node\Expr\Exit_ $node)
    {
        $kind = $node->getAttribute('kind', \PHPUnit\PhpParser\Node\Expr\Exit_::KIND_DIE);
        return ($kind === \PHPUnit\PhpParser\Node\Expr\Exit_::KIND_EXIT ? 'exit' : 'die') . (null !== $node->expr ? '(' . $this->p($node->expr) . ')' : '');
    }
    protected function pExpr_Throw(\PHPUnit\PhpParser\Node\Expr\Throw_ $node)
    {
        return 'throw ' . $this->p($node->expr);
    }
    protected function pExpr_Yield(\PHPUnit\PhpParser\Node\Expr\Yield_ $node)
    {
        if ($node->value === null) {
            return 'yield';
        } else {
            // this is a bit ugly, but currently there is no way to detect whether the parentheses are necessary
            return '(yield ' . ($node->key !== null ? $this->p($node->key) . ' => ' : '') . $this->p($node->value) . ')';
        }
    }
    // Declarations
    protected function pStmt_Namespace(\PHPUnit\PhpParser\Node\Stmt\Namespace_ $node)
    {
        if ($this->canUseSemicolonNamespaces) {
            return 'namespace ' . $this->p($node->name) . ';' . $this->nl . $this->pStmts($node->stmts, \false);
        } else {
            return 'namespace' . (null !== $node->name ? ' ' . $this->p($node->name) : '') . ' {' . $this->pStmts($node->stmts) . $this->nl . '}';
        }
    }
    protected function pStmt_Use(\PHPUnit\PhpParser\Node\Stmt\Use_ $node)
    {
        return 'use ' . $this->pUseType($node->type) . $this->pCommaSeparated($node->uses) . ';';
    }
    protected function pStmt_GroupUse(\PHPUnit\PhpParser\Node\Stmt\GroupUse $node)
    {
        return 'use ' . $this->pUseType($node->type) . $this->pName($node->prefix) . '\\{' . $this->pCommaSeparated($node->uses) . '};';
    }
    protected function pStmt_UseUse(\PHPUnit\PhpParser\Node\Stmt\UseUse $node)
    {
        return $this->pUseType($node->type) . $this->p($node->name) . (null !== $node->alias ? ' as ' . $node->alias : '');
    }
    protected function pUseType($type)
    {
        return $type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_FUNCTION ? 'function ' : ($type === \PHPUnit\PhpParser\Node\Stmt\Use_::TYPE_CONSTANT ? 'const ' : '');
    }
    protected function pStmt_Interface(\PHPUnit\PhpParser\Node\Stmt\Interface_ $node)
    {
        return $this->pAttrGroups($node->attrGroups) . 'interface ' . $node->name . (!empty($node->extends) ? ' extends ' . $this->pCommaSeparated($node->extends) : '') . $this->nl . '{' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Enum(\PHPUnit\PhpParser\Node\Stmt\Enum_ $node)
    {
        return $this->pAttrGroups($node->attrGroups) . 'enum ' . $node->name . (!empty($node->implements) ? ' implements ' . $this->pCommaSeparated($node->implements) : '') . $this->nl . '{' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Class(\PHPUnit\PhpParser\Node\Stmt\Class_ $node)
    {
        return $this->pClassCommon($node, ' ' . $node->name);
    }
    protected function pStmt_Trait(\PHPUnit\PhpParser\Node\Stmt\Trait_ $node)
    {
        return $this->pAttrGroups($node->attrGroups) . 'trait ' . $node->name . $this->nl . '{' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_EnumCase(\PHPUnit\PhpParser\Node\Stmt\EnumCase $node)
    {
        return $this->pAttrGroups($node->attrGroups) . 'case ' . $node->name . ($node->expr ? ' = ' . $this->p($node->expr) : '') . ';';
    }
    protected function pStmt_TraitUse(\PHPUnit\PhpParser\Node\Stmt\TraitUse $node)
    {
        return 'use ' . $this->pCommaSeparated($node->traits) . (empty($node->adaptations) ? ';' : ' {' . $this->pStmts($node->adaptations) . $this->nl . '}');
    }
    protected function pStmt_TraitUseAdaptation_Precedence(\PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Precedence $node)
    {
        return $this->p($node->trait) . '::' . $node->method . ' insteadof ' . $this->pCommaSeparated($node->insteadof) . ';';
    }
    protected function pStmt_TraitUseAdaptation_Alias(\PHPUnit\PhpParser\Node\Stmt\TraitUseAdaptation\Alias $node)
    {
        return (null !== $node->trait ? $this->p($node->trait) . '::' : '') . $node->method . ' as' . (null !== $node->newModifier ? ' ' . \rtrim($this->pModifiers($node->newModifier), ' ') : '') . (null !== $node->newName ? ' ' . $node->newName : '') . ';';
    }
    protected function pStmt_Property(\PHPUnit\PhpParser\Node\Stmt\Property $node)
    {
        return $this->pAttrGroups($node->attrGroups) . (0 === $node->flags ? 'var ' : $this->pModifiers($node->flags)) . ($node->type ? $this->p($node->type) . ' ' : '') . $this->pCommaSeparated($node->props) . ';';
    }
    protected function pStmt_PropertyProperty(\PHPUnit\PhpParser\Node\Stmt\PropertyProperty $node)
    {
        return '$' . $node->name . (null !== $node->default ? ' = ' . $this->p($node->default) : '');
    }
    protected function pStmt_ClassMethod(\PHPUnit\PhpParser\Node\Stmt\ClassMethod $node)
    {
        return $this->pAttrGroups($node->attrGroups) . $this->pModifiers($node->flags) . 'function ' . ($node->byRef ? '&' : '') . $node->name . '(' . $this->pMaybeMultiline($node->params) . ')' . (null !== $node->returnType ? ' : ' . $this->p($node->returnType) : '') . (null !== $node->stmts ? $this->nl . '{' . $this->pStmts($node->stmts) . $this->nl . '}' : ';');
    }
    protected function pStmt_ClassConst(\PHPUnit\PhpParser\Node\Stmt\ClassConst $node)
    {
        return $this->pAttrGroups($node->attrGroups) . $this->pModifiers($node->flags) . 'const ' . $this->pCommaSeparated($node->consts) . ';';
    }
    protected function pStmt_Function(\PHPUnit\PhpParser\Node\Stmt\Function_ $node)
    {
        return $this->pAttrGroups($node->attrGroups) . 'function ' . ($node->byRef ? '&' : '') . $node->name . '(' . $this->pCommaSeparated($node->params) . ')' . (null !== $node->returnType ? ' : ' . $this->p($node->returnType) : '') . $this->nl . '{' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Const(\PHPUnit\PhpParser\Node\Stmt\Const_ $node)
    {
        return 'const ' . $this->pCommaSeparated($node->consts) . ';';
    }
    protected function pStmt_Declare(\PHPUnit\PhpParser\Node\Stmt\Declare_ $node)
    {
        return 'declare (' . $this->pCommaSeparated($node->declares) . ')' . (null !== $node->stmts ? ' {' . $this->pStmts($node->stmts) . $this->nl . '}' : ';');
    }
    protected function pStmt_DeclareDeclare(\PHPUnit\PhpParser\Node\Stmt\DeclareDeclare $node)
    {
        return $node->key . '=' . $this->p($node->value);
    }
    // Control flow
    protected function pStmt_If(\PHPUnit\PhpParser\Node\Stmt\If_ $node)
    {
        return 'if (' . $this->p($node->cond) . ') {' . $this->pStmts($node->stmts) . $this->nl . '}' . ($node->elseifs ? ' ' . $this->pImplode($node->elseifs, ' ') : '') . (null !== $node->else ? ' ' . $this->p($node->else) : '');
    }
    protected function pStmt_ElseIf(\PHPUnit\PhpParser\Node\Stmt\ElseIf_ $node)
    {
        return 'elseif (' . $this->p($node->cond) . ') {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Else(\PHPUnit\PhpParser\Node\Stmt\Else_ $node)
    {
        return 'else {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_For(\PHPUnit\PhpParser\Node\Stmt\For_ $node)
    {
        return 'for (' . $this->pCommaSeparated($node->init) . ';' . (!empty($node->cond) ? ' ' : '') . $this->pCommaSeparated($node->cond) . ';' . (!empty($node->loop) ? ' ' : '') . $this->pCommaSeparated($node->loop) . ') {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Foreach(\PHPUnit\PhpParser\Node\Stmt\Foreach_ $node)
    {
        return 'foreach (' . $this->p($node->expr) . ' as ' . (null !== $node->keyVar ? $this->p($node->keyVar) . ' => ' : '') . ($node->byRef ? '&' : '') . $this->p($node->valueVar) . ') {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_While(\PHPUnit\PhpParser\Node\Stmt\While_ $node)
    {
        return 'while (' . $this->p($node->cond) . ') {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Do(\PHPUnit\PhpParser\Node\Stmt\Do_ $node)
    {
        return 'do {' . $this->pStmts($node->stmts) . $this->nl . '} while (' . $this->p($node->cond) . ');';
    }
    protected function pStmt_Switch(\PHPUnit\PhpParser\Node\Stmt\Switch_ $node)
    {
        return 'switch (' . $this->p($node->cond) . ') {' . $this->pStmts($node->cases) . $this->nl . '}';
    }
    protected function pStmt_Case(\PHPUnit\PhpParser\Node\Stmt\Case_ $node)
    {
        return (null !== $node->cond ? 'case ' . $this->p($node->cond) : 'default') . ':' . $this->pStmts($node->stmts);
    }
    protected function pStmt_TryCatch(\PHPUnit\PhpParser\Node\Stmt\TryCatch $node)
    {
        return 'try {' . $this->pStmts($node->stmts) . $this->nl . '}' . ($node->catches ? ' ' . $this->pImplode($node->catches, ' ') : '') . ($node->finally !== null ? ' ' . $this->p($node->finally) : '');
    }
    protected function pStmt_Catch(\PHPUnit\PhpParser\Node\Stmt\Catch_ $node)
    {
        return 'catch (' . $this->pImplode($node->types, '|') . ($node->var !== null ? ' ' . $this->p($node->var) : '') . ') {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Finally(\PHPUnit\PhpParser\Node\Stmt\Finally_ $node)
    {
        return 'finally {' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pStmt_Break(\PHPUnit\PhpParser\Node\Stmt\Break_ $node)
    {
        return 'break' . ($node->num !== null ? ' ' . $this->p($node->num) : '') . ';';
    }
    protected function pStmt_Continue(\PHPUnit\PhpParser\Node\Stmt\Continue_ $node)
    {
        return 'continue' . ($node->num !== null ? ' ' . $this->p($node->num) : '') . ';';
    }
    protected function pStmt_Return(\PHPUnit\PhpParser\Node\Stmt\Return_ $node)
    {
        return 'return' . (null !== $node->expr ? ' ' . $this->p($node->expr) : '') . ';';
    }
    protected function pStmt_Throw(\PHPUnit\PhpParser\Node\Stmt\Throw_ $node)
    {
        return 'throw ' . $this->p($node->expr) . ';';
    }
    protected function pStmt_Label(\PHPUnit\PhpParser\Node\Stmt\Label $node)
    {
        return $node->name . ':';
    }
    protected function pStmt_Goto(\PHPUnit\PhpParser\Node\Stmt\Goto_ $node)
    {
        return 'goto ' . $node->name . ';';
    }
    // Other
    protected function pStmt_Expression(\PHPUnit\PhpParser\Node\Stmt\Expression $node)
    {
        return $this->p($node->expr) . ';';
    }
    protected function pStmt_Echo(\PHPUnit\PhpParser\Node\Stmt\Echo_ $node)
    {
        return 'echo ' . $this->pCommaSeparated($node->exprs) . ';';
    }
    protected function pStmt_Static(\PHPUnit\PhpParser\Node\Stmt\Static_ $node)
    {
        return 'static ' . $this->pCommaSeparated($node->vars) . ';';
    }
    protected function pStmt_Global(\PHPUnit\PhpParser\Node\Stmt\Global_ $node)
    {
        return 'global ' . $this->pCommaSeparated($node->vars) . ';';
    }
    protected function pStmt_StaticVar(\PHPUnit\PhpParser\Node\Stmt\StaticVar $node)
    {
        return $this->p($node->var) . (null !== $node->default ? ' = ' . $this->p($node->default) : '');
    }
    protected function pStmt_Unset(\PHPUnit\PhpParser\Node\Stmt\Unset_ $node)
    {
        return 'unset(' . $this->pCommaSeparated($node->vars) . ');';
    }
    protected function pStmt_InlineHTML(\PHPUnit\PhpParser\Node\Stmt\InlineHTML $node)
    {
        $newline = $node->getAttribute('hasLeadingNewline', \true) ? "\n" : '';
        return '?>' . $newline . $node->value . '<?php ';
    }
    protected function pStmt_HaltCompiler(\PHPUnit\PhpParser\Node\Stmt\HaltCompiler $node)
    {
        return '__halt_compiler();' . $node->remaining;
    }
    protected function pStmt_Nop(\PHPUnit\PhpParser\Node\Stmt\Nop $node)
    {
        return '';
    }
    // Helpers
    protected function pClassCommon(\PHPUnit\PhpParser\Node\Stmt\Class_ $node, $afterClassToken)
    {
        return $this->pAttrGroups($node->attrGroups, $node->name === null) . $this->pModifiers($node->flags) . 'class' . $afterClassToken . (null !== $node->extends ? ' extends ' . $this->p($node->extends) : '') . (!empty($node->implements) ? ' implements ' . $this->pCommaSeparated($node->implements) : '') . $this->nl . '{' . $this->pStmts($node->stmts) . $this->nl . '}';
    }
    protected function pObjectProperty($node)
    {
        if ($node instanceof \PHPUnit\PhpParser\Node\Expr) {
            return '{' . $this->p($node) . '}';
        } else {
            return $node;
        }
    }
    protected function pEncapsList(array $encapsList, $quote)
    {
        $return = '';
        foreach ($encapsList as $element) {
            if ($element instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart) {
                $return .= $this->escapeString($element->value, $quote);
            } else {
                $return .= '{' . $this->p($element) . '}';
            }
        }
        return $return;
    }
    protected function pSingleQuotedString(string $string)
    {
        return '\'' . \addcslashes($string, '\'\\') . '\'';
    }
    protected function escapeString($string, $quote)
    {
        if (null === $quote) {
            // For doc strings, don't escape newlines
            $escaped = \addcslashes($string, "\t\f\v\$\\");
        } else {
            $escaped = \addcslashes($string, "\n\r\t\f\v\$" . $quote . "\\");
        }
        // Escape control characters and non-UTF-8 characters.
        // Regex based on https://stackoverflow.com/a/11709412/385378.
        $regex = '/(
              [\\x00-\\x08\\x0E-\\x1F] # Control characters
            | [\\xC0-\\xC1] # Invalid UTF-8 Bytes
            | [\\xF5-\\xFF] # Invalid UTF-8 Bytes
            | \\xE0(?=[\\x80-\\x9F]) # Overlong encoding of prior code point
            | \\xF0(?=[\\x80-\\x8F]) # Overlong encoding of prior code point
            | [\\xC2-\\xDF](?![\\x80-\\xBF]) # Invalid UTF-8 Sequence Start
            | [\\xE0-\\xEF](?![\\x80-\\xBF]{2}) # Invalid UTF-8 Sequence Start
            | [\\xF0-\\xF4](?![\\x80-\\xBF]{3}) # Invalid UTF-8 Sequence Start
            | (?<=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF] # Invalid UTF-8 Sequence Middle
            | (?<![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF] # Overlong Sequence
            | (?<=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF]) # Short 3 byte sequence
            | (?<=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2}) # Short 4 byte sequence
            | (?<=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF]) # Short 4 byte sequence (2)
        )/x';
        return \preg_replace_callback($regex, function ($matches) {
            \assert(\strlen($matches[0]) === 1);
            $hex = \dechex(\ord($matches[0]));
            return '\\x' . \str_pad($hex, 2, '0', \STR_PAD_LEFT);
        }, $escaped);
    }
    protected function containsEndLabel($string, $label, $atStart = \true, $atEnd = \true)
    {
        $start = $atStart ? '(?:^|[\\r\\n])' : '[\\r\\n]';
        $end = $atEnd ? '(?:$|[;\\r\\n])' : '[;\\r\\n]';
        return \false !== \strpos($string, $label) && \preg_match('/' . $start . $label . $end . '/', $string);
    }
    protected function encapsedContainsEndLabel(array $parts, $label)
    {
        foreach ($parts as $i => $part) {
            $atStart = $i === 0;
            $atEnd = $i === \count($parts) - 1;
            if ($part instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart && $this->containsEndLabel($part->value, $label, $atStart, $atEnd)) {
                return \true;
            }
        }
        return \false;
    }
    protected function pDereferenceLhs(\PHPUnit\PhpParser\Node $node)
    {
        if (!$this->dereferenceLhsRequiresParens($node)) {
            return $this->p($node);
        } else {
            return '(' . $this->p($node) . ')';
        }
    }
    protected function pCallLhs(\PHPUnit\PhpParser\Node $node)
    {
        if (!$this->callLhsRequiresParens($node)) {
            return $this->p($node);
        } else {
            return '(' . $this->p($node) . ')';
        }
    }
    protected function pNewVariable(\PHPUnit\PhpParser\Node $node)
    {
        // TODO: This is not fully accurate.
        return $this->pDereferenceLhs($node);
    }
    /**
     * @param Node[] $nodes
     * @return bool
     */
    protected function hasNodeWithComments(array $nodes)
    {
        foreach ($nodes as $node) {
            if ($node && $node->getComments()) {
                return \true;
            }
        }
        return \false;
    }
    protected function pMaybeMultiline(array $nodes, bool $trailingComma = \false)
    {
        if (!$this->hasNodeWithComments($nodes)) {
            return $this->pCommaSeparated($nodes);
        } else {
            return $this->pCommaSeparatedMultiline($nodes, $trailingComma) . $this->nl;
        }
    }
    protected function pAttrGroups(array $nodes, bool $inline = \false) : string
    {
        $result = '';
        $sep = $inline ? ' ' : $this->nl;
        foreach ($nodes as $node) {
            $result .= $this->p($node) . $sep;
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PhpParser;

use PHPUnit\PhpParser\Internal\DiffElem;
use PHPUnit\PhpParser\Internal\PrintableNewAnonClassNode;
use PHPUnit\PhpParser\Internal\TokenStream;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\Node\Expr\AssignOp;
use PHPUnit\PhpParser\Node\Expr\BinaryOp;
use PHPUnit\PhpParser\Node\Expr\Cast;
use PHPUnit\PhpParser\Node\Scalar;
use PHPUnit\PhpParser\Node\Stmt;
abstract class PrettyPrinterAbstract
{
    const FIXUP_PREC_LEFT = 0;
    // LHS operand affected by precedence
    const FIXUP_PREC_RIGHT = 1;
    // RHS operand affected by precedence
    const FIXUP_CALL_LHS = 2;
    // LHS of call
    const FIXUP_DEREF_LHS = 3;
    // LHS of dereferencing operation
    const FIXUP_BRACED_NAME = 4;
    // Name operand that may require bracing
    const FIXUP_VAR_BRACED_NAME = 5;
    // Name operand that may require ${} bracing
    const FIXUP_ENCAPSED = 6;
    // Encapsed string part
    protected $precedenceMap = [
        // [precedence, associativity]
        // where for precedence -1 is %left, 0 is %nonassoc and 1 is %right
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Pow::class => [0, 1],
        \PHPUnit\PhpParser\Node\Expr\BitwiseNot::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\PreInc::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\PreDec::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\PostInc::class => [10, -1],
        \PHPUnit\PhpParser\Node\Expr\PostDec::class => [10, -1],
        \PHPUnit\PhpParser\Node\Expr\UnaryPlus::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\UnaryMinus::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Cast\Int_::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Cast\Double::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Cast\String_::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Cast\Array_::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Cast\Object_::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Cast\Bool_::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Cast\Unset_::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\ErrorSuppress::class => [10, 1],
        \PHPUnit\PhpParser\Node\Expr\Instanceof_::class => [20, 0],
        \PHPUnit\PhpParser\Node\Expr\BooleanNot::class => [30, 1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mul::class => [40, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Div::class => [40, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mod::class => [40, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Plus::class => [50, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Minus::class => [50, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat::class => [50, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftLeft::class => [60, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftRight::class => [60, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Smaller::class => [70, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual::class => [70, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Greater::class => [70, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual::class => [70, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Equal::class => [80, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotEqual::class => [80, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Identical::class => [80, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotIdentical::class => [80, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Spaceship::class => [80, 0],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseAnd::class => [90, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseXor::class => [100, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseOr::class => [110, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd::class => [120, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr::class => [130, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\Coalesce::class => [140, 1],
        \PHPUnit\PhpParser\Node\Expr\Ternary::class => [150, 0],
        // parser uses %left for assignments, but they really behave as %right
        \PHPUnit\PhpParser\Node\Expr\Assign::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignRef::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Plus::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Minus::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Mul::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Div::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Concat::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Mod::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseAnd::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseOr::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseXor::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftLeft::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftRight::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Pow::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\AssignOp\Coalesce::class => [160, 1],
        \PHPUnit\PhpParser\Node\Expr\YieldFrom::class => [165, 1],
        \PHPUnit\PhpParser\Node\Expr\Print_::class => [168, 1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd::class => [170, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalXor::class => [180, -1],
        \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr::class => [190, -1],
        \PHPUnit\PhpParser\Node\Expr\Include_::class => [200, -1],
    ];
    /** @var int Current indentation level. */
    protected $indentLevel;
    /** @var string Newline including current indentation. */
    protected $nl;
    /** @var string Token placed at end of doc string to ensure it is followed by a newline. */
    protected $docStringEndToken;
    /** @var bool Whether semicolon namespaces can be used (i.e. no global namespace is used) */
    protected $canUseSemicolonNamespaces;
    /** @var array Pretty printer options */
    protected $options;
    /** @var TokenStream Original tokens for use in format-preserving pretty print */
    protected $origTokens;
    /** @var Internal\Differ Differ for node lists */
    protected $nodeListDiffer;
    /** @var bool[] Map determining whether a certain character is a label character */
    protected $labelCharMap;
    /**
     * @var int[][] Map from token classes and subnode names to FIXUP_* constants. This is used
     *              during format-preserving prints to place additional parens/braces if necessary.
     */
    protected $fixupMap;
    /**
     * @var int[][] Map from "{$node->getType()}->{$subNode}" to ['left' => $l, 'right' => $r],
     *              where $l and $r specify the token type that needs to be stripped when removing
     *              this node.
     */
    protected $removalMap;
    /**
     * @var mixed[] Map from "{$node->getType()}->{$subNode}" to [$find, $beforeToken, $extraLeft, $extraRight].
     *              $find is an optional token after which the insertion occurs. $extraLeft/Right
     *              are optionally added before/after the main insertions.
     */
    protected $insertionMap;
    /**
     * @var string[] Map From "{$node->getType()}->{$subNode}" to string that should be inserted
     *               between elements of this list subnode.
     */
    protected $listInsertionMap;
    protected $emptyListInsertionMap;
    /** @var int[] Map from "{$node->getType()}->{$subNode}" to token before which the modifiers
     *             should be reprinted. */
    protected $modifierChangeMap;
    /**
     * Creates a pretty printer instance using the given options.
     *
     * Supported options:
     *  * bool $shortArraySyntax = false: Whether to use [] instead of array() as the default array
     *                                    syntax, if the node does not specify a format.
     *
     * @param array $options Dictionary of formatting options
     */
    public function __construct(array $options = [])
    {
        $this->docStringEndToken = '_DOC_STRING_END_' . \mt_rand();
        $defaultOptions = ['shortArraySyntax' => \false];
        $this->options = $options + $defaultOptions;
    }
    /**
     * Reset pretty printing state.
     */
    protected function resetState()
    {
        $this->indentLevel = 0;
        $this->nl = "\n";
        $this->origTokens = null;
    }
    /**
     * Set indentation level
     *
     * @param int $level Level in number of spaces
     */
    protected function setIndentLevel(int $level)
    {
        $this->indentLevel = $level;
        $this->nl = "\n" . \str_repeat(' ', $level);
    }
    /**
     * Increase indentation level.
     */
    protected function indent()
    {
        $this->indentLevel += 4;
        $this->nl .= '    ';
    }
    /**
     * Decrease indentation level.
     */
    protected function outdent()
    {
        \assert($this->indentLevel >= 4);
        $this->indentLevel -= 4;
        $this->nl = "\n" . \str_repeat(' ', $this->indentLevel);
    }
    /**
     * Pretty prints an array of statements.
     *
     * @param Node[] $stmts Array of statements
     *
     * @return string Pretty printed statements
     */
    public function prettyPrint(array $stmts) : string
    {
        $this->resetState();
        $this->preprocessNodes($stmts);
        return \ltrim($this->handleMagicTokens($this->pStmts($stmts, \false)));
    }
    /**
     * Pretty prints an expression.
     *
     * @param Expr $node Expression node
     *
     * @return string Pretty printed node
     */
    public function prettyPrintExpr(\PHPUnit\PhpParser\Node\Expr $node) : string
    {
        $this->resetState();
        return $this->handleMagicTokens($this->p($node));
    }
    /**
     * Pretty prints a file of statements (includes the opening <?php tag if it is required).
     *
     * @param Node[] $stmts Array of statements
     *
     * @return string Pretty printed statements
     */
    public function prettyPrintFile(array $stmts) : string
    {
        if (!$stmts) {
            return "<?php\n\n";
        }
        $p = "<?php\n\n" . $this->prettyPrint($stmts);
        if ($stmts[0] instanceof \PHPUnit\PhpParser\Node\Stmt\InlineHTML) {
            $p = \preg_replace('/^<\\?php\\s+\\?>\\n?/', '', $p);
        }
        if ($stmts[\count($stmts) - 1] instanceof \PHPUnit\PhpParser\Node\Stmt\InlineHTML) {
            $p = \preg_replace('/<\\?php$/', '', \rtrim($p));
        }
        return $p;
    }
    /**
     * Preprocesses the top-level nodes to initialize pretty printer state.
     *
     * @param Node[] $nodes Array of nodes
     */
    protected function preprocessNodes(array $nodes)
    {
        /* We can use semicolon-namespaces unless there is a global namespace declaration */
        $this->canUseSemicolonNamespaces = \true;
        foreach ($nodes as $node) {
            if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Namespace_ && null === $node->name) {
                $this->canUseSemicolonNamespaces = \false;
                break;
            }
        }
    }
    /**
     * Handles (and removes) no-indent and doc-string-end tokens.
     *
     * @param string $str
     * @return string
     */
    protected function handleMagicTokens(string $str) : string
    {
        // Replace doc-string-end tokens with nothing or a newline
        $str = \str_replace($this->docStringEndToken . ";\n", ";\n", $str);
        $str = \str_replace($this->docStringEndToken, "\n", $str);
        return $str;
    }
    /**
     * Pretty prints an array of nodes (statements) and indents them optionally.
     *
     * @param Node[] $nodes  Array of nodes
     * @param bool   $indent Whether to indent the printed nodes
     *
     * @return string Pretty printed statements
     */
    protected function pStmts(array $nodes, bool $indent = \true) : string
    {
        if ($indent) {
            $this->indent();
        }
        $result = '';
        foreach ($nodes as $node) {
            $comments = $node->getComments();
            if ($comments) {
                $result .= $this->nl . $this->pComments($comments);
                if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Nop) {
                    continue;
                }
            }
            $result .= $this->nl . $this->p($node);
        }
        if ($indent) {
            $this->outdent();
        }
        return $result;
    }
    /**
     * Pretty-print an infix operation while taking precedence into account.
     *
     * @param string $class          Node class of operator
     * @param Node   $leftNode       Left-hand side node
     * @param string $operatorString String representation of the operator
     * @param Node   $rightNode      Right-hand side node
     *
     * @return string Pretty printed infix operation
     */
    protected function pInfixOp(string $class, \PHPUnit\PhpParser\Node $leftNode, string $operatorString, \PHPUnit\PhpParser\Node $rightNode) : string
    {
        list($precedence, $associativity) = $this->precedenceMap[$class];
        return $this->pPrec($leftNode, $precedence, $associativity, -1) . $operatorString . $this->pPrec($rightNode, $precedence, $associativity, 1);
    }
    /**
     * Pretty-print a prefix operation while taking precedence into account.
     *
     * @param string $class          Node class of operator
     * @param string $operatorString String representation of the operator
     * @param Node   $node           Node
     *
     * @return string Pretty printed prefix operation
     */
    protected function pPrefixOp(string $class, string $operatorString, \PHPUnit\PhpParser\Node $node) : string
    {
        list($precedence, $associativity) = $this->precedenceMap[$class];
        return $operatorString . $this->pPrec($node, $precedence, $associativity, 1);
    }
    /**
     * Pretty-print a postfix operation while taking precedence into account.
     *
     * @param string $class          Node class of operator
     * @param string $operatorString String representation of the operator
     * @param Node   $node           Node
     *
     * @return string Pretty printed postfix operation
     */
    protected function pPostfixOp(string $class, \PHPUnit\PhpParser\Node $node, string $operatorString) : string
    {
        list($precedence, $associativity) = $this->precedenceMap[$class];
        return $this->pPrec($node, $precedence, $associativity, -1) . $operatorString;
    }
    /**
     * Prints an expression node with the least amount of parentheses necessary to preserve the meaning.
     *
     * @param Node $node                Node to pretty print
     * @param int  $parentPrecedence    Precedence of the parent operator
     * @param int  $parentAssociativity Associativity of parent operator
     *                                  (-1 is left, 0 is nonassoc, 1 is right)
     * @param int  $childPosition       Position of the node relative to the operator
     *                                  (-1 is left, 1 is right)
     *
     * @return string The pretty printed node
     */
    protected function pPrec(\PHPUnit\PhpParser\Node $node, int $parentPrecedence, int $parentAssociativity, int $childPosition) : string
    {
        $class = \get_class($node);
        if (isset($this->precedenceMap[$class])) {
            $childPrecedence = $this->precedenceMap[$class][0];
            if ($childPrecedence > $parentPrecedence || $parentPrecedence === $childPrecedence && $parentAssociativity !== $childPosition) {
                return '(' . $this->p($node) . ')';
            }
        }
        return $this->p($node);
    }
    /**
     * Pretty prints an array of nodes and implodes the printed values.
     *
     * @param Node[] $nodes Array of Nodes to be printed
     * @param string $glue  Character to implode with
     *
     * @return string Imploded pretty printed nodes
     */
    protected function pImplode(array $nodes, string $glue = '') : string
    {
        $pNodes = [];
        foreach ($nodes as $node) {
            if (null === $node) {
                $pNodes[] = '';
            } else {
                $pNodes[] = $this->p($node);
            }
        }
        return \implode($glue, $pNodes);
    }
    /**
     * Pretty prints an array of nodes and implodes the printed values with commas.
     *
     * @param Node[] $nodes Array of Nodes to be printed
     *
     * @return string Comma separated pretty printed nodes
     */
    protected function pCommaSeparated(array $nodes) : string
    {
        return $this->pImplode($nodes, ', ');
    }
    /**
     * Pretty prints a comma-separated list of nodes in multiline style, including comments.
     *
     * The result includes a leading newline and one level of indentation (same as pStmts).
     *
     * @param Node[] $nodes         Array of Nodes to be printed
     * @param bool   $trailingComma Whether to use a trailing comma
     *
     * @return string Comma separated pretty printed nodes in multiline style
     */
    protected function pCommaSeparatedMultiline(array $nodes, bool $trailingComma) : string
    {
        $this->indent();
        $result = '';
        $lastIdx = \count($nodes) - 1;
        foreach ($nodes as $idx => $node) {
            if ($node !== null) {
                $comments = $node->getComments();
                if ($comments) {
                    $result .= $this->nl . $this->pComments($comments);
                }
                $result .= $this->nl . $this->p($node);
            } else {
                $result .= $this->nl;
            }
            if ($trailingComma || $idx !== $lastIdx) {
                $result .= ',';
            }
        }
        $this->outdent();
        return $result;
    }
    /**
     * Prints reformatted text of the passed comments.
     *
     * @param Comment[] $comments List of comments
     *
     * @return string Reformatted text of comments
     */
    protected function pComments(array $comments) : string
    {
        $formattedComments = [];
        foreach ($comments as $comment) {
            $formattedComments[] = \str_replace("\n", $this->nl, $comment->getReformattedText());
        }
        return \implode($this->nl, $formattedComments);
    }
    /**
     * Perform a format-preserving pretty print of an AST.
     *
     * The format preservation is best effort. For some changes to the AST the formatting will not
     * be preserved (at least not locally).
     *
     * In order to use this method a number of prerequisites must be satisfied:
     *  * The startTokenPos and endTokenPos attributes in the lexer must be enabled.
     *  * The CloningVisitor must be run on the AST prior to modification.
     *  * The original tokens must be provided, using the getTokens() method on the lexer.
     *
     * @param Node[] $stmts      Modified AST with links to original AST
     * @param Node[] $origStmts  Original AST with token offset information
     * @param array  $origTokens Tokens of the original code
     *
     * @return string
     */
    public function printFormatPreserving(array $stmts, array $origStmts, array $origTokens) : string
    {
        $this->initializeNodeListDiffer();
        $this->initializeLabelCharMap();
        $this->initializeFixupMap();
        $this->initializeRemovalMap();
        $this->initializeInsertionMap();
        $this->initializeListInsertionMap();
        $this->initializeEmptyListInsertionMap();
        $this->initializeModifierChangeMap();
        $this->resetState();
        $this->origTokens = new \PHPUnit\PhpParser\Internal\TokenStream($origTokens);
        $this->preprocessNodes($stmts);
        $pos = 0;
        $result = $this->pArray($stmts, $origStmts, $pos, 0, 'File', 'stmts', null);
        if (null !== $result) {
            $result .= $this->origTokens->getTokenCode($pos, \count($origTokens), 0);
        } else {
            // Fallback
            // TODO Add <?php properly
            $result = "<?php\n" . $this->pStmts($stmts, \false);
        }
        return \ltrim($this->handleMagicTokens($result));
    }
    protected function pFallback(\PHPUnit\PhpParser\Node $node)
    {
        return $this->{'p' . $node->getType()}($node);
    }
    /**
     * Pretty prints a node.
     *
     * This method also handles formatting preservation for nodes.
     *
     * @param Node $node Node to be pretty printed
     * @param bool $parentFormatPreserved Whether parent node has preserved formatting
     *
     * @return string Pretty printed node
     */
    protected function p(\PHPUnit\PhpParser\Node $node, $parentFormatPreserved = \false) : string
    {
        // No orig tokens means this is a normal pretty print without preservation of formatting
        if (!$this->origTokens) {
            return $this->{'p' . $node->getType()}($node);
        }
        /** @var Node $origNode */
        $origNode = $node->getAttribute('origNode');
        if (null === $origNode) {
            return $this->pFallback($node);
        }
        $class = \get_class($node);
        \assert($class === \get_class($origNode));
        $startPos = $origNode->getStartTokenPos();
        $endPos = $origNode->getEndTokenPos();
        \assert($startPos >= 0 && $endPos >= 0);
        $fallbackNode = $node;
        if ($node instanceof \PHPUnit\PhpParser\Node\Expr\New_ && $node->class instanceof \PHPUnit\PhpParser\Node\Stmt\Class_) {
            // Normalize node structure of anonymous classes
            $node = \PHPUnit\PhpParser\Internal\PrintableNewAnonClassNode::fromNewNode($node);
            $origNode = \PHPUnit\PhpParser\Internal\PrintableNewAnonClassNode::fromNewNode($origNode);
        }
        // InlineHTML node does not contain closing and opening PHP tags. If the parent formatting
        // is not preserved, then we need to use the fallback code to make sure the tags are
        // printed.
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\InlineHTML && !$parentFormatPreserved) {
            return $this->pFallback($fallbackNode);
        }
        $indentAdjustment = $this->indentLevel - $this->origTokens->getIndentationBefore($startPos);
        $type = $node->getType();
        $fixupInfo = $this->fixupMap[$class] ?? null;
        $result = '';
        $pos = $startPos;
        foreach ($node->getSubNodeNames() as $subNodeName) {
            $subNode = $node->{$subNodeName};
            $origSubNode = $origNode->{$subNodeName};
            if (!$subNode instanceof \PHPUnit\PhpParser\Node && $subNode !== null || !$origSubNode instanceof \PHPUnit\PhpParser\Node && $origSubNode !== null) {
                if ($subNode === $origSubNode) {
                    // Unchanged, can reuse old code
                    continue;
                }
                if (\is_array($subNode) && \is_array($origSubNode)) {
                    // Array subnode changed, we might be able to reconstruct it
                    $listResult = $this->pArray($subNode, $origSubNode, $pos, $indentAdjustment, $type, $subNodeName, $fixupInfo[$subNodeName] ?? null);
                    if (null === $listResult) {
                        return $this->pFallback($fallbackNode);
                    }
                    $result .= $listResult;
                    continue;
                }
                if (\is_int($subNode) && \is_int($origSubNode)) {
                    // Check if this is a modifier change
                    $key = $type . '->' . $subNodeName;
                    if (!isset($this->modifierChangeMap[$key])) {
                        return $this->pFallback($fallbackNode);
                    }
                    $findToken = $this->modifierChangeMap[$key];
                    $result .= $this->pModifiers($subNode);
                    $pos = $this->origTokens->findRight($pos, $findToken);
                    continue;
                }
                // If a non-node, non-array subnode changed, we don't be able to do a partial
                // reconstructions, as we don't have enough offset information. Pretty print the
                // whole node instead.
                return $this->pFallback($fallbackNode);
            }
            $extraLeft = '';
            $extraRight = '';
            if ($origSubNode !== null) {
                $subStartPos = $origSubNode->getStartTokenPos();
                $subEndPos = $origSubNode->getEndTokenPos();
                \assert($subStartPos >= 0 && $subEndPos >= 0);
            } else {
                if ($subNode === null) {
                    // Both null, nothing to do
                    continue;
                }
                // A node has been inserted, check if we have insertion information for it
                $key = $type . '->' . $subNodeName;
                if (!isset($this->insertionMap[$key])) {
                    return $this->pFallback($fallbackNode);
                }
                list($findToken, $beforeToken, $extraLeft, $extraRight) = $this->insertionMap[$key];
                if (null !== $findToken) {
                    $subStartPos = $this->origTokens->findRight($pos, $findToken) + (int) (!$beforeToken);
                } else {
                    $subStartPos = $pos;
                }
                if (null === $extraLeft && null !== $extraRight) {
                    // If inserting on the right only, skipping whitespace looks better
                    $subStartPos = $this->origTokens->skipRightWhitespace($subStartPos);
                }
                $subEndPos = $subStartPos - 1;
            }
            if (null === $subNode) {
                // A node has been removed, check if we have removal information for it
                $key = $type . '->' . $subNodeName;
                if (!isset($this->removalMap[$key])) {
                    return $this->pFallback($fallbackNode);
                }
                // Adjust positions to account for additional tokens that must be skipped
                $removalInfo = $this->removalMap[$key];
                if (isset($removalInfo['left'])) {
                    $subStartPos = $this->origTokens->skipLeft($subStartPos - 1, $removalInfo['left']) + 1;
                }
                if (isset($removalInfo['right'])) {
                    $subEndPos = $this->origTokens->skipRight($subEndPos + 1, $removalInfo['right']) - 1;
                }
            }
            $result .= $this->origTokens->getTokenCode($pos, $subStartPos, $indentAdjustment);
            if (null !== $subNode) {
                $result .= $extraLeft;
                $origIndentLevel = $this->indentLevel;
                $this->setIndentLevel($this->origTokens->getIndentationBefore($subStartPos) + $indentAdjustment);
                // If it's the same node that was previously in this position, it certainly doesn't
                // need fixup. It's important to check this here, because our fixup checks are more
                // conservative than strictly necessary.
                if (isset($fixupInfo[$subNodeName]) && $subNode->getAttribute('origNode') !== $origSubNode) {
                    $fixup = $fixupInfo[$subNodeName];
                    $res = $this->pFixup($fixup, $subNode, $class, $subStartPos, $subEndPos);
                } else {
                    $res = $this->p($subNode, \true);
                }
                $this->safeAppend($result, $res);
                $this->setIndentLevel($origIndentLevel);
                $result .= $extraRight;
            }
            $pos = $subEndPos + 1;
        }
        $result .= $this->origTokens->getTokenCode($pos, $endPos + 1, $indentAdjustment);
        return $result;
    }
    /**
     * Perform a format-preserving pretty print of an array.
     *
     * @param array       $nodes            New nodes
     * @param array       $origNodes        Original nodes
     * @param int         $pos              Current token position (updated by reference)
     * @param int         $indentAdjustment Adjustment for indentation
     * @param string      $parentNodeType   Type of the containing node.
     * @param string      $subNodeName      Name of array subnode.
     * @param null|int    $fixup            Fixup information for array item nodes
     *
     * @return null|string Result of pretty print or null if cannot preserve formatting
     */
    protected function pArray(array $nodes, array $origNodes, int &$pos, int $indentAdjustment, string $parentNodeType, string $subNodeName, $fixup)
    {
        $diff = $this->nodeListDiffer->diffWithReplacements($origNodes, $nodes);
        $mapKey = $parentNodeType . '->' . $subNodeName;
        $insertStr = $this->listInsertionMap[$mapKey] ?? null;
        $isStmtList = $subNodeName === 'stmts';
        $beforeFirstKeepOrReplace = \true;
        $skipRemovedNode = \false;
        $delayedAdd = [];
        $lastElemIndentLevel = $this->indentLevel;
        $insertNewline = \false;
        if ($insertStr === "\n") {
            $insertStr = '';
            $insertNewline = \true;
        }
        if ($isStmtList && \count($origNodes) === 1 && \count($nodes) !== 1) {
            $startPos = $origNodes[0]->getStartTokenPos();
            $endPos = $origNodes[0]->getEndTokenPos();
            \assert($startPos >= 0 && $endPos >= 0);
            if (!$this->origTokens->haveBraces($startPos, $endPos)) {
                // This was a single statement without braces, but either additional statements
                // have been added, or the single statement has been removed. This requires the
                // addition of braces. For now fall back.
                // TODO: Try to preserve formatting
                return null;
            }
        }
        $result = '';
        foreach ($diff as $i => $diffElem) {
            $diffType = $diffElem->type;
            /** @var Node|null $arrItem */
            $arrItem = $diffElem->new;
            /** @var Node|null $origArrItem */
            $origArrItem = $diffElem->old;
            if ($diffType === \PHPUnit\PhpParser\Internal\DiffElem::TYPE_KEEP || $diffType === \PHPUnit\PhpParser\Internal\DiffElem::TYPE_REPLACE) {
                $beforeFirstKeepOrReplace = \false;
                if ($origArrItem === null || $arrItem === null) {
                    // We can only handle the case where both are null
                    if ($origArrItem === $arrItem) {
                        continue;
                    }
                    return null;
                }
                if (!$arrItem instanceof \PHPUnit\PhpParser\Node || !$origArrItem instanceof \PHPUnit\PhpParser\Node) {
                    // We can only deal with nodes. This can occur for Names, which use string arrays.
                    return null;
                }
                $itemStartPos = $origArrItem->getStartTokenPos();
                $itemEndPos = $origArrItem->getEndTokenPos();
                \assert($itemStartPos >= 0 && $itemEndPos >= 0 && $itemStartPos >= $pos);
                $origIndentLevel = $this->indentLevel;
                $lastElemIndentLevel = $this->origTokens->getIndentationBefore($itemStartPos) + $indentAdjustment;
                $this->setIndentLevel($lastElemIndentLevel);
                $comments = $arrItem->getComments();
                $origComments = $origArrItem->getComments();
                $commentStartPos = $origComments ? $origComments[0]->getStartTokenPos() : $itemStartPos;
                \assert($commentStartPos >= 0);
                if ($commentStartPos < $pos) {
                    // Comments may be assigned to multiple nodes if they start at the same position.
                    // Make sure we don't try to print them multiple times.
                    $commentStartPos = $itemStartPos;
                }
                if ($skipRemovedNode) {
                    if ($isStmtList && $this->origTokens->haveBracesInRange($pos, $itemStartPos)) {
                        // We'd remove the brace of a code block.
                        // TODO: Preserve formatting.
                        $this->setIndentLevel($origIndentLevel);
                        return null;
                    }
                } else {
                    $result .= $this->origTokens->getTokenCode($pos, $commentStartPos, $indentAdjustment);
                }
                if (!empty($delayedAdd)) {
                    /** @var Node $delayedAddNode */
                    foreach ($delayedAdd as $delayedAddNode) {
                        if ($insertNewline) {
                            $delayedAddComments = $delayedAddNode->getComments();
                            if ($delayedAddComments) {
                                $result .= $this->pComments($delayedAddComments) . $this->nl;
                            }
                        }
                        $this->safeAppend($result, $this->p($delayedAddNode, \true));
                        if ($insertNewline) {
                            $result .= $insertStr . $this->nl;
                        } else {
                            $result .= $insertStr;
                        }
                    }
                    $delayedAdd = [];
                }
                if ($comments !== $origComments) {
                    if ($comments) {
                        $result .= $this->pComments($comments) . $this->nl;
                    }
                } else {
                    $result .= $this->origTokens->getTokenCode($commentStartPos, $itemStartPos, $indentAdjustment);
                }
                // If we had to remove anything, we have done so now.
                $skipRemovedNode = \false;
            } elseif ($diffType === \PHPUnit\PhpParser\Internal\DiffElem::TYPE_ADD) {
                if (null === $insertStr) {
                    // We don't have insertion information for this list type
                    return null;
                }
                if ($insertStr === ', ' && $this->isMultiline($origNodes)) {
                    $insertStr = ',';
                    $insertNewline = \true;
                }
                if ($beforeFirstKeepOrReplace) {
                    // Will be inserted at the next "replace" or "keep" element
                    $delayedAdd[] = $arrItem;
                    continue;
                }
                $itemStartPos = $pos;
                $itemEndPos = $pos - 1;
                $origIndentLevel = $this->indentLevel;
                $this->setIndentLevel($lastElemIndentLevel);
                if ($insertNewline) {
                    $comments = $arrItem->getComments();
                    if ($comments) {
                        $result .= $this->nl . $this->pComments($comments);
                    }
                    $result .= $insertStr . $this->nl;
                } else {
                    $result .= $insertStr;
                }
            } elseif ($diffType === \PHPUnit\PhpParser\Internal\DiffElem::TYPE_REMOVE) {
                if (!$origArrItem instanceof \PHPUnit\PhpParser\Node) {
                    // We only support removal for nodes
                    return null;
                }
                $itemStartPos = $origArrItem->getStartTokenPos();
                $itemEndPos = $origArrItem->getEndTokenPos();
                \assert($itemStartPos >= 0 && $itemEndPos >= 0);
                // Consider comments part of the node.
                $origComments = $origArrItem->getComments();
                if ($origComments) {
                    $itemStartPos = $origComments[0]->getStartTokenPos();
                }
                if ($i === 0) {
                    // If we're removing from the start, keep the tokens before the node and drop those after it,
                    // instead of the other way around.
                    $result .= $this->origTokens->getTokenCode($pos, $itemStartPos, $indentAdjustment);
                    $skipRemovedNode = \true;
                } else {
                    if ($isStmtList && $this->origTokens->haveBracesInRange($pos, $itemStartPos)) {
                        // We'd remove the brace of a code block.
                        // TODO: Preserve formatting.
                        return null;
                    }
                }
                $pos = $itemEndPos + 1;
                continue;
            } else {
                throw new \Exception("Shouldn't happen");
            }
            if (null !== $fixup && $arrItem->getAttribute('origNode') !== $origArrItem) {
                $res = $this->pFixup($fixup, $arrItem, null, $itemStartPos, $itemEndPos);
            } else {
                $res = $this->p($arrItem, \true);
            }
            $this->safeAppend($result, $res);
            $this->setIndentLevel($origIndentLevel);
            $pos = $itemEndPos + 1;
        }
        if ($skipRemovedNode) {
            // TODO: Support removing single node.
            return null;
        }
        if (!empty($delayedAdd)) {
            if (!isset($this->emptyListInsertionMap[$mapKey])) {
                return null;
            }
            list($findToken, $extraLeft, $extraRight) = $this->emptyListInsertionMap[$mapKey];
            if (null !== $findToken) {
                $insertPos = $this->origTokens->findRight($pos, $findToken) + 1;
                $result .= $this->origTokens->getTokenCode($pos, $insertPos, $indentAdjustment);
                $pos = $insertPos;
            }
            $first = \true;
            $result .= $extraLeft;
            foreach ($delayedAdd as $delayedAddNode) {
                if (!$first) {
                    $result .= $insertStr;
                }
                $result .= $this->p($delayedAddNode, \true);
                $first = \false;
            }
            $result .= $extraRight;
        }
        return $result;
    }
    /**
     * Print node with fixups.
     *
     * Fixups here refer to the addition of extra parentheses, braces or other characters, that
     * are required to preserve program semantics in a certain context (e.g. to maintain precedence
     * or because only certain expressions are allowed in certain places).
     *
     * @param int         $fixup       Fixup type
     * @param Node        $subNode     Subnode to print
     * @param string|null $parentClass Class of parent node
     * @param int         $subStartPos Original start pos of subnode
     * @param int         $subEndPos   Original end pos of subnode
     *
     * @return string Result of fixed-up print of subnode
     */
    protected function pFixup(int $fixup, \PHPUnit\PhpParser\Node $subNode, $parentClass, int $subStartPos, int $subEndPos) : string
    {
        switch ($fixup) {
            case self::FIXUP_PREC_LEFT:
            case self::FIXUP_PREC_RIGHT:
                if (!$this->origTokens->haveParens($subStartPos, $subEndPos)) {
                    list($precedence, $associativity) = $this->precedenceMap[$parentClass];
                    return $this->pPrec($subNode, $precedence, $associativity, $fixup === self::FIXUP_PREC_LEFT ? -1 : 1);
                }
                break;
            case self::FIXUP_CALL_LHS:
                if ($this->callLhsRequiresParens($subNode) && !$this->origTokens->haveParens($subStartPos, $subEndPos)) {
                    return '(' . $this->p($subNode) . ')';
                }
                break;
            case self::FIXUP_DEREF_LHS:
                if ($this->dereferenceLhsRequiresParens($subNode) && !$this->origTokens->haveParens($subStartPos, $subEndPos)) {
                    return '(' . $this->p($subNode) . ')';
                }
                break;
            case self::FIXUP_BRACED_NAME:
            case self::FIXUP_VAR_BRACED_NAME:
                if ($subNode instanceof \PHPUnit\PhpParser\Node\Expr && !$this->origTokens->haveBraces($subStartPos, $subEndPos)) {
                    return ($fixup === self::FIXUP_VAR_BRACED_NAME ? '$' : '') . '{' . $this->p($subNode) . '}';
                }
                break;
            case self::FIXUP_ENCAPSED:
                if (!$subNode instanceof \PHPUnit\PhpParser\Node\Scalar\EncapsedStringPart && !$this->origTokens->haveBraces($subStartPos, $subEndPos)) {
                    return '{' . $this->p($subNode) . '}';
                }
                break;
            default:
                throw new \Exception('Cannot happen');
        }
        // Nothing special to do
        return $this->p($subNode);
    }
    /**
     * Appends to a string, ensuring whitespace between label characters.
     *
     * Example: "echo" and "$x" result in "echo$x", but "echo" and "x" result in "echo x".
     * Without safeAppend the result would be "echox", which does not preserve semantics.
     *
     * @param string $str
     * @param string $append
     */
    protected function safeAppend(string &$str, string $append)
    {
        if ($str === "") {
            $str = $append;
            return;
        }
        if ($append === "") {
            return;
        }
        if (!$this->labelCharMap[$append[0]] || !$this->labelCharMap[$str[\strlen($str) - 1]]) {
            $str .= $append;
        } else {
            $str .= " " . $append;
        }
    }
    /**
     * Determines whether the LHS of a call must be wrapped in parenthesis.
     *
     * @param Node $node LHS of a call
     *
     * @return bool Whether parentheses are required
     */
    protected function callLhsRequiresParens(\PHPUnit\PhpParser\Node $node) : bool
    {
        return !($node instanceof \PHPUnit\PhpParser\Node\Name || $node instanceof \PHPUnit\PhpParser\Node\Expr\Variable || $node instanceof \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\FuncCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\MethodCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\NullsafeMethodCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\StaticCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\Array_);
    }
    /**
     * Determines whether the LHS of a dereferencing operation must be wrapped in parenthesis.
     *
     * @param Node $node LHS of dereferencing operation
     *
     * @return bool Whether parentheses are required
     */
    protected function dereferenceLhsRequiresParens(\PHPUnit\PhpParser\Node $node) : bool
    {
        return !($node instanceof \PHPUnit\PhpParser\Node\Expr\Variable || $node instanceof \PHPUnit\PhpParser\Node\Name || $node instanceof \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\PropertyFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\NullsafePropertyFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\FuncCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\MethodCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\NullsafeMethodCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\StaticCall || $node instanceof \PHPUnit\PhpParser\Node\Expr\Array_ || $node instanceof \PHPUnit\PhpParser\Node\Scalar\String_ || $node instanceof \PHPUnit\PhpParser\Node\Expr\ConstFetch || $node instanceof \PHPUnit\PhpParser\Node\Expr\ClassConstFetch);
    }
    /**
     * Print modifiers, including trailing whitespace.
     *
     * @param int $modifiers Modifier mask to print
     *
     * @return string Printed modifiers
     */
    protected function pModifiers(int $modifiers)
    {
        return ($modifiers & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PUBLIC ? 'public ' : '') . ($modifiers & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PROTECTED ? 'protected ' : '') . ($modifiers & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_PRIVATE ? 'private ' : '') . ($modifiers & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_STATIC ? 'static ' : '') . ($modifiers & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_ABSTRACT ? 'abstract ' : '') . ($modifiers & \PHPUnit\PhpParser\Node\Stmt\Class_::MODIFIER_FINAL ? 'final ' : '');
    }
    /**
     * Determine whether a list of nodes uses multiline formatting.
     *
     * @param (Node|null)[] $nodes Node list
     *
     * @return bool Whether multiline formatting is used
     */
    protected function isMultiline(array $nodes) : bool
    {
        if (\count($nodes) < 2) {
            return \false;
        }
        $pos = -1;
        foreach ($nodes as $node) {
            if (null === $node) {
                continue;
            }
            $endPos = $node->getEndTokenPos() + 1;
            if ($pos >= 0) {
                $text = $this->origTokens->getTokenCode($pos, $endPos, 0);
                if (\false === \strpos($text, "\n")) {
                    // We require that a newline is present between *every* item. If the formatting
                    // is inconsistent, with only some items having newlines, we don't consider it
                    // as multiline
                    return \false;
                }
            }
            $pos = $endPos;
        }
        return \true;
    }
    /**
     * Lazily initializes label char map.
     *
     * The label char map determines whether a certain character may occur in a label.
     */
    protected function initializeLabelCharMap()
    {
        if ($this->labelCharMap) {
            return;
        }
        $this->labelCharMap = [];
        for ($i = 0; $i < 256; $i++) {
            // Since PHP 7.1 The lower range is 0x80. However, we also want to support code for
            // older versions.
            $this->labelCharMap[\chr($i)] = $i >= 0x7f || \ctype_alnum($i);
        }
    }
    /**
     * Lazily initializes node list differ.
     *
     * The node list differ is used to determine differences between two array subnodes.
     */
    protected function initializeNodeListDiffer()
    {
        if ($this->nodeListDiffer) {
            return;
        }
        $this->nodeListDiffer = new \PHPUnit\PhpParser\Internal\Differ(function ($a, $b) {
            if ($a instanceof \PHPUnit\PhpParser\Node && $b instanceof \PHPUnit\PhpParser\Node) {
                return $a === $b->getAttribute('origNode');
            }
            // Can happen for array destructuring
            return $a === null && $b === null;
        });
    }
    /**
     * Lazily initializes fixup map.
     *
     * The fixup map is used to determine whether a certain subnode of a certain node may require
     * some kind of "fixup" operation, e.g. the addition of parenthesis or braces.
     */
    protected function initializeFixupMap()
    {
        if ($this->fixupMap) {
            return;
        }
        $this->fixupMap = [
            \PHPUnit\PhpParser\Node\Expr\PreInc::class => ['var' => self::FIXUP_PREC_RIGHT],
            \PHPUnit\PhpParser\Node\Expr\PreDec::class => ['var' => self::FIXUP_PREC_RIGHT],
            \PHPUnit\PhpParser\Node\Expr\PostInc::class => ['var' => self::FIXUP_PREC_LEFT],
            \PHPUnit\PhpParser\Node\Expr\PostDec::class => ['var' => self::FIXUP_PREC_LEFT],
            \PHPUnit\PhpParser\Node\Expr\Instanceof_::class => ['expr' => self::FIXUP_PREC_LEFT, 'class' => self::FIXUP_PREC_RIGHT],
            \PHPUnit\PhpParser\Node\Expr\Ternary::class => ['cond' => self::FIXUP_PREC_LEFT, 'else' => self::FIXUP_PREC_RIGHT],
            \PHPUnit\PhpParser\Node\Expr\FuncCall::class => ['name' => self::FIXUP_CALL_LHS],
            \PHPUnit\PhpParser\Node\Expr\StaticCall::class => ['class' => self::FIXUP_DEREF_LHS],
            \PHPUnit\PhpParser\Node\Expr\ArrayDimFetch::class => ['var' => self::FIXUP_DEREF_LHS],
            \PHPUnit\PhpParser\Node\Expr\ClassConstFetch::class => ['var' => self::FIXUP_DEREF_LHS],
            \PHPUnit\PhpParser\Node\Expr\New_::class => ['class' => self::FIXUP_DEREF_LHS],
            // TODO: FIXUP_NEW_VARIABLE
            \PHPUnit\PhpParser\Node\Expr\MethodCall::class => ['var' => self::FIXUP_DEREF_LHS, 'name' => self::FIXUP_BRACED_NAME],
            \PHPUnit\PhpParser\Node\Expr\NullsafeMethodCall::class => ['var' => self::FIXUP_DEREF_LHS, 'name' => self::FIXUP_BRACED_NAME],
            \PHPUnit\PhpParser\Node\Expr\StaticPropertyFetch::class => ['class' => self::FIXUP_DEREF_LHS, 'name' => self::FIXUP_VAR_BRACED_NAME],
            \PHPUnit\PhpParser\Node\Expr\PropertyFetch::class => ['var' => self::FIXUP_DEREF_LHS, 'name' => self::FIXUP_BRACED_NAME],
            \PHPUnit\PhpParser\Node\Expr\NullsafePropertyFetch::class => ['var' => self::FIXUP_DEREF_LHS, 'name' => self::FIXUP_BRACED_NAME],
            \PHPUnit\PhpParser\Node\Scalar\Encapsed::class => ['parts' => self::FIXUP_ENCAPSED],
        ];
        $binaryOps = [\PHPUnit\PhpParser\Node\Expr\BinaryOp\Pow::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mul::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Div::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Mod::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Plus::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Minus::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Concat::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftLeft::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\ShiftRight::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Smaller::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\SmallerOrEqual::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Greater::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\GreaterOrEqual::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Equal::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotEqual::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Identical::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\NotIdentical::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Spaceship::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseAnd::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseXor::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\BitwiseOr::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\Coalesce::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalXor::class, \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr::class];
        foreach ($binaryOps as $binaryOp) {
            $this->fixupMap[$binaryOp] = ['left' => self::FIXUP_PREC_LEFT, 'right' => self::FIXUP_PREC_RIGHT];
        }
        $assignOps = [\PHPUnit\PhpParser\Node\Expr\Assign::class, \PHPUnit\PhpParser\Node\Expr\AssignRef::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Plus::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Minus::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Mul::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Div::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Concat::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Mod::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseAnd::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseOr::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\BitwiseXor::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftLeft::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\ShiftRight::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Pow::class, \PHPUnit\PhpParser\Node\Expr\AssignOp\Coalesce::class];
        foreach ($assignOps as $assignOp) {
            $this->fixupMap[$assignOp] = ['var' => self::FIXUP_PREC_LEFT, 'expr' => self::FIXUP_PREC_RIGHT];
        }
        $prefixOps = [\PHPUnit\PhpParser\Node\Expr\BitwiseNot::class, \PHPUnit\PhpParser\Node\Expr\BooleanNot::class, \PHPUnit\PhpParser\Node\Expr\UnaryPlus::class, \PHPUnit\PhpParser\Node\Expr\UnaryMinus::class, \PHPUnit\PhpParser\Node\Expr\Cast\Int_::class, \PHPUnit\PhpParser\Node\Expr\Cast\Double::class, \PHPUnit\PhpParser\Node\Expr\Cast\String_::class, \PHPUnit\PhpParser\Node\Expr\Cast\Array_::class, \PHPUnit\PhpParser\Node\Expr\Cast\Object_::class, \PHPUnit\PhpParser\Node\Expr\Cast\Bool_::class, \PHPUnit\PhpParser\Node\Expr\Cast\Unset_::class, \PHPUnit\PhpParser\Node\Expr\ErrorSuppress::class, \PHPUnit\PhpParser\Node\Expr\YieldFrom::class, \PHPUnit\PhpParser\Node\Expr\Print_::class, \PHPUnit\PhpParser\Node\Expr\Include_::class];
        foreach ($prefixOps as $prefixOp) {
            $this->fixupMap[$prefixOp] = ['expr' => self::FIXUP_PREC_RIGHT];
        }
    }
    /**
     * Lazily initializes the removal map.
     *
     * The removal map is used to determine which additional tokens should be removed when a
     * certain node is replaced by null.
     */
    protected function initializeRemovalMap()
    {
        if ($this->removalMap) {
            return;
        }
        $stripBoth = ['left' => \T_WHITESPACE, 'right' => \T_WHITESPACE];
        $stripLeft = ['left' => \T_WHITESPACE];
        $stripRight = ['right' => \T_WHITESPACE];
        $stripDoubleArrow = ['right' => \T_DOUBLE_ARROW];
        $stripColon = ['left' => ':'];
        $stripEquals = ['left' => '='];
        $this->removalMap = ['Expr_ArrayDimFetch->dim' => $stripBoth, 'Expr_ArrayItem->key' => $stripDoubleArrow, 'Expr_ArrowFunction->returnType' => $stripColon, 'Expr_Closure->returnType' => $stripColon, 'Expr_Exit->expr' => $stripBoth, 'Expr_Ternary->if' => $stripBoth, 'Expr_Yield->key' => $stripDoubleArrow, 'Expr_Yield->value' => $stripBoth, 'Param->type' => $stripRight, 'Param->default' => $stripEquals, 'Stmt_Break->num' => $stripBoth, 'Stmt_Catch->var' => $stripLeft, 'Stmt_ClassMethod->returnType' => $stripColon, 'Stmt_Class->extends' => ['left' => \T_EXTENDS], 'Stmt_Enum->scalarType' => $stripColon, 'Stmt_EnumCase->expr' => $stripEquals, 'Expr_PrintableNewAnonClass->extends' => ['left' => \T_EXTENDS], 'Stmt_Continue->num' => $stripBoth, 'Stmt_Foreach->keyVar' => $stripDoubleArrow, 'Stmt_Function->returnType' => $stripColon, 'Stmt_If->else' => $stripLeft, 'Stmt_Namespace->name' => $stripLeft, 'Stmt_Property->type' => $stripRight, 'Stmt_PropertyProperty->default' => $stripEquals, 'Stmt_Return->expr' => $stripBoth, 'Stmt_StaticVar->default' => $stripEquals, 'Stmt_TraitUseAdaptation_Alias->newName' => $stripLeft, 'Stmt_TryCatch->finally' => $stripLeft];
    }
    protected function initializeInsertionMap()
    {
        if ($this->insertionMap) {
            return;
        }
        // TODO: "yield" where both key and value are inserted doesn't work
        // [$find, $beforeToken, $extraLeft, $extraRight]
        $this->insertionMap = [
            'Expr_ArrayDimFetch->dim' => ['[', \false, null, null],
            'Expr_ArrayItem->key' => [null, \false, null, ' => '],
            'Expr_ArrowFunction->returnType' => [')', \false, ' : ', null],
            'Expr_Closure->returnType' => [')', \false, ' : ', null],
            'Expr_Ternary->if' => ['?', \false, ' ', ' '],
            'Expr_Yield->key' => [\T_YIELD, \false, null, ' => '],
            'Expr_Yield->value' => [\T_YIELD, \false, ' ', null],
            'Param->type' => [null, \false, null, ' '],
            'Param->default' => [null, \false, ' = ', null],
            'Stmt_Break->num' => [\T_BREAK, \false, ' ', null],
            'Stmt_Catch->var' => [null, \false, ' ', null],
            'Stmt_ClassMethod->returnType' => [')', \false, ' : ', null],
            'Stmt_Class->extends' => [null, \false, ' extends ', null],
            'Stmt_Enum->scalarType' => [null, \false, ' : ', null],
            'Stmt_EnumCase->expr' => [null, \false, ' = ', null],
            'Expr_PrintableNewAnonClass->extends' => [null, ' extends ', null],
            'Stmt_Continue->num' => [\T_CONTINUE, \false, ' ', null],
            'Stmt_Foreach->keyVar' => [\T_AS, \false, null, ' => '],
            'Stmt_Function->returnType' => [')', \false, ' : ', null],
            'Stmt_If->else' => [null, \false, ' ', null],
            'Stmt_Namespace->name' => [\T_NAMESPACE, \false, ' ', null],
            'Stmt_Property->type' => [\T_VARIABLE, \true, null, ' '],
            'Stmt_PropertyProperty->default' => [null, \false, ' = ', null],
            'Stmt_Return->expr' => [\T_RETURN, \false, ' ', null],
            'Stmt_StaticVar->default' => [null, \false, ' = ', null],
            //'Stmt_TraitUseAdaptation_Alias->newName' => [T_AS, false, ' ', null], // TODO
            'Stmt_TryCatch->finally' => [null, \false, ' ', null],
        ];
    }
    protected function initializeListInsertionMap()
    {
        if ($this->listInsertionMap) {
            return;
        }
        $this->listInsertionMap = [
            // special
            //'Expr_ShellExec->parts' => '', // TODO These need to be treated more carefully
            //'Scalar_Encapsed->parts' => '',
            'Stmt_Catch->types' => '|',
            'UnionType->types' => '|',
            'Stmt_If->elseifs' => ' ',
            'Stmt_TryCatch->catches' => ' ',
            // comma-separated lists
            'Expr_Array->items' => ', ',
            'Expr_ArrowFunction->params' => ', ',
            'Expr_Closure->params' => ', ',
            'Expr_Closure->uses' => ', ',
            'Expr_FuncCall->args' => ', ',
            'Expr_Isset->vars' => ', ',
            'Expr_List->items' => ', ',
            'Expr_MethodCall->args' => ', ',
            'Expr_NullsafeMethodCall->args' => ', ',
            'Expr_New->args' => ', ',
            'Expr_PrintableNewAnonClass->args' => ', ',
            'Expr_StaticCall->args' => ', ',
            'Stmt_ClassConst->consts' => ', ',
            'Stmt_ClassMethod->params' => ', ',
            'Stmt_Class->implements' => ', ',
            'Stmt_Enum->implements' => ', ',
            'Expr_PrintableNewAnonClass->implements' => ', ',
            'Stmt_Const->consts' => ', ',
            'Stmt_Declare->declares' => ', ',
            'Stmt_Echo->exprs' => ', ',
            'Stmt_For->init' => ', ',
            'Stmt_For->cond' => ', ',
            'Stmt_For->loop' => ', ',
            'Stmt_Function->params' => ', ',
            'Stmt_Global->vars' => ', ',
            'Stmt_GroupUse->uses' => ', ',
            'Stmt_Interface->extends' => ', ',
            'Stmt_Match->arms' => ', ',
            'Stmt_Property->props' => ', ',
            'Stmt_StaticVar->vars' => ', ',
            'Stmt_TraitUse->traits' => ', ',
            'Stmt_TraitUseAdaptation_Precedence->insteadof' => ', ',
            'Stmt_Unset->vars' => ', ',
            'Stmt_Use->uses' => ', ',
            'MatchArm->conds' => ', ',
            'AttributeGroup->attrs' => ', ',
            // statement lists
            'Expr_Closure->stmts' => "\n",
            'Stmt_Case->stmts' => "\n",
            'Stmt_Catch->stmts' => "\n",
            'Stmt_Class->stmts' => "\n",
            'Stmt_Enum->stmts' => "\n",
            'Expr_PrintableNewAnonClass->stmts' => "\n",
            'Stmt_Interface->stmts' => "\n",
            'Stmt_Trait->stmts' => "\n",
            'Stmt_ClassMethod->stmts' => "\n",
            'Stmt_Declare->stmts' => "\n",
            'Stmt_Do->stmts' => "\n",
            'Stmt_ElseIf->stmts' => "\n",
            'Stmt_Else->stmts' => "\n",
            'Stmt_Finally->stmts' => "\n",
            'Stmt_Foreach->stmts' => "\n",
            'Stmt_For->stmts' => "\n",
            'Stmt_Function->stmts' => "\n",
            'Stmt_If->stmts' => "\n",
            'Stmt_Namespace->stmts' => "\n",
            'Stmt_Class->attrGroups' => "\n",
            'Stmt_Enum->attrGroups' => "\n",
            'Stmt_EnumCase->attrGroups' => "\n",
            'Stmt_Interface->attrGroups' => "\n",
            'Stmt_Trait->attrGroups' => "\n",
            'Stmt_Function->attrGroups' => "\n",
            'Stmt_ClassMethod->attrGroups' => "\n",
            'Stmt_ClassConst->attrGroups' => "\n",
            'Stmt_Property->attrGroups' => "\n",
            'Expr_PrintableNewAnonClass->attrGroups' => ' ',
            'Expr_Closure->attrGroups' => ' ',
            'Expr_ArrowFunction->attrGroups' => ' ',
            'Param->attrGroups' => ' ',
            'Stmt_Switch->cases' => "\n",
            'Stmt_TraitUse->adaptations' => "\n",
            'Stmt_TryCatch->stmts' => "\n",
            'Stmt_While->stmts' => "\n",
            // dummy for top-level context
            'File->stmts' => "\n",
        ];
    }
    protected function initializeEmptyListInsertionMap()
    {
        if ($this->emptyListInsertionMap) {
            return;
        }
        // TODO Insertion into empty statement lists.
        // [$find, $extraLeft, $extraRight]
        $this->emptyListInsertionMap = ['Expr_ArrowFunction->params' => ['(', '', ''], 'Expr_Closure->uses' => [')', ' use(', ')'], 'Expr_Closure->params' => ['(', '', ''], 'Expr_FuncCall->args' => ['(', '', ''], 'Expr_MethodCall->args' => ['(', '', ''], 'Expr_NullsafeMethodCall->args' => ['(', '', ''], 'Expr_New->args' => ['(', '', ''], 'Expr_PrintableNewAnonClass->args' => ['(', '', ''], 'Expr_PrintableNewAnonClass->implements' => [null, ' implements ', ''], 'Expr_StaticCall->args' => ['(', '', ''], 'Stmt_Class->implements' => [null, ' implements ', ''], 'Stmt_Enum->implements' => [null, ' implements ', ''], 'Stmt_ClassMethod->params' => ['(', '', ''], 'Stmt_Interface->extends' => [null, ' extends ', ''], 'Stmt_Function->params' => ['(', '', '']];
    }
    protected function initializeModifierChangeMap()
    {
        if ($this->modifierChangeMap) {
            return;
        }
        $this->modifierChangeMap = ['Stmt_ClassConst->flags' => \T_CONST, 'Stmt_ClassMethod->flags' => \T_FUNCTION, 'Stmt_Class->flags' => \T_CLASS, 'Stmt_Property->flags' => \T_VARIABLE, 'Param->flags' => \T_VARIABLE];
        // List of integer subnodes that are not modifiers:
        // Expr_Include->type
        // Stmt_GroupUse->type
        // Stmt_Use->type
        // Stmt_UseUse->type
    }
}
Object Enumerator

Copyright (c) 2016-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
Object Reflector

Copyright (c) 2017-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
Phar.io - Manifest

Copyright (c) 2016-2019 Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>, and contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of Arne Blankerts nor the names of contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  * NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use PHPUnit\PharIo\Version\Exception as VersionException;
use PHPUnit\PharIo\Version\Version;
use PHPUnit\PharIo\Version\VersionConstraintParser;
class ManifestDocumentMapper
{
    public function map(\PHPUnit\PharIo\Manifest\ManifestDocument $document) : \PHPUnit\PharIo\Manifest\Manifest
    {
        try {
            $contains = $document->getContainsElement();
            $type = $this->mapType($contains);
            $copyright = $this->mapCopyright($document->getCopyrightElement());
            $requirements = $this->mapRequirements($document->getRequiresElement());
            $bundledComponents = $this->mapBundledComponents($document);
            return new \PHPUnit\PharIo\Manifest\Manifest(new \PHPUnit\PharIo\Manifest\ApplicationName($contains->getName()), new \PHPUnit\PharIo\Version\Version($contains->getVersion()), $type, $copyright, $requirements, $bundledComponents);
        } catch (\PHPUnit\PharIo\Version\Exception $e) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentMapperException($e->getMessage(), (int) $e->getCode(), $e);
        } catch (\PHPUnit\PharIo\Manifest\Exception $e) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentMapperException($e->getMessage(), (int) $e->getCode(), $e);
        }
    }
    private function mapType(\PHPUnit\PharIo\Manifest\ContainsElement $contains) : \PHPUnit\PharIo\Manifest\Type
    {
        switch ($contains->getType()) {
            case 'application':
                return \PHPUnit\PharIo\Manifest\Type::application();
            case 'library':
                return \PHPUnit\PharIo\Manifest\Type::library();
            case 'extension':
                return $this->mapExtension($contains->getExtensionElement());
        }
        throw new \PHPUnit\PharIo\Manifest\ManifestDocumentMapperException(\sprintf('Unsupported type %s', $contains->getType()));
    }
    private function mapCopyright(\PHPUnit\PharIo\Manifest\CopyrightElement $copyright) : \PHPUnit\PharIo\Manifest\CopyrightInformation
    {
        $authors = new \PHPUnit\PharIo\Manifest\AuthorCollection();
        foreach ($copyright->getAuthorElements() as $authorElement) {
            $authors->add(new \PHPUnit\PharIo\Manifest\Author($authorElement->getName(), new \PHPUnit\PharIo\Manifest\Email($authorElement->getEmail())));
        }
        $licenseElement = $copyright->getLicenseElement();
        $license = new \PHPUnit\PharIo\Manifest\License($licenseElement->getType(), new \PHPUnit\PharIo\Manifest\Url($licenseElement->getUrl()));
        return new \PHPUnit\PharIo\Manifest\CopyrightInformation($authors, $license);
    }
    private function mapRequirements(\PHPUnit\PharIo\Manifest\RequiresElement $requires) : \PHPUnit\PharIo\Manifest\RequirementCollection
    {
        $collection = new \PHPUnit\PharIo\Manifest\RequirementCollection();
        $phpElement = $requires->getPHPElement();
        $parser = new \PHPUnit\PharIo\Version\VersionConstraintParser();
        try {
            $versionConstraint = $parser->parse($phpElement->getVersion());
        } catch (\PHPUnit\PharIo\Version\Exception $e) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentMapperException(\sprintf('Unsupported version constraint - %s', $e->getMessage()), (int) $e->getCode(), $e);
        }
        $collection->add(new \PHPUnit\PharIo\Manifest\PhpVersionRequirement($versionConstraint));
        if (!$phpElement->hasExtElements()) {
            return $collection;
        }
        foreach ($phpElement->getExtElements() as $extElement) {
            $collection->add(new \PHPUnit\PharIo\Manifest\PhpExtensionRequirement($extElement->getName()));
        }
        return $collection;
    }
    private function mapBundledComponents(\PHPUnit\PharIo\Manifest\ManifestDocument $document) : \PHPUnit\PharIo\Manifest\BundledComponentCollection
    {
        $collection = new \PHPUnit\PharIo\Manifest\BundledComponentCollection();
        if (!$document->hasBundlesElement()) {
            return $collection;
        }
        foreach ($document->getBundlesElement()->getComponentElements() as $componentElement) {
            $collection->add(new \PHPUnit\PharIo\Manifest\BundledComponent($componentElement->getName(), new \PHPUnit\PharIo\Version\Version($componentElement->getVersion())));
        }
        return $collection;
    }
    private function mapExtension(\PHPUnit\PharIo\Manifest\ExtensionElement $extension) : \PHPUnit\PharIo\Manifest\Extension
    {
        try {
            $versionConstraint = (new \PHPUnit\PharIo\Version\VersionConstraintParser())->parse($extension->getCompatible());
            return \PHPUnit\PharIo\Manifest\Type::extension(new \PHPUnit\PharIo\Manifest\ApplicationName($extension->getFor()), $versionConstraint);
        } catch (\PHPUnit\PharIo\Version\Exception $e) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentMapperException(\sprintf('Unsupported version constraint - %s', $e->getMessage()), (int) $e->getCode(), $e);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ManifestLoader
{
    public static function fromFile(string $filename) : \PHPUnit\PharIo\Manifest\Manifest
    {
        try {
            return (new \PHPUnit\PharIo\Manifest\ManifestDocumentMapper())->map(\PHPUnit\PharIo\Manifest\ManifestDocument::fromFile($filename));
        } catch (\PHPUnit\PharIo\Manifest\Exception $e) {
            throw new \PHPUnit\PharIo\Manifest\ManifestLoaderException(\sprintf('Loading %s failed.', $filename), (int) $e->getCode(), $e);
        }
    }
    public static function fromPhar(string $filename) : \PHPUnit\PharIo\Manifest\Manifest
    {
        return self::fromFile('phar://' . $filename . '/manifest.xml');
    }
    public static function fromString(string $manifest) : \PHPUnit\PharIo\Manifest\Manifest
    {
        try {
            return (new \PHPUnit\PharIo\Manifest\ManifestDocumentMapper())->map(\PHPUnit\PharIo\Manifest\ManifestDocument::fromString($manifest));
        } catch (\PHPUnit\PharIo\Manifest\Exception $e) {
            throw new \PHPUnit\PharIo\Manifest\ManifestLoaderException('Processing string failed', (int) $e->getCode(), $e);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use PHPUnit\PharIo\Version\AnyVersionConstraint;
use PHPUnit\PharIo\Version\Version;
use PHPUnit\PharIo\Version\VersionConstraint;
use XMLWriter;
/** @psalm-suppress MissingConstructor */
class ManifestSerializer
{
    /** @var XMLWriter */
    private $xmlWriter;
    public function serializeToFile(\PHPUnit\PharIo\Manifest\Manifest $manifest, string $filename) : void
    {
        \file_put_contents($filename, $this->serializeToString($manifest));
    }
    public function serializeToString(\PHPUnit\PharIo\Manifest\Manifest $manifest) : string
    {
        $this->startDocument();
        $this->addContains($manifest->getName(), $manifest->getVersion(), $manifest->getType());
        $this->addCopyright($manifest->getCopyrightInformation());
        $this->addRequirements($manifest->getRequirements());
        $this->addBundles($manifest->getBundledComponents());
        return $this->finishDocument();
    }
    private function startDocument() : void
    {
        $xmlWriter = new \XMLWriter();
        $xmlWriter->openMemory();
        $xmlWriter->setIndent(\true);
        $xmlWriter->setIndentString(\str_repeat(' ', 4));
        $xmlWriter->startDocument('1.0', 'UTF-8');
        $xmlWriter->startElement('phar');
        $xmlWriter->writeAttribute('xmlns', 'https://phar.io/xml/manifest/1.0');
        $this->xmlWriter = $xmlWriter;
    }
    private function finishDocument() : string
    {
        $this->xmlWriter->endElement();
        $this->xmlWriter->endDocument();
        return $this->xmlWriter->outputMemory();
    }
    private function addContains(\PHPUnit\PharIo\Manifest\ApplicationName $name, \PHPUnit\PharIo\Version\Version $version, \PHPUnit\PharIo\Manifest\Type $type) : void
    {
        $this->xmlWriter->startElement('contains');
        $this->xmlWriter->writeAttribute('name', $name->asString());
        $this->xmlWriter->writeAttribute('version', $version->getVersionString());
        switch (\true) {
            case $type->isApplication():
                $this->xmlWriter->writeAttribute('type', 'application');
                break;
            case $type->isLibrary():
                $this->xmlWriter->writeAttribute('type', 'library');
                break;
            case $type->isExtension():
                $this->xmlWriter->writeAttribute('type', 'extension');
                /* @var $type Extension */
                $this->addExtension($type->getApplicationName(), $type->getVersionConstraint());
                break;
            default:
                $this->xmlWriter->writeAttribute('type', 'custom');
        }
        $this->xmlWriter->endElement();
    }
    private function addCopyright(\PHPUnit\PharIo\Manifest\CopyrightInformation $copyrightInformation) : void
    {
        $this->xmlWriter->startElement('copyright');
        foreach ($copyrightInformation->getAuthors() as $author) {
            $this->xmlWriter->startElement('author');
            $this->xmlWriter->writeAttribute('name', $author->getName());
            $this->xmlWriter->writeAttribute('email', $author->getEmail()->asString());
            $this->xmlWriter->endElement();
        }
        $license = $copyrightInformation->getLicense();
        $this->xmlWriter->startElement('license');
        $this->xmlWriter->writeAttribute('type', $license->getName());
        $this->xmlWriter->writeAttribute('url', $license->getUrl()->asString());
        $this->xmlWriter->endElement();
        $this->xmlWriter->endElement();
    }
    private function addRequirements(\PHPUnit\PharIo\Manifest\RequirementCollection $requirementCollection) : void
    {
        $phpRequirement = new \PHPUnit\PharIo\Version\AnyVersionConstraint();
        $extensions = [];
        foreach ($requirementCollection as $requirement) {
            if ($requirement instanceof \PHPUnit\PharIo\Manifest\PhpVersionRequirement) {
                $phpRequirement = $requirement->getVersionConstraint();
                continue;
            }
            if ($requirement instanceof \PHPUnit\PharIo\Manifest\PhpExtensionRequirement) {
                $extensions[] = $requirement->asString();
            }
        }
        $this->xmlWriter->startElement('requires');
        $this->xmlWriter->startElement('php');
        $this->xmlWriter->writeAttribute('version', $phpRequirement->asString());
        foreach ($extensions as $extension) {
            $this->xmlWriter->startElement('ext');
            $this->xmlWriter->writeAttribute('name', $extension);
            $this->xmlWriter->endElement();
        }
        $this->xmlWriter->endElement();
        $this->xmlWriter->endElement();
    }
    private function addBundles(\PHPUnit\PharIo\Manifest\BundledComponentCollection $bundledComponentCollection) : void
    {
        if (\count($bundledComponentCollection) === 0) {
            return;
        }
        $this->xmlWriter->startElement('bundles');
        foreach ($bundledComponentCollection as $bundledComponent) {
            $this->xmlWriter->startElement('component');
            $this->xmlWriter->writeAttribute('name', $bundledComponent->getName());
            $this->xmlWriter->writeAttribute('version', $bundledComponent->getVersion()->getVersionString());
            $this->xmlWriter->endElement();
        }
        $this->xmlWriter->endElement();
    }
    private function addExtension(\PHPUnit\PharIo\Manifest\ApplicationName $applicationName, \PHPUnit\PharIo\Version\VersionConstraint $versionConstraint) : void
    {
        $this->xmlWriter->startElement('extension');
        $this->xmlWriter->writeAttribute('for', $applicationName->asString());
        $this->xmlWriter->writeAttribute('compatible', $versionConstraint->asString());
        $this->xmlWriter->endElement();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ElementCollectionException extends \InvalidArgumentException implements \PHPUnit\PharIo\Manifest\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class InvalidApplicationNameException extends \InvalidArgumentException implements \PHPUnit\PharIo\Manifest\Exception
{
    public const InvalidFormat = 2;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class InvalidEmailException extends \InvalidArgumentException implements \PHPUnit\PharIo\Manifest\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class InvalidUrlException extends \InvalidArgumentException implements \PHPUnit\PharIo\Manifest\Exception
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Manifest;

class ManifestDocumentException extends \RuntimeException implements \PHPUnit\PharIo\Manifest\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use LibXMLError;
class ManifestDocumentLoadingException extends \Exception implements \PHPUnit\PharIo\Manifest\Exception
{
    /** @var LibXMLError[] */
    private $libxmlErrors;
    /**
     * ManifestDocumentLoadingException constructor.
     *
     * @param LibXMLError[] $libxmlErrors
     */
    public function __construct(array $libxmlErrors)
    {
        $this->libxmlErrors = $libxmlErrors;
        $first = $this->libxmlErrors[0];
        parent::__construct(\sprintf('%s (Line: %d / Column: %d / File: %s)', $first->message, $first->line, $first->column, $first->file), $first->code);
    }
    /**
     * @return LibXMLError[]
     */
    public function getLibxmlErrors() : array
    {
        return $this->libxmlErrors;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Manifest;

class ManifestDocumentMapperException extends \RuntimeException implements \PHPUnit\PharIo\Manifest\Exception
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Manifest;

class ManifestElementException extends \RuntimeException implements \PHPUnit\PharIo\Manifest\Exception
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Manifest;

class ManifestLoaderException extends \Exception implements \PHPUnit\PharIo\Manifest\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class Application extends \PHPUnit\PharIo\Manifest\Type
{
    public function isApplication() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ApplicationName
{
    /** @var string */
    private $name;
    public function __construct(string $name)
    {
        $this->ensureValidFormat($name);
        $this->name = $name;
    }
    public function asString() : string
    {
        return $this->name;
    }
    public function isEqual(\PHPUnit\PharIo\Manifest\ApplicationName $name) : bool
    {
        return $this->name === $name->name;
    }
    private function ensureValidFormat(string $name) : void
    {
        if (!\preg_match('#\\w/\\w#', $name)) {
            throw new \PHPUnit\PharIo\Manifest\InvalidApplicationNameException(\sprintf('Format of name "%s" is not valid - expected: vendor/packagename', $name), \PHPUnit\PharIo\Manifest\InvalidApplicationNameException::InvalidFormat);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class Author
{
    /** @var string */
    private $name;
    /** @var Email */
    private $email;
    public function __construct(string $name, \PHPUnit\PharIo\Manifest\Email $email)
    {
        $this->name = $name;
        $this->email = $email;
    }
    public function asString() : string
    {
        return \sprintf('%s <%s>', $this->name, $this->email->asString());
    }
    public function getName() : string
    {
        return $this->name;
    }
    public function getEmail() : \PHPUnit\PharIo\Manifest\Email
    {
        return $this->email;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class AuthorCollection implements \Countable, \IteratorAggregate
{
    /** @var Author[] */
    private $authors = [];
    public function add(\PHPUnit\PharIo\Manifest\Author $author) : void
    {
        $this->authors[] = $author;
    }
    /**
     * @return Author[]
     */
    public function getAuthors() : array
    {
        return $this->authors;
    }
    public function count() : int
    {
        return \count($this->authors);
    }
    public function getIterator() : \PHPUnit\PharIo\Manifest\AuthorCollectionIterator
    {
        return new \PHPUnit\PharIo\Manifest\AuthorCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class AuthorCollectionIterator implements \Iterator
{
    /** @var Author[] */
    private $authors;
    /** @var int */
    private $position = 0;
    public function __construct(\PHPUnit\PharIo\Manifest\AuthorCollection $authors)
    {
        $this->authors = $authors->getAuthors();
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->authors);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\PharIo\Manifest\Author
    {
        return $this->authors[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use PHPUnit\PharIo\Version\Version;
class BundledComponent
{
    /** @var string */
    private $name;
    /** @var Version */
    private $version;
    public function __construct(string $name, \PHPUnit\PharIo\Version\Version $version)
    {
        $this->name = $name;
        $this->version = $version;
    }
    public function getName() : string
    {
        return $this->name;
    }
    public function getVersion() : \PHPUnit\PharIo\Version\Version
    {
        return $this->version;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class BundledComponentCollection implements \Countable, \IteratorAggregate
{
    /** @var BundledComponent[] */
    private $bundledComponents = [];
    public function add(\PHPUnit\PharIo\Manifest\BundledComponent $bundledComponent) : void
    {
        $this->bundledComponents[] = $bundledComponent;
    }
    /**
     * @return BundledComponent[]
     */
    public function getBundledComponents() : array
    {
        return $this->bundledComponents;
    }
    public function count() : int
    {
        return \count($this->bundledComponents);
    }
    public function getIterator() : \PHPUnit\PharIo\Manifest\BundledComponentCollectionIterator
    {
        return new \PHPUnit\PharIo\Manifest\BundledComponentCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class BundledComponentCollectionIterator implements \Iterator
{
    /** @var BundledComponent[] */
    private $bundledComponents;
    /** @var int */
    private $position = 0;
    public function __construct(\PHPUnit\PharIo\Manifest\BundledComponentCollection $bundledComponents)
    {
        $this->bundledComponents = $bundledComponents->getBundledComponents();
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->bundledComponents);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\PharIo\Manifest\BundledComponent
    {
        return $this->bundledComponents[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class CopyrightInformation
{
    /** @var AuthorCollection */
    private $authors;
    /** @var License */
    private $license;
    public function __construct(\PHPUnit\PharIo\Manifest\AuthorCollection $authors, \PHPUnit\PharIo\Manifest\License $license)
    {
        $this->authors = $authors;
        $this->license = $license;
    }
    public function getAuthors() : \PHPUnit\PharIo\Manifest\AuthorCollection
    {
        return $this->authors;
    }
    public function getLicense() : \PHPUnit\PharIo\Manifest\License
    {
        return $this->license;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class Email
{
    /** @var string */
    private $email;
    public function __construct(string $email)
    {
        $this->ensureEmailIsValid($email);
        $this->email = $email;
    }
    public function asString() : string
    {
        return $this->email;
    }
    private function ensureEmailIsValid(string $url) : void
    {
        if (\filter_var($url, \FILTER_VALIDATE_EMAIL) === \false) {
            throw new \PHPUnit\PharIo\Manifest\InvalidEmailException();
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use PHPUnit\PharIo\Version\Version;
use PHPUnit\PharIo\Version\VersionConstraint;
class Extension extends \PHPUnit\PharIo\Manifest\Type
{
    /** @var ApplicationName */
    private $application;
    /** @var VersionConstraint */
    private $versionConstraint;
    public function __construct(\PHPUnit\PharIo\Manifest\ApplicationName $application, \PHPUnit\PharIo\Version\VersionConstraint $versionConstraint)
    {
        $this->application = $application;
        $this->versionConstraint = $versionConstraint;
    }
    public function getApplicationName() : \PHPUnit\PharIo\Manifest\ApplicationName
    {
        return $this->application;
    }
    public function getVersionConstraint() : \PHPUnit\PharIo\Version\VersionConstraint
    {
        return $this->versionConstraint;
    }
    public function isExtension() : bool
    {
        return \true;
    }
    public function isExtensionFor(\PHPUnit\PharIo\Manifest\ApplicationName $name) : bool
    {
        return $this->application->isEqual($name);
    }
    public function isCompatibleWith(\PHPUnit\PharIo\Manifest\ApplicationName $name, \PHPUnit\PharIo\Version\Version $version) : bool
    {
        return $this->isExtensionFor($name) && $this->versionConstraint->complies($version);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class Library extends \PHPUnit\PharIo\Manifest\Type
{
    public function isLibrary() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class License
{
    /** @var string */
    private $name;
    /** @var Url */
    private $url;
    public function __construct(string $name, \PHPUnit\PharIo\Manifest\Url $url)
    {
        $this->name = $name;
        $this->url = $url;
    }
    public function getName() : string
    {
        return $this->name;
    }
    public function getUrl() : \PHPUnit\PharIo\Manifest\Url
    {
        return $this->url;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use PHPUnit\PharIo\Version\Version;
class Manifest
{
    /** @var ApplicationName */
    private $name;
    /** @var Version */
    private $version;
    /** @var Type */
    private $type;
    /** @var CopyrightInformation */
    private $copyrightInformation;
    /** @var RequirementCollection */
    private $requirements;
    /** @var BundledComponentCollection */
    private $bundledComponents;
    public function __construct(\PHPUnit\PharIo\Manifest\ApplicationName $name, \PHPUnit\PharIo\Version\Version $version, \PHPUnit\PharIo\Manifest\Type $type, \PHPUnit\PharIo\Manifest\CopyrightInformation $copyrightInformation, \PHPUnit\PharIo\Manifest\RequirementCollection $requirements, \PHPUnit\PharIo\Manifest\BundledComponentCollection $bundledComponents)
    {
        $this->name = $name;
        $this->version = $version;
        $this->type = $type;
        $this->copyrightInformation = $copyrightInformation;
        $this->requirements = $requirements;
        $this->bundledComponents = $bundledComponents;
    }
    public function getName() : \PHPUnit\PharIo\Manifest\ApplicationName
    {
        return $this->name;
    }
    public function getVersion() : \PHPUnit\PharIo\Version\Version
    {
        return $this->version;
    }
    public function getType() : \PHPUnit\PharIo\Manifest\Type
    {
        return $this->type;
    }
    public function getCopyrightInformation() : \PHPUnit\PharIo\Manifest\CopyrightInformation
    {
        return $this->copyrightInformation;
    }
    public function getRequirements() : \PHPUnit\PharIo\Manifest\RequirementCollection
    {
        return $this->requirements;
    }
    public function getBundledComponents() : \PHPUnit\PharIo\Manifest\BundledComponentCollection
    {
        return $this->bundledComponents;
    }
    public function isApplication() : bool
    {
        return $this->type->isApplication();
    }
    public function isLibrary() : bool
    {
        return $this->type->isLibrary();
    }
    public function isExtension() : bool
    {
        return $this->type->isExtension();
    }
    public function isExtensionFor(\PHPUnit\PharIo\Manifest\ApplicationName $application, \PHPUnit\PharIo\Version\Version $version = null) : bool
    {
        if (!$this->isExtension()) {
            return \false;
        }
        /** @var Extension $type */
        $type = $this->type;
        if ($version !== null) {
            return $type->isCompatibleWith($application, $version);
        }
        return $type->isExtensionFor($application);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class PhpExtensionRequirement implements \PHPUnit\PharIo\Manifest\Requirement
{
    /** @var string */
    private $extension;
    public function __construct(string $extension)
    {
        $this->extension = $extension;
    }
    public function asString() : string
    {
        return $this->extension;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use PHPUnit\PharIo\Version\VersionConstraint;
class PhpVersionRequirement implements \PHPUnit\PharIo\Manifest\Requirement
{
    /** @var VersionConstraint */
    private $versionConstraint;
    public function __construct(\PHPUnit\PharIo\Version\VersionConstraint $versionConstraint)
    {
        $this->versionConstraint = $versionConstraint;
    }
    public function getVersionConstraint() : \PHPUnit\PharIo\Version\VersionConstraint
    {
        return $this->versionConstraint;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

interface Requirement
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class RequirementCollection implements \Countable, \IteratorAggregate
{
    /** @var Requirement[] */
    private $requirements = [];
    public function add(\PHPUnit\PharIo\Manifest\Requirement $requirement) : void
    {
        $this->requirements[] = $requirement;
    }
    /**
     * @return Requirement[]
     */
    public function getRequirements() : array
    {
        return $this->requirements;
    }
    public function count() : int
    {
        return \count($this->requirements);
    }
    public function getIterator() : \PHPUnit\PharIo\Manifest\RequirementCollectionIterator
    {
        return new \PHPUnit\PharIo\Manifest\RequirementCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class RequirementCollectionIterator implements \Iterator
{
    /** @var Requirement[] */
    private $requirements;
    /** @var int */
    private $position = 0;
    public function __construct(\PHPUnit\PharIo\Manifest\RequirementCollection $requirements)
    {
        $this->requirements = $requirements->getRequirements();
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->requirements);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\PharIo\Manifest\Requirement
    {
        return $this->requirements[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use PHPUnit\PharIo\Version\VersionConstraint;
abstract class Type
{
    public static function application() : \PHPUnit\PharIo\Manifest\Application
    {
        return new \PHPUnit\PharIo\Manifest\Application();
    }
    public static function library() : \PHPUnit\PharIo\Manifest\Library
    {
        return new \PHPUnit\PharIo\Manifest\Library();
    }
    public static function extension(\PHPUnit\PharIo\Manifest\ApplicationName $application, \PHPUnit\PharIo\Version\VersionConstraint $versionConstraint) : \PHPUnit\PharIo\Manifest\Extension
    {
        return new \PHPUnit\PharIo\Manifest\Extension($application, $versionConstraint);
    }
    /** @psalm-assert-if-true Application $this */
    public function isApplication() : bool
    {
        return \false;
    }
    /** @psalm-assert-if-true Library $this */
    public function isLibrary() : bool
    {
        return \false;
    }
    /** @psalm-assert-if-true Extension $this */
    public function isExtension() : bool
    {
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class Url
{
    /** @var string */
    private $url;
    public function __construct(string $url)
    {
        $this->ensureUrlIsValid($url);
        $this->url = $url;
    }
    public function asString() : string
    {
        return $this->url;
    }
    /**
     * @param string $url
     *
     * @throws InvalidUrlException
     */
    private function ensureUrlIsValid($url) : void
    {
        if (\filter_var($url, \FILTER_VALIDATE_URL) === \false) {
            throw new \PHPUnit\PharIo\Manifest\InvalidUrlException();
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class AuthorElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getName() : string
    {
        return $this->getAttributeValue('name');
    }
    public function getEmail() : string
    {
        return $this->getAttributeValue('email');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class AuthorElementCollection extends \PHPUnit\PharIo\Manifest\ElementCollection
{
    public function current() : \PHPUnit\PharIo\Manifest\AuthorElement
    {
        return new \PHPUnit\PharIo\Manifest\AuthorElement($this->getCurrentElement());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class BundlesElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getComponentElements() : \PHPUnit\PharIo\Manifest\ComponentElementCollection
    {
        return new \PHPUnit\PharIo\Manifest\ComponentElementCollection($this->getChildrenByName('component'));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ComponentElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getName() : string
    {
        return $this->getAttributeValue('name');
    }
    public function getVersion() : string
    {
        return $this->getAttributeValue('version');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ComponentElementCollection extends \PHPUnit\PharIo\Manifest\ElementCollection
{
    public function current() : \PHPUnit\PharIo\Manifest\ComponentElement
    {
        return new \PHPUnit\PharIo\Manifest\ComponentElement($this->getCurrentElement());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ContainsElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getName() : string
    {
        return $this->getAttributeValue('name');
    }
    public function getVersion() : string
    {
        return $this->getAttributeValue('version');
    }
    public function getType() : string
    {
        return $this->getAttributeValue('type');
    }
    public function getExtensionElement() : \PHPUnit\PharIo\Manifest\ExtensionElement
    {
        return new \PHPUnit\PharIo\Manifest\ExtensionElement($this->getChildByName('extension'));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class CopyrightElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getAuthorElements() : \PHPUnit\PharIo\Manifest\AuthorElementCollection
    {
        return new \PHPUnit\PharIo\Manifest\AuthorElementCollection($this->getChildrenByName('author'));
    }
    public function getLicenseElement() : \PHPUnit\PharIo\Manifest\LicenseElement
    {
        return new \PHPUnit\PharIo\Manifest\LicenseElement($this->getChildByName('license'));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use DOMElement;
use DOMNodeList;
abstract class ElementCollection implements \Iterator
{
    /** @var DOMElement[] */
    private $nodes = [];
    /** @var int */
    private $position;
    public function __construct(\DOMNodeList $nodeList)
    {
        $this->position = 0;
        $this->importNodes($nodeList);
    }
    public abstract function current();
    public function next() : void
    {
        $this->position++;
    }
    public function key()
    {
        return $this->position;
    }
    public function valid()
    {
        return $this->position < \count($this->nodes);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    protected function getCurrentElement() : \DOMElement
    {
        return $this->nodes[$this->position];
    }
    private function importNodes(\DOMNodeList $nodeList) : void
    {
        foreach ($nodeList as $node) {
            if (!$node instanceof \DOMElement) {
                throw new \PHPUnit\PharIo\Manifest\ElementCollectionException(\sprintf('\\DOMElement expected, got \\%s', \get_class($node)));
            }
            $this->nodes[] = $node;
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ExtElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getName() : string
    {
        return $this->getAttributeValue('name');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ExtElementCollection extends \PHPUnit\PharIo\Manifest\ElementCollection
{
    public function current() : \PHPUnit\PharIo\Manifest\ExtElement
    {
        return new \PHPUnit\PharIo\Manifest\ExtElement($this->getCurrentElement());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class ExtensionElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getFor() : string
    {
        return $this->getAttributeValue('for');
    }
    public function getCompatible() : string
    {
        return $this->getAttributeValue('compatible');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class LicenseElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getType() : string
    {
        return $this->getAttributeValue('type');
    }
    public function getUrl() : string
    {
        return $this->getAttributeValue('url');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use DOMDocument;
use DOMElement;
class ManifestDocument
{
    public const XMLNS = 'https://phar.io/xml/manifest/1.0';
    /** @var DOMDocument */
    private $dom;
    public static function fromFile(string $filename) : \PHPUnit\PharIo\Manifest\ManifestDocument
    {
        if (!\file_exists($filename)) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentException(\sprintf('File "%s" not found', $filename));
        }
        return self::fromString(\file_get_contents($filename));
    }
    public static function fromString(string $xmlString) : \PHPUnit\PharIo\Manifest\ManifestDocument
    {
        $prev = \libxml_use_internal_errors(\true);
        \libxml_clear_errors();
        $dom = new \DOMDocument();
        $dom->loadXML($xmlString);
        $errors = \libxml_get_errors();
        \libxml_use_internal_errors($prev);
        if (\count($errors) !== 0) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentLoadingException($errors);
        }
        return new self($dom);
    }
    private function __construct(\DOMDocument $dom)
    {
        $this->ensureCorrectDocumentType($dom);
        $this->dom = $dom;
    }
    public function getContainsElement() : \PHPUnit\PharIo\Manifest\ContainsElement
    {
        return new \PHPUnit\PharIo\Manifest\ContainsElement($this->fetchElementByName('contains'));
    }
    public function getCopyrightElement() : \PHPUnit\PharIo\Manifest\CopyrightElement
    {
        return new \PHPUnit\PharIo\Manifest\CopyrightElement($this->fetchElementByName('copyright'));
    }
    public function getRequiresElement() : \PHPUnit\PharIo\Manifest\RequiresElement
    {
        return new \PHPUnit\PharIo\Manifest\RequiresElement($this->fetchElementByName('requires'));
    }
    public function hasBundlesElement() : bool
    {
        return $this->dom->getElementsByTagNameNS(self::XMLNS, 'bundles')->length === 1;
    }
    public function getBundlesElement() : \PHPUnit\PharIo\Manifest\BundlesElement
    {
        return new \PHPUnit\PharIo\Manifest\BundlesElement($this->fetchElementByName('bundles'));
    }
    private function ensureCorrectDocumentType(\DOMDocument $dom) : void
    {
        $root = $dom->documentElement;
        if ($root->localName !== 'phar' || $root->namespaceURI !== self::XMLNS) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentException('Not a phar.io manifest document');
        }
    }
    private function fetchElementByName(string $elementName) : \DOMElement
    {
        $element = $this->dom->getElementsByTagNameNS(self::XMLNS, $elementName)->item(0);
        if (!$element instanceof \DOMElement) {
            throw new \PHPUnit\PharIo\Manifest\ManifestDocumentException(\sprintf('Element %s missing', $elementName));
        }
        return $element;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

use DOMElement;
use DOMNodeList;
class ManifestElement
{
    public const XMLNS = 'https://phar.io/xml/manifest/1.0';
    /** @var DOMElement */
    private $element;
    public function __construct(\DOMElement $element)
    {
        $this->element = $element;
    }
    protected function getAttributeValue(string $name) : string
    {
        if (!$this->element->hasAttribute($name)) {
            throw new \PHPUnit\PharIo\Manifest\ManifestElementException(\sprintf('Attribute %s not set on element %s', $name, $this->element->localName));
        }
        return $this->element->getAttribute($name);
    }
    protected function getChildByName(string $elementName) : \DOMElement
    {
        $element = $this->element->getElementsByTagNameNS(self::XMLNS, $elementName)->item(0);
        if (!$element instanceof \DOMElement) {
            throw new \PHPUnit\PharIo\Manifest\ManifestElementException(\sprintf('Element %s missing', $elementName));
        }
        return $element;
    }
    protected function getChildrenByName(string $elementName) : \DOMNodeList
    {
        $elementList = $this->element->getElementsByTagNameNS(self::XMLNS, $elementName);
        if ($elementList->length === 0) {
            throw new \PHPUnit\PharIo\Manifest\ManifestElementException(\sprintf('Element(s) %s missing', $elementName));
        }
        return $elementList;
    }
    protected function hasChild(string $elementName) : bool
    {
        return $this->element->getElementsByTagNameNS(self::XMLNS, $elementName)->length !== 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class PhpElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getVersion() : string
    {
        return $this->getAttributeValue('version');
    }
    public function hasExtElements() : bool
    {
        return $this->hasChild('ext');
    }
    public function getExtElements() : \PHPUnit\PharIo\Manifest\ExtElementCollection
    {
        return new \PHPUnit\PharIo\Manifest\ExtElementCollection($this->getChildrenByName('ext'));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Manifest.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Manifest;

class RequiresElement extends \PHPUnit\PharIo\Manifest\ManifestElement
{
    public function getPHPElement() : \PHPUnit\PharIo\Manifest\PhpElement
    {
        return new \PHPUnit\PharIo\Manifest\PhpElement($this->getChildByName('php'));
    }
}
phar-io/version

Copyright (c) 2016-2017 Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de> and contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of Arne Blankerts nor the names of contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  * NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Version;

class PreReleaseSuffix
{
    private const valueScoreMap = ['dev' => 0, 'a' => 1, 'alpha' => 1, 'b' => 2, 'beta' => 2, 'rc' => 3, 'p' => 4, 'patch' => 4];
    /** @var string */
    private $value;
    /** @var int */
    private $valueScore;
    /** @var int */
    private $number = 0;
    /** @var string */
    private $full;
    /**
     * @throws InvalidPreReleaseSuffixException
     */
    public function __construct(string $value)
    {
        $this->parseValue($value);
    }
    public function asString() : string
    {
        return $this->full;
    }
    public function getValue() : string
    {
        return $this->value;
    }
    public function getNumber() : ?int
    {
        return $this->number;
    }
    public function isGreaterThan(\PHPUnit\PharIo\Version\PreReleaseSuffix $suffix) : bool
    {
        if ($this->valueScore > $suffix->valueScore) {
            return \true;
        }
        if ($this->valueScore < $suffix->valueScore) {
            return \false;
        }
        return $this->getNumber() > $suffix->getNumber();
    }
    private function mapValueToScore(string $value) : int
    {
        $value = \strtolower($value);
        if (\array_key_exists($value, self::valueScoreMap)) {
            return self::valueScoreMap[$value];
        }
        return 0;
    }
    private function parseValue(string $value) : void
    {
        $regex = '/-?((dev|beta|b|rc|alpha|a|patch|p)\\.?(\\d*)).*$/i';
        if (\preg_match($regex, $value, $matches) !== 1) {
            throw new \PHPUnit\PharIo\Version\InvalidPreReleaseSuffixException(\sprintf('Invalid label %s', $value));
        }
        $this->full = $matches[1];
        $this->value = $matches[2];
        if ($matches[3] !== '') {
            $this->number = (int) $matches[3];
        }
        $this->valueScore = $this->mapValueToScore($matches[2]);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class Version
{
    /** @var string */
    private $originalVersionString;
    /** @var VersionNumber */
    private $major;
    /** @var VersionNumber */
    private $minor;
    /** @var VersionNumber */
    private $patch;
    /** @var null|PreReleaseSuffix */
    private $preReleaseSuffix;
    public function __construct(string $versionString)
    {
        $this->ensureVersionStringIsValid($versionString);
        $this->originalVersionString = $versionString;
    }
    public function getPreReleaseSuffix() : \PHPUnit\PharIo\Version\PreReleaseSuffix
    {
        if ($this->preReleaseSuffix === null) {
            throw new \PHPUnit\PharIo\Version\NoPreReleaseSuffixException('No pre-release suffix set');
        }
        return $this->preReleaseSuffix;
    }
    public function getOriginalString() : string
    {
        return $this->originalVersionString;
    }
    public function getVersionString() : string
    {
        $str = \sprintf('%d.%d.%d', $this->getMajor()->getValue() ?? 0, $this->getMinor()->getValue() ?? 0, $this->getPatch()->getValue() ?? 0);
        if (!$this->hasPreReleaseSuffix()) {
            return $str;
        }
        return $str . '-' . $this->getPreReleaseSuffix()->asString();
    }
    public function hasPreReleaseSuffix() : bool
    {
        return $this->preReleaseSuffix !== null;
    }
    public function equals(\PHPUnit\PharIo\Version\Version $other) : bool
    {
        return $this->getVersionString() === $other->getVersionString();
    }
    public function isGreaterThan(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        if ($version->getMajor()->getValue() > $this->getMajor()->getValue()) {
            return \false;
        }
        if ($version->getMajor()->getValue() < $this->getMajor()->getValue()) {
            return \true;
        }
        if ($version->getMinor()->getValue() > $this->getMinor()->getValue()) {
            return \false;
        }
        if ($version->getMinor()->getValue() < $this->getMinor()->getValue()) {
            return \true;
        }
        if ($version->getPatch()->getValue() > $this->getPatch()->getValue()) {
            return \false;
        }
        if ($version->getPatch()->getValue() < $this->getPatch()->getValue()) {
            return \true;
        }
        if (!$version->hasPreReleaseSuffix() && !$this->hasPreReleaseSuffix()) {
            return \false;
        }
        if ($version->hasPreReleaseSuffix() && !$this->hasPreReleaseSuffix()) {
            return \true;
        }
        if (!$version->hasPreReleaseSuffix() && $this->hasPreReleaseSuffix()) {
            return \false;
        }
        return $this->getPreReleaseSuffix()->isGreaterThan($version->getPreReleaseSuffix());
    }
    public function getMajor() : \PHPUnit\PharIo\Version\VersionNumber
    {
        return $this->major;
    }
    public function getMinor() : \PHPUnit\PharIo\Version\VersionNumber
    {
        return $this->minor;
    }
    public function getPatch() : \PHPUnit\PharIo\Version\VersionNumber
    {
        return $this->patch;
    }
    /**
     * @param string[] $matches
     *
     * @throws InvalidPreReleaseSuffixException
     */
    private function parseVersion(array $matches) : void
    {
        $this->major = new \PHPUnit\PharIo\Version\VersionNumber((int) $matches['Major']);
        $this->minor = new \PHPUnit\PharIo\Version\VersionNumber((int) $matches['Minor']);
        $this->patch = isset($matches['Patch']) ? new \PHPUnit\PharIo\Version\VersionNumber((int) $matches['Patch']) : new \PHPUnit\PharIo\Version\VersionNumber(0);
        if (isset($matches['PreReleaseSuffix'])) {
            $this->preReleaseSuffix = new \PHPUnit\PharIo\Version\PreReleaseSuffix($matches['PreReleaseSuffix']);
        }
    }
    /**
     * @param string $version
     *
     * @throws InvalidVersionException
     */
    private function ensureVersionStringIsValid($version) : void
    {
        $regex = '/^v?
            (?<Major>(0|(?:[1-9]\\d*)))
            \\.
            (?<Minor>(0|(?:[1-9]\\d*)))
            (\\.
                (?<Patch>(0|(?:[1-9]\\d*)))
            )?
            (?:
                -
                (?<PreReleaseSuffix>(?:(dev|beta|b|rc|alpha|a|patch|p)\\.?\\d*))
            )?       
        $/xi';
        if (\preg_match($regex, $version, $matches) !== 1) {
            throw new \PHPUnit\PharIo\Version\InvalidVersionException(\sprintf("Version string '%s' does not follow SemVer semantics", $version));
        }
        $this->parseVersion($matches);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class VersionConstraintParser
{
    /**
     * @throws UnsupportedVersionConstraintException
     */
    public function parse(string $value) : \PHPUnit\PharIo\Version\VersionConstraint
    {
        if (\strpos($value, '||') !== \false) {
            return $this->handleOrGroup($value);
        }
        if (!\preg_match('/^[\\^~*]?v?[\\d.*]+(?:-.*)?$/i', $value)) {
            throw new \PHPUnit\PharIo\Version\UnsupportedVersionConstraintException(\sprintf('Version constraint %s is not supported.', $value));
        }
        switch ($value[0]) {
            case '~':
                return $this->handleTildeOperator($value);
            case '^':
                return $this->handleCaretOperator($value);
        }
        $constraint = new \PHPUnit\PharIo\Version\VersionConstraintValue($value);
        if ($constraint->getMajor()->isAny()) {
            return new \PHPUnit\PharIo\Version\AnyVersionConstraint();
        }
        if ($constraint->getMinor()->isAny()) {
            return new \PHPUnit\PharIo\Version\SpecificMajorVersionConstraint($constraint->getVersionString(), $constraint->getMajor()->getValue() ?? 0);
        }
        if ($constraint->getPatch()->isAny()) {
            return new \PHPUnit\PharIo\Version\SpecificMajorAndMinorVersionConstraint($constraint->getVersionString(), $constraint->getMajor()->getValue() ?? 0, $constraint->getMinor()->getValue() ?? 0);
        }
        return new \PHPUnit\PharIo\Version\ExactVersionConstraint($constraint->getVersionString());
    }
    private function handleOrGroup(string $value) : \PHPUnit\PharIo\Version\OrVersionConstraintGroup
    {
        $constraints = [];
        foreach (\explode('||', $value) as $groupSegment) {
            $constraints[] = $this->parse(\trim($groupSegment));
        }
        return new \PHPUnit\PharIo\Version\OrVersionConstraintGroup($value, $constraints);
    }
    private function handleTildeOperator(string $value) : \PHPUnit\PharIo\Version\AndVersionConstraintGroup
    {
        $constraintValue = new \PHPUnit\PharIo\Version\VersionConstraintValue(\substr($value, 1));
        if ($constraintValue->getPatch()->isAny()) {
            return $this->handleCaretOperator($value);
        }
        $constraints = [new \PHPUnit\PharIo\Version\GreaterThanOrEqualToVersionConstraint($value, new \PHPUnit\PharIo\Version\Version(\substr($value, 1))), new \PHPUnit\PharIo\Version\SpecificMajorAndMinorVersionConstraint($value, $constraintValue->getMajor()->getValue() ?? 0, $constraintValue->getMinor()->getValue() ?? 0)];
        return new \PHPUnit\PharIo\Version\AndVersionConstraintGroup($value, $constraints);
    }
    private function handleCaretOperator(string $value) : \PHPUnit\PharIo\Version\AndVersionConstraintGroup
    {
        $constraintValue = new \PHPUnit\PharIo\Version\VersionConstraintValue(\substr($value, 1));
        $constraints = [new \PHPUnit\PharIo\Version\GreaterThanOrEqualToVersionConstraint($value, new \PHPUnit\PharIo\Version\Version(\substr($value, 1)))];
        if ($constraintValue->getMajor()->getValue() === 0) {
            $constraints[] = new \PHPUnit\PharIo\Version\SpecificMajorAndMinorVersionConstraint($value, $constraintValue->getMajor()->getValue() ?? 0, $constraintValue->getMinor()->getValue() ?? 0);
        } else {
            $constraints[] = new \PHPUnit\PharIo\Version\SpecificMajorVersionConstraint($value, $constraintValue->getMajor()->getValue() ?? 0);
        }
        return new \PHPUnit\PharIo\Version\AndVersionConstraintGroup($value, $constraints);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Version;

class VersionConstraintValue
{
    /** @var VersionNumber */
    private $major;
    /** @var VersionNumber */
    private $minor;
    /** @var VersionNumber */
    private $patch;
    /** @var string */
    private $label = '';
    /** @var string */
    private $buildMetaData = '';
    /** @var string */
    private $versionString = '';
    public function __construct(string $versionString)
    {
        $this->versionString = $versionString;
        $this->parseVersion($versionString);
    }
    public function getLabel() : string
    {
        return $this->label;
    }
    public function getBuildMetaData() : string
    {
        return $this->buildMetaData;
    }
    public function getVersionString() : string
    {
        return $this->versionString;
    }
    public function getMajor() : \PHPUnit\PharIo\Version\VersionNumber
    {
        return $this->major;
    }
    public function getMinor() : \PHPUnit\PharIo\Version\VersionNumber
    {
        return $this->minor;
    }
    public function getPatch() : \PHPUnit\PharIo\Version\VersionNumber
    {
        return $this->patch;
    }
    private function parseVersion(string $versionString) : void
    {
        $this->extractBuildMetaData($versionString);
        $this->extractLabel($versionString);
        $this->stripPotentialVPrefix($versionString);
        $versionSegments = \explode('.', $versionString);
        $this->major = new \PHPUnit\PharIo\Version\VersionNumber(\is_numeric($versionSegments[0]) ? (int) $versionSegments[0] : null);
        $minorValue = isset($versionSegments[1]) && \is_numeric($versionSegments[1]) ? (int) $versionSegments[1] : null;
        $patchValue = isset($versionSegments[2]) && \is_numeric($versionSegments[2]) ? (int) $versionSegments[2] : null;
        $this->minor = new \PHPUnit\PharIo\Version\VersionNumber($minorValue);
        $this->patch = new \PHPUnit\PharIo\Version\VersionNumber($patchValue);
    }
    private function extractBuildMetaData(string &$versionString) : void
    {
        if (\preg_match('/\\+(.*)/', $versionString, $matches) === 1) {
            $this->buildMetaData = $matches[1];
            $versionString = \str_replace($matches[0], '', $versionString);
        }
    }
    private function extractLabel(string &$versionString) : void
    {
        if (\preg_match('/-(.*)/', $versionString, $matches) === 1) {
            $this->label = $matches[1];
            $versionString = \str_replace($matches[0], '', $versionString);
        }
    }
    private function stripPotentialVPrefix(string &$versionString) : void
    {
        if ($versionString[0] !== 'v') {
            return;
        }
        $versionString = \substr($versionString, 1);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class VersionNumber
{
    /** @var ?int */
    private $value;
    public function __construct(?int $value)
    {
        $this->value = $value;
    }
    public function isAny() : bool
    {
        return $this->value === null;
    }
    public function getValue() : ?int
    {
        return $this->value;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

abstract class AbstractVersionConstraint implements \PHPUnit\PharIo\Version\VersionConstraint
{
    /** @var string */
    private $originalValue;
    public function __construct(string $originalValue)
    {
        $this->originalValue = $originalValue;
    }
    public function asString() : string
    {
        return $this->originalValue;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class AndVersionConstraintGroup extends \PHPUnit\PharIo\Version\AbstractVersionConstraint
{
    /** @var VersionConstraint[] */
    private $constraints = [];
    /**
     * @param VersionConstraint[] $constraints
     */
    public function __construct(string $originalValue, array $constraints)
    {
        parent::__construct($originalValue);
        $this->constraints = $constraints;
    }
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        foreach ($this->constraints as $constraint) {
            if (!$constraint->complies($version)) {
                return \false;
            }
        }
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class AnyVersionConstraint implements \PHPUnit\PharIo\Version\VersionConstraint
{
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return '*';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class ExactVersionConstraint extends \PHPUnit\PharIo\Version\AbstractVersionConstraint
{
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        return $this->asString() === $version->getVersionString();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class GreaterThanOrEqualToVersionConstraint extends \PHPUnit\PharIo\Version\AbstractVersionConstraint
{
    /** @var Version */
    private $minimalVersion;
    public function __construct(string $originalValue, \PHPUnit\PharIo\Version\Version $minimalVersion)
    {
        parent::__construct($originalValue);
        $this->minimalVersion = $minimalVersion;
    }
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        return $version->getVersionString() === $this->minimalVersion->getVersionString() || $version->isGreaterThan($this->minimalVersion);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class OrVersionConstraintGroup extends \PHPUnit\PharIo\Version\AbstractVersionConstraint
{
    /** @var VersionConstraint[] */
    private $constraints = [];
    /**
     * @param string              $originalValue
     * @param VersionConstraint[] $constraints
     */
    public function __construct($originalValue, array $constraints)
    {
        parent::__construct($originalValue);
        $this->constraints = $constraints;
    }
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        foreach ($this->constraints as $constraint) {
            if ($constraint->complies($version)) {
                return \true;
            }
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class SpecificMajorAndMinorVersionConstraint extends \PHPUnit\PharIo\Version\AbstractVersionConstraint
{
    /** @var int */
    private $major;
    /** @var int */
    private $minor;
    public function __construct(string $originalValue, int $major, int $minor)
    {
        parent::__construct($originalValue);
        $this->major = $major;
        $this->minor = $minor;
    }
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        if ($version->getMajor()->getValue() !== $this->major) {
            return \false;
        }
        return $version->getMinor()->getValue() === $this->minor;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

class SpecificMajorVersionConstraint extends \PHPUnit\PharIo\Version\AbstractVersionConstraint
{
    /** @var int */
    private $major;
    public function __construct(string $originalValue, int $major)
    {
        parent::__construct($originalValue);
        $this->major = $major;
    }
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool
    {
        return $version->getMajor()->getValue() === $this->major;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

interface VersionConstraint
{
    public function complies(\PHPUnit\PharIo\Version\Version $version) : bool;
    public function asString() : string;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Version;

class InvalidPreReleaseSuffixException extends \Exception implements \PHPUnit\PharIo\Version\Exception
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Version;

class InvalidVersionException extends \InvalidArgumentException implements \PHPUnit\PharIo\Version\Exception
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\PharIo\Version;

class NoPreReleaseSuffixException extends \Exception implements \PHPUnit\PharIo\Version\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PharIo\Version.
 *
 * (c) Arne Blankerts <arne@blankerts.de>, Sebastian Heuer <sebastian@phpeople.de>, Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\PharIo\Version;

final class UnsupportedVersionConstraintException extends \RuntimeException implements \PHPUnit\PharIo\Version\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function array_diff;
use function array_diff_key;
use function array_flip;
use function array_keys;
use function array_merge;
use function array_unique;
use function array_values;
use function count;
use function explode;
use function get_class;
use function is_array;
use function is_file;
use function sort;
use PHPUnit\Framework\TestCase;
use PHPUnit\Runner\PhptTestCase;
use ReflectionClass;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\Builder;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CachingCoveredFileAnalyser;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CachingUncoveredFileAnalyser;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingCoveredFileAnalyser;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingUncoveredFileAnalyser;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser;
use PHPUnit\SebastianBergmann\CodeUnitReverseLookup\Wizard;
/**
 * Provides collection functionality for PHP code coverage information.
 */
final class CodeCoverage
{
    private const UNCOVERED_FILES = 'UNCOVERED_FILES';
    private \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver $driver;
    private \PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter;
    /**
     * @var Wizard
     */
    private $wizard;
    private bool $checkForUnintentionallyCoveredCode = \false;
    private bool $includeUncoveredFiles = \true;
    private bool $ignoreDeprecatedCode = \false;
    /**
     * @var PhptTestCase|string|TestCase
     */
    private $currentId;
    private \PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData $data;
    private bool $useAnnotationsForIgnoringCode = \true;
    private array $tests = [];
    /**
     * @psalm-var list<class-string>
     */
    private array $parentClassesExcludedFromUnintentionallyCoveredCodeCheck = [];
    private ?\PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser $coveredFileAnalyser = null;
    private ?\PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser $uncoveredFileAnalyser = null;
    private ?string $cacheDirectory = null;
    public function __construct(\PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver $driver, \PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter)
    {
        $this->driver = $driver;
        $this->filter = $filter;
        $this->data = new \PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData();
        $this->wizard = new \PHPUnit\SebastianBergmann\CodeUnitReverseLookup\Wizard();
    }
    /**
     * Returns the code coverage information as a graph of node objects.
     */
    public function getReport() : \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory
    {
        return (new \PHPUnit\SebastianBergmann\CodeCoverage\Node\Builder($this->coveredFileAnalyser()))->build($this);
    }
    /**
     * Clears collected code coverage data.
     */
    public function clear() : void
    {
        $this->currentId = null;
        $this->data = new \PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData();
        $this->tests = [];
    }
    /**
     * Returns the filter object used.
     */
    public function filter() : \PHPUnit\SebastianBergmann\CodeCoverage\Filter
    {
        return $this->filter;
    }
    /**
     * Returns the collected code coverage data.
     */
    public function getData(bool $raw = \false) : \PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData
    {
        if (!$raw && $this->includeUncoveredFiles) {
            $this->addUncoveredFilesFromFilter();
        }
        return $this->data;
    }
    /**
     * Sets the coverage data.
     */
    public function setData(\PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData $data) : void
    {
        $this->data = $data;
    }
    /**
     * Returns the test data.
     */
    public function getTests() : array
    {
        return $this->tests;
    }
    /**
     * Sets the test data.
     */
    public function setTests(array $tests) : void
    {
        $this->tests = $tests;
    }
    /**
     * Start collection of code coverage information.
     *
     * @param PhptTestCase|string|TestCase $id
     */
    public function start($id, bool $clear = \false) : void
    {
        if ($clear) {
            $this->clear();
        }
        $this->currentId = $id;
        $this->driver->start();
    }
    /**
     * Stop collection of code coverage information.
     *
     * @param array|false $linesToBeCovered
     */
    public function stop(bool $append = \true, $linesToBeCovered = [], array $linesToBeUsed = []) : \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData
    {
        if (!\is_array($linesToBeCovered) && $linesToBeCovered !== \false) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\InvalidArgumentException('$linesToBeCovered must be an array or false');
        }
        $data = $this->driver->stop();
        $this->append($data, null, $append, $linesToBeCovered, $linesToBeUsed);
        $this->currentId = null;
        return $data;
    }
    /**
     * Appends code coverage data.
     *
     * @param PhptTestCase|string|TestCase $id
     * @param array|false                  $linesToBeCovered
     *
     * @throws ReflectionException
     * @throws TestIdMissingException
     * @throws UnintentionallyCoveredCodeException
     */
    public function append(\PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData $rawData, $id = null, bool $append = \true, $linesToBeCovered = [], array $linesToBeUsed = []) : void
    {
        if ($id === null) {
            $id = $this->currentId;
        }
        if ($id === null) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\TestIdMissingException();
        }
        $this->applyFilter($rawData);
        if ($this->useAnnotationsForIgnoringCode) {
            $this->applyIgnoredLinesFilter($rawData);
        }
        $this->data->initializeUnseenData($rawData);
        if (!$append) {
            return;
        }
        if ($id !== self::UNCOVERED_FILES) {
            $this->applyCoversAnnotationFilter($rawData, $linesToBeCovered, $linesToBeUsed);
            if (empty($rawData->lineCoverage())) {
                return;
            }
            $size = 'unknown';
            $status = 'unknown';
            $fromTestcase = \false;
            if ($id instanceof \PHPUnit\Framework\TestCase) {
                $fromTestcase = \true;
                $size = $id->size()->asString();
                $status = $id->status()->asString();
                $id = \get_class($id) . '::' . $id->getName();
            } elseif ($id instanceof \PHPUnit\Runner\PhptTestCase) {
                $fromTestcase = \true;
                $size = 'large';
                $id = $id->getName();
            }
            $this->tests[$id] = ['size' => $size, 'status' => $status, 'fromTestcase' => $fromTestcase];
            $this->data->markCodeAsExecutedByTestCase($id, $rawData);
        }
    }
    /**
     * Merges the data from another instance.
     */
    public function merge(self $that) : void
    {
        $this->filter->includeFiles($that->filter()->files());
        $this->data->merge($that->data);
        $this->tests = \array_merge($this->tests, $that->getTests());
    }
    public function enableCheckForUnintentionallyCoveredCode() : void
    {
        $this->checkForUnintentionallyCoveredCode = \true;
    }
    public function disableCheckForUnintentionallyCoveredCode() : void
    {
        $this->checkForUnintentionallyCoveredCode = \false;
    }
    public function includeUncoveredFiles() : void
    {
        $this->includeUncoveredFiles = \true;
    }
    public function excludeUncoveredFiles() : void
    {
        $this->includeUncoveredFiles = \false;
    }
    public function enableAnnotationsForIgnoringCode() : void
    {
        $this->useAnnotationsForIgnoringCode = \true;
    }
    public function disableAnnotationsForIgnoringCode() : void
    {
        $this->useAnnotationsForIgnoringCode = \false;
    }
    public function ignoreDeprecatedCode() : void
    {
        $this->ignoreDeprecatedCode = \true;
    }
    public function doNotIgnoreDeprecatedCode() : void
    {
        $this->ignoreDeprecatedCode = \false;
    }
    /**
     * @psalm-assert-if-true !null $this->cacheDirectory
     */
    public function cachesStaticAnalysis() : bool
    {
        return $this->cacheDirectory !== null;
    }
    public function cacheStaticAnalysis(string $directory) : void
    {
        $this->cacheDirectory = $directory;
    }
    public function doNotCacheStaticAnalysis() : void
    {
        $this->cacheDirectory = null;
    }
    /**
     * @throws StaticAnalysisCacheNotConfiguredException
     */
    public function cacheDirectory() : string
    {
        if (!$this->cachesStaticAnalysis()) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysisCacheNotConfiguredException('The static analysis cache is not configured');
        }
        return $this->cacheDirectory;
    }
    /**
     * @psalm-param class-string $className
     */
    public function excludeSubclassesOfThisClassFromUnintentionallyCoveredCodeCheck(string $className) : void
    {
        $this->parentClassesExcludedFromUnintentionallyCoveredCodeCheck[] = $className;
    }
    public function enableBranchAndPathCoverage() : void
    {
        $this->driver->enableBranchAndPathCoverage();
    }
    public function disableBranchAndPathCoverage() : void
    {
        $this->driver->disableBranchAndPathCoverage();
    }
    public function collectsBranchAndPathCoverage() : bool
    {
        return $this->driver->collectsBranchAndPathCoverage();
    }
    public function detectsDeadCode() : bool
    {
        return $this->driver->detectsDeadCode();
    }
    /**
     * Applies the @covers annotation filtering.
     *
     * @param array|false $linesToBeCovered
     *
     * @throws ReflectionException
     * @throws UnintentionallyCoveredCodeException
     */
    private function applyCoversAnnotationFilter(\PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData $rawData, $linesToBeCovered, array $linesToBeUsed) : void
    {
        if ($linesToBeCovered === \false) {
            $rawData->clear();
            return;
        }
        if (empty($linesToBeCovered)) {
            return;
        }
        if ($this->checkForUnintentionallyCoveredCode && (!$this->currentId instanceof \PHPUnit\Framework\TestCase || !$this->currentId->size()->isMedium() && !$this->currentId->size()->isLarge())) {
            $this->performUnintentionallyCoveredCodeCheck($rawData, $linesToBeCovered, $linesToBeUsed);
        }
        $rawLineData = $rawData->lineCoverage();
        $filesWithNoCoverage = \array_diff_key($rawLineData, $linesToBeCovered);
        foreach (\array_keys($filesWithNoCoverage) as $fileWithNoCoverage) {
            $rawData->removeCoverageDataForFile($fileWithNoCoverage);
        }
        if (\is_array($linesToBeCovered)) {
            foreach ($linesToBeCovered as $fileToBeCovered => $includedLines) {
                $rawData->keepCoverageDataOnlyForLines($fileToBeCovered, $includedLines);
            }
        }
    }
    private function applyFilter(\PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData $data) : void
    {
        if ($this->filter->isEmpty()) {
            return;
        }
        foreach (\array_keys($data->lineCoverage()) as $filename) {
            if ($this->filter->isExcluded($filename)) {
                $data->removeCoverageDataForFile($filename);
            }
        }
    }
    private function applyIgnoredLinesFilter(\PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData $data) : void
    {
        foreach (\array_keys($data->lineCoverage()) as $filename) {
            if (!$this->filter->isFile($filename)) {
                continue;
            }
            $data->removeCoverageDataForLines($filename, $this->coveredFileAnalyser()->ignoredLinesFor($filename));
        }
    }
    /**
     * @throws UnintentionallyCoveredCodeException
     */
    private function addUncoveredFilesFromFilter() : void
    {
        $uncoveredFiles = \array_diff($this->filter->files(), $this->data->coveredFiles());
        foreach ($uncoveredFiles as $uncoveredFile) {
            if (\is_file($uncoveredFile)) {
                $this->append(\PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromUncoveredFile($uncoveredFile, $this->uncoveredFileAnalyser()), self::UNCOVERED_FILES);
            }
        }
    }
    /**
     * @throws ReflectionException
     * @throws UnintentionallyCoveredCodeException
     */
    private function performUnintentionallyCoveredCodeCheck(\PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData $data, array $linesToBeCovered, array $linesToBeUsed) : void
    {
        $allowedLines = $this->getAllowedLines($linesToBeCovered, $linesToBeUsed);
        $unintentionallyCoveredUnits = [];
        foreach ($data->lineCoverage() as $file => $_data) {
            foreach ($_data as $line => $flag) {
                if ($flag === 1 && !isset($allowedLines[$file][$line])) {
                    $unintentionallyCoveredUnits[] = $this->wizard->lookup($file, $line);
                }
            }
        }
        $unintentionallyCoveredUnits = $this->processUnintentionallyCoveredUnits($unintentionallyCoveredUnits);
        if (!empty($unintentionallyCoveredUnits)) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException($unintentionallyCoveredUnits);
        }
    }
    private function getAllowedLines(array $linesToBeCovered, array $linesToBeUsed) : array
    {
        $allowedLines = [];
        foreach (\array_keys($linesToBeCovered) as $file) {
            if (!isset($allowedLines[$file])) {
                $allowedLines[$file] = [];
            }
            $allowedLines[$file] = \array_merge($allowedLines[$file], $linesToBeCovered[$file]);
        }
        foreach (\array_keys($linesToBeUsed) as $file) {
            if (!isset($allowedLines[$file])) {
                $allowedLines[$file] = [];
            }
            $allowedLines[$file] = \array_merge($allowedLines[$file], $linesToBeUsed[$file]);
        }
        foreach (\array_keys($allowedLines) as $file) {
            $allowedLines[$file] = \array_flip(\array_unique($allowedLines[$file]));
        }
        return $allowedLines;
    }
    /**
     * @param list<string> $unintentionallyCoveredUnits
     *
     * @throws ReflectionException
     *
     * @return list<string>
     */
    private function processUnintentionallyCoveredUnits(array $unintentionallyCoveredUnits) : array
    {
        $unintentionallyCoveredUnits = \array_unique($unintentionallyCoveredUnits);
        \sort($unintentionallyCoveredUnits);
        foreach (\array_keys($unintentionallyCoveredUnits) as $k => $v) {
            $unit = \explode('::', $unintentionallyCoveredUnits[$k]);
            if (\count($unit) !== 2) {
                continue;
            }
            try {
                $class = new \ReflectionClass($unit[0]);
                foreach ($this->parentClassesExcludedFromUnintentionallyCoveredCodeCheck as $parentClass) {
                    if ($class->isSubclassOf($parentClass)) {
                        unset($unintentionallyCoveredUnits[$k]);
                        break;
                    }
                }
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
            }
        }
        return \array_values($unintentionallyCoveredUnits);
    }
    private function coveredFileAnalyser() : \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser
    {
        if ($this->coveredFileAnalyser !== null) {
            return $this->coveredFileAnalyser;
        }
        $this->coveredFileAnalyser = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingCoveredFileAnalyser($this->useAnnotationsForIgnoringCode, $this->ignoreDeprecatedCode);
        if ($this->cachesStaticAnalysis()) {
            $this->coveredFileAnalyser = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CachingCoveredFileAnalyser($this->cacheDirectory, $this->coveredFileAnalyser);
        }
        return $this->coveredFileAnalyser;
    }
    private function uncoveredFileAnalyser() : \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser
    {
        if ($this->uncoveredFileAnalyser !== null) {
            return $this->uncoveredFileAnalyser;
        }
        $this->uncoveredFileAnalyser = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingUncoveredFileAnalyser();
        if ($this->cachesStaticAnalysis()) {
            $this->uncoveredFileAnalyser = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CachingUncoveredFileAnalyser($this->cacheDirectory, $this->uncoveredFileAnalyser);
        }
        return $this->uncoveredFileAnalyser;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class CrapIndex
{
    private int $cyclomaticComplexity;
    private float $codeCoverage;
    public static function fromCyclomaticComplexityAndCoveragePercentage(int $cyclomaticComplexity, float $codeCoverage) : self
    {
        return new self($cyclomaticComplexity, $codeCoverage);
    }
    public function __construct(int $cyclomaticComplexity, float $codeCoverage)
    {
        $this->cyclomaticComplexity = $cyclomaticComplexity;
        $this->codeCoverage = $codeCoverage;
    }
    public function asString() : string
    {
        if ($this->codeCoverage === 0.0) {
            return (string) ($this->cyclomaticComplexity ** 2 + $this->cyclomaticComplexity);
        }
        if ($this->codeCoverage >= 95) {
            return (string) $this->cyclomaticComplexity;
        }
        return \sprintf('%01.2F', $this->cyclomaticComplexity ** 2 * (1 - $this->codeCoverage / 100) ** 3 + $this->cyclomaticComplexity);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function is_dir;
use function mkdir;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Directory
{
    /**
     * @throws DirectoryCouldNotBeCreatedException
     */
    public static function create(string $directory) : void
    {
        $success = !(!\is_dir($directory) && !@\mkdir($directory, 0777, \true) && !\is_dir($directory));
        if (!$success) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\DirectoryCouldNotBeCreatedException(\sprintf('Directory "%s" could not be created', $directory));
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use function sprintf;
use PHPUnit\SebastianBergmann\CodeCoverage\BranchAndPathCoverageNotSupportedException;
use PHPUnit\SebastianBergmann\CodeCoverage\DeadCodeDetectionNotSupportedException;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
use PHPUnit\SebastianBergmann\CodeCoverage\NoCodeCoverageDriverAvailableException;
use PHPUnit\SebastianBergmann\CodeCoverage\NoCodeCoverageDriverWithPathCoverageSupportAvailableException;
use PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
abstract class Driver
{
    /**
     * @var int
     *
     * @see http://xdebug.org/docs/code_coverage
     */
    public const LINE_NOT_EXECUTABLE = -2;
    /**
     * @var int
     *
     * @see http://xdebug.org/docs/code_coverage
     */
    public const LINE_NOT_EXECUTED = -1;
    /**
     * @var int
     *
     * @see http://xdebug.org/docs/code_coverage
     */
    public const LINE_EXECUTED = 1;
    /**
     * @var int
     *
     * @see http://xdebug.org/docs/code_coverage
     */
    public const BRANCH_NOT_HIT = 0;
    /**
     * @var int
     *
     * @see http://xdebug.org/docs/code_coverage
     */
    public const BRANCH_HIT = 1;
    private bool $collectBranchAndPathCoverage = \false;
    private bool $detectDeadCode = \false;
    /**
     * @throws NoCodeCoverageDriverAvailableException
     * @throws PcovNotAvailableException
     * @throws PhpdbgNotAvailableException
     * @throws Xdebug2NotEnabledException
     * @throws Xdebug3NotEnabledException
     * @throws XdebugNotAvailableException
     *
     * @deprecated Use DriverSelector::forLineCoverage() instead
     */
    public static function forLineCoverage(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter) : self
    {
        return (new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Selector())->forLineCoverage($filter);
    }
    /**
     * @throws NoCodeCoverageDriverWithPathCoverageSupportAvailableException
     * @throws Xdebug2NotEnabledException
     * @throws Xdebug3NotEnabledException
     * @throws XdebugNotAvailableException
     *
     * @deprecated Use DriverSelector::forLineAndPathCoverage() instead
     */
    public static function forLineAndPathCoverage(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter) : self
    {
        return (new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Selector())->forLineAndPathCoverage($filter);
    }
    public function canCollectBranchAndPathCoverage() : bool
    {
        return \false;
    }
    public function collectsBranchAndPathCoverage() : bool
    {
        return $this->collectBranchAndPathCoverage;
    }
    /**
     * @throws BranchAndPathCoverageNotSupportedException
     */
    public function enableBranchAndPathCoverage() : void
    {
        if (!$this->canCollectBranchAndPathCoverage()) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\BranchAndPathCoverageNotSupportedException(\sprintf('%s does not support branch and path coverage', $this->nameAndVersion()));
        }
        $this->collectBranchAndPathCoverage = \true;
    }
    public function disableBranchAndPathCoverage() : void
    {
        $this->collectBranchAndPathCoverage = \false;
    }
    public function canDetectDeadCode() : bool
    {
        return \false;
    }
    public function detectsDeadCode() : bool
    {
        return $this->detectDeadCode;
    }
    /**
     * @throws DeadCodeDetectionNotSupportedException
     */
    public function enableDeadCodeDetection() : void
    {
        if (!$this->canDetectDeadCode()) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\DeadCodeDetectionNotSupportedException(\sprintf('%s does not support dead code detection', $this->nameAndVersion()));
        }
        $this->detectDeadCode = \true;
    }
    public function disableDeadCodeDetection() : void
    {
        $this->detectDeadCode = \false;
    }
    public abstract function nameAndVersion() : string;
    public abstract function start() : void;
    public abstract function stop() : \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData;
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use function extension_loaded;
use function phpversion;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
use PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class PcovDriver extends \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver
{
    private \PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter;
    /**
     * @throws PcovNotAvailableException
     */
    public function __construct(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter)
    {
        $this->ensurePcovIsAvailable();
        $this->filter = $filter;
    }
    public function start() : void
    {
        \pcov\start();
    }
    public function stop() : \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData
    {
        \pcov\stop();
        $collect = \pcov\collect(\pcov\inclusive, !$this->filter->isEmpty() ? $this->filter->files() : \pcov\waiting());
        \pcov\clear();
        return \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithoutPathCoverage($collect);
    }
    public function nameAndVersion() : string
    {
        return 'PCOV ' . \phpversion('pcov');
    }
    /**
     * @throws PcovNotAvailableException
     */
    private function ensurePcovIsAvailable() : void
    {
        if (!\extension_loaded('pcov')) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\PcovNotAvailableException();
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use const PHP_SAPI;
use const PHP_VERSION;
use function array_diff;
use function array_keys;
use function array_merge;
use function get_included_files;
use function phpdbg_end_oplog;
use function phpdbg_get_executable;
use function phpdbg_start_oplog;
use PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class PhpdbgDriver extends \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver
{
    /**
     * @throws PhpdbgNotAvailableException
     */
    public function __construct()
    {
        $this->ensurePhpdbgIsAvailable();
    }
    public function start() : void
    {
        \phpdbg_start_oplog();
    }
    public function stop() : \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData
    {
        static $fetchedLines = [];
        $dbgData = \phpdbg_end_oplog();
        if ($fetchedLines === []) {
            $sourceLines = \phpdbg_get_executable();
        } else {
            $newFiles = \array_diff(\get_included_files(), \array_keys($fetchedLines));
            $sourceLines = [];
            if ($newFiles) {
                $sourceLines = \phpdbg_get_executable(['files' => $newFiles]);
            }
        }
        foreach ($sourceLines as $file => $lines) {
            foreach ($lines as $lineNo => $numExecuted) {
                $sourceLines[$file][$lineNo] = self::LINE_NOT_EXECUTED;
            }
        }
        $fetchedLines = \array_merge($fetchedLines, $sourceLines);
        return \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithoutPathCoverage($this->detectExecutedLines($fetchedLines, $dbgData));
    }
    public function nameAndVersion() : string
    {
        return 'PHPDBG ' . \PHP_VERSION;
    }
    private function detectExecutedLines(array $sourceLines, array $dbgData) : array
    {
        foreach ($dbgData as $file => $coveredLines) {
            foreach ($coveredLines as $lineNo => $numExecuted) {
                // phpdbg also reports $lineNo=0 when e.g. exceptions get thrown.
                // make sure we only mark lines executed which are actually executable.
                if (isset($sourceLines[$file][$lineNo])) {
                    $sourceLines[$file][$lineNo] = self::LINE_EXECUTED;
                }
            }
        }
        return $sourceLines;
    }
    /**
     * @throws PhpdbgNotAvailableException
     */
    private function ensurePhpdbgIsAvailable() : void
    {
        if (\PHP_SAPI !== 'phpdbg') {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\PhpdbgNotAvailableException();
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use function phpversion;
use function version_compare;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
use PHPUnit\SebastianBergmann\CodeCoverage\NoCodeCoverageDriverAvailableException;
use PHPUnit\SebastianBergmann\CodeCoverage\NoCodeCoverageDriverWithPathCoverageSupportAvailableException;
use PHPUnit\SebastianBergmann\Environment\Runtime;
final class Selector
{
    /**
     * @throws NoCodeCoverageDriverAvailableException
     * @throws PcovNotAvailableException
     * @throws PhpdbgNotAvailableException
     * @throws Xdebug2NotEnabledException
     * @throws Xdebug3NotEnabledException
     * @throws XdebugNotAvailableException
     */
    public function forLineCoverage(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter) : \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver
    {
        $runtime = new \PHPUnit\SebastianBergmann\Environment\Runtime();
        if ($runtime->hasPHPDBGCodeCoverage()) {
            return new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\PhpdbgDriver();
        }
        if ($runtime->hasPCOV()) {
            return new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\PcovDriver($filter);
        }
        if ($runtime->hasXdebug()) {
            if (\version_compare(\phpversion('xdebug'), '3', '>=')) {
                $driver = new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Xdebug3Driver($filter);
            } else {
                $driver = new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Xdebug2Driver($filter);
            }
            $driver->enableDeadCodeDetection();
            return $driver;
        }
        throw new \PHPUnit\SebastianBergmann\CodeCoverage\NoCodeCoverageDriverAvailableException();
    }
    /**
     * @throws NoCodeCoverageDriverWithPathCoverageSupportAvailableException
     * @throws Xdebug2NotEnabledException
     * @throws Xdebug3NotEnabledException
     * @throws XdebugNotAvailableException
     */
    public function forLineAndPathCoverage(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter) : \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver
    {
        if ((new \PHPUnit\SebastianBergmann\Environment\Runtime())->hasXdebug()) {
            if (\version_compare(\phpversion('xdebug'), '3', '>=')) {
                $driver = new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Xdebug3Driver($filter);
            } else {
                $driver = new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Xdebug2Driver($filter);
            }
            $driver->enableDeadCodeDetection();
            $driver->enableBranchAndPathCoverage();
            return $driver;
        }
        throw new \PHPUnit\SebastianBergmann\CodeCoverage\NoCodeCoverageDriverWithPathCoverageSupportAvailableException();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use const XDEBUG_CC_BRANCH_CHECK;
use const XDEBUG_CC_DEAD_CODE;
use const XDEBUG_CC_UNUSED;
use const XDEBUG_FILTER_CODE_COVERAGE;
use const XDEBUG_PATH_INCLUDE;
use const XDEBUG_PATH_WHITELIST;
use function defined;
use function extension_loaded;
use function ini_get;
use function phpversion;
use function sprintf;
use function version_compare;
use function xdebug_get_code_coverage;
use function xdebug_set_filter;
use function xdebug_start_code_coverage;
use function xdebug_stop_code_coverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
use PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Xdebug2Driver extends \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver
{
    private bool $pathCoverageIsMixedCoverage;
    /**
     * @throws WrongXdebugVersionException
     * @throws Xdebug2NotEnabledException
     * @throws XdebugNotAvailableException
     */
    public function __construct(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter)
    {
        $this->ensureXdebugIsAvailable();
        $this->ensureXdebugIsCorrectVersion();
        $this->ensureXdebugCodeCoverageFeatureIsEnabled();
        if (!$filter->isEmpty()) {
            if (\defined('XDEBUG_PATH_WHITELIST')) {
                $listType = \XDEBUG_PATH_WHITELIST;
            } else {
                $listType = \XDEBUG_PATH_INCLUDE;
            }
            \xdebug_set_filter(\XDEBUG_FILTER_CODE_COVERAGE, $listType, $filter->files());
        }
        $this->pathCoverageIsMixedCoverage = \version_compare(\phpversion('xdebug'), '2.9.6', '<');
    }
    public function canCollectBranchAndPathCoverage() : bool
    {
        return \true;
    }
    public function canDetectDeadCode() : bool
    {
        return \true;
    }
    public function start() : void
    {
        $flags = \XDEBUG_CC_UNUSED;
        if ($this->detectsDeadCode() || $this->collectsBranchAndPathCoverage()) {
            $flags |= \XDEBUG_CC_DEAD_CODE;
        }
        if ($this->collectsBranchAndPathCoverage()) {
            $flags |= \XDEBUG_CC_BRANCH_CHECK;
        }
        \xdebug_start_code_coverage($flags);
    }
    public function stop() : \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData
    {
        $data = \xdebug_get_code_coverage();
        \xdebug_stop_code_coverage();
        if ($this->collectsBranchAndPathCoverage()) {
            if ($this->pathCoverageIsMixedCoverage) {
                return \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithMixedCoverage($data);
            }
            return \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithPathCoverage($data);
        }
        return \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithoutPathCoverage($data);
    }
    public function nameAndVersion() : string
    {
        return 'Xdebug ' . \phpversion('xdebug');
    }
    /**
     * @throws XdebugNotAvailableException
     */
    private function ensureXdebugIsAvailable() : void
    {
        if (!\extension_loaded('xdebug')) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\XdebugNotAvailableException();
        }
    }
    /**
     * @throws WrongXdebugVersionException
     */
    private function ensureXdebugIsCorrectVersion() : void
    {
        if (\version_compare(\phpversion('xdebug'), '3', '>=')) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\WrongXdebugVersionException(\sprintf('This driver requires Xdebug 2 but version %s is loaded', \phpversion('xdebug')));
        }
    }
    /**
     * @throws Xdebug2NotEnabledException
     */
    private function ensureXdebugCodeCoverageFeatureIsEnabled() : void
    {
        if (!\ini_get('xdebug.coverage_enable')) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Xdebug2NotEnabledException();
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use const XDEBUG_CC_BRANCH_CHECK;
use const XDEBUG_CC_DEAD_CODE;
use const XDEBUG_CC_UNUSED;
use const XDEBUG_FILTER_CODE_COVERAGE;
use const XDEBUG_PATH_INCLUDE;
use function explode;
use function extension_loaded;
use function getenv;
use function in_array;
use function ini_get;
use function phpversion;
use function sprintf;
use function version_compare;
use function xdebug_get_code_coverage;
use function xdebug_info;
use function xdebug_set_filter;
use function xdebug_start_code_coverage;
use function xdebug_stop_code_coverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
use PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Xdebug3Driver extends \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver
{
    /**
     * @throws WrongXdebugVersionException
     * @throws Xdebug3NotEnabledException
     * @throws XdebugNotAvailableException
     */
    public function __construct(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter)
    {
        $this->ensureXdebugIsAvailable();
        $this->ensureXdebugIsCorrectVersion();
        $this->ensureXdebugCodeCoverageFeatureIsEnabled();
        if (!$filter->isEmpty()) {
            \xdebug_set_filter(\XDEBUG_FILTER_CODE_COVERAGE, \XDEBUG_PATH_INCLUDE, $filter->files());
        }
    }
    public function canCollectBranchAndPathCoverage() : bool
    {
        return \true;
    }
    public function canDetectDeadCode() : bool
    {
        return \true;
    }
    public function start() : void
    {
        $flags = \XDEBUG_CC_UNUSED;
        if ($this->detectsDeadCode() || $this->collectsBranchAndPathCoverage()) {
            $flags |= \XDEBUG_CC_DEAD_CODE;
        }
        if ($this->collectsBranchAndPathCoverage()) {
            $flags |= \XDEBUG_CC_BRANCH_CHECK;
        }
        \xdebug_start_code_coverage($flags);
    }
    public function stop() : \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData
    {
        $data = \xdebug_get_code_coverage();
        \xdebug_stop_code_coverage();
        if ($this->collectsBranchAndPathCoverage()) {
            return \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithPathCoverage($data);
        }
        return \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithoutPathCoverage($data);
    }
    public function nameAndVersion() : string
    {
        return 'Xdebug ' . \phpversion('xdebug');
    }
    /**
     * @throws XdebugNotAvailableException
     */
    private function ensureXdebugIsAvailable() : void
    {
        if (!\extension_loaded('xdebug')) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\XdebugNotAvailableException();
        }
    }
    /**
     * @throws WrongXdebugVersionException
     */
    private function ensureXdebugIsCorrectVersion() : void
    {
        if (\version_compare(\phpversion('xdebug'), '3', '<')) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\WrongXdebugVersionException(\sprintf('This driver requires Xdebug 3 but version %s is loaded', \phpversion('xdebug')));
        }
    }
    /**
     * @throws Xdebug3NotEnabledException
     */
    private function ensureXdebugCodeCoverageFeatureIsEnabled() : void
    {
        if (\version_compare(\phpversion('xdebug'), '3.1', '>=')) {
            if (!\in_array('coverage', \xdebug_info('mode'), \true)) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Xdebug3NotEnabledException();
            }
            return;
        }
        $mode = \getenv('XDEBUG_MODE');
        if ($mode === \false) {
            $mode = \ini_get('xdebug.mode');
        }
        if ($mode === \false || !\in_array('coverage', \explode(',', $mode), \true)) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Xdebug3NotEnabledException();
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class BranchAndPathCoverageNotSupportedException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class DeadCodeDetectionNotSupportedException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class DirectoryCouldNotBeCreatedException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

final class InvalidArgumentException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class NoCodeCoverageDriverAvailableException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('No code coverage driver available');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class NoCodeCoverageDriverWithPathCoverageSupportAvailableException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('No code coverage driver with path coverage support available');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class ParserException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use function sprintf;
use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class PathExistsButIsNotDirectoryException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct(string $path)
    {
        parent::__construct(\sprintf('"%s" exists but is not a directory', $path));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class PcovNotAvailableException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('The PCOV extension is not available');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class PhpdbgNotAvailableException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('The PHPDBG SAPI is not available');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class ReflectionException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class ReportAlreadyFinalizedException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('The code coverage report has already been finalized');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class StaticAnalysisCacheNotConfiguredException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class TestIdMissingException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('Test ID is missing');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class UnintentionallyCoveredCodeException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    /**
     * @var list<string>
     */
    private array $unintentionallyCoveredUnits;
    /**
     * @param list<string> $unintentionallyCoveredUnits
     */
    public function __construct(array $unintentionallyCoveredUnits)
    {
        $this->unintentionallyCoveredUnits = $unintentionallyCoveredUnits;
        parent::__construct($this->toString());
    }
    /**
     * @return list<string>
     */
    public function getUnintentionallyCoveredUnits() : array
    {
        return $this->unintentionallyCoveredUnits;
    }
    private function toString() : string
    {
        $message = '';
        foreach ($this->unintentionallyCoveredUnits as $unit) {
            $message .= '- ' . $unit . "\n";
        }
        return $message;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use function sprintf;
use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class WriteOperationFailedException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct(string $path)
    {
        parent::__construct(\sprintf('Cannot write to "%s"', $path));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class WrongXdebugVersionException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class Xdebug2NotEnabledException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('xdebug.coverage_enable=On has to be set');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class Xdebug3NotEnabledException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('XDEBUG_MODE=coverage or xdebug.mode=coverage has to be set');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Driver;

use RuntimeException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception;
final class XdebugNotAvailableException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
    public function __construct()
    {
        parent::__construct('The Xdebug extension is not available');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use RuntimeException;
final class XmlException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeCoverage\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function array_keys;
use function is_file;
use function realpath;
use function strpos;
use PHPUnit\SebastianBergmann\FileIterator\Facade as FileIteratorFacade;
final class Filter
{
    /**
     * @psalm-var array<string,true>
     */
    private array $files = [];
    /**
     * @psalm-var array<string,bool>
     */
    private array $isFileCache = [];
    public function includeDirectory(string $directory, string $suffix = '.php', string $prefix = '') : void
    {
        foreach ((new \PHPUnit\SebastianBergmann\FileIterator\Facade())->getFilesAsArray($directory, $suffix, $prefix) as $file) {
            $this->includeFile($file);
        }
    }
    /**
     * @psalm-param list<string> $files
     */
    public function includeFiles(array $filenames) : void
    {
        foreach ($filenames as $filename) {
            $this->includeFile($filename);
        }
    }
    public function includeFile(string $filename) : void
    {
        $filename = \realpath($filename);
        if (!$filename) {
            return;
        }
        $this->files[$filename] = \true;
    }
    public function excludeDirectory(string $directory, string $suffix = '.php', string $prefix = '') : void
    {
        foreach ((new \PHPUnit\SebastianBergmann\FileIterator\Facade())->getFilesAsArray($directory, $suffix, $prefix) as $file) {
            $this->excludeFile($file);
        }
    }
    public function excludeFile(string $filename) : void
    {
        $filename = \realpath($filename);
        if (!$filename || !isset($this->files[$filename])) {
            return;
        }
        unset($this->files[$filename]);
    }
    public function isFile(string $filename) : bool
    {
        if (isset($this->isFileCache[$filename])) {
            return $this->isFileCache[$filename];
        }
        if ($filename === '-' || \strpos($filename, 'vfs://') === 0 || \strpos($filename, 'xdebug://debug-eval') !== \false || \strpos($filename, 'eval()\'d code') !== \false || \strpos($filename, 'runtime-created function') !== \false || \strpos($filename, 'runkit created function') !== \false || \strpos($filename, 'assert code') !== \false || \strpos($filename, 'regexp code') !== \false || \strpos($filename, 'Standard input code') !== \false) {
            $isFile = \false;
        } else {
            $isFile = \is_file($filename);
        }
        $this->isFileCache[$filename] = $isFile;
        return $isFile;
    }
    public function isExcluded(string $filename) : bool
    {
        if (!$this->isFile($filename)) {
            return \true;
        }
        return !isset($this->files[$filename]);
    }
    /**
     * @psalm-return list<string>
     */
    public function files() : array
    {
        return \array_keys($this->files);
    }
    public function isEmpty() : bool
    {
        return empty($this->files);
    }
}
php-code-coverage

Copyright (c) 2009-2021, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Node;

use const DIRECTORY_SEPARATOR;
use function array_merge;
use function str_replace;
use function substr;
use Countable;
use PHPUnit\SebastianBergmann\CodeCoverage\Percentage;
use PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
abstract class AbstractNode implements \Countable
{
    private string $name;
    private string $pathAsString;
    private array $pathAsArray;
    private ?\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $parent;
    private string $id;
    public function __construct(string $name, self $parent = null)
    {
        if (\substr($name, -1) === \DIRECTORY_SEPARATOR) {
            $name = \substr($name, 0, -1);
        }
        $this->name = $name;
        $this->parent = $parent;
        $this->processId();
        $this->processPath();
    }
    public function name() : string
    {
        return $this->name;
    }
    public function id() : string
    {
        return $this->id;
    }
    public function pathAsString() : string
    {
        return $this->pathAsString;
    }
    public function pathAsArray() : array
    {
        return $this->pathAsArray;
    }
    public function parent() : ?self
    {
        return $this->parent;
    }
    public function percentageOfTestedClasses() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfTestedClasses(), $this->numberOfClasses());
    }
    public function percentageOfTestedTraits() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfTestedTraits(), $this->numberOfTraits());
    }
    public function percentageOfTestedClassesAndTraits() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfTestedClassesAndTraits(), $this->numberOfClassesAndTraits());
    }
    public function percentageOfTestedFunctions() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfTestedFunctions(), $this->numberOfFunctions());
    }
    public function percentageOfTestedMethods() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfTestedMethods(), $this->numberOfMethods());
    }
    public function percentageOfTestedFunctionsAndMethods() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfTestedFunctionsAndMethods(), $this->numberOfFunctionsAndMethods());
    }
    public function percentageOfExecutedLines() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfExecutedLines(), $this->numberOfExecutableLines());
    }
    public function percentageOfExecutedBranches() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfExecutedBranches(), $this->numberOfExecutableBranches());
    }
    public function percentageOfExecutedPaths() : \PHPUnit\SebastianBergmann\CodeCoverage\Percentage
    {
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($this->numberOfExecutedPaths(), $this->numberOfExecutablePaths());
    }
    public function numberOfClassesAndTraits() : int
    {
        return $this->numberOfClasses() + $this->numberOfTraits();
    }
    public function numberOfTestedClassesAndTraits() : int
    {
        return $this->numberOfTestedClasses() + $this->numberOfTestedTraits();
    }
    public function classesAndTraits() : array
    {
        return \array_merge($this->classes(), $this->traits());
    }
    public function numberOfFunctionsAndMethods() : int
    {
        return $this->numberOfFunctions() + $this->numberOfMethods();
    }
    public function numberOfTestedFunctionsAndMethods() : int
    {
        return $this->numberOfTestedFunctions() + $this->numberOfTestedMethods();
    }
    public abstract function classes() : array;
    public abstract function traits() : array;
    public abstract function functions() : array;
    public abstract function linesOfCode() : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
    public abstract function numberOfExecutableLines() : int;
    public abstract function numberOfExecutedLines() : int;
    public abstract function numberOfExecutableBranches() : int;
    public abstract function numberOfExecutedBranches() : int;
    public abstract function numberOfExecutablePaths() : int;
    public abstract function numberOfExecutedPaths() : int;
    public abstract function numberOfClasses() : int;
    public abstract function numberOfTestedClasses() : int;
    public abstract function numberOfTraits() : int;
    public abstract function numberOfTestedTraits() : int;
    public abstract function numberOfMethods() : int;
    public abstract function numberOfTestedMethods() : int;
    public abstract function numberOfFunctions() : int;
    public abstract function numberOfTestedFunctions() : int;
    private function processId() : void
    {
        if ($this->parent === null) {
            $this->id = 'index';
            return;
        }
        $parentId = $this->parent->id();
        if ($parentId === 'index') {
            $this->id = \str_replace(':', '_', $this->name);
        } else {
            $this->id = $parentId . '/' . $this->name;
        }
    }
    private function processPath() : void
    {
        if ($this->parent === null) {
            $this->pathAsArray = [$this];
            $this->pathAsString = $this->name;
            return;
        }
        $this->pathAsArray = $this->parent->pathAsArray();
        $this->pathAsString = $this->parent->pathAsString() . \DIRECTORY_SEPARATOR . $this->name;
        $this->pathAsArray[] = $this;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Node;

use const DIRECTORY_SEPARATOR;
use function array_shift;
use function basename;
use function count;
use function dirname;
use function explode;
use function implode;
use function is_file;
use function str_replace;
use function strpos;
use function substr;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Builder
{
    private \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser $coveredFileAnalyser;
    public function __construct(\PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser $coveredFileAnalyser)
    {
        $this->coveredFileAnalyser = $coveredFileAnalyser;
    }
    public function build(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage) : \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory
    {
        $data = clone $coverage->getData();
        // clone because path munging is destructive to the original data
        $commonPath = $this->reducePaths($data);
        $root = new \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory($commonPath, null);
        $this->addItems($root, $this->buildDirectoryStructure($data), $coverage->getTests());
        return $root;
    }
    private function addItems(\PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory $root, array $items, array $tests) : void
    {
        foreach ($items as $key => $value) {
            $key = (string) $key;
            if (\substr($key, -2) === '/f') {
                $key = \substr($key, 0, -2);
                $filename = $root->pathAsString() . \DIRECTORY_SEPARATOR . $key;
                if (\is_file($filename)) {
                    $root->addFile(new \PHPUnit\SebastianBergmann\CodeCoverage\Node\File($key, $root, $value['lineCoverage'], $value['functionCoverage'], $tests, $this->coveredFileAnalyser->classesIn($filename), $this->coveredFileAnalyser->traitsIn($filename), $this->coveredFileAnalyser->functionsIn($filename), $this->coveredFileAnalyser->linesOfCodeFor($filename)));
                }
            } else {
                $child = $root->addDirectory($key);
                $this->addItems($child, $value, $tests);
            }
        }
    }
    /**
     * Builds an array representation of the directory structure.
     *
     * For instance,
     *
     * <code>
     * Array
     * (
     *     [Money.php] => Array
     *         (
     *             ...
     *         )
     *
     *     [MoneyBag.php] => Array
     *         (
     *             ...
     *         )
     * )
     * </code>
     *
     * is transformed into
     *
     * <code>
     * Array
     * (
     *     [.] => Array
     *         (
     *             [Money.php] => Array
     *                 (
     *                     ...
     *                 )
     *
     *             [MoneyBag.php] => Array
     *                 (
     *                     ...
     *                 )
     *         )
     * )
     * </code>
     */
    private function buildDirectoryStructure(\PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData $data) : array
    {
        $result = [];
        foreach ($data->coveredFiles() as $originalPath) {
            $path = \explode(\DIRECTORY_SEPARATOR, $originalPath);
            $pointer =& $result;
            $max = \count($path);
            for ($i = 0; $i < $max; $i++) {
                $type = '';
                if ($i === $max - 1) {
                    $type = '/f';
                }
                $pointer =& $pointer[$path[$i] . $type];
            }
            $pointer = ['lineCoverage' => $data->lineCoverage()[$originalPath] ?? [], 'functionCoverage' => $data->functionCoverage()[$originalPath] ?? []];
        }
        return $result;
    }
    /**
     * Reduces the paths by cutting the longest common start path.
     *
     * For instance,
     *
     * <code>
     * Array
     * (
     *     [/home/sb/Money/Money.php] => Array
     *         (
     *             ...
     *         )
     *
     *     [/home/sb/Money/MoneyBag.php] => Array
     *         (
     *             ...
     *         )
     * )
     * </code>
     *
     * is reduced to
     *
     * <code>
     * Array
     * (
     *     [Money.php] => Array
     *         (
     *             ...
     *         )
     *
     *     [MoneyBag.php] => Array
     *         (
     *             ...
     *         )
     * )
     * </code>
     */
    private function reducePaths(\PHPUnit\SebastianBergmann\CodeCoverage\ProcessedCodeCoverageData $coverage) : string
    {
        if (empty($coverage->coveredFiles())) {
            return '.';
        }
        $commonPath = '';
        $paths = $coverage->coveredFiles();
        if (\count($paths) === 1) {
            $commonPath = \dirname($paths[0]) . \DIRECTORY_SEPARATOR;
            $coverage->renameFile($paths[0], \basename($paths[0]));
            return $commonPath;
        }
        $max = \count($paths);
        for ($i = 0; $i < $max; $i++) {
            // strip phar:// prefixes
            if (\strpos($paths[$i], 'phar://') === 0) {
                $paths[$i] = \substr($paths[$i], 7);
                $paths[$i] = \str_replace('/', \DIRECTORY_SEPARATOR, $paths[$i]);
            }
            $paths[$i] = \explode(\DIRECTORY_SEPARATOR, $paths[$i]);
            if (empty($paths[$i][0])) {
                $paths[$i][0] = \DIRECTORY_SEPARATOR;
            }
        }
        $done = \false;
        $max = \count($paths);
        while (!$done) {
            for ($i = 0; $i < $max - 1; $i++) {
                if (!isset($paths[$i][0]) || !isset($paths[$i + 1][0]) || $paths[$i][0] !== $paths[$i + 1][0]) {
                    $done = \true;
                    break;
                }
            }
            if (!$done) {
                $commonPath .= $paths[0][0];
                if ($paths[0][0] !== \DIRECTORY_SEPARATOR) {
                    $commonPath .= \DIRECTORY_SEPARATOR;
                }
                for ($i = 0; $i < $max; $i++) {
                    \array_shift($paths[$i]);
                }
            }
        }
        $original = $coverage->coveredFiles();
        $max = \count($original);
        for ($i = 0; $i < $max; $i++) {
            $coverage->renameFile($original[$i], \implode(\DIRECTORY_SEPARATOR, $paths[$i]));
        }
        return \substr($commonPath, 0, -1);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Node;

use function array_merge;
use function count;
use IteratorAggregate;
use RecursiveIteratorIterator;
use PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Directory extends \PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode implements \IteratorAggregate
{
    /**
     * @var list<AbstractNode>
     */
    private array $children = [];
    /**
     * @var list<Directory>
     */
    private array $directories = [];
    /**
     * @var list<File>
     */
    private array $files = [];
    private ?array $classes = null;
    private ?array $traits = null;
    private ?array $functions = null;
    private ?\PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode $linesOfCode = null;
    private int $numFiles = -1;
    private int $numExecutableLines = -1;
    private int $numExecutedLines = -1;
    private int $numExecutableBranches = -1;
    private int $numExecutedBranches = -1;
    private int $numExecutablePaths = -1;
    private int $numExecutedPaths = -1;
    private int $numClasses = -1;
    private int $numTestedClasses = -1;
    private int $numTraits = -1;
    private int $numTestedTraits = -1;
    private int $numMethods = -1;
    private int $numTestedMethods = -1;
    private int $numFunctions = -1;
    private int $numTestedFunctions = -1;
    public function count() : int
    {
        if ($this->numFiles === -1) {
            $this->numFiles = 0;
            foreach ($this->children as $child) {
                $this->numFiles += \count($child);
            }
        }
        return $this->numFiles;
    }
    public function getIterator() : \RecursiveIteratorIterator
    {
        return new \RecursiveIteratorIterator(new \PHPUnit\SebastianBergmann\CodeCoverage\Node\Iterator($this), \RecursiveIteratorIterator::SELF_FIRST);
    }
    public function addDirectory(string $name) : self
    {
        $directory = new self($name, $this);
        $this->children[] = $directory;
        $this->directories[] =& $this->children[\count($this->children) - 1];
        return $directory;
    }
    public function addFile(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $file) : void
    {
        $this->children[] = $file;
        $this->files[] =& $this->children[\count($this->children) - 1];
        $this->numExecutableLines = -1;
        $this->numExecutedLines = -1;
    }
    public function directories() : array
    {
        return $this->directories;
    }
    public function files() : array
    {
        return $this->files;
    }
    public function children() : array
    {
        return $this->children;
    }
    public function classes() : array
    {
        if ($this->classes === null) {
            $this->classes = [];
            foreach ($this->children as $child) {
                $this->classes = \array_merge($this->classes, $child->classes());
            }
        }
        return $this->classes;
    }
    public function traits() : array
    {
        if ($this->traits === null) {
            $this->traits = [];
            foreach ($this->children as $child) {
                $this->traits = \array_merge($this->traits, $child->traits());
            }
        }
        return $this->traits;
    }
    public function functions() : array
    {
        if ($this->functions === null) {
            $this->functions = [];
            foreach ($this->children as $child) {
                $this->functions = \array_merge($this->functions, $child->functions());
            }
        }
        return $this->functions;
    }
    public function linesOfCode() : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        if ($this->linesOfCode === null) {
            $this->linesOfCode = new \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode(0, 0, 0, 0);
            foreach ($this->children as $child) {
                $this->linesOfCode = $this->linesOfCode->plus($child->linesOfCode());
            }
        }
        return $this->linesOfCode;
    }
    public function numberOfExecutableLines() : int
    {
        if ($this->numExecutableLines === -1) {
            $this->numExecutableLines = 0;
            foreach ($this->children as $child) {
                $this->numExecutableLines += $child->numberOfExecutableLines();
            }
        }
        return $this->numExecutableLines;
    }
    public function numberOfExecutedLines() : int
    {
        if ($this->numExecutedLines === -1) {
            $this->numExecutedLines = 0;
            foreach ($this->children as $child) {
                $this->numExecutedLines += $child->numberOfExecutedLines();
            }
        }
        return $this->numExecutedLines;
    }
    public function numberOfExecutableBranches() : int
    {
        if ($this->numExecutableBranches === -1) {
            $this->numExecutableBranches = 0;
            foreach ($this->children as $child) {
                $this->numExecutableBranches += $child->numberOfExecutableBranches();
            }
        }
        return $this->numExecutableBranches;
    }
    public function numberOfExecutedBranches() : int
    {
        if ($this->numExecutedBranches === -1) {
            $this->numExecutedBranches = 0;
            foreach ($this->children as $child) {
                $this->numExecutedBranches += $child->numberOfExecutedBranches();
            }
        }
        return $this->numExecutedBranches;
    }
    public function numberOfExecutablePaths() : int
    {
        if ($this->numExecutablePaths === -1) {
            $this->numExecutablePaths = 0;
            foreach ($this->children as $child) {
                $this->numExecutablePaths += $child->numberOfExecutablePaths();
            }
        }
        return $this->numExecutablePaths;
    }
    public function numberOfExecutedPaths() : int
    {
        if ($this->numExecutedPaths === -1) {
            $this->numExecutedPaths = 0;
            foreach ($this->children as $child) {
                $this->numExecutedPaths += $child->numberOfExecutedPaths();
            }
        }
        return $this->numExecutedPaths;
    }
    public function numberOfClasses() : int
    {
        if ($this->numClasses === -1) {
            $this->numClasses = 0;
            foreach ($this->children as $child) {
                $this->numClasses += $child->numberOfClasses();
            }
        }
        return $this->numClasses;
    }
    public function numberOfTestedClasses() : int
    {
        if ($this->numTestedClasses === -1) {
            $this->numTestedClasses = 0;
            foreach ($this->children as $child) {
                $this->numTestedClasses += $child->numberOfTestedClasses();
            }
        }
        return $this->numTestedClasses;
    }
    public function numberOfTraits() : int
    {
        if ($this->numTraits === -1) {
            $this->numTraits = 0;
            foreach ($this->children as $child) {
                $this->numTraits += $child->numberOfTraits();
            }
        }
        return $this->numTraits;
    }
    public function numberOfTestedTraits() : int
    {
        if ($this->numTestedTraits === -1) {
            $this->numTestedTraits = 0;
            foreach ($this->children as $child) {
                $this->numTestedTraits += $child->numberOfTestedTraits();
            }
        }
        return $this->numTestedTraits;
    }
    public function numberOfMethods() : int
    {
        if ($this->numMethods === -1) {
            $this->numMethods = 0;
            foreach ($this->children as $child) {
                $this->numMethods += $child->numberOfMethods();
            }
        }
        return $this->numMethods;
    }
    public function numberOfTestedMethods() : int
    {
        if ($this->numTestedMethods === -1) {
            $this->numTestedMethods = 0;
            foreach ($this->children as $child) {
                $this->numTestedMethods += $child->numberOfTestedMethods();
            }
        }
        return $this->numTestedMethods;
    }
    public function numberOfFunctions() : int
    {
        if ($this->numFunctions === -1) {
            $this->numFunctions = 0;
            foreach ($this->children as $child) {
                $this->numFunctions += $child->numberOfFunctions();
            }
        }
        return $this->numFunctions;
    }
    public function numberOfTestedFunctions() : int
    {
        if ($this->numTestedFunctions === -1) {
            $this->numTestedFunctions = 0;
            foreach ($this->children as $child) {
                $this->numTestedFunctions += $child->numberOfTestedFunctions();
            }
        }
        return $this->numTestedFunctions;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Node;

use function array_filter;
use function count;
use function range;
use PHPUnit\SebastianBergmann\CodeCoverage\CrapIndex;
use PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class File extends \PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode
{
    private array $lineCoverageData;
    private array $functionCoverageData;
    private array $testData;
    private int $numExecutableLines = 0;
    private int $numExecutedLines = 0;
    private int $numExecutableBranches = 0;
    private int $numExecutedBranches = 0;
    private int $numExecutablePaths = 0;
    private int $numExecutedPaths = 0;
    private array $classes = [];
    private array $traits = [];
    private array $functions = [];
    private \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode $linesOfCode;
    private ?int $numClasses = null;
    private int $numTestedClasses = 0;
    private ?int $numTraits = null;
    private int $numTestedTraits = 0;
    private ?int $numMethods = null;
    private ?int $numTestedMethods = null;
    private ?int $numTestedFunctions = null;
    private array $codeUnitsByLine = [];
    public function __construct(string $name, \PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $parent, array $lineCoverageData, array $functionCoverageData, array $testData, array $classes, array $traits, array $functions, \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode $linesOfCode)
    {
        parent::__construct($name, $parent);
        $this->lineCoverageData = $lineCoverageData;
        $this->functionCoverageData = $functionCoverageData;
        $this->testData = $testData;
        $this->linesOfCode = $linesOfCode;
        $this->calculateStatistics($classes, $traits, $functions);
    }
    public function count() : int
    {
        return 1;
    }
    public function lineCoverageData() : array
    {
        return $this->lineCoverageData;
    }
    public function functionCoverageData() : array
    {
        return $this->functionCoverageData;
    }
    public function testData() : array
    {
        return $this->testData;
    }
    public function classes() : array
    {
        return $this->classes;
    }
    public function traits() : array
    {
        return $this->traits;
    }
    public function functions() : array
    {
        return $this->functions;
    }
    public function linesOfCode() : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        return $this->linesOfCode;
    }
    public function numberOfExecutableLines() : int
    {
        return $this->numExecutableLines;
    }
    public function numberOfExecutedLines() : int
    {
        return $this->numExecutedLines;
    }
    public function numberOfExecutableBranches() : int
    {
        return $this->numExecutableBranches;
    }
    public function numberOfExecutedBranches() : int
    {
        return $this->numExecutedBranches;
    }
    public function numberOfExecutablePaths() : int
    {
        return $this->numExecutablePaths;
    }
    public function numberOfExecutedPaths() : int
    {
        return $this->numExecutedPaths;
    }
    public function numberOfClasses() : int
    {
        if ($this->numClasses === null) {
            $this->numClasses = 0;
            foreach ($this->classes as $class) {
                foreach ($class['methods'] as $method) {
                    if ($method['executableLines'] > 0) {
                        $this->numClasses++;
                        continue 2;
                    }
                }
            }
        }
        return $this->numClasses;
    }
    public function numberOfTestedClasses() : int
    {
        return $this->numTestedClasses;
    }
    public function numberOfTraits() : int
    {
        if ($this->numTraits === null) {
            $this->numTraits = 0;
            foreach ($this->traits as $trait) {
                foreach ($trait['methods'] as $method) {
                    if ($method['executableLines'] > 0) {
                        $this->numTraits++;
                        continue 2;
                    }
                }
            }
        }
        return $this->numTraits;
    }
    public function numberOfTestedTraits() : int
    {
        return $this->numTestedTraits;
    }
    public function numberOfMethods() : int
    {
        if ($this->numMethods === null) {
            $this->numMethods = 0;
            foreach ($this->classes as $class) {
                foreach ($class['methods'] as $method) {
                    if ($method['executableLines'] > 0) {
                        $this->numMethods++;
                    }
                }
            }
            foreach ($this->traits as $trait) {
                foreach ($trait['methods'] as $method) {
                    if ($method['executableLines'] > 0) {
                        $this->numMethods++;
                    }
                }
            }
        }
        return $this->numMethods;
    }
    public function numberOfTestedMethods() : int
    {
        if ($this->numTestedMethods === null) {
            $this->numTestedMethods = 0;
            foreach ($this->classes as $class) {
                foreach ($class['methods'] as $method) {
                    if ($method['executableLines'] > 0 && $method['coverage'] === 100) {
                        $this->numTestedMethods++;
                    }
                }
            }
            foreach ($this->traits as $trait) {
                foreach ($trait['methods'] as $method) {
                    if ($method['executableLines'] > 0 && $method['coverage'] === 100) {
                        $this->numTestedMethods++;
                    }
                }
            }
        }
        return $this->numTestedMethods;
    }
    public function numberOfFunctions() : int
    {
        return \count($this->functions);
    }
    public function numberOfTestedFunctions() : int
    {
        if ($this->numTestedFunctions === null) {
            $this->numTestedFunctions = 0;
            foreach ($this->functions as $function) {
                if ($function['executableLines'] > 0 && $function['coverage'] === 100) {
                    $this->numTestedFunctions++;
                }
            }
        }
        return $this->numTestedFunctions;
    }
    private function calculateStatistics(array $classes, array $traits, array $functions) : void
    {
        foreach (\range(1, $this->linesOfCode->linesOfCode()) as $lineNumber) {
            $this->codeUnitsByLine[$lineNumber] = [];
        }
        $this->processClasses($classes);
        $this->processTraits($traits);
        $this->processFunctions($functions);
        foreach (\range(1, $this->linesOfCode->linesOfCode()) as $lineNumber) {
            if (isset($this->lineCoverageData[$lineNumber])) {
                foreach ($this->codeUnitsByLine[$lineNumber] as &$codeUnit) {
                    $codeUnit['executableLines']++;
                }
                unset($codeUnit);
                $this->numExecutableLines++;
                if (\count($this->lineCoverageData[$lineNumber]) > 0) {
                    foreach ($this->codeUnitsByLine[$lineNumber] as &$codeUnit) {
                        $codeUnit['executedLines']++;
                    }
                    unset($codeUnit);
                    $this->numExecutedLines++;
                }
            }
        }
        foreach ($this->traits as &$trait) {
            foreach ($trait['methods'] as &$method) {
                $methodLineCoverage = $method['executableLines'] ? $method['executedLines'] / $method['executableLines'] * 100 : 100;
                $methodBranchCoverage = $method['executableBranches'] ? $method['executedBranches'] / $method['executableBranches'] * 100 : 0;
                $methodPathCoverage = $method['executablePaths'] ? $method['executedPaths'] / $method['executablePaths'] * 100 : 0;
                $method['coverage'] = $methodBranchCoverage ?: $methodLineCoverage;
                $method['crap'] = (new \PHPUnit\SebastianBergmann\CodeCoverage\CrapIndex($method['ccn'], $methodPathCoverage ?: $methodLineCoverage))->asString();
                $trait['ccn'] += $method['ccn'];
            }
            unset($method);
            $traitLineCoverage = $trait['executableLines'] ? $trait['executedLines'] / $trait['executableLines'] * 100 : 100;
            $traitBranchCoverage = $trait['executableBranches'] ? $trait['executedBranches'] / $trait['executableBranches'] * 100 : 0;
            $traitPathCoverage = $trait['executablePaths'] ? $trait['executedPaths'] / $trait['executablePaths'] * 100 : 0;
            $trait['coverage'] = $traitBranchCoverage ?: $traitLineCoverage;
            $trait['crap'] = (new \PHPUnit\SebastianBergmann\CodeCoverage\CrapIndex($trait['ccn'], $traitPathCoverage ?: $traitLineCoverage))->asString();
            if ($trait['executableLines'] > 0 && $trait['coverage'] === 100) {
                $this->numTestedClasses++;
            }
        }
        unset($trait);
        foreach ($this->classes as &$class) {
            foreach ($class['methods'] as &$method) {
                $methodLineCoverage = $method['executableLines'] ? $method['executedLines'] / $method['executableLines'] * 100 : 100;
                $methodBranchCoverage = $method['executableBranches'] ? $method['executedBranches'] / $method['executableBranches'] * 100 : 0;
                $methodPathCoverage = $method['executablePaths'] ? $method['executedPaths'] / $method['executablePaths'] * 100 : 0;
                $method['coverage'] = $methodBranchCoverage ?: $methodLineCoverage;
                $method['crap'] = (new \PHPUnit\SebastianBergmann\CodeCoverage\CrapIndex($method['ccn'], $methodPathCoverage ?: $methodLineCoverage))->asString();
                $class['ccn'] += $method['ccn'];
            }
            unset($method);
            $classLineCoverage = $class['executableLines'] ? $class['executedLines'] / $class['executableLines'] * 100 : 100;
            $classBranchCoverage = $class['executableBranches'] ? $class['executedBranches'] / $class['executableBranches'] * 100 : 0;
            $classPathCoverage = $class['executablePaths'] ? $class['executedPaths'] / $class['executablePaths'] * 100 : 0;
            $class['coverage'] = $classBranchCoverage ?: $classLineCoverage;
            $class['crap'] = (new \PHPUnit\SebastianBergmann\CodeCoverage\CrapIndex($class['ccn'], $classPathCoverage ?: $classLineCoverage))->asString();
            if ($class['executableLines'] > 0 && $class['coverage'] === 100) {
                $this->numTestedClasses++;
            }
        }
        unset($class);
        foreach ($this->functions as &$function) {
            $functionLineCoverage = $function['executableLines'] ? $function['executedLines'] / $function['executableLines'] * 100 : 100;
            $functionBranchCoverage = $function['executableBranches'] ? $function['executedBranches'] / $function['executableBranches'] * 100 : 0;
            $functionPathCoverage = $function['executablePaths'] ? $function['executedPaths'] / $function['executablePaths'] * 100 : 0;
            $function['coverage'] = $functionBranchCoverage ?: $functionLineCoverage;
            $function['crap'] = (new \PHPUnit\SebastianBergmann\CodeCoverage\CrapIndex($function['ccn'], $functionPathCoverage ?: $functionLineCoverage))->asString();
            if ($function['coverage'] === 100) {
                $this->numTestedFunctions++;
            }
        }
    }
    private function processClasses(array $classes) : void
    {
        $link = $this->id() . '.html#';
        foreach ($classes as $className => $class) {
            $this->classes[$className] = ['className' => $className, 'namespace' => $class['namespace'], 'methods' => [], 'startLine' => $class['startLine'], 'executableLines' => 0, 'executedLines' => 0, 'executableBranches' => 0, 'executedBranches' => 0, 'executablePaths' => 0, 'executedPaths' => 0, 'ccn' => 0, 'coverage' => 0, 'crap' => 0, 'link' => $link . $class['startLine']];
            foreach ($class['methods'] as $methodName => $method) {
                $methodData = $this->newMethod($className, $methodName, $method, $link);
                $this->classes[$className]['methods'][$methodName] = $methodData;
                $this->classes[$className]['executableBranches'] += $methodData['executableBranches'];
                $this->classes[$className]['executedBranches'] += $methodData['executedBranches'];
                $this->classes[$className]['executablePaths'] += $methodData['executablePaths'];
                $this->classes[$className]['executedPaths'] += $methodData['executedPaths'];
                $this->numExecutableBranches += $methodData['executableBranches'];
                $this->numExecutedBranches += $methodData['executedBranches'];
                $this->numExecutablePaths += $methodData['executablePaths'];
                $this->numExecutedPaths += $methodData['executedPaths'];
                foreach (\range($method['startLine'], $method['endLine']) as $lineNumber) {
                    $this->codeUnitsByLine[$lineNumber] = [&$this->classes[$className], &$this->classes[$className]['methods'][$methodName]];
                }
            }
        }
    }
    private function processTraits(array $traits) : void
    {
        $link = $this->id() . '.html#';
        foreach ($traits as $traitName => $trait) {
            $this->traits[$traitName] = ['traitName' => $traitName, 'namespace' => $trait['namespace'], 'methods' => [], 'startLine' => $trait['startLine'], 'executableLines' => 0, 'executedLines' => 0, 'executableBranches' => 0, 'executedBranches' => 0, 'executablePaths' => 0, 'executedPaths' => 0, 'ccn' => 0, 'coverage' => 0, 'crap' => 0, 'link' => $link . $trait['startLine']];
            foreach ($trait['methods'] as $methodName => $method) {
                $methodData = $this->newMethod($traitName, $methodName, $method, $link);
                $this->traits[$traitName]['methods'][$methodName] = $methodData;
                $this->traits[$traitName]['executableBranches'] += $methodData['executableBranches'];
                $this->traits[$traitName]['executedBranches'] += $methodData['executedBranches'];
                $this->traits[$traitName]['executablePaths'] += $methodData['executablePaths'];
                $this->traits[$traitName]['executedPaths'] += $methodData['executedPaths'];
                $this->numExecutableBranches += $methodData['executableBranches'];
                $this->numExecutedBranches += $methodData['executedBranches'];
                $this->numExecutablePaths += $methodData['executablePaths'];
                $this->numExecutedPaths += $methodData['executedPaths'];
                foreach (\range($method['startLine'], $method['endLine']) as $lineNumber) {
                    $this->codeUnitsByLine[$lineNumber] = [&$this->traits[$traitName], &$this->traits[$traitName]['methods'][$methodName]];
                }
            }
        }
    }
    private function processFunctions(array $functions) : void
    {
        $link = $this->id() . '.html#';
        foreach ($functions as $functionName => $function) {
            $this->functions[$functionName] = ['functionName' => $functionName, 'namespace' => $function['namespace'], 'signature' => $function['signature'], 'startLine' => $function['startLine'], 'endLine' => $function['endLine'], 'executableLines' => 0, 'executedLines' => 0, 'executableBranches' => 0, 'executedBranches' => 0, 'executablePaths' => 0, 'executedPaths' => 0, 'ccn' => $function['ccn'], 'coverage' => 0, 'crap' => 0, 'link' => $link . $function['startLine']];
            foreach (\range($function['startLine'], $function['endLine']) as $lineNumber) {
                $this->codeUnitsByLine[$lineNumber] = [&$this->functions[$functionName]];
            }
            if (isset($this->functionCoverageData[$functionName]['branches'])) {
                $this->functions[$functionName]['executableBranches'] = \count($this->functionCoverageData[$functionName]['branches']);
                $this->functions[$functionName]['executedBranches'] = \count(\array_filter($this->functionCoverageData[$functionName]['branches'], static function (array $branch) {
                    return (bool) $branch['hit'];
                }));
            }
            if (isset($this->functionCoverageData[$functionName]['paths'])) {
                $this->functions[$functionName]['executablePaths'] = \count($this->functionCoverageData[$functionName]['paths']);
                $this->functions[$functionName]['executedPaths'] = \count(\array_filter($this->functionCoverageData[$functionName]['paths'], static function (array $path) {
                    return (bool) $path['hit'];
                }));
            }
            $this->numExecutableBranches += $this->functions[$functionName]['executableBranches'];
            $this->numExecutedBranches += $this->functions[$functionName]['executedBranches'];
            $this->numExecutablePaths += $this->functions[$functionName]['executablePaths'];
            $this->numExecutedPaths += $this->functions[$functionName]['executedPaths'];
        }
    }
    private function newMethod(string $className, string $methodName, array $method, string $link) : array
    {
        $methodData = ['methodName' => $methodName, 'visibility' => $method['visibility'], 'signature' => $method['signature'], 'startLine' => $method['startLine'], 'endLine' => $method['endLine'], 'executableLines' => 0, 'executedLines' => 0, 'executableBranches' => 0, 'executedBranches' => 0, 'executablePaths' => 0, 'executedPaths' => 0, 'ccn' => $method['ccn'], 'coverage' => 0, 'crap' => 0, 'link' => $link . $method['startLine']];
        $key = $className . '->' . $methodName;
        if (isset($this->functionCoverageData[$key]['branches'])) {
            $methodData['executableBranches'] = \count($this->functionCoverageData[$key]['branches']);
            $methodData['executedBranches'] = \count(\array_filter($this->functionCoverageData[$key]['branches'], static function (array $branch) {
                return (bool) $branch['hit'];
            }));
        }
        if (isset($this->functionCoverageData[$key]['paths'])) {
            $methodData['executablePaths'] = \count($this->functionCoverageData[$key]['paths']);
            $methodData['executedPaths'] = \count(\array_filter($this->functionCoverageData[$key]['paths'], static function (array $path) {
                return (bool) $path['hit'];
            }));
        }
        return $methodData;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Node;

use function count;
use RecursiveIterator;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Iterator implements \RecursiveIterator
{
    private int $position;
    /**
     * @var list<AbstractNode>
     */
    private array $nodes;
    public function __construct(\PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory $node)
    {
        $this->nodes = $node->children();
    }
    /**
     * Rewinds the Iterator to the first element.
     */
    public function rewind() : void
    {
        $this->position = 0;
    }
    /**
     * Checks if there is a current element after calls to rewind() or next().
     */
    public function valid() : bool
    {
        return $this->position < \count($this->nodes);
    }
    /**
     * Returns the key of the current element.
     */
    public function key() : int
    {
        return $this->position;
    }
    /**
     * Returns the current element.
     */
    public function current() : ?\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode
    {
        return $this->valid() ? $this->nodes[$this->position] : null;
    }
    /**
     * Moves forward to next element.
     */
    public function next() : void
    {
        $this->position++;
    }
    /**
     * Returns the sub iterator for the current element.
     *
     * @return Iterator
     */
    public function getChildren() : self
    {
        return new self($this->nodes[$this->position]);
    }
    /**
     * Checks whether the current element has children.
     */
    public function hasChildren() : bool
    {
        return $this->nodes[$this->position] instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Percentage
{
    private float $fraction;
    private float $total;
    public static function fromFractionAndTotal(float $fraction, float $total) : self
    {
        return new self($fraction, $total);
    }
    private function __construct(float $fraction, float $total)
    {
        $this->fraction = $fraction;
        $this->total = $total;
    }
    public function asFloat() : float
    {
        if ($this->total > 0) {
            return $this->fraction / $this->total * 100;
        }
        return 100.0;
    }
    public function asString() : string
    {
        if ($this->total > 0) {
            return \sprintf('%01.2F%%', $this->asFloat());
        }
        return '';
    }
    public function asFixedWidthString() : string
    {
        if ($this->total > 0) {
            return \sprintf('%6.2F%%', $this->asFloat());
        }
        return '';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function array_key_exists;
use function array_keys;
use function array_merge;
use function array_unique;
use function count;
use function is_array;
use function ksort;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class ProcessedCodeCoverageData
{
    /**
     * Line coverage data.
     * An array of filenames, each having an array of linenumbers, each executable line having an array of testcase ids.
     */
    private array $lineCoverage = [];
    /**
     * Function coverage data.
     * Maintains base format of raw data (@see https://xdebug.org/docs/code_coverage), but each 'hit' entry is an array
     * of testcase ids.
     */
    private array $functionCoverage = [];
    public function initializeUnseenData(\PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData $rawData) : void
    {
        foreach ($rawData->lineCoverage() as $file => $lines) {
            if (!isset($this->lineCoverage[$file])) {
                $this->lineCoverage[$file] = [];
                foreach ($lines as $k => $v) {
                    $this->lineCoverage[$file][$k] = $v === \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver::LINE_NOT_EXECUTABLE ? null : [];
                }
            }
        }
        foreach ($rawData->functionCoverage() as $file => $functions) {
            foreach ($functions as $functionName => $functionData) {
                if (isset($this->functionCoverage[$file][$functionName])) {
                    $this->initPreviouslySeenFunction($file, $functionName, $functionData);
                } else {
                    $this->initPreviouslyUnseenFunction($file, $functionName, $functionData);
                }
            }
        }
    }
    public function markCodeAsExecutedByTestCase(string $testCaseId, \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData $executedCode) : void
    {
        foreach ($executedCode->lineCoverage() as $file => $lines) {
            foreach ($lines as $k => $v) {
                if ($v === \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver::LINE_EXECUTED) {
                    $this->lineCoverage[$file][$k][] = $testCaseId;
                }
            }
        }
        foreach ($executedCode->functionCoverage() as $file => $functions) {
            foreach ($functions as $functionName => $functionData) {
                foreach ($functionData['branches'] as $branchId => $branchData) {
                    if ($branchData['hit'] === \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver::BRANCH_HIT) {
                        $this->functionCoverage[$file][$functionName]['branches'][$branchId]['hit'][] = $testCaseId;
                    }
                }
                foreach ($functionData['paths'] as $pathId => $pathData) {
                    if ($pathData['hit'] === \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver::BRANCH_HIT) {
                        $this->functionCoverage[$file][$functionName]['paths'][$pathId]['hit'][] = $testCaseId;
                    }
                }
            }
        }
    }
    public function setLineCoverage(array $lineCoverage) : void
    {
        $this->lineCoverage = $lineCoverage;
    }
    public function lineCoverage() : array
    {
        \ksort($this->lineCoverage);
        return $this->lineCoverage;
    }
    public function setFunctionCoverage(array $functionCoverage) : void
    {
        $this->functionCoverage = $functionCoverage;
    }
    public function functionCoverage() : array
    {
        \ksort($this->functionCoverage);
        return $this->functionCoverage;
    }
    public function coveredFiles() : array
    {
        \ksort($this->lineCoverage);
        return \array_keys($this->lineCoverage);
    }
    public function renameFile(string $oldFile, string $newFile) : void
    {
        $this->lineCoverage[$newFile] = $this->lineCoverage[$oldFile];
        if (isset($this->functionCoverage[$oldFile])) {
            $this->functionCoverage[$newFile] = $this->functionCoverage[$oldFile];
        }
        unset($this->lineCoverage[$oldFile], $this->functionCoverage[$oldFile]);
    }
    public function merge(self $newData) : void
    {
        foreach ($newData->lineCoverage as $file => $lines) {
            if (!isset($this->lineCoverage[$file])) {
                $this->lineCoverage[$file] = $lines;
                continue;
            }
            // we should compare the lines if any of two contains data
            $compareLineNumbers = \array_unique(\array_merge(\array_keys($this->lineCoverage[$file]), \array_keys($newData->lineCoverage[$file])));
            foreach ($compareLineNumbers as $line) {
                $thatPriority = $this->priorityForLine($newData->lineCoverage[$file], $line);
                $thisPriority = $this->priorityForLine($this->lineCoverage[$file], $line);
                if ($thatPriority > $thisPriority) {
                    $this->lineCoverage[$file][$line] = $newData->lineCoverage[$file][$line];
                } elseif ($thatPriority === $thisPriority && \is_array($this->lineCoverage[$file][$line])) {
                    $this->lineCoverage[$file][$line] = \array_unique(\array_merge($this->lineCoverage[$file][$line], $newData->lineCoverage[$file][$line]));
                }
            }
        }
        foreach ($newData->functionCoverage as $file => $functions) {
            if (!isset($this->functionCoverage[$file])) {
                $this->functionCoverage[$file] = $functions;
                continue;
            }
            foreach ($functions as $functionName => $functionData) {
                if (isset($this->functionCoverage[$file][$functionName])) {
                    $this->initPreviouslySeenFunction($file, $functionName, $functionData);
                } else {
                    $this->initPreviouslyUnseenFunction($file, $functionName, $functionData);
                }
                foreach ($functionData['branches'] as $branchId => $branchData) {
                    $this->functionCoverage[$file][$functionName]['branches'][$branchId]['hit'] = \array_unique(\array_merge($this->functionCoverage[$file][$functionName]['branches'][$branchId]['hit'], $branchData['hit']));
                }
                foreach ($functionData['paths'] as $pathId => $pathData) {
                    $this->functionCoverage[$file][$functionName]['paths'][$pathId]['hit'] = \array_unique(\array_merge($this->functionCoverage[$file][$functionName]['paths'][$pathId]['hit'], $pathData['hit']));
                }
            }
        }
    }
    /**
     * Determine the priority for a line.
     *
     * 1 = the line is not set
     * 2 = the line has not been tested
     * 3 = the line is dead code
     * 4 = the line has been tested
     *
     * During a merge, a higher number is better.
     */
    private function priorityForLine(array $data, int $line) : int
    {
        if (!\array_key_exists($line, $data)) {
            return 1;
        }
        if (\is_array($data[$line]) && \count($data[$line]) === 0) {
            return 2;
        }
        if ($data[$line] === null) {
            return 3;
        }
        return 4;
    }
    /**
     * For a function we have never seen before, copy all data over and simply init the 'hit' array.
     */
    private function initPreviouslyUnseenFunction(string $file, string $functionName, array $functionData) : void
    {
        $this->functionCoverage[$file][$functionName] = $functionData;
        foreach (\array_keys($functionData['branches']) as $branchId) {
            $this->functionCoverage[$file][$functionName]['branches'][$branchId]['hit'] = [];
        }
        foreach (\array_keys($functionData['paths']) as $pathId) {
            $this->functionCoverage[$file][$functionName]['paths'][$pathId]['hit'] = [];
        }
    }
    /**
     * For a function we have seen before, only copy over and init the 'hit' array for any unseen branches and paths.
     * Techniques such as mocking and where the contents of a file are different vary during tests (e.g. compiling
     * containers) mean that the functions inside a file cannot be relied upon to be static.
     */
    private function initPreviouslySeenFunction(string $file, string $functionName, array $functionData) : void
    {
        foreach ($functionData['branches'] as $branchId => $branchData) {
            if (!isset($this->functionCoverage[$file][$functionName]['branches'][$branchId])) {
                $this->functionCoverage[$file][$functionName]['branches'][$branchId] = $branchData;
                $this->functionCoverage[$file][$functionName]['branches'][$branchId]['hit'] = [];
            }
        }
        foreach ($functionData['paths'] as $pathId => $pathData) {
            if (!isset($this->functionCoverage[$file][$functionName]['paths'][$pathId])) {
                $this->functionCoverage[$file][$functionName]['paths'][$pathId] = $pathData;
                $this->functionCoverage[$file][$functionName]['paths'][$pathId]['hit'] = [];
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function array_diff;
use function array_diff_key;
use function array_flip;
use function array_intersect;
use function array_intersect_key;
use function count;
use function file;
use function in_array;
use function range;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class RawCodeCoverageData
{
    /**
     * @var array<string, array<int>>
     */
    private static array $emptyLineCache = [];
    /**
     * @see https://xdebug.org/docs/code_coverage for format
     */
    private array $lineCoverage;
    /**
     * @see https://xdebug.org/docs/code_coverage for format
     */
    private array $functionCoverage;
    public static function fromXdebugWithoutPathCoverage(array $rawCoverage) : self
    {
        return new self($rawCoverage, []);
    }
    public static function fromXdebugWithPathCoverage(array $rawCoverage) : self
    {
        $lineCoverage = [];
        $functionCoverage = [];
        foreach ($rawCoverage as $file => $fileCoverageData) {
            $lineCoverage[$file] = $fileCoverageData['lines'];
            $functionCoverage[$file] = $fileCoverageData['functions'];
        }
        return new self($lineCoverage, $functionCoverage);
    }
    public static function fromXdebugWithMixedCoverage(array $rawCoverage) : self
    {
        $lineCoverage = [];
        $functionCoverage = [];
        foreach ($rawCoverage as $file => $fileCoverageData) {
            if (!isset($fileCoverageData['functions'])) {
                // Current file does not have functions, so line coverage
                // is stored in $fileCoverageData, not in $fileCoverageData['lines']
                $lineCoverage[$file] = $fileCoverageData;
                continue;
            }
            $lineCoverage[$file] = $fileCoverageData['lines'];
            $functionCoverage[$file] = $fileCoverageData['functions'];
        }
        return new self($lineCoverage, $functionCoverage);
    }
    public static function fromUncoveredFile(string $filename, \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser $uncoveredFileAnalyser) : self
    {
        $lineCoverage = [];
        foreach ($uncoveredFileAnalyser->executableLinesIn($filename) as $line) {
            $lineCoverage[$line] = \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver::LINE_NOT_EXECUTED;
        }
        return new self([$filename => $lineCoverage], []);
    }
    private function __construct(array $lineCoverage, array $functionCoverage)
    {
        $this->lineCoverage = $lineCoverage;
        $this->functionCoverage = $functionCoverage;
        $this->skipEmptyLines();
    }
    public function clear() : void
    {
        $this->lineCoverage = $this->functionCoverage = [];
    }
    public function lineCoverage() : array
    {
        return $this->lineCoverage;
    }
    public function functionCoverage() : array
    {
        return $this->functionCoverage;
    }
    public function removeCoverageDataForFile(string $filename) : void
    {
        unset($this->lineCoverage[$filename], $this->functionCoverage[$filename]);
    }
    /**
     * @param int[] $lines
     */
    public function keepCoverageDataOnlyForLines(string $filename, array $lines) : void
    {
        if (!isset($this->lineCoverage[$filename])) {
            return;
        }
        $this->lineCoverage[$filename] = \array_intersect_key($this->lineCoverage[$filename], \array_flip($lines));
        if (isset($this->functionCoverage[$filename])) {
            foreach ($this->functionCoverage[$filename] as $functionName => $functionData) {
                foreach ($functionData['branches'] as $branchId => $branch) {
                    if (\count(\array_diff(\range($branch['line_start'], $branch['line_end']), $lines)) > 0) {
                        unset($this->functionCoverage[$filename][$functionName]['branches'][$branchId]);
                        foreach ($functionData['paths'] as $pathId => $path) {
                            if (\in_array($branchId, $path['path'], \true)) {
                                unset($this->functionCoverage[$filename][$functionName]['paths'][$pathId]);
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * @param int[] $lines
     */
    public function removeCoverageDataForLines(string $filename, array $lines) : void
    {
        if (empty($lines)) {
            return;
        }
        if (!isset($this->lineCoverage[$filename])) {
            return;
        }
        $this->lineCoverage[$filename] = \array_diff_key($this->lineCoverage[$filename], \array_flip($lines));
        if (isset($this->functionCoverage[$filename])) {
            foreach ($this->functionCoverage[$filename] as $functionName => $functionData) {
                foreach ($functionData['branches'] as $branchId => $branch) {
                    if (\count(\array_intersect($lines, \range($branch['line_start'], $branch['line_end']))) > 0) {
                        unset($this->functionCoverage[$filename][$functionName]['branches'][$branchId]);
                        foreach ($functionData['paths'] as $pathId => $path) {
                            if (\in_array($branchId, $path['path'], \true)) {
                                unset($this->functionCoverage[$filename][$functionName]['paths'][$pathId]);
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * At the end of a file, the PHP interpreter always sees an implicit return. Where this occurs in a file that has
     * e.g. a class definition, that line cannot be invoked from a test and results in confusing coverage. This engine
     * implementation detail therefore needs to be masked which is done here by simply ensuring that all empty lines
     * are skipped over for coverage purposes.
     *
     * @see https://github.com/sebastianbergmann/php-code-coverage/issues/799
     */
    private function skipEmptyLines() : void
    {
        foreach ($this->lineCoverage as $filename => $coverage) {
            foreach ($this->getEmptyLinesForFile($filename) as $emptyLine) {
                unset($this->lineCoverage[$filename][$emptyLine]);
            }
        }
    }
    private function getEmptyLinesForFile(string $filename) : array
    {
        if (!isset(self::$emptyLineCache[$filename])) {
            self::$emptyLineCache[$filename] = [];
            if (\is_file($filename)) {
                $sourceLines = \explode("\n", \file_get_contents($filename));
                foreach ($sourceLines as $line => $source) {
                    if (\trim($source) === '') {
                        self::$emptyLineCache[$filename][] = $line + 1;
                    }
                }
            }
        }
        return self::$emptyLineCache[$filename];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report;

use function count;
use function dirname;
use function file_put_contents;
use function is_string;
use function ksort;
use function max;
use function range;
use function time;
use DOMDocument;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Directory;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\File;
final class Clover
{
    /**
     * @throws WriteOperationFailedException
     */
    public function process(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null, ?string $name = null) : string
    {
        $time = (string) \time();
        $xmlDocument = new \DOMDocument('1.0', 'UTF-8');
        $xmlDocument->formatOutput = \true;
        $xmlCoverage = $xmlDocument->createElement('coverage');
        $xmlCoverage->setAttribute('generated', $time);
        $xmlDocument->appendChild($xmlCoverage);
        $xmlProject = $xmlDocument->createElement('project');
        $xmlProject->setAttribute('timestamp', $time);
        if (\is_string($name)) {
            $xmlProject->setAttribute('name', $name);
        }
        $xmlCoverage->appendChild($xmlProject);
        $packages = [];
        $report = $coverage->getReport();
        foreach ($report as $item) {
            if (!$item instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\File) {
                continue;
            }
            /* @var File $item */
            $xmlFile = $xmlDocument->createElement('file');
            $xmlFile->setAttribute('name', $item->pathAsString());
            $classes = $item->classesAndTraits();
            $coverageData = $item->lineCoverageData();
            $lines = [];
            $namespace = 'global';
            foreach ($classes as $className => $class) {
                $classStatements = 0;
                $coveredClassStatements = 0;
                $coveredMethods = 0;
                $classMethods = 0;
                foreach ($class['methods'] as $methodName => $method) {
                    if ($method['executableLines'] == 0) {
                        continue;
                    }
                    $classMethods++;
                    $classStatements += $method['executableLines'];
                    $coveredClassStatements += $method['executedLines'];
                    if ($method['coverage'] == 100) {
                        $coveredMethods++;
                    }
                    $methodCount = 0;
                    foreach (\range($method['startLine'], $method['endLine']) as $line) {
                        if (isset($coverageData[$line]) && $coverageData[$line] !== null) {
                            $methodCount = \max($methodCount, \count($coverageData[$line]));
                        }
                    }
                    $lines[$method['startLine']] = ['ccn' => $method['ccn'], 'count' => $methodCount, 'crap' => $method['crap'], 'type' => 'method', 'visibility' => $method['visibility'], 'name' => $methodName];
                }
                if (!empty($class['package']['namespace'])) {
                    $namespace = $class['package']['namespace'];
                }
                $xmlClass = $xmlDocument->createElement('class');
                $xmlClass->setAttribute('name', $className);
                $xmlClass->setAttribute('namespace', $namespace);
                if (!empty($class['package']['fullPackage'])) {
                    $xmlClass->setAttribute('fullPackage', $class['package']['fullPackage']);
                }
                if (!empty($class['package']['category'])) {
                    $xmlClass->setAttribute('category', $class['package']['category']);
                }
                if (!empty($class['package']['package'])) {
                    $xmlClass->setAttribute('package', $class['package']['package']);
                }
                if (!empty($class['package']['subpackage'])) {
                    $xmlClass->setAttribute('subpackage', $class['package']['subpackage']);
                }
                $xmlFile->appendChild($xmlClass);
                $xmlMetrics = $xmlDocument->createElement('metrics');
                $xmlMetrics->setAttribute('complexity', (string) $class['ccn']);
                $xmlMetrics->setAttribute('methods', (string) $classMethods);
                $xmlMetrics->setAttribute('coveredmethods', (string) $coveredMethods);
                $xmlMetrics->setAttribute('conditionals', (string) $class['executableBranches']);
                $xmlMetrics->setAttribute('coveredconditionals', (string) $class['executedBranches']);
                $xmlMetrics->setAttribute('statements', (string) $classStatements);
                $xmlMetrics->setAttribute('coveredstatements', (string) $coveredClassStatements);
                $xmlMetrics->setAttribute('elements', (string) ($classMethods + $classStatements + $class['executableBranches']));
                $xmlMetrics->setAttribute('coveredelements', (string) ($coveredMethods + $coveredClassStatements + $class['executedBranches']));
                $xmlClass->appendChild($xmlMetrics);
            }
            foreach ($coverageData as $line => $data) {
                if ($data === null || isset($lines[$line])) {
                    continue;
                }
                $lines[$line] = ['count' => \count($data), 'type' => 'stmt'];
            }
            \ksort($lines);
            foreach ($lines as $line => $data) {
                $xmlLine = $xmlDocument->createElement('line');
                $xmlLine->setAttribute('num', (string) $line);
                $xmlLine->setAttribute('type', $data['type']);
                if (isset($data['name'])) {
                    $xmlLine->setAttribute('name', $data['name']);
                }
                if (isset($data['visibility'])) {
                    $xmlLine->setAttribute('visibility', $data['visibility']);
                }
                if (isset($data['ccn'])) {
                    $xmlLine->setAttribute('complexity', (string) $data['ccn']);
                }
                if (isset($data['crap'])) {
                    $xmlLine->setAttribute('crap', (string) $data['crap']);
                }
                $xmlLine->setAttribute('count', (string) $data['count']);
                $xmlFile->appendChild($xmlLine);
            }
            $linesOfCode = $item->linesOfCode();
            $xmlMetrics = $xmlDocument->createElement('metrics');
            $xmlMetrics->setAttribute('loc', (string) $linesOfCode->linesOfCode());
            $xmlMetrics->setAttribute('ncloc', (string) $linesOfCode->nonCommentLinesOfCode());
            $xmlMetrics->setAttribute('classes', (string) $item->numberOfClassesAndTraits());
            $xmlMetrics->setAttribute('methods', (string) $item->numberOfMethods());
            $xmlMetrics->setAttribute('coveredmethods', (string) $item->numberOfTestedMethods());
            $xmlMetrics->setAttribute('conditionals', (string) $item->numberOfExecutableBranches());
            $xmlMetrics->setAttribute('coveredconditionals', (string) $item->numberOfExecutedBranches());
            $xmlMetrics->setAttribute('statements', (string) $item->numberOfExecutableLines());
            $xmlMetrics->setAttribute('coveredstatements', (string) $item->numberOfExecutedLines());
            $xmlMetrics->setAttribute('elements', (string) ($item->numberOfMethods() + $item->numberOfExecutableLines() + $item->numberOfExecutableBranches()));
            $xmlMetrics->setAttribute('coveredelements', (string) ($item->numberOfTestedMethods() + $item->numberOfExecutedLines() + $item->numberOfExecutedBranches()));
            $xmlFile->appendChild($xmlMetrics);
            if ($namespace === 'global') {
                $xmlProject->appendChild($xmlFile);
            } else {
                if (!isset($packages[$namespace])) {
                    $packages[$namespace] = $xmlDocument->createElement('package');
                    $packages[$namespace]->setAttribute('name', $namespace);
                    $xmlProject->appendChild($packages[$namespace]);
                }
                $packages[$namespace]->appendChild($xmlFile);
            }
        }
        $linesOfCode = $report->linesOfCode();
        $xmlMetrics = $xmlDocument->createElement('metrics');
        $xmlMetrics->setAttribute('files', (string) \count($report));
        $xmlMetrics->setAttribute('loc', (string) $linesOfCode->linesOfCode());
        $xmlMetrics->setAttribute('ncloc', (string) $linesOfCode->nonCommentLinesOfCode());
        $xmlMetrics->setAttribute('classes', (string) $report->numberOfClassesAndTraits());
        $xmlMetrics->setAttribute('methods', (string) $report->numberOfMethods());
        $xmlMetrics->setAttribute('coveredmethods', (string) $report->numberOfTestedMethods());
        $xmlMetrics->setAttribute('conditionals', (string) $report->numberOfExecutableBranches());
        $xmlMetrics->setAttribute('coveredconditionals', (string) $report->numberOfExecutedBranches());
        $xmlMetrics->setAttribute('statements', (string) $report->numberOfExecutableLines());
        $xmlMetrics->setAttribute('coveredstatements', (string) $report->numberOfExecutedLines());
        $xmlMetrics->setAttribute('elements', (string) ($report->numberOfMethods() + $report->numberOfExecutableLines() + $report->numberOfExecutableBranches()));
        $xmlMetrics->setAttribute('coveredelements', (string) ($report->numberOfTestedMethods() + $report->numberOfExecutedLines() + $report->numberOfExecutedBranches()));
        $xmlProject->appendChild($xmlMetrics);
        $buffer = $xmlDocument->saveXML();
        if ($target !== null) {
            \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create(\dirname($target));
            if (@\file_put_contents($target, $buffer) === \false) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException($target);
            }
        }
        return $buffer;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report;

use function count;
use function dirname;
use function file_put_contents;
use function range;
use function time;
use DOMImplementation;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Directory;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\File;
final class Cobertura
{
    /**
     * @throws WriteOperationFailedException
     */
    public function process(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null, ?string $name = null) : string
    {
        $time = (string) \time();
        $report = $coverage->getReport();
        $implementation = new \DOMImplementation();
        $documentType = $implementation->createDocumentType('coverage', '', 'http://cobertura.sourceforge.net/xml/coverage-04.dtd');
        $document = $implementation->createDocument('', '', $documentType);
        $document->xmlVersion = '1.0';
        $document->encoding = 'UTF-8';
        $document->formatOutput = \true;
        $coverageElement = $document->createElement('coverage');
        $linesValid = $report->numberOfExecutableLines();
        $linesCovered = $report->numberOfExecutedLines();
        $lineRate = $linesValid === 0 ? 0 : $linesCovered / $linesValid;
        $coverageElement->setAttribute('line-rate', (string) $lineRate);
        $branchesValid = $report->numberOfExecutableBranches();
        $branchesCovered = $report->numberOfExecutedBranches();
        $branchRate = $branchesValid === 0 ? 0 : $branchesCovered / $branchesValid;
        $coverageElement->setAttribute('branch-rate', (string) $branchRate);
        $coverageElement->setAttribute('lines-covered', (string) $report->numberOfExecutedLines());
        $coverageElement->setAttribute('lines-valid', (string) $report->numberOfExecutableLines());
        $coverageElement->setAttribute('branches-covered', (string) $report->numberOfExecutedBranches());
        $coverageElement->setAttribute('branches-valid', (string) $report->numberOfExecutableBranches());
        $coverageElement->setAttribute('complexity', '');
        $coverageElement->setAttribute('version', '0.4');
        $coverageElement->setAttribute('timestamp', $time);
        $document->appendChild($coverageElement);
        $sourcesElement = $document->createElement('sources');
        $coverageElement->appendChild($sourcesElement);
        $sourceElement = $document->createElement('source', $report->pathAsString());
        $sourcesElement->appendChild($sourceElement);
        $packagesElement = $document->createElement('packages');
        $coverageElement->appendChild($packagesElement);
        $complexity = 0;
        foreach ($report as $item) {
            if (!$item instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\File) {
                continue;
            }
            $packageElement = $document->createElement('package');
            $packageComplexity = 0;
            $packageName = $name ?? '';
            $packageElement->setAttribute('name', $packageName);
            $linesValid = $item->numberOfExecutableLines();
            $linesCovered = $item->numberOfExecutedLines();
            $lineRate = $linesValid === 0 ? 0 : $linesCovered / $linesValid;
            $packageElement->setAttribute('line-rate', (string) $lineRate);
            $branchesValid = $item->numberOfExecutableBranches();
            $branchesCovered = $item->numberOfExecutedBranches();
            $branchRate = $branchesValid === 0 ? 0 : $branchesCovered / $branchesValid;
            $packageElement->setAttribute('branch-rate', (string) $branchRate);
            $packageElement->setAttribute('complexity', '');
            $packagesElement->appendChild($packageElement);
            $classesElement = $document->createElement('classes');
            $packageElement->appendChild($classesElement);
            $classes = $item->classesAndTraits();
            $coverageData = $item->lineCoverageData();
            foreach ($classes as $className => $class) {
                $complexity += $class['ccn'];
                $packageComplexity += $class['ccn'];
                if (!empty($class['package']['namespace'])) {
                    $className = $class['package']['namespace'] . '\\' . $className;
                }
                $linesValid = $class['executableLines'];
                $linesCovered = $class['executedLines'];
                $lineRate = $linesValid === 0 ? 0 : $linesCovered / $linesValid;
                $branchesValid = $class['executableBranches'];
                $branchesCovered = $class['executedBranches'];
                $branchRate = $branchesValid === 0 ? 0 : $branchesCovered / $branchesValid;
                $classElement = $document->createElement('class');
                $classElement->setAttribute('name', $className);
                $classElement->setAttribute('filename', \str_replace($report->pathAsString() . \DIRECTORY_SEPARATOR, '', $item->pathAsString()));
                $classElement->setAttribute('line-rate', (string) $lineRate);
                $classElement->setAttribute('branch-rate', (string) $branchRate);
                $classElement->setAttribute('complexity', (string) $class['ccn']);
                $classesElement->appendChild($classElement);
                $methodsElement = $document->createElement('methods');
                $classElement->appendChild($methodsElement);
                $classLinesElement = $document->createElement('lines');
                $classElement->appendChild($classLinesElement);
                foreach ($class['methods'] as $methodName => $method) {
                    if ($method['executableLines'] === 0) {
                        continue;
                    }
                    \preg_match("/\\((.*?)\\)/", $method['signature'], $signature);
                    $linesValid = $method['executableLines'];
                    $linesCovered = $method['executedLines'];
                    $lineRate = $linesValid === 0 ? 0 : $linesCovered / $linesValid;
                    $branchesValid = $method['executableBranches'];
                    $branchesCovered = $method['executedBranches'];
                    $branchRate = $branchesValid === 0 ? 0 : $branchesCovered / $branchesValid;
                    $methodElement = $document->createElement('method');
                    $methodElement->setAttribute('name', $methodName);
                    $methodElement->setAttribute('signature', $signature[1]);
                    $methodElement->setAttribute('line-rate', (string) $lineRate);
                    $methodElement->setAttribute('branch-rate', (string) $branchRate);
                    $methodElement->setAttribute('complexity', (string) $method['ccn']);
                    $methodLinesElement = $document->createElement('lines');
                    $methodElement->appendChild($methodLinesElement);
                    foreach (\range($method['startLine'], $method['endLine']) as $line) {
                        if (!isset($coverageData[$line]) || $coverageData[$line] === null) {
                            continue;
                        }
                        $methodLineElement = $document->createElement('line');
                        $methodLineElement->setAttribute('number', (string) $line);
                        $methodLineElement->setAttribute('hits', (string) \count($coverageData[$line]));
                        $methodLinesElement->appendChild($methodLineElement);
                        $classLineElement = $methodLineElement->cloneNode();
                        $classLinesElement->appendChild($classLineElement);
                    }
                    $methodsElement->appendChild($methodElement);
                }
            }
            if ($report->numberOfFunctions() === 0) {
                $packageElement->setAttribute('complexity', (string) $packageComplexity);
                continue;
            }
            $functionsComplexity = 0;
            $functionsLinesValid = 0;
            $functionsLinesCovered = 0;
            $functionsBranchesValid = 0;
            $functionsBranchesCovered = 0;
            $classElement = $document->createElement('class');
            $classElement->setAttribute('name', \basename($item->pathAsString()));
            $classElement->setAttribute('filename', \str_replace($report->pathAsString() . \DIRECTORY_SEPARATOR, '', $item->pathAsString()));
            $methodsElement = $document->createElement('methods');
            $classElement->appendChild($methodsElement);
            $classLinesElement = $document->createElement('lines');
            $classElement->appendChild($classLinesElement);
            $functions = $report->functions();
            foreach ($functions as $functionName => $function) {
                if ($function['executableLines'] === 0) {
                    continue;
                }
                $complexity += $function['ccn'];
                $packageComplexity += $function['ccn'];
                $functionsComplexity += $function['ccn'];
                $linesValid = $function['executableLines'];
                $linesCovered = $function['executedLines'];
                $lineRate = $linesValid === 0 ? 0 : $linesCovered / $linesValid;
                $functionsLinesValid += $linesValid;
                $functionsLinesCovered += $linesCovered;
                $branchesValid = $function['executableBranches'];
                $branchesCovered = $function['executedBranches'];
                $branchRate = $branchesValid === 0 ? 0 : $branchesCovered / $branchesValid;
                $functionsBranchesValid += $branchesValid;
                $functionsBranchesCovered += $branchesValid;
                $methodElement = $document->createElement('method');
                $methodElement->setAttribute('name', $functionName);
                $methodElement->setAttribute('signature', $function['signature']);
                $methodElement->setAttribute('line-rate', (string) $lineRate);
                $methodElement->setAttribute('branch-rate', (string) $branchRate);
                $methodElement->setAttribute('complexity', (string) $function['ccn']);
                $methodLinesElement = $document->createElement('lines');
                $methodElement->appendChild($methodLinesElement);
                foreach (\range($function['startLine'], $function['endLine']) as $line) {
                    if (!isset($coverageData[$line]) || $coverageData[$line] === null) {
                        continue;
                    }
                    $methodLineElement = $document->createElement('line');
                    $methodLineElement->setAttribute('number', (string) $line);
                    $methodLineElement->setAttribute('hits', (string) \count($coverageData[$line]));
                    $methodLinesElement->appendChild($methodLineElement);
                    $classLineElement = $methodLineElement->cloneNode();
                    $classLinesElement->appendChild($classLineElement);
                }
                $methodsElement->appendChild($methodElement);
            }
            $packageElement->setAttribute('complexity', (string) $packageComplexity);
            if ($functionsLinesValid === 0) {
                continue;
            }
            $lineRate = $functionsLinesCovered / $functionsLinesValid;
            $branchRate = $functionsBranchesValid === 0 ? 0 : $functionsBranchesCovered / $functionsBranchesValid;
            $classElement->setAttribute('line-rate', (string) $lineRate);
            $classElement->setAttribute('branch-rate', (string) $branchRate);
            $classElement->setAttribute('complexity', (string) $functionsComplexity);
            $classesElement->appendChild($classElement);
        }
        $coverageElement->setAttribute('complexity', (string) $complexity);
        $buffer = $document->saveXML();
        if ($target !== null) {
            \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create(\dirname($target));
            if (@\file_put_contents($target, $buffer) === \false) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException($target);
            }
        }
        return $buffer;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report;

use function date;
use function dirname;
use function file_put_contents;
use function htmlspecialchars;
use function is_string;
use function round;
use DOMDocument;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Directory;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\File;
final class Crap4j
{
    private int $threshold;
    public function __construct(int $threshold = 30)
    {
        $this->threshold = $threshold;
    }
    /**
     * @throws WriteOperationFailedException
     */
    public function process(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null, ?string $name = null) : string
    {
        $document = new \DOMDocument('1.0', 'UTF-8');
        $document->formatOutput = \true;
        $root = $document->createElement('crap_result');
        $document->appendChild($root);
        $project = $document->createElement('project', \is_string($name) ? $name : '');
        $root->appendChild($project);
        $root->appendChild($document->createElement('timestamp', \date('Y-m-d H:i:s')));
        $stats = $document->createElement('stats');
        $methodsNode = $document->createElement('methods');
        $report = $coverage->getReport();
        unset($coverage);
        $fullMethodCount = 0;
        $fullCrapMethodCount = 0;
        $fullCrapLoad = 0;
        $fullCrap = 0;
        foreach ($report as $item) {
            $namespace = 'global';
            if (!$item instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\File) {
                continue;
            }
            $file = $document->createElement('file');
            $file->setAttribute('name', $item->pathAsString());
            $classes = $item->classesAndTraits();
            foreach ($classes as $className => $class) {
                foreach ($class['methods'] as $methodName => $method) {
                    $crapLoad = $this->crapLoad((float) $method['crap'], $method['ccn'], $method['coverage']);
                    $fullCrap += $method['crap'];
                    $fullCrapLoad += $crapLoad;
                    $fullMethodCount++;
                    if ($method['crap'] >= $this->threshold) {
                        $fullCrapMethodCount++;
                    }
                    $methodNode = $document->createElement('method');
                    if (!empty($class['namespace'])) {
                        $namespace = $class['namespace'];
                    }
                    $methodNode->appendChild($document->createElement('package', $namespace));
                    $methodNode->appendChild($document->createElement('className', $className));
                    $methodNode->appendChild($document->createElement('methodName', $methodName));
                    $methodNode->appendChild($document->createElement('methodSignature', \htmlspecialchars($method['signature'])));
                    $methodNode->appendChild($document->createElement('fullMethod', \htmlspecialchars($method['signature'])));
                    $methodNode->appendChild($document->createElement('crap', (string) $this->roundValue((float) $method['crap'])));
                    $methodNode->appendChild($document->createElement('complexity', (string) $method['ccn']));
                    $methodNode->appendChild($document->createElement('coverage', (string) $this->roundValue($method['coverage'])));
                    $methodNode->appendChild($document->createElement('crapLoad', (string) \round($crapLoad)));
                    $methodsNode->appendChild($methodNode);
                }
            }
        }
        $stats->appendChild($document->createElement('name', 'Method Crap Stats'));
        $stats->appendChild($document->createElement('methodCount', (string) $fullMethodCount));
        $stats->appendChild($document->createElement('crapMethodCount', (string) $fullCrapMethodCount));
        $stats->appendChild($document->createElement('crapLoad', (string) \round($fullCrapLoad)));
        $stats->appendChild($document->createElement('totalCrap', (string) $fullCrap));
        $crapMethodPercent = 0;
        if ($fullMethodCount > 0) {
            $crapMethodPercent = $this->roundValue(100 * $fullCrapMethodCount / $fullMethodCount);
        }
        $stats->appendChild($document->createElement('crapMethodPercent', (string) $crapMethodPercent));
        $root->appendChild($stats);
        $root->appendChild($methodsNode);
        $buffer = $document->saveXML();
        if ($target !== null) {
            \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create(\dirname($target));
            if (@\file_put_contents($target, $buffer) === \false) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException($target);
            }
        }
        return $buffer;
    }
    private function crapLoad(float $crapValue, int $cyclomaticComplexity, float $coveragePercent) : float
    {
        $crapLoad = 0;
        if ($crapValue >= $this->threshold) {
            $crapLoad += $cyclomaticComplexity * (1.0 - $coveragePercent / 100);
            $crapLoad += $cyclomaticComplexity / $this->threshold;
        }
        return $crapLoad;
    }
    private function roundValue(float $value) : float
    {
        return \round($value, 2);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Html;

use const DIRECTORY_SEPARATOR;
use function copy;
use function date;
use function dirname;
use function substr;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Directory as DirectoryUtil;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
final class Facade
{
    private string $templatePath;
    private string $generator;
    private int $lowUpperBound;
    private int $highLowerBound;
    public function __construct(int $lowUpperBound = 50, int $highLowerBound = 90, string $generator = '')
    {
        $this->generator = $generator;
        $this->highLowerBound = $highLowerBound;
        $this->lowUpperBound = $lowUpperBound;
        $this->templatePath = __DIR__ . '/Renderer/Template/';
    }
    public function process(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, string $target) : void
    {
        $target = $this->directory($target);
        $report = $coverage->getReport();
        $date = \date('D M j G:i:s T Y');
        $dashboard = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\Dashboard($this->templatePath, $this->generator, $date, $this->lowUpperBound, $this->highLowerBound, $coverage->collectsBranchAndPathCoverage());
        $directory = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\Directory($this->templatePath, $this->generator, $date, $this->lowUpperBound, $this->highLowerBound, $coverage->collectsBranchAndPathCoverage());
        $file = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\File($this->templatePath, $this->generator, $date, $this->lowUpperBound, $this->highLowerBound, $coverage->collectsBranchAndPathCoverage());
        $directory->render($report, $target . 'index.html');
        $dashboard->render($report, $target . 'dashboard.html');
        foreach ($report as $node) {
            $id = $node->id();
            if ($node instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory) {
                \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create($target . $id);
                $directory->render($node, $target . $id . '/index.html');
                $dashboard->render($node, $target . $id . '/dashboard.html');
            } else {
                $dir = \dirname($target . $id);
                \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create($dir);
                $file->render($node, $target . $id);
            }
        }
        $this->copyFiles($target);
    }
    private function copyFiles(string $target) : void
    {
        $dir = $this->directory($target . '_css');
        \copy($this->templatePath . 'css/bootstrap.min.css', $dir . 'bootstrap.min.css');
        \copy($this->templatePath . 'css/nv.d3.min.css', $dir . 'nv.d3.min.css');
        \copy($this->templatePath . 'css/style.css', $dir . 'style.css');
        \copy($this->templatePath . 'css/custom.css', $dir . 'custom.css');
        \copy($this->templatePath . 'css/octicons.css', $dir . 'octicons.css');
        $dir = $this->directory($target . '_icons');
        \copy($this->templatePath . 'icons/file-code.svg', $dir . 'file-code.svg');
        \copy($this->templatePath . 'icons/file-directory.svg', $dir . 'file-directory.svg');
        $dir = $this->directory($target . '_js');
        \copy($this->templatePath . 'js/bootstrap.min.js', $dir . 'bootstrap.min.js');
        \copy($this->templatePath . 'js/popper.min.js', $dir . 'popper.min.js');
        \copy($this->templatePath . 'js/d3.min.js', $dir . 'd3.min.js');
        \copy($this->templatePath . 'js/jquery.min.js', $dir . 'jquery.min.js');
        \copy($this->templatePath . 'js/nv.d3.min.js', $dir . 'nv.d3.min.js');
        \copy($this->templatePath . 'js/file.js', $dir . 'file.js');
    }
    private function directory(string $directory) : string
    {
        if (\substr($directory, -1, 1) != \DIRECTORY_SEPARATOR) {
            $directory .= \DIRECTORY_SEPARATOR;
        }
        \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create($directory);
        return $directory;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Html;

use function array_pop;
use function count;
use function phpversion;
use function sprintf;
use function str_repeat;
use function substr_count;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\File as FileNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Version;
use PHPUnit\SebastianBergmann\Environment\Runtime;
use PHPUnit\SebastianBergmann\Template\Template;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
abstract class Renderer
{
    protected string $templatePath;
    protected string $generator;
    protected string $date;
    protected int $lowUpperBound;
    protected int $highLowerBound;
    protected bool $hasBranchCoverage;
    protected string $version;
    public function __construct(string $templatePath, string $generator, string $date, int $lowUpperBound, int $highLowerBound, bool $hasBranchCoverage)
    {
        $this->templatePath = $templatePath;
        $this->generator = $generator;
        $this->date = $date;
        $this->lowUpperBound = $lowUpperBound;
        $this->highLowerBound = $highLowerBound;
        $this->version = \PHPUnit\SebastianBergmann\CodeCoverage\Version::id();
        $this->hasBranchCoverage = $hasBranchCoverage;
    }
    protected function renderItemTemplate(\PHPUnit\SebastianBergmann\Template\Template $template, array $data) : string
    {
        $numSeparator = '&nbsp;/&nbsp;';
        if (isset($data['numClasses']) && $data['numClasses'] > 0) {
            $classesLevel = $this->colorLevel($data['testedClassesPercent']);
            $classesNumber = $data['numTestedClasses'] . $numSeparator . $data['numClasses'];
            $classesBar = $this->coverageBar($data['testedClassesPercent']);
        } else {
            $classesLevel = '';
            $classesNumber = '0' . $numSeparator . '0';
            $classesBar = '';
            $data['testedClassesPercentAsString'] = 'n/a';
        }
        if ($data['numMethods'] > 0) {
            $methodsLevel = $this->colorLevel($data['testedMethodsPercent']);
            $methodsNumber = $data['numTestedMethods'] . $numSeparator . $data['numMethods'];
            $methodsBar = $this->coverageBar($data['testedMethodsPercent']);
        } else {
            $methodsLevel = '';
            $methodsNumber = '0' . $numSeparator . '0';
            $methodsBar = '';
            $data['testedMethodsPercentAsString'] = 'n/a';
        }
        if ($data['numExecutableLines'] > 0) {
            $linesLevel = $this->colorLevel($data['linesExecutedPercent']);
            $linesNumber = $data['numExecutedLines'] . $numSeparator . $data['numExecutableLines'];
            $linesBar = $this->coverageBar($data['linesExecutedPercent']);
        } else {
            $linesLevel = '';
            $linesNumber = '0' . $numSeparator . '0';
            $linesBar = '';
            $data['linesExecutedPercentAsString'] = 'n/a';
        }
        if ($data['numExecutablePaths'] > 0) {
            $pathsLevel = $this->colorLevel($data['pathsExecutedPercent']);
            $pathsNumber = $data['numExecutedPaths'] . $numSeparator . $data['numExecutablePaths'];
            $pathsBar = $this->coverageBar($data['pathsExecutedPercent']);
        } else {
            $pathsLevel = '';
            $pathsNumber = '0' . $numSeparator . '0';
            $pathsBar = '';
            $data['pathsExecutedPercentAsString'] = 'n/a';
        }
        if ($data['numExecutableBranches'] > 0) {
            $branchesLevel = $this->colorLevel($data['branchesExecutedPercent']);
            $branchesNumber = $data['numExecutedBranches'] . $numSeparator . $data['numExecutableBranches'];
            $branchesBar = $this->coverageBar($data['branchesExecutedPercent']);
        } else {
            $branchesLevel = '';
            $branchesNumber = '0' . $numSeparator . '0';
            $branchesBar = '';
            $data['branchesExecutedPercentAsString'] = 'n/a';
        }
        $template->setVar(['icon' => $data['icon'] ?? '', 'crap' => $data['crap'] ?? '', 'name' => $data['name'], 'lines_bar' => $linesBar, 'lines_executed_percent' => $data['linesExecutedPercentAsString'], 'lines_level' => $linesLevel, 'lines_number' => $linesNumber, 'paths_bar' => $pathsBar, 'paths_executed_percent' => $data['pathsExecutedPercentAsString'], 'paths_level' => $pathsLevel, 'paths_number' => $pathsNumber, 'branches_bar' => $branchesBar, 'branches_executed_percent' => $data['branchesExecutedPercentAsString'], 'branches_level' => $branchesLevel, 'branches_number' => $branchesNumber, 'methods_bar' => $methodsBar, 'methods_tested_percent' => $data['testedMethodsPercentAsString'], 'methods_level' => $methodsLevel, 'methods_number' => $methodsNumber, 'classes_bar' => $classesBar, 'classes_tested_percent' => $data['testedClassesPercentAsString'] ?? '', 'classes_level' => $classesLevel, 'classes_number' => $classesNumber]);
        return $template->render();
    }
    protected function setCommonTemplateVariables(\PHPUnit\SebastianBergmann\Template\Template $template, \PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node) : void
    {
        $template->setVar(['id' => $node->id(), 'full_path' => $node->pathAsString(), 'path_to_root' => $this->pathToRoot($node), 'breadcrumbs' => $this->breadcrumbs($node), 'date' => $this->date, 'version' => $this->version, 'runtime' => $this->runtimeString(), 'generator' => $this->generator, 'low_upper_bound' => $this->lowUpperBound, 'high_lower_bound' => $this->highLowerBound]);
    }
    protected function breadcrumbs(\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node) : string
    {
        $breadcrumbs = '';
        $path = $node->pathAsArray();
        $pathToRoot = [];
        $max = \count($path);
        if ($node instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\File) {
            $max--;
        }
        for ($i = 0; $i < $max; $i++) {
            $pathToRoot[] = \str_repeat('../', $i);
        }
        foreach ($path as $step) {
            if ($step !== $node) {
                $breadcrumbs .= $this->inactiveBreadcrumb($step, \array_pop($pathToRoot));
            } else {
                $breadcrumbs .= $this->activeBreadcrumb($step);
            }
        }
        return $breadcrumbs;
    }
    protected function activeBreadcrumb(\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node) : string
    {
        $buffer = \sprintf('         <li class="breadcrumb-item active">%s</li>' . "\n", $node->name());
        if ($node instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory) {
            $buffer .= '         <li class="breadcrumb-item">(<a href="dashboard.html">Dashboard</a>)</li>' . "\n";
        }
        return $buffer;
    }
    protected function inactiveBreadcrumb(\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node, string $pathToRoot) : string
    {
        return \sprintf('         <li class="breadcrumb-item"><a href="%sindex.html">%s</a></li>' . "\n", $pathToRoot, $node->name());
    }
    protected function pathToRoot(\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node) : string
    {
        $id = $node->id();
        $depth = \substr_count($id, '/');
        if ($id !== 'index' && $node instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory) {
            $depth++;
        }
        return \str_repeat('../', $depth);
    }
    protected function coverageBar(float $percent) : string
    {
        $level = $this->colorLevel($percent);
        $templateName = $this->templatePath . ($this->hasBranchCoverage ? 'coverage_bar_branch.html' : 'coverage_bar.html');
        $template = new \PHPUnit\SebastianBergmann\Template\Template($templateName, '{{', '}}');
        $template->setVar(['level' => $level, 'percent' => \sprintf('%.2F', $percent)]);
        return $template->render();
    }
    protected function colorLevel(float $percent) : string
    {
        if ($percent <= $this->lowUpperBound) {
            return 'danger';
        }
        if ($percent > $this->lowUpperBound && $percent < $this->highLowerBound) {
            return 'warning';
        }
        return 'success';
    }
    private function runtimeString() : string
    {
        $runtime = new \PHPUnit\SebastianBergmann\Environment\Runtime();
        $buffer = \sprintf('<a href="%s" target="_top">%s %s</a>', $runtime->getVendorUrl(), $runtime->getName(), $runtime->getVersion());
        if ($runtime->hasPHPDBGCodeCoverage()) {
            return $buffer;
        }
        if ($runtime->hasPCOV()) {
            $buffer .= \sprintf(' with <a href="https://github.com/krakjoe/pcov">PCOV %s</a>', \phpversion('pcov'));
        } elseif ($runtime->hasXdebug()) {
            $buffer .= \sprintf(' with <a href="https://xdebug.org/">Xdebug %s</a>', \phpversion('xdebug'));
        }
        return $buffer;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Html;

use function array_values;
use function arsort;
use function asort;
use function count;
use function explode;
use function floor;
use function json_encode;
use function sprintf;
use function str_replace;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
use PHPUnit\SebastianBergmann\Template\Template;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Dashboard extends \PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\Renderer
{
    public function render(\PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory $node, string $file) : void
    {
        $classes = $node->classesAndTraits();
        $templateName = $this->templatePath . ($this->hasBranchCoverage ? 'dashboard_branch.html' : 'dashboard.html');
        $template = new \PHPUnit\SebastianBergmann\Template\Template($templateName, '{{', '}}');
        $this->setCommonTemplateVariables($template, $node);
        $baseLink = $node->id() . '/';
        $complexity = $this->complexity($classes, $baseLink);
        $coverageDistribution = $this->coverageDistribution($classes);
        $insufficientCoverage = $this->insufficientCoverage($classes, $baseLink);
        $projectRisks = $this->projectRisks($classes, $baseLink);
        $template->setVar(['insufficient_coverage_classes' => $insufficientCoverage['class'], 'insufficient_coverage_methods' => $insufficientCoverage['method'], 'project_risks_classes' => $projectRisks['class'], 'project_risks_methods' => $projectRisks['method'], 'complexity_class' => $complexity['class'], 'complexity_method' => $complexity['method'], 'class_coverage_distribution' => $coverageDistribution['class'], 'method_coverage_distribution' => $coverageDistribution['method']]);
        $template->renderTo($file);
    }
    protected function activeBreadcrumb(\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node) : string
    {
        return \sprintf('         <li class="breadcrumb-item"><a href="index.html">%s</a></li>' . "\n" . '         <li class="breadcrumb-item active">(Dashboard)</li>' . "\n", $node->name());
    }
    /**
     * Returns the data for the Class/Method Complexity charts.
     */
    private function complexity(array $classes, string $baseLink) : array
    {
        $result = ['class' => [], 'method' => []];
        foreach ($classes as $className => $class) {
            foreach ($class['methods'] as $methodName => $method) {
                if ($className !== '*') {
                    $methodName = $className . '::' . $methodName;
                }
                $result['method'][] = [$method['coverage'], $method['ccn'], \sprintf('<a href="%s">%s</a>', \str_replace($baseLink, '', $method['link']), $methodName)];
            }
            $result['class'][] = [$class['coverage'], $class['ccn'], \sprintf('<a href="%s">%s</a>', \str_replace($baseLink, '', $class['link']), $className)];
        }
        return ['class' => \json_encode($result['class']), 'method' => \json_encode($result['method'])];
    }
    /**
     * Returns the data for the Class / Method Coverage Distribution chart.
     */
    private function coverageDistribution(array $classes) : array
    {
        $result = ['class' => ['0%' => 0, '0-10%' => 0, '10-20%' => 0, '20-30%' => 0, '30-40%' => 0, '40-50%' => 0, '50-60%' => 0, '60-70%' => 0, '70-80%' => 0, '80-90%' => 0, '90-100%' => 0, '100%' => 0], 'method' => ['0%' => 0, '0-10%' => 0, '10-20%' => 0, '20-30%' => 0, '30-40%' => 0, '40-50%' => 0, '50-60%' => 0, '60-70%' => 0, '70-80%' => 0, '80-90%' => 0, '90-100%' => 0, '100%' => 0]];
        foreach ($classes as $class) {
            foreach ($class['methods'] as $methodName => $method) {
                if ($method['coverage'] === 0) {
                    $result['method']['0%']++;
                } elseif ($method['coverage'] === 100) {
                    $result['method']['100%']++;
                } else {
                    $key = \floor($method['coverage'] / 10) * 10;
                    $key = $key . '-' . ($key + 10) . '%';
                    $result['method'][$key]++;
                }
            }
            if ($class['coverage'] === 0) {
                $result['class']['0%']++;
            } elseif ($class['coverage'] === 100) {
                $result['class']['100%']++;
            } else {
                $key = \floor($class['coverage'] / 10) * 10;
                $key = $key . '-' . ($key + 10) . '%';
                $result['class'][$key]++;
            }
        }
        return ['class' => \json_encode(\array_values($result['class'])), 'method' => \json_encode(\array_values($result['method']))];
    }
    /**
     * Returns the classes / methods with insufficient coverage.
     */
    private function insufficientCoverage(array $classes, string $baseLink) : array
    {
        $leastTestedClasses = [];
        $leastTestedMethods = [];
        $result = ['class' => '', 'method' => ''];
        foreach ($classes as $className => $class) {
            foreach ($class['methods'] as $methodName => $method) {
                if ($method['coverage'] < $this->highLowerBound) {
                    $key = $methodName;
                    if ($className !== '*') {
                        $key = $className . '::' . $methodName;
                    }
                    $leastTestedMethods[$key] = $method['coverage'];
                }
            }
            if ($class['coverage'] < $this->highLowerBound) {
                $leastTestedClasses[$className] = $class['coverage'];
            }
        }
        \asort($leastTestedClasses);
        \asort($leastTestedMethods);
        foreach ($leastTestedClasses as $className => $coverage) {
            $result['class'] .= \sprintf('       <tr><td><a href="%s">%s</a></td><td class="text-right">%d%%</td></tr>' . "\n", \str_replace($baseLink, '', $classes[$className]['link']), $className, $coverage);
        }
        foreach ($leastTestedMethods as $methodName => $coverage) {
            [$class, $method] = \explode('::', $methodName);
            $result['method'] .= \sprintf('       <tr><td><a href="%s"><abbr title="%s">%s</abbr></a></td><td class="text-right">%d%%</td></tr>' . "\n", \str_replace($baseLink, '', $classes[$class]['methods'][$method]['link']), $methodName, $method, $coverage);
        }
        return $result;
    }
    /**
     * Returns the project risks according to the CRAP index.
     */
    private function projectRisks(array $classes, string $baseLink) : array
    {
        $classRisks = [];
        $methodRisks = [];
        $result = ['class' => '', 'method' => ''];
        foreach ($classes as $className => $class) {
            foreach ($class['methods'] as $methodName => $method) {
                if ($method['coverage'] < $this->highLowerBound && $method['ccn'] > 1) {
                    $key = $methodName;
                    if ($className !== '*') {
                        $key = $className . '::' . $methodName;
                    }
                    $methodRisks[$key] = $method['crap'];
                }
            }
            if ($class['coverage'] < $this->highLowerBound && $class['ccn'] > \count($class['methods'])) {
                $classRisks[$className] = $class['crap'];
            }
        }
        \arsort($classRisks);
        \arsort($methodRisks);
        foreach ($classRisks as $className => $crap) {
            $result['class'] .= \sprintf('       <tr><td><a href="%s">%s</a></td><td class="text-right">%d</td></tr>' . "\n", \str_replace($baseLink, '', $classes[$className]['link']), $className, $crap);
        }
        foreach ($methodRisks as $methodName => $crap) {
            [$class, $method] = \explode('::', $methodName);
            $result['method'] .= \sprintf('       <tr><td><a href="%s"><abbr title="%s">%s</abbr></a></td><td class="text-right">%d</td></tr>' . "\n", \str_replace($baseLink, '', $classes[$class]['methods'][$method]['link']), $methodName, $method, $crap);
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Html;

use function count;
use function sprintf;
use function str_repeat;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode as Node;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
use PHPUnit\SebastianBergmann\Template\Template;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Directory extends \PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\Renderer
{
    public function render(\PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory $node, string $file) : void
    {
        $templateName = $this->templatePath . ($this->hasBranchCoverage ? 'directory_branch.html' : 'directory.html');
        $template = new \PHPUnit\SebastianBergmann\Template\Template($templateName, '{{', '}}');
        $this->setCommonTemplateVariables($template, $node);
        $items = $this->renderItem($node, \true);
        foreach ($node->directories() as $item) {
            $items .= $this->renderItem($item);
        }
        foreach ($node->files() as $item) {
            $items .= $this->renderItem($item);
        }
        $template->setVar(['id' => $node->id(), 'items' => $items]);
        $template->renderTo($file);
    }
    private function renderItem(\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node, bool $total = \false) : string
    {
        $data = ['numClasses' => $node->numberOfClassesAndTraits(), 'numTestedClasses' => $node->numberOfTestedClassesAndTraits(), 'numMethods' => $node->numberOfFunctionsAndMethods(), 'numTestedMethods' => $node->numberOfTestedFunctionsAndMethods(), 'linesExecutedPercent' => $node->percentageOfExecutedLines()->asFloat(), 'linesExecutedPercentAsString' => $node->percentageOfExecutedLines()->asString(), 'numExecutedLines' => $node->numberOfExecutedLines(), 'numExecutableLines' => $node->numberOfExecutableLines(), 'branchesExecutedPercent' => $node->percentageOfExecutedBranches()->asFloat(), 'branchesExecutedPercentAsString' => $node->percentageOfExecutedBranches()->asString(), 'numExecutedBranches' => $node->numberOfExecutedBranches(), 'numExecutableBranches' => $node->numberOfExecutableBranches(), 'pathsExecutedPercent' => $node->percentageOfExecutedPaths()->asFloat(), 'pathsExecutedPercentAsString' => $node->percentageOfExecutedPaths()->asString(), 'numExecutedPaths' => $node->numberOfExecutedPaths(), 'numExecutablePaths' => $node->numberOfExecutablePaths(), 'testedMethodsPercent' => $node->percentageOfTestedFunctionsAndMethods()->asFloat(), 'testedMethodsPercentAsString' => $node->percentageOfTestedFunctionsAndMethods()->asString(), 'testedClassesPercent' => $node->percentageOfTestedClassesAndTraits()->asFloat(), 'testedClassesPercentAsString' => $node->percentageOfTestedClassesAndTraits()->asString()];
        if ($total) {
            $data['name'] = 'Total';
        } else {
            $up = \str_repeat('../', \count($node->pathAsArray()) - 2);
            $data['icon'] = \sprintf('<img src="%s_icons/file-code.svg" class="octicon" />', $up);
            if ($node instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory) {
                $data['name'] = \sprintf('<a href="%s/index.html">%s</a>', $node->name(), $node->name());
                $data['icon'] = \sprintf('<img src="%s_icons/file-directory.svg" class="octicon" />', $up);
            } elseif ($this->hasBranchCoverage) {
                $data['name'] = \sprintf('%s <a class="small" href="%s.html">[line]</a> <a class="small" href="%s_branch.html">[branch]</a> <a class="small" href="%s_path.html">[path]</a>', $node->name(), $node->name(), $node->name(), $node->name());
            } else {
                $data['name'] = \sprintf('<a href="%s.html">%s</a>', $node->name(), $node->name());
            }
        }
        $templateName = $this->templatePath . ($this->hasBranchCoverage ? 'directory_item_branch.html' : 'directory_item.html');
        return $this->renderItemTemplate(new \PHPUnit\SebastianBergmann\Template\Template($templateName, '{{', '}}'), $data);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Html;

use const ENT_COMPAT;
use const ENT_HTML401;
use const ENT_SUBSTITUTE;
use const T_ABSTRACT;
use const T_ARRAY;
use const T_AS;
use const T_BREAK;
use const T_CALLABLE;
use const T_CASE;
use const T_CATCH;
use const T_CLASS;
use const T_CLONE;
use const T_COMMENT;
use const T_CONST;
use const T_CONTINUE;
use const T_DECLARE;
use const T_DEFAULT;
use const T_DO;
use const T_DOC_COMMENT;
use const T_ECHO;
use const T_ELSE;
use const T_ELSEIF;
use const T_EMPTY;
use const T_ENDDECLARE;
use const T_ENDFOR;
use const T_ENDFOREACH;
use const T_ENDIF;
use const T_ENDSWITCH;
use const T_ENDWHILE;
use const T_EVAL;
use const T_EXIT;
use const T_EXTENDS;
use const T_FINAL;
use const T_FINALLY;
use const T_FOR;
use const T_FOREACH;
use const T_FUNCTION;
use const T_GLOBAL;
use const T_GOTO;
use const T_HALT_COMPILER;
use const T_IF;
use const T_IMPLEMENTS;
use const T_INCLUDE;
use const T_INCLUDE_ONCE;
use const T_INLINE_HTML;
use const T_INSTANCEOF;
use const T_INSTEADOF;
use const T_INTERFACE;
use const T_ISSET;
use const T_LIST;
use const T_NAMESPACE;
use const T_NEW;
use const T_PRINT;
use const T_PRIVATE;
use const T_PROTECTED;
use const T_PUBLIC;
use const T_REQUIRE;
use const T_REQUIRE_ONCE;
use const T_RETURN;
use const T_STATIC;
use const T_SWITCH;
use const T_THROW;
use const T_TRAIT;
use const T_TRY;
use const T_UNSET;
use const T_USE;
use const T_VAR;
use const T_WHILE;
use const T_YIELD;
use const T_YIELD_FROM;
use function array_key_exists;
use function array_pop;
use function array_unique;
use function constant;
use function count;
use function defined;
use function explode;
use function file_get_contents;
use function htmlspecialchars;
use function is_string;
use function sprintf;
use function str_replace;
use function substr;
use function token_get_all;
use function trim;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\File as FileNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Percentage;
use PHPUnit\SebastianBergmann\Template\Template;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class File extends \PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\Renderer
{
    /**
     * @psalm-var array<int,true>
     */
    private static array $keywordTokens = [];
    private static array $formattedSourceCache = [];
    private int $htmlSpecialCharsFlags = \ENT_COMPAT | \ENT_HTML401 | \ENT_SUBSTITUTE;
    public function render(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $node, string $file) : void
    {
        $templateName = $this->templatePath . ($this->hasBranchCoverage ? 'file_branch.html' : 'file.html');
        $template = new \PHPUnit\SebastianBergmann\Template\Template($templateName, '{{', '}}');
        $this->setCommonTemplateVariables($template, $node);
        $template->setVar(['items' => $this->renderItems($node), 'lines' => $this->renderSourceWithLineCoverage($node), 'legend' => '<p><span class="success"><strong>Executed</strong></span><span class="danger"><strong>Not Executed</strong></span><span class="warning"><strong>Dead Code</strong></span></p>', 'structure' => '']);
        $template->renderTo($file . '.html');
        if ($this->hasBranchCoverage) {
            $template->setVar(['items' => $this->renderItems($node), 'lines' => $this->renderSourceWithBranchCoverage($node), 'legend' => '<p><span class="success"><strong>Fully covered</strong></span><span class="warning"><strong>Partially covered</strong></span><span class="danger"><strong>Not covered</strong></span></p>', 'structure' => $this->renderBranchStructure($node)]);
            $template->renderTo($file . '_branch.html');
            $template->setVar(['items' => $this->renderItems($node), 'lines' => $this->renderSourceWithPathCoverage($node), 'legend' => '<p><span class="success"><strong>Fully covered</strong></span><span class="warning"><strong>Partially covered</strong></span><span class="danger"><strong>Not covered</strong></span></p>', 'structure' => $this->renderPathStructure($node)]);
            $template->renderTo($file . '_path.html');
        }
    }
    private function renderItems(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $node) : string
    {
        $templateName = $this->templatePath . ($this->hasBranchCoverage ? 'file_item_branch.html' : 'file_item.html');
        $template = new \PHPUnit\SebastianBergmann\Template\Template($templateName, '{{', '}}');
        $methodTemplateName = $this->templatePath . ($this->hasBranchCoverage ? 'method_item_branch.html' : 'method_item.html');
        $methodItemTemplate = new \PHPUnit\SebastianBergmann\Template\Template($methodTemplateName, '{{', '}}');
        $items = $this->renderItemTemplate($template, ['name' => 'Total', 'numClasses' => $node->numberOfClassesAndTraits(), 'numTestedClasses' => $node->numberOfTestedClassesAndTraits(), 'numMethods' => $node->numberOfFunctionsAndMethods(), 'numTestedMethods' => $node->numberOfTestedFunctionsAndMethods(), 'linesExecutedPercent' => $node->percentageOfExecutedLines()->asFloat(), 'linesExecutedPercentAsString' => $node->percentageOfExecutedLines()->asString(), 'numExecutedLines' => $node->numberOfExecutedLines(), 'numExecutableLines' => $node->numberOfExecutableLines(), 'branchesExecutedPercent' => $node->percentageOfExecutedBranches()->asFloat(), 'branchesExecutedPercentAsString' => $node->percentageOfExecutedBranches()->asString(), 'numExecutedBranches' => $node->numberOfExecutedBranches(), 'numExecutableBranches' => $node->numberOfExecutableBranches(), 'pathsExecutedPercent' => $node->percentageOfExecutedPaths()->asFloat(), 'pathsExecutedPercentAsString' => $node->percentageOfExecutedPaths()->asString(), 'numExecutedPaths' => $node->numberOfExecutedPaths(), 'numExecutablePaths' => $node->numberOfExecutablePaths(), 'testedMethodsPercent' => $node->percentageOfTestedFunctionsAndMethods()->asFloat(), 'testedMethodsPercentAsString' => $node->percentageOfTestedFunctionsAndMethods()->asString(), 'testedClassesPercent' => $node->percentageOfTestedClassesAndTraits()->asFloat(), 'testedClassesPercentAsString' => $node->percentageOfTestedClassesAndTraits()->asString(), 'crap' => '<abbr title="Change Risk Anti-Patterns (CRAP) Index">CRAP</abbr>']);
        $items .= $this->renderFunctionItems($node->functions(), $methodItemTemplate);
        $items .= $this->renderTraitOrClassItems($node->traits(), $template, $methodItemTemplate);
        $items .= $this->renderTraitOrClassItems($node->classes(), $template, $methodItemTemplate);
        return $items;
    }
    private function renderTraitOrClassItems(array $items, \PHPUnit\SebastianBergmann\Template\Template $template, \PHPUnit\SebastianBergmann\Template\Template $methodItemTemplate) : string
    {
        $buffer = '';
        if (empty($items)) {
            return $buffer;
        }
        foreach ($items as $name => $item) {
            $numMethods = 0;
            $numTestedMethods = 0;
            foreach ($item['methods'] as $method) {
                if ($method['executableLines'] > 0) {
                    $numMethods++;
                    if ($method['executedLines'] === $method['executableLines']) {
                        $numTestedMethods++;
                    }
                }
            }
            if ($item['executableLines'] > 0) {
                $numClasses = 1;
                $numTestedClasses = $numTestedMethods === $numMethods ? 1 : 0;
                $linesExecutedPercentAsString = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedLines'], $item['executableLines'])->asString();
                $branchesExecutedPercentAsString = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedBranches'], $item['executableBranches'])->asString();
                $pathsExecutedPercentAsString = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedPaths'], $item['executablePaths'])->asString();
            } else {
                $numClasses = 0;
                $numTestedClasses = 0;
                $linesExecutedPercentAsString = 'n/a';
                $branchesExecutedPercentAsString = 'n/a';
                $pathsExecutedPercentAsString = 'n/a';
            }
            $testedMethodsPercentage = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($numTestedMethods, $numMethods);
            $testedClassesPercentage = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($numTestedMethods === $numMethods ? 1 : 0, 1);
            $buffer .= $this->renderItemTemplate($template, ['name' => $this->abbreviateClassName($name), 'numClasses' => $numClasses, 'numTestedClasses' => $numTestedClasses, 'numMethods' => $numMethods, 'numTestedMethods' => $numTestedMethods, 'linesExecutedPercent' => \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedLines'], $item['executableLines'])->asFloat(), 'linesExecutedPercentAsString' => $linesExecutedPercentAsString, 'numExecutedLines' => $item['executedLines'], 'numExecutableLines' => $item['executableLines'], 'branchesExecutedPercent' => \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedBranches'], $item['executableBranches'])->asFloat(), 'branchesExecutedPercentAsString' => $branchesExecutedPercentAsString, 'numExecutedBranches' => $item['executedBranches'], 'numExecutableBranches' => $item['executableBranches'], 'pathsExecutedPercent' => \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedPaths'], $item['executablePaths'])->asFloat(), 'pathsExecutedPercentAsString' => $pathsExecutedPercentAsString, 'numExecutedPaths' => $item['executedPaths'], 'numExecutablePaths' => $item['executablePaths'], 'testedMethodsPercent' => $testedMethodsPercentage->asFloat(), 'testedMethodsPercentAsString' => $testedMethodsPercentage->asString(), 'testedClassesPercent' => $testedClassesPercentage->asFloat(), 'testedClassesPercentAsString' => $testedClassesPercentage->asString(), 'crap' => $item['crap']]);
            foreach ($item['methods'] as $method) {
                $buffer .= $this->renderFunctionOrMethodItem($methodItemTemplate, $method, '&nbsp;');
            }
        }
        return $buffer;
    }
    private function renderFunctionItems(array $functions, \PHPUnit\SebastianBergmann\Template\Template $template) : string
    {
        if (empty($functions)) {
            return '';
        }
        $buffer = '';
        foreach ($functions as $function) {
            $buffer .= $this->renderFunctionOrMethodItem($template, $function);
        }
        return $buffer;
    }
    private function renderFunctionOrMethodItem(\PHPUnit\SebastianBergmann\Template\Template $template, array $item, string $indent = '') : string
    {
        $numMethods = 0;
        $numTestedMethods = 0;
        if ($item['executableLines'] > 0) {
            $numMethods = 1;
            if ($item['executedLines'] === $item['executableLines']) {
                $numTestedMethods = 1;
            }
        }
        $executedLinesPercentage = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedLines'], $item['executableLines']);
        $executedBranchesPercentage = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedBranches'], $item['executableBranches']);
        $executedPathsPercentage = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($item['executedPaths'], $item['executablePaths']);
        $testedMethodsPercentage = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($numTestedMethods, 1);
        return $this->renderItemTemplate($template, ['name' => \sprintf('%s<a href="#%d"><abbr title="%s">%s</abbr></a>', $indent, $item['startLine'], \htmlspecialchars($item['signature'], $this->htmlSpecialCharsFlags), $item['functionName'] ?? $item['methodName']), 'numMethods' => $numMethods, 'numTestedMethods' => $numTestedMethods, 'linesExecutedPercent' => $executedLinesPercentage->asFloat(), 'linesExecutedPercentAsString' => $executedLinesPercentage->asString(), 'numExecutedLines' => $item['executedLines'], 'numExecutableLines' => $item['executableLines'], 'branchesExecutedPercent' => $executedBranchesPercentage->asFloat(), 'branchesExecutedPercentAsString' => $executedBranchesPercentage->asString(), 'numExecutedBranches' => $item['executedBranches'], 'numExecutableBranches' => $item['executableBranches'], 'pathsExecutedPercent' => $executedPathsPercentage->asFloat(), 'pathsExecutedPercentAsString' => $executedPathsPercentage->asString(), 'numExecutedPaths' => $item['executedPaths'], 'numExecutablePaths' => $item['executablePaths'], 'testedMethodsPercent' => $testedMethodsPercentage->asFloat(), 'testedMethodsPercentAsString' => $testedMethodsPercentage->asString(), 'crap' => $item['crap']]);
    }
    private function renderSourceWithLineCoverage(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $node) : string
    {
        $linesTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'lines.html.dist', '{{', '}}');
        $singleLineTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'line.html.dist', '{{', '}}');
        $coverageData = $node->lineCoverageData();
        $testData = $node->testData();
        $codeLines = $this->loadFile($node->pathAsString());
        $lines = '';
        $i = 1;
        foreach ($codeLines as $line) {
            $trClass = '';
            $popoverContent = '';
            $popoverTitle = '';
            if (\array_key_exists($i, $coverageData)) {
                $numTests = $coverageData[$i] ? \count($coverageData[$i]) : 0;
                if ($coverageData[$i] === null) {
                    $trClass = 'warning';
                } elseif ($numTests === 0) {
                    $trClass = 'danger';
                } else {
                    if ($numTests > 1) {
                        $popoverTitle = $numTests . ' tests cover line ' . $i;
                    } else {
                        $popoverTitle = '1 test covers line ' . $i;
                    }
                    $lineCss = 'covered-by-large-tests';
                    $popoverContent = '<ul>';
                    foreach ($coverageData[$i] as $test) {
                        if ($lineCss === 'covered-by-large-tests' && $testData[$test]['size'] === 'medium') {
                            $lineCss = 'covered-by-medium-tests';
                        } elseif ($testData[$test]['size'] === 'small') {
                            $lineCss = 'covered-by-small-tests';
                        }
                        $popoverContent .= $this->createPopoverContentForTest($test, $testData[$test]);
                    }
                    $popoverContent .= '</ul>';
                    $trClass = $lineCss . ' popin';
                }
            }
            $popover = '';
            if (!empty($popoverTitle)) {
                $popover = \sprintf(' data-title="%s" data-content="%s" data-placement="top" data-html="true"', $popoverTitle, \htmlspecialchars($popoverContent, $this->htmlSpecialCharsFlags));
            }
            $lines .= $this->renderLine($singleLineTemplate, $i, $line, $trClass, $popover);
            $i++;
        }
        $linesTemplate->setVar(['lines' => $lines]);
        return $linesTemplate->render();
    }
    private function renderSourceWithBranchCoverage(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $node) : string
    {
        $linesTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'lines.html.dist', '{{', '}}');
        $singleLineTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'line.html.dist', '{{', '}}');
        $functionCoverageData = $node->functionCoverageData();
        $testData = $node->testData();
        $codeLines = $this->loadFile($node->pathAsString());
        $lineData = [];
        /** @var int $line */
        foreach (\array_keys($codeLines) as $line) {
            $lineData[$line + 1] = ['includedInBranches' => 0, 'includedInHitBranches' => 0, 'tests' => []];
        }
        foreach ($functionCoverageData as $method) {
            foreach ($method['branches'] as $branch) {
                foreach (\range($branch['line_start'], $branch['line_end']) as $line) {
                    if (!isset($lineData[$line])) {
                        // blank line at end of file is sometimes included here
                        continue;
                    }
                    $lineData[$line]['includedInBranches']++;
                    if ($branch['hit']) {
                        $lineData[$line]['includedInHitBranches']++;
                        $lineData[$line]['tests'] = \array_unique(\array_merge($lineData[$line]['tests'], $branch['hit']));
                    }
                }
            }
        }
        $lines = '';
        $i = 1;
        /** @var string $line */
        foreach ($codeLines as $line) {
            $trClass = '';
            $popover = '';
            if ($lineData[$i]['includedInBranches'] > 0) {
                $lineCss = 'success';
                if ($lineData[$i]['includedInHitBranches'] === 0) {
                    $lineCss = 'danger';
                } elseif ($lineData[$i]['includedInHitBranches'] !== $lineData[$i]['includedInBranches']) {
                    $lineCss = 'warning';
                }
                $popoverContent = '<ul>';
                if (\count($lineData[$i]['tests']) === 1) {
                    $popoverTitle = '1 test covers line ' . $i;
                } else {
                    $popoverTitle = \count($lineData[$i]['tests']) . ' tests cover line ' . $i;
                }
                $popoverTitle .= '. These are covering ' . $lineData[$i]['includedInHitBranches'] . ' out of the ' . $lineData[$i]['includedInBranches'] . ' code branches.';
                foreach ($lineData[$i]['tests'] as $test) {
                    $popoverContent .= $this->createPopoverContentForTest($test, $testData[$test]);
                }
                $popoverContent .= '</ul>';
                $trClass = $lineCss . ' popin';
                $popover = \sprintf(' data-title="%s" data-content="%s" data-placement="top" data-html="true"', $popoverTitle, \htmlspecialchars($popoverContent, $this->htmlSpecialCharsFlags));
            }
            $lines .= $this->renderLine($singleLineTemplate, $i, $line, $trClass, $popover);
            $i++;
        }
        $linesTemplate->setVar(['lines' => $lines]);
        return $linesTemplate->render();
    }
    private function renderSourceWithPathCoverage(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $node) : string
    {
        $linesTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'lines.html.dist', '{{', '}}');
        $singleLineTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'line.html.dist', '{{', '}}');
        $functionCoverageData = $node->functionCoverageData();
        $testData = $node->testData();
        $codeLines = $this->loadFile($node->pathAsString());
        $lineData = [];
        /** @var int $line */
        foreach (\array_keys($codeLines) as $line) {
            $lineData[$line + 1] = ['includedInPaths' => [], 'includedInHitPaths' => [], 'tests' => []];
        }
        foreach ($functionCoverageData as $method) {
            foreach ($method['paths'] as $pathId => $path) {
                foreach ($path['path'] as $branchTaken) {
                    foreach (\range($method['branches'][$branchTaken]['line_start'], $method['branches'][$branchTaken]['line_end']) as $line) {
                        if (!isset($lineData[$line])) {
                            continue;
                        }
                        $lineData[$line]['includedInPaths'][] = $pathId;
                        if ($path['hit']) {
                            $lineData[$line]['includedInHitPaths'][] = $pathId;
                            $lineData[$line]['tests'] = \array_unique(\array_merge($lineData[$line]['tests'], $path['hit']));
                        }
                    }
                }
            }
        }
        $lines = '';
        $i = 1;
        /** @var string $line */
        foreach ($codeLines as $line) {
            $trClass = '';
            $popover = '';
            $includedInPathsCount = \count(\array_unique($lineData[$i]['includedInPaths']));
            $includedInHitPathsCount = \count(\array_unique($lineData[$i]['includedInHitPaths']));
            if ($includedInPathsCount > 0) {
                $lineCss = 'success';
                if ($includedInHitPathsCount === 0) {
                    $lineCss = 'danger';
                } elseif ($includedInHitPathsCount !== $includedInPathsCount) {
                    $lineCss = 'warning';
                }
                $popoverContent = '<ul>';
                if (\count($lineData[$i]['tests']) === 1) {
                    $popoverTitle = '1 test covers line ' . $i;
                } else {
                    $popoverTitle = \count($lineData[$i]['tests']) . ' tests cover line ' . $i;
                }
                $popoverTitle .= '. These are covering ' . $includedInHitPathsCount . ' out of the ' . $includedInPathsCount . ' code paths.';
                foreach ($lineData[$i]['tests'] as $test) {
                    $popoverContent .= $this->createPopoverContentForTest($test, $testData[$test]);
                }
                $popoverContent .= '</ul>';
                $trClass = $lineCss . ' popin';
                $popover = \sprintf(' data-title="%s" data-content="%s" data-placement="top" data-html="true"', $popoverTitle, \htmlspecialchars($popoverContent, $this->htmlSpecialCharsFlags));
            }
            $lines .= $this->renderLine($singleLineTemplate, $i, $line, $trClass, $popover);
            $i++;
        }
        $linesTemplate->setVar(['lines' => $lines]);
        return $linesTemplate->render();
    }
    private function renderBranchStructure(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $node) : string
    {
        $branchesTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'branches.html.dist', '{{', '}}');
        $coverageData = $node->functionCoverageData();
        $testData = $node->testData();
        $codeLines = $this->loadFile($node->pathAsString());
        $branches = '';
        \ksort($coverageData);
        foreach ($coverageData as $methodName => $methodData) {
            if (!$methodData['branches']) {
                continue;
            }
            $branchStructure = '';
            foreach ($methodData['branches'] as $branch) {
                $branchStructure .= $this->renderBranchLines($branch, $codeLines, $testData);
            }
            if ($branchStructure !== '') {
                // don't show empty branches
                $branches .= '<h5 class="structure-heading"><a name="' . \htmlspecialchars($methodName, $this->htmlSpecialCharsFlags) . '">' . $this->abbreviateMethodName($methodName) . '</a></h5>' . "\n";
                $branches .= $branchStructure;
            }
        }
        $branchesTemplate->setVar(['branches' => $branches]);
        return $branchesTemplate->render();
    }
    private function renderBranchLines(array $branch, array $codeLines, array $testData) : string
    {
        $linesTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'lines.html.dist', '{{', '}}');
        $singleLineTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'line.html.dist', '{{', '}}');
        $lines = '';
        $branchLines = \range($branch['line_start'], $branch['line_end']);
        \sort($branchLines);
        // sometimes end_line < start_line
        /** @var int $line */
        foreach ($branchLines as $line) {
            if (!isset($codeLines[$line])) {
                // blank line at end of file is sometimes included here
                continue;
            }
            $popoverContent = '';
            $popoverTitle = '';
            $numTests = \count($branch['hit']);
            if ($numTests === 0) {
                $trClass = 'danger';
            } else {
                $lineCss = 'covered-by-large-tests';
                $popoverContent = '<ul>';
                if ($numTests > 1) {
                    $popoverTitle = $numTests . ' tests cover this branch';
                } else {
                    $popoverTitle = '1 test covers this branch';
                }
                foreach ($branch['hit'] as $test) {
                    if ($lineCss === 'covered-by-large-tests' && $testData[$test]['size'] === 'medium') {
                        $lineCss = 'covered-by-medium-tests';
                    } elseif ($testData[$test]['size'] === 'small') {
                        $lineCss = 'covered-by-small-tests';
                    }
                    $popoverContent .= $this->createPopoverContentForTest($test, $testData[$test]);
                }
                $trClass = $lineCss . ' popin';
            }
            $popover = '';
            if (!empty($popoverTitle)) {
                $popover = \sprintf(' data-title="%s" data-content="%s" data-placement="top" data-html="true"', $popoverTitle, \htmlspecialchars($popoverContent, $this->htmlSpecialCharsFlags));
            }
            $lines .= $this->renderLine($singleLineTemplate, $line, $codeLines[$line - 1], $trClass, $popover);
        }
        if ($lines === '') {
            return '';
        }
        $linesTemplate->setVar(['lines' => $lines]);
        return $linesTemplate->render();
    }
    private function renderPathStructure(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $node) : string
    {
        $pathsTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'paths.html.dist', '{{', '}}');
        $coverageData = $node->functionCoverageData();
        $testData = $node->testData();
        $codeLines = $this->loadFile($node->pathAsString());
        $paths = '';
        \ksort($coverageData);
        foreach ($coverageData as $methodName => $methodData) {
            if (!$methodData['paths']) {
                continue;
            }
            $pathStructure = '';
            if (\count($methodData['paths']) > 100) {
                $pathStructure .= '<p>' . \count($methodData['paths']) . ' is too many paths to sensibly render, consider refactoring your code to bring this number down.</p>';
                continue;
            }
            foreach ($methodData['paths'] as $path) {
                $pathStructure .= $this->renderPathLines($path, $methodData['branches'], $codeLines, $testData);
            }
            if ($pathStructure !== '') {
                $paths .= '<h5 class="structure-heading"><a name="' . \htmlspecialchars($methodName, $this->htmlSpecialCharsFlags) . '">' . $this->abbreviateMethodName($methodName) . '</a></h5>' . "\n";
                $paths .= $pathStructure;
            }
        }
        $pathsTemplate->setVar(['paths' => $paths]);
        return $pathsTemplate->render();
    }
    private function renderPathLines(array $path, array $branches, array $codeLines, array $testData) : string
    {
        $linesTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'lines.html.dist', '{{', '}}');
        $singleLineTemplate = new \PHPUnit\SebastianBergmann\Template\Template($this->templatePath . 'line.html.dist', '{{', '}}');
        $lines = '';
        foreach ($path['path'] as $branchId) {
            $branchLines = \range($branches[$branchId]['line_start'], $branches[$branchId]['line_end']);
            \sort($branchLines);
            // sometimes end_line < start_line
            /** @var int $line */
            foreach ($branchLines as $line) {
                if (!isset($codeLines[$line])) {
                    // blank line at end of file is sometimes included here
                    continue;
                }
                $popoverContent = '';
                $popoverTitle = '';
                $numTests = \count($path['hit']);
                if ($numTests === 0) {
                    $trClass = 'danger';
                } else {
                    $lineCss = 'covered-by-large-tests';
                    $popoverContent = '<ul>';
                    if ($numTests > 1) {
                        $popoverTitle = $numTests . ' tests cover this path';
                    } else {
                        $popoverTitle = '1 test covers this path';
                    }
                    foreach ($path['hit'] as $test) {
                        if ($lineCss === 'covered-by-large-tests' && $testData[$test]['size'] === 'medium') {
                            $lineCss = 'covered-by-medium-tests';
                        } elseif ($testData[$test]['size'] === 'small') {
                            $lineCss = 'covered-by-small-tests';
                        }
                        $popoverContent .= $this->createPopoverContentForTest($test, $testData[$test]);
                    }
                    $trClass = $lineCss . ' popin';
                }
                $popover = '';
                if (!empty($popoverTitle)) {
                    $popover = \sprintf(' data-title="%s" data-content="%s" data-placement="top" data-html="true"', $popoverTitle, \htmlspecialchars($popoverContent, $this->htmlSpecialCharsFlags));
                }
                $lines .= $this->renderLine($singleLineTemplate, $line, $codeLines[$line - 1], $trClass, $popover);
            }
        }
        if ($lines === '') {
            return '';
        }
        $linesTemplate->setVar(['lines' => $lines]);
        return $linesTemplate->render();
    }
    private function renderLine(\PHPUnit\SebastianBergmann\Template\Template $template, int $lineNumber, string $lineContent, string $class, string $popover) : string
    {
        $template->setVar(['lineNumber' => $lineNumber, 'lineContent' => $lineContent, 'class' => $class, 'popover' => $popover]);
        return $template->render();
    }
    private function loadFile(string $file) : array
    {
        if (isset(self::$formattedSourceCache[$file])) {
            return self::$formattedSourceCache[$file];
        }
        $buffer = \file_get_contents($file);
        $tokens = \token_get_all($buffer);
        $result = [''];
        $i = 0;
        $stringFlag = \false;
        $fileEndsWithNewLine = \substr($buffer, -1) === "\n";
        unset($buffer);
        foreach ($tokens as $j => $token) {
            if (\is_string($token)) {
                if ($token === '"' && $tokens[$j - 1] !== '\\') {
                    $result[$i] .= \sprintf('<span class="string">%s</span>', \htmlspecialchars($token, $this->htmlSpecialCharsFlags));
                    $stringFlag = !$stringFlag;
                } else {
                    $result[$i] .= \sprintf('<span class="keyword">%s</span>', \htmlspecialchars($token, $this->htmlSpecialCharsFlags));
                }
                continue;
            }
            [$token, $value] = $token;
            $value = \str_replace(["\t", ' '], ['&nbsp;&nbsp;&nbsp;&nbsp;', '&nbsp;'], \htmlspecialchars($value, $this->htmlSpecialCharsFlags));
            if ($value === "\n") {
                $result[++$i] = '';
            } else {
                $lines = \explode("\n", $value);
                foreach ($lines as $jj => $line) {
                    $line = \trim($line);
                    if ($line !== '') {
                        if ($stringFlag) {
                            $colour = 'string';
                        } else {
                            $colour = 'default';
                            if ($this->isInlineHtml($token)) {
                                $colour = 'html';
                            } elseif ($this->isComment($token)) {
                                $colour = 'comment';
                            } elseif ($this->isKeyword($token)) {
                                $colour = 'keyword';
                            }
                        }
                        $result[$i] .= \sprintf('<span class="%s">%s</span>', $colour, $line);
                    }
                    if (isset($lines[$jj + 1])) {
                        $result[++$i] = '';
                    }
                }
            }
        }
        if ($fileEndsWithNewLine) {
            unset($result[\count($result) - 1]);
        }
        self::$formattedSourceCache[$file] = $result;
        return $result;
    }
    private function abbreviateClassName(string $className) : string
    {
        $tmp = \explode('\\', $className);
        if (\count($tmp) > 1) {
            $className = \sprintf('<abbr title="%s">%s</abbr>', $className, \array_pop($tmp));
        }
        return $className;
    }
    private function abbreviateMethodName(string $methodName) : string
    {
        $parts = \explode('->', $methodName);
        if (\count($parts) === 2) {
            return $this->abbreviateClassName($parts[0]) . '->' . $parts[1];
        }
        return $methodName;
    }
    private function createPopoverContentForTest(string $test, array $testData) : string
    {
        $testCSS = '';
        if ($testData['fromTestcase']) {
            switch ($testData['status']) {
                case 'success':
                    switch ($testData['size']) {
                        case 'small':
                            $testCSS = ' class="covered-by-small-tests"';
                            break;
                        case 'medium':
                            $testCSS = ' class="covered-by-medium-tests"';
                            break;
                        default:
                            $testCSS = ' class="covered-by-large-tests"';
                            break;
                    }
                    break;
                case 'skipped':
                case 'incomplete':
                case 'risky':
                case 'warning':
                    $testCSS = ' class="warning"';
                    break;
                case 'failure':
                case 'error':
                    $testCSS = ' class="danger"';
                    break;
            }
        }
        return \sprintf('<li%s>%s</li>', $testCSS, \htmlspecialchars($test, $this->htmlSpecialCharsFlags));
    }
    private function isComment(int $token) : bool
    {
        return $token === \T_COMMENT || $token === \T_DOC_COMMENT;
    }
    private function isInlineHtml(int $token) : bool
    {
        return $token === \T_INLINE_HTML;
    }
    private function isKeyword(int $token) : bool
    {
        return isset(self::keywordTokens()[$token]);
    }
    /**
     * @psalm-return array<int,true>
     */
    private static function keywordTokens() : array
    {
        if (self::$keywordTokens !== []) {
            return self::$keywordTokens;
        }
        self::$keywordTokens = [\T_ABSTRACT => \true, \T_ARRAY => \true, \T_AS => \true, \T_BREAK => \true, \T_CALLABLE => \true, \T_CASE => \true, \T_CATCH => \true, \T_CLASS => \true, \T_CLONE => \true, \T_CONST => \true, \T_CONTINUE => \true, \T_DECLARE => \true, \T_DEFAULT => \true, \T_DO => \true, \T_ECHO => \true, \T_ELSE => \true, \T_ELSEIF => \true, \T_EMPTY => \true, \T_ENDDECLARE => \true, \T_ENDFOR => \true, \T_ENDFOREACH => \true, \T_ENDIF => \true, \T_ENDSWITCH => \true, \T_ENDWHILE => \true, \T_EVAL => \true, \T_EXIT => \true, \T_EXTENDS => \true, \T_FINAL => \true, \T_FINALLY => \true, \T_FOR => \true, \T_FOREACH => \true, \T_FUNCTION => \true, \T_GLOBAL => \true, \T_GOTO => \true, \T_HALT_COMPILER => \true, \T_IF => \true, \T_IMPLEMENTS => \true, \T_INCLUDE => \true, \T_INCLUDE_ONCE => \true, \T_INSTANCEOF => \true, \T_INSTEADOF => \true, \T_INTERFACE => \true, \T_ISSET => \true, \T_LIST => \true, \T_NAMESPACE => \true, \T_NEW => \true, \T_PRINT => \true, \T_PRIVATE => \true, \T_PROTECTED => \true, \T_PUBLIC => \true, \T_REQUIRE => \true, \T_REQUIRE_ONCE => \true, \T_RETURN => \true, \T_STATIC => \true, \T_SWITCH => \true, \T_THROW => \true, \T_TRAIT => \true, \T_TRY => \true, \T_UNSET => \true, \T_USE => \true, \T_VAR => \true, \T_WHILE => \true, \T_YIELD => \true, \T_YIELD_FROM => \true];
        if (\defined('T_FN')) {
            self::$keywordTokens[\constant('T_FN')] = \true;
        }
        if (\defined('T_MATCH')) {
            self::$keywordTokens[\constant('T_MATCH')] = \true;
        }
        return self::$keywordTokens;
    }
}
<hr/>
<h4>Branches</h4>
<p>
    Below are the source code lines that represent each code branch as identified by Xdebug. Please note a branch is not
    necessarily coterminous with a line, a line may contain multiple branches and therefore show up more than once.
    Please also be aware that some branches may be implicit rather than explicit, e.g. an <code>if</code> statement
    <i>always</i> has an <code>else</code> as part of its logical flow even if you didn't write one.
</p>
{{branches}}
       <div class="progress">
         <div class="progress-bar bg-{{level}}" role="progressbar" aria-valuenow="{{percent}}" aria-valuemin="0" aria-valuemax="100" style="width: {{percent}}%">
           <span class="sr-only">{{percent}}% covered ({{level}})</span>
         </div>
       </div>
       <div class="progress">
         <div class="progress-bar bg-{{level}}" role="progressbar" aria-valuenow="{{percent}}" aria-valuemin="0" aria-valuemax="100" style="width: {{percent}}%">
           <span class="sr-only">{{percent}}% covered ({{level}})</span>
         </div>
       </div>
/*!
 * Bootstrap v4.5.0 (https://getbootstrap.com/)
 * Copyright 2011-2020 The Bootstrap Authors
 * Copyright 2011-2020 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */:root{--blue:#007bff;--indigo:#6610f2;--purple:#6f42c1;--pink:#e83e8c;--red:#dc3545;--orange:#fd7e14;--yellow:#ffc107;--green:#28a745;--teal:#20c997;--cyan:#17a2b8;--white:#fff;--gray:#6c757d;--gray-dark:#343a40;--primary:#007bff;--secondary:#6c757d;--success:#28a745;--info:#17a2b8;--warning:#ffc107;--danger:#dc3545;--light:#f8f9fa;--dark:#343a40;--breakpoint-xs:0;--breakpoint-sm:576px;--breakpoint-md:768px;--breakpoint-lg:992px;--breakpoint-xl:1200px;--font-family-sans-serif:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-family-monospace:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}*,::after,::before{box-sizing:border-box}html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}article,aside,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;text-align:left;background-color:#fff}[tabindex="-1"]:focus:not(:focus-visible){outline:0!important}hr{box-sizing:content-box;height:0;overflow:visible}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem}p{margin-top:0;margin-bottom:1rem}abbr[data-original-title],abbr[title]{text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;border-bottom:0;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#007bff;text-decoration:none;background-color:transparent}a:hover{color:#0056b3;text-decoration:underline}a:not([href]){color:inherit;text-decoration:none}a:not([href]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em}pre{margin-top:0;margin-bottom:1rem;overflow:auto;-ms-overflow-style:scrollbar}figure{margin:0 0 1rem}img{vertical-align:middle;border-style:none}svg{overflow:hidden;vertical-align:middle}table{border-collapse:collapse}caption{padding-top:.75rem;padding-bottom:.75rem;color:#6c757d;text-align:left;caption-side:bottom}th{text-align:inherit}label{display:inline-block;margin-bottom:.5rem}button{border-radius:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,input{overflow:visible}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{padding:0;border-style:none}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}textarea{overflow:auto;resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;max-width:100%;padding:0;margin-bottom:.5rem;font-size:1.5rem;line-height:inherit;color:inherit;white-space:normal}progress{vertical-align:baseline}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:none}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}summary{display:list-item;cursor:pointer}template{display:none}[hidden]{display:none!important}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{margin-bottom:.5rem;font-weight:500;line-height:1.2}.h1,h1{font-size:2.5rem}.h2,h2{font-size:2rem}.h3,h3{font-size:1.75rem}.h4,h4{font-size:1.5rem}.h5,h5{font-size:1.25rem}.h6,h6{font-size:1rem}.lead{font-size:1.25rem;font-weight:300}.display-1{font-size:6rem;font-weight:300;line-height:1.2}.display-2{font-size:5.5rem;font-weight:300;line-height:1.2}.display-3{font-size:4.5rem;font-weight:300;line-height:1.2}.display-4{font-size:3.5rem;font-weight:300;line-height:1.2}hr{margin-top:1rem;margin-bottom:1rem;border:0;border-top:1px solid rgba(0,0,0,.1)}.small,small{font-size:80%;font-weight:400}.mark,mark{padding:.2em;background-color:#fcf8e3}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;list-style:none}.list-inline-item{display:inline-block}.list-inline-item:not(:last-child){margin-right:.5rem}.initialism{font-size:90%;text-transform:uppercase}.blockquote{margin-bottom:1rem;font-size:1.25rem}.blockquote-footer{display:block;font-size:80%;color:#6c757d}.blockquote-footer::before{content:"\2014\00A0"}.img-fluid{max-width:100%;height:auto}.img-thumbnail{padding:.25rem;background-color:#fff;border:1px solid #dee2e6;border-radius:.25rem;max-width:100%;height:auto}.figure{display:inline-block}.figure-img{margin-bottom:.5rem;line-height:1}.figure-caption{font-size:90%;color:#6c757d}code{font-size:87.5%;color:#e83e8c;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:87.5%;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:100%;font-weight:700}pre{display:block;font-size:87.5%;color:#212529}pre code{font-size:inherit;color:inherit;word-break:normal}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:576px){.container{max-width:540px}}@media (min-width:768px){.container{max-width:720px}}@media (min-width:992px){.container{max-width:960px}}@media (min-width:1200px){.container{max-width:1140px}}.container-fluid,.container-lg,.container-md,.container-sm,.container-xl{width:100%;padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:576px){.container,.container-sm{max-width:540px}}@media (min-width:768px){.container,.container-md,.container-sm{max-width:720px}}@media (min-width:992px){.container,.container-lg,.container-md,.container-sm{max-width:960px}}@media (min-width:1200px){.container,.container-lg,.container-md,.container-sm,.container-xl{max-width:1140px}}.row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-15px;margin-left:-15px}.no-gutters{margin-right:0;margin-left:0}.no-gutters>.col,.no-gutters>[class*=col-]{padding-right:0;padding-left:0}.col,.col-1,.col-10,.col-11,.col-12,.col-2,.col-3,.col-4,.col-5,.col-6,.col-7,.col-8,.col-9,.col-auto,.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-auto,.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-auto,.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-auto,.col-xl,.col-xl-1,.col-xl-10,.col-xl-11,.col-xl-12,.col-xl-2,.col-xl-3,.col-xl-4,.col-xl-5,.col-xl-6,.col-xl-7,.col-xl-8,.col-xl-9,.col-xl-auto{position:relative;width:100%;padding-right:15px;padding-left:15px}.col{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;min-width:0;max-width:100%}.row-cols-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-first{-ms-flex-order:-1;order:-1}.order-last{-ms-flex-order:13;order:13}.order-0{-ms-flex-order:0;order:0}.order-1{-ms-flex-order:1;order:1}.order-2{-ms-flex-order:2;order:2}.order-3{-ms-flex-order:3;order:3}.order-4{-ms-flex-order:4;order:4}.order-5{-ms-flex-order:5;order:5}.order-6{-ms-flex-order:6;order:6}.order-7{-ms-flex-order:7;order:7}.order-8{-ms-flex-order:8;order:8}.order-9{-ms-flex-order:9;order:9}.order-10{-ms-flex-order:10;order:10}.order-11{-ms-flex-order:11;order:11}.order-12{-ms-flex-order:12;order:12}.offset-1{margin-left:8.333333%}.offset-2{margin-left:16.666667%}.offset-3{margin-left:25%}.offset-4{margin-left:33.333333%}.offset-5{margin-left:41.666667%}.offset-6{margin-left:50%}.offset-7{margin-left:58.333333%}.offset-8{margin-left:66.666667%}.offset-9{margin-left:75%}.offset-10{margin-left:83.333333%}.offset-11{margin-left:91.666667%}@media (min-width:576px){.col-sm{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;min-width:0;max-width:100%}.row-cols-sm-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-sm-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-sm-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-sm-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-sm-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-sm-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-sm-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-sm-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-sm-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-sm-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-sm-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-sm-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-sm-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-sm-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-sm-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-sm-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-sm-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-sm-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-sm-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-sm-first{-ms-flex-order:-1;order:-1}.order-sm-last{-ms-flex-order:13;order:13}.order-sm-0{-ms-flex-order:0;order:0}.order-sm-1{-ms-flex-order:1;order:1}.order-sm-2{-ms-flex-order:2;order:2}.order-sm-3{-ms-flex-order:3;order:3}.order-sm-4{-ms-flex-order:4;order:4}.order-sm-5{-ms-flex-order:5;order:5}.order-sm-6{-ms-flex-order:6;order:6}.order-sm-7{-ms-flex-order:7;order:7}.order-sm-8{-ms-flex-order:8;order:8}.order-sm-9{-ms-flex-order:9;order:9}.order-sm-10{-ms-flex-order:10;order:10}.order-sm-11{-ms-flex-order:11;order:11}.order-sm-12{-ms-flex-order:12;order:12}.offset-sm-0{margin-left:0}.offset-sm-1{margin-left:8.333333%}.offset-sm-2{margin-left:16.666667%}.offset-sm-3{margin-left:25%}.offset-sm-4{margin-left:33.333333%}.offset-sm-5{margin-left:41.666667%}.offset-sm-6{margin-left:50%}.offset-sm-7{margin-left:58.333333%}.offset-sm-8{margin-left:66.666667%}.offset-sm-9{margin-left:75%}.offset-sm-10{margin-left:83.333333%}.offset-sm-11{margin-left:91.666667%}}@media (min-width:768px){.col-md{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;min-width:0;max-width:100%}.row-cols-md-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-md-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-md-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-md-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-md-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-md-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-md-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-md-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-md-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-md-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-md-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-md-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-md-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-md-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-md-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-md-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-md-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-md-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-md-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-md-first{-ms-flex-order:-1;order:-1}.order-md-last{-ms-flex-order:13;order:13}.order-md-0{-ms-flex-order:0;order:0}.order-md-1{-ms-flex-order:1;order:1}.order-md-2{-ms-flex-order:2;order:2}.order-md-3{-ms-flex-order:3;order:3}.order-md-4{-ms-flex-order:4;order:4}.order-md-5{-ms-flex-order:5;order:5}.order-md-6{-ms-flex-order:6;order:6}.order-md-7{-ms-flex-order:7;order:7}.order-md-8{-ms-flex-order:8;order:8}.order-md-9{-ms-flex-order:9;order:9}.order-md-10{-ms-flex-order:10;order:10}.order-md-11{-ms-flex-order:11;order:11}.order-md-12{-ms-flex-order:12;order:12}.offset-md-0{margin-left:0}.offset-md-1{margin-left:8.333333%}.offset-md-2{margin-left:16.666667%}.offset-md-3{margin-left:25%}.offset-md-4{margin-left:33.333333%}.offset-md-5{margin-left:41.666667%}.offset-md-6{margin-left:50%}.offset-md-7{margin-left:58.333333%}.offset-md-8{margin-left:66.666667%}.offset-md-9{margin-left:75%}.offset-md-10{margin-left:83.333333%}.offset-md-11{margin-left:91.666667%}}@media (min-width:992px){.col-lg{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;min-width:0;max-width:100%}.row-cols-lg-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-lg-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-lg-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-lg-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-lg-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-lg-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-lg-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-lg-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-lg-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-lg-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-lg-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-lg-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-lg-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-lg-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-lg-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-lg-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-lg-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-lg-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-lg-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-lg-first{-ms-flex-order:-1;order:-1}.order-lg-last{-ms-flex-order:13;order:13}.order-lg-0{-ms-flex-order:0;order:0}.order-lg-1{-ms-flex-order:1;order:1}.order-lg-2{-ms-flex-order:2;order:2}.order-lg-3{-ms-flex-order:3;order:3}.order-lg-4{-ms-flex-order:4;order:4}.order-lg-5{-ms-flex-order:5;order:5}.order-lg-6{-ms-flex-order:6;order:6}.order-lg-7{-ms-flex-order:7;order:7}.order-lg-8{-ms-flex-order:8;order:8}.order-lg-9{-ms-flex-order:9;order:9}.order-lg-10{-ms-flex-order:10;order:10}.order-lg-11{-ms-flex-order:11;order:11}.order-lg-12{-ms-flex-order:12;order:12}.offset-lg-0{margin-left:0}.offset-lg-1{margin-left:8.333333%}.offset-lg-2{margin-left:16.666667%}.offset-lg-3{margin-left:25%}.offset-lg-4{margin-left:33.333333%}.offset-lg-5{margin-left:41.666667%}.offset-lg-6{margin-left:50%}.offset-lg-7{margin-left:58.333333%}.offset-lg-8{margin-left:66.666667%}.offset-lg-9{margin-left:75%}.offset-lg-10{margin-left:83.333333%}.offset-lg-11{margin-left:91.666667%}}@media (min-width:1200px){.col-xl{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;min-width:0;max-width:100%}.row-cols-xl-1>*{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.row-cols-xl-2>*{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.row-cols-xl-3>*{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.row-cols-xl-4>*{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.row-cols-xl-5>*{-ms-flex:0 0 20%;flex:0 0 20%;max-width:20%}.row-cols-xl-6>*{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-xl-auto{-ms-flex:0 0 auto;flex:0 0 auto;width:auto;max-width:100%}.col-xl-1{-ms-flex:0 0 8.333333%;flex:0 0 8.333333%;max-width:8.333333%}.col-xl-2{-ms-flex:0 0 16.666667%;flex:0 0 16.666667%;max-width:16.666667%}.col-xl-3{-ms-flex:0 0 25%;flex:0 0 25%;max-width:25%}.col-xl-4{-ms-flex:0 0 33.333333%;flex:0 0 33.333333%;max-width:33.333333%}.col-xl-5{-ms-flex:0 0 41.666667%;flex:0 0 41.666667%;max-width:41.666667%}.col-xl-6{-ms-flex:0 0 50%;flex:0 0 50%;max-width:50%}.col-xl-7{-ms-flex:0 0 58.333333%;flex:0 0 58.333333%;max-width:58.333333%}.col-xl-8{-ms-flex:0 0 66.666667%;flex:0 0 66.666667%;max-width:66.666667%}.col-xl-9{-ms-flex:0 0 75%;flex:0 0 75%;max-width:75%}.col-xl-10{-ms-flex:0 0 83.333333%;flex:0 0 83.333333%;max-width:83.333333%}.col-xl-11{-ms-flex:0 0 91.666667%;flex:0 0 91.666667%;max-width:91.666667%}.col-xl-12{-ms-flex:0 0 100%;flex:0 0 100%;max-width:100%}.order-xl-first{-ms-flex-order:-1;order:-1}.order-xl-last{-ms-flex-order:13;order:13}.order-xl-0{-ms-flex-order:0;order:0}.order-xl-1{-ms-flex-order:1;order:1}.order-xl-2{-ms-flex-order:2;order:2}.order-xl-3{-ms-flex-order:3;order:3}.order-xl-4{-ms-flex-order:4;order:4}.order-xl-5{-ms-flex-order:5;order:5}.order-xl-6{-ms-flex-order:6;order:6}.order-xl-7{-ms-flex-order:7;order:7}.order-xl-8{-ms-flex-order:8;order:8}.order-xl-9{-ms-flex-order:9;order:9}.order-xl-10{-ms-flex-order:10;order:10}.order-xl-11{-ms-flex-order:11;order:11}.order-xl-12{-ms-flex-order:12;order:12}.offset-xl-0{margin-left:0}.offset-xl-1{margin-left:8.333333%}.offset-xl-2{margin-left:16.666667%}.offset-xl-3{margin-left:25%}.offset-xl-4{margin-left:33.333333%}.offset-xl-5{margin-left:41.666667%}.offset-xl-6{margin-left:50%}.offset-xl-7{margin-left:58.333333%}.offset-xl-8{margin-left:66.666667%}.offset-xl-9{margin-left:75%}.offset-xl-10{margin-left:83.333333%}.offset-xl-11{margin-left:91.666667%}}.table{width:100%;margin-bottom:1rem;color:#212529}.table td,.table th{padding:.75rem;vertical-align:top;border-top:1px solid #dee2e6}.table thead th{vertical-align:bottom;border-bottom:2px solid #dee2e6}.table tbody+tbody{border-top:2px solid #dee2e6}.table-sm td,.table-sm th{padding:.3rem}.table-bordered{border:1px solid #dee2e6}.table-bordered td,.table-bordered th{border:1px solid #dee2e6}.table-bordered thead td,.table-bordered thead th{border-bottom-width:2px}.table-borderless tbody+tbody,.table-borderless td,.table-borderless th,.table-borderless thead th{border:0}.table-striped tbody tr:nth-of-type(odd){background-color:rgba(0,0,0,.05)}.table-hover tbody tr:hover{color:#212529;background-color:rgba(0,0,0,.075)}.table-primary,.table-primary>td,.table-primary>th{background-color:#b8daff}.table-primary tbody+tbody,.table-primary td,.table-primary th,.table-primary thead th{border-color:#7abaff}.table-hover .table-primary:hover{background-color:#9fcdff}.table-hover .table-primary:hover>td,.table-hover .table-primary:hover>th{background-color:#9fcdff}.table-secondary,.table-secondary>td,.table-secondary>th{background-color:#d6d8db}.table-secondary tbody+tbody,.table-secondary td,.table-secondary th,.table-secondary thead th{border-color:#b3b7bb}.table-hover .table-secondary:hover{background-color:#c8cbcf}.table-hover .table-secondary:hover>td,.table-hover .table-secondary:hover>th{background-color:#c8cbcf}.table-success,.table-success>td,.table-success>th{background-color:#c3e6cb}.table-success tbody+tbody,.table-success td,.table-success th,.table-success thead th{border-color:#8fd19e}.table-hover .table-success:hover{background-color:#b1dfbb}.table-hover .table-success:hover>td,.table-hover .table-success:hover>th{background-color:#b1dfbb}.table-info,.table-info>td,.table-info>th{background-color:#bee5eb}.table-info tbody+tbody,.table-info td,.table-info th,.table-info thead th{border-color:#86cfda}.table-hover .table-info:hover{background-color:#abdde5}.table-hover .table-info:hover>td,.table-hover .table-info:hover>th{background-color:#abdde5}.table-warning,.table-warning>td,.table-warning>th{background-color:#ffeeba}.table-warning tbody+tbody,.table-warning td,.table-warning th,.table-warning thead th{border-color:#ffdf7e}.table-hover .table-warning:hover{background-color:#ffe8a1}.table-hover .table-warning:hover>td,.table-hover .table-warning:hover>th{background-color:#ffe8a1}.table-danger,.table-danger>td,.table-danger>th{background-color:#f5c6cb}.table-danger tbody+tbody,.table-danger td,.table-danger th,.table-danger thead th{border-color:#ed969e}.table-hover .table-danger:hover{background-color:#f1b0b7}.table-hover .table-danger:hover>td,.table-hover .table-danger:hover>th{background-color:#f1b0b7}.table-light,.table-light>td,.table-light>th{background-color:#fdfdfe}.table-light tbody+tbody,.table-light td,.table-light th,.table-light thead th{border-color:#fbfcfc}.table-hover .table-light:hover{background-color:#ececf6}.table-hover .table-light:hover>td,.table-hover .table-light:hover>th{background-color:#ececf6}.table-dark,.table-dark>td,.table-dark>th{background-color:#c6c8ca}.table-dark tbody+tbody,.table-dark td,.table-dark th,.table-dark thead th{border-color:#95999c}.table-hover .table-dark:hover{background-color:#b9bbbe}.table-hover .table-dark:hover>td,.table-hover .table-dark:hover>th{background-color:#b9bbbe}.table-active,.table-active>td,.table-active>th{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover{background-color:rgba(0,0,0,.075)}.table-hover .table-active:hover>td,.table-hover .table-active:hover>th{background-color:rgba(0,0,0,.075)}.table .thead-dark th{color:#fff;background-color:#343a40;border-color:#454d55}.table .thead-light th{color:#495057;background-color:#e9ecef;border-color:#dee2e6}.table-dark{color:#fff;background-color:#343a40}.table-dark td,.table-dark th,.table-dark thead th{border-color:#454d55}.table-dark.table-bordered{border:0}.table-dark.table-striped tbody tr:nth-of-type(odd){background-color:rgba(255,255,255,.05)}.table-dark.table-hover tbody tr:hover{color:#fff;background-color:rgba(255,255,255,.075)}@media (max-width:575.98px){.table-responsive-sm{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-sm>.table-bordered{border:0}}@media (max-width:767.98px){.table-responsive-md{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-md>.table-bordered{border:0}}@media (max-width:991.98px){.table-responsive-lg{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-lg>.table-bordered{border:0}}@media (max-width:1199.98px){.table-responsive-xl{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive-xl>.table-bordered{border:0}}.table-responsive{display:block;width:100%;overflow-x:auto;-webkit-overflow-scrolling:touch}.table-responsive>.table-bordered{border:0}.form-control{display:block;width:100%;height:calc(1.5em + .75rem + 2px);padding:.375rem .75rem;font-size:1rem;font-weight:400;line-height:1.5;color:#495057;background-color:#fff;background-clip:padding-box;border:1px solid #ced4da;border-radius:.25rem;transition:border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.form-control{transition:none}}.form-control::-ms-expand{background-color:transparent;border:0}.form-control:-moz-focusring{color:transparent;text-shadow:0 0 0 #495057}.form-control:focus{color:#495057;background-color:#fff;border-color:#80bdff;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.form-control::-webkit-input-placeholder{color:#6c757d;opacity:1}.form-control::-moz-placeholder{color:#6c757d;opacity:1}.form-control:-ms-input-placeholder{color:#6c757d;opacity:1}.form-control::-ms-input-placeholder{color:#6c757d;opacity:1}.form-control::placeholder{color:#6c757d;opacity:1}.form-control:disabled,.form-control[readonly]{background-color:#e9ecef;opacity:1}input[type=date].form-control,input[type=datetime-local].form-control,input[type=month].form-control,input[type=time].form-control{-webkit-appearance:none;-moz-appearance:none;appearance:none}select.form-control:focus::-ms-value{color:#495057;background-color:#fff}.form-control-file,.form-control-range{display:block;width:100%}.col-form-label{padding-top:calc(.375rem + 1px);padding-bottom:calc(.375rem + 1px);margin-bottom:0;font-size:inherit;line-height:1.5}.col-form-label-lg{padding-top:calc(.5rem + 1px);padding-bottom:calc(.5rem + 1px);font-size:1.25rem;line-height:1.5}.col-form-label-sm{padding-top:calc(.25rem + 1px);padding-bottom:calc(.25rem + 1px);font-size:.875rem;line-height:1.5}.form-control-plaintext{display:block;width:100%;padding:.375rem 0;margin-bottom:0;font-size:1rem;line-height:1.5;color:#212529;background-color:transparent;border:solid transparent;border-width:1px 0}.form-control-plaintext.form-control-lg,.form-control-plaintext.form-control-sm{padding-right:0;padding-left:0}.form-control-sm{height:calc(1.5em + .5rem + 2px);padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.form-control-lg{height:calc(1.5em + 1rem + 2px);padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}select.form-control[multiple],select.form-control[size]{height:auto}textarea.form-control{height:auto}.form-group{margin-bottom:1rem}.form-text{display:block;margin-top:.25rem}.form-row{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-5px;margin-left:-5px}.form-row>.col,.form-row>[class*=col-]{padding-right:5px;padding-left:5px}.form-check{position:relative;display:block;padding-left:1.25rem}.form-check-input{position:absolute;margin-top:.3rem;margin-left:-1.25rem}.form-check-input:disabled~.form-check-label,.form-check-input[disabled]~.form-check-label{color:#6c757d}.form-check-label{margin-bottom:0}.form-check-inline{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;padding-left:0;margin-right:.75rem}.form-check-inline .form-check-input{position:static;margin-top:0;margin-right:.3125rem;margin-left:0}.valid-feedback{display:none;width:100%;margin-top:.25rem;font-size:80%;color:#28a745}.valid-tooltip{position:absolute;top:100%;z-index:5;display:none;max-width:100%;padding:.25rem .5rem;margin-top:.1rem;font-size:.875rem;line-height:1.5;color:#fff;background-color:rgba(40,167,69,.9);border-radius:.25rem}.is-valid~.valid-feedback,.is-valid~.valid-tooltip,.was-validated :valid~.valid-feedback,.was-validated :valid~.valid-tooltip{display:block}.form-control.is-valid,.was-validated .form-control:valid{border-color:#28a745;padding-right:calc(1.5em + .75rem);background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%2328a745' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right calc(.375em + .1875rem) center;background-size:calc(.75em + .375rem) calc(.75em + .375rem)}.form-control.is-valid:focus,.was-validated .form-control:valid:focus{border-color:#28a745;box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.was-validated textarea.form-control:valid,textarea.form-control.is-valid{padding-right:calc(1.5em + .75rem);background-position:top calc(.375em + .1875rem) right calc(.375em + .1875rem)}.custom-select.is-valid,.was-validated .custom-select:valid{border-color:#28a745;padding-right:calc(.75em + 2.3125rem);background:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23343a40' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right .75rem center/8px 10px,url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%2328a745' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3e%3c/svg%3e") #fff no-repeat center right 1.75rem/calc(.75em + .375rem) calc(.75em + .375rem)}.custom-select.is-valid:focus,.was-validated .custom-select:valid:focus{border-color:#28a745;box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.form-check-input.is-valid~.form-check-label,.was-validated .form-check-input:valid~.form-check-label{color:#28a745}.form-check-input.is-valid~.valid-feedback,.form-check-input.is-valid~.valid-tooltip,.was-validated .form-check-input:valid~.valid-feedback,.was-validated .form-check-input:valid~.valid-tooltip{display:block}.custom-control-input.is-valid~.custom-control-label,.was-validated .custom-control-input:valid~.custom-control-label{color:#28a745}.custom-control-input.is-valid~.custom-control-label::before,.was-validated .custom-control-input:valid~.custom-control-label::before{border-color:#28a745}.custom-control-input.is-valid:checked~.custom-control-label::before,.was-validated .custom-control-input:valid:checked~.custom-control-label::before{border-color:#34ce57;background-color:#34ce57}.custom-control-input.is-valid:focus~.custom-control-label::before,.was-validated .custom-control-input:valid:focus~.custom-control-label::before{box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.custom-control-input.is-valid:focus:not(:checked)~.custom-control-label::before,.was-validated .custom-control-input:valid:focus:not(:checked)~.custom-control-label::before{border-color:#28a745}.custom-file-input.is-valid~.custom-file-label,.was-validated .custom-file-input:valid~.custom-file-label{border-color:#28a745}.custom-file-input.is-valid:focus~.custom-file-label,.was-validated .custom-file-input:valid:focus~.custom-file-label{border-color:#28a745;box-shadow:0 0 0 .2rem rgba(40,167,69,.25)}.invalid-feedback{display:none;width:100%;margin-top:.25rem;font-size:80%;color:#dc3545}.invalid-tooltip{position:absolute;top:100%;z-index:5;display:none;max-width:100%;padding:.25rem .5rem;margin-top:.1rem;font-size:.875rem;line-height:1.5;color:#fff;background-color:rgba(220,53,69,.9);border-radius:.25rem}.is-invalid~.invalid-feedback,.is-invalid~.invalid-tooltip,.was-validated :invalid~.invalid-feedback,.was-validated :invalid~.invalid-tooltip{display:block}.form-control.is-invalid,.was-validated .form-control:invalid{border-color:#dc3545;padding-right:calc(1.5em + .75rem);background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");background-repeat:no-repeat;background-position:right calc(.375em + .1875rem) center;background-size:calc(.75em + .375rem) calc(.75em + .375rem)}.form-control.is-invalid:focus,.was-validated .form-control:invalid:focus{border-color:#dc3545;box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.was-validated textarea.form-control:invalid,textarea.form-control.is-invalid{padding-right:calc(1.5em + .75rem);background-position:top calc(.375em + .1875rem) right calc(.375em + .1875rem)}.custom-select.is-invalid,.was-validated .custom-select:invalid{border-color:#dc3545;padding-right:calc(.75em + 2.3125rem);background:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23343a40' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right .75rem center/8px 10px,url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e") #fff no-repeat center right 1.75rem/calc(.75em + .375rem) calc(.75em + .375rem)}.custom-select.is-invalid:focus,.was-validated .custom-select:invalid:focus{border-color:#dc3545;box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.form-check-input.is-invalid~.form-check-label,.was-validated .form-check-input:invalid~.form-check-label{color:#dc3545}.form-check-input.is-invalid~.invalid-feedback,.form-check-input.is-invalid~.invalid-tooltip,.was-validated .form-check-input:invalid~.invalid-feedback,.was-validated .form-check-input:invalid~.invalid-tooltip{display:block}.custom-control-input.is-invalid~.custom-control-label,.was-validated .custom-control-input:invalid~.custom-control-label{color:#dc3545}.custom-control-input.is-invalid~.custom-control-label::before,.was-validated .custom-control-input:invalid~.custom-control-label::before{border-color:#dc3545}.custom-control-input.is-invalid:checked~.custom-control-label::before,.was-validated .custom-control-input:invalid:checked~.custom-control-label::before{border-color:#e4606d;background-color:#e4606d}.custom-control-input.is-invalid:focus~.custom-control-label::before,.was-validated .custom-control-input:invalid:focus~.custom-control-label::before{box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.custom-control-input.is-invalid:focus:not(:checked)~.custom-control-label::before,.was-validated .custom-control-input:invalid:focus:not(:checked)~.custom-control-label::before{border-color:#dc3545}.custom-file-input.is-invalid~.custom-file-label,.was-validated .custom-file-input:invalid~.custom-file-label{border-color:#dc3545}.custom-file-input.is-invalid:focus~.custom-file-label,.was-validated .custom-file-input:invalid:focus~.custom-file-label{border-color:#dc3545;box-shadow:0 0 0 .2rem rgba(220,53,69,.25)}.form-inline{display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-align:center;align-items:center}.form-inline .form-check{width:100%}@media (min-width:576px){.form-inline label{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;margin-bottom:0}.form-inline .form-group{display:-ms-flexbox;display:flex;-ms-flex:0 0 auto;flex:0 0 auto;-ms-flex-flow:row wrap;flex-flow:row wrap;-ms-flex-align:center;align-items:center;margin-bottom:0}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-plaintext{display:inline-block}.form-inline .custom-select,.form-inline .input-group{width:auto}.form-inline .form-check{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-left:0}.form-inline .form-check-input{position:relative;-ms-flex-negative:0;flex-shrink:0;margin-top:0;margin-right:.25rem;margin-left:0}.form-inline .custom-control{-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center}.form-inline .custom-control-label{margin-bottom:0}}.btn{display:inline-block;font-weight:400;color:#212529;text-align:center;vertical-align:middle;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:transparent;border:1px solid transparent;padding:.375rem .75rem;font-size:1rem;line-height:1.5;border-radius:.25rem;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.btn{transition:none}}.btn:hover{color:#212529;text-decoration:none}.btn.focus,.btn:focus{outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.btn.disabled,.btn:disabled{opacity:.65}.btn:not(:disabled):not(.disabled){cursor:pointer}a.btn.disabled,fieldset:disabled a.btn{pointer-events:none}.btn-primary{color:#fff;background-color:#007bff;border-color:#007bff}.btn-primary:hover{color:#fff;background-color:#0069d9;border-color:#0062cc}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#0069d9;border-color:#0062cc;box-shadow:0 0 0 .2rem rgba(38,143,255,.5)}.btn-primary.disabled,.btn-primary:disabled{color:#fff;background-color:#007bff;border-color:#007bff}.btn-primary:not(:disabled):not(.disabled).active,.btn-primary:not(:disabled):not(.disabled):active,.show>.btn-primary.dropdown-toggle{color:#fff;background-color:#0062cc;border-color:#005cbf}.btn-primary:not(:disabled):not(.disabled).active:focus,.btn-primary:not(:disabled):not(.disabled):active:focus,.show>.btn-primary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(38,143,255,.5)}.btn-secondary{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:hover{color:#fff;background-color:#5a6268;border-color:#545b62}.btn-secondary.focus,.btn-secondary:focus{color:#fff;background-color:#5a6268;border-color:#545b62;box-shadow:0 0 0 .2rem rgba(130,138,145,.5)}.btn-secondary.disabled,.btn-secondary:disabled{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-secondary:not(:disabled):not(.disabled).active,.btn-secondary:not(:disabled):not(.disabled):active,.show>.btn-secondary.dropdown-toggle{color:#fff;background-color:#545b62;border-color:#4e555b}.btn-secondary:not(:disabled):not(.disabled).active:focus,.btn-secondary:not(:disabled):not(.disabled):active:focus,.show>.btn-secondary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(130,138,145,.5)}.btn-success{color:#fff;background-color:#28a745;border-color:#28a745}.btn-success:hover{color:#fff;background-color:#218838;border-color:#1e7e34}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#218838;border-color:#1e7e34;box-shadow:0 0 0 .2rem rgba(72,180,97,.5)}.btn-success.disabled,.btn-success:disabled{color:#fff;background-color:#28a745;border-color:#28a745}.btn-success:not(:disabled):not(.disabled).active,.btn-success:not(:disabled):not(.disabled):active,.show>.btn-success.dropdown-toggle{color:#fff;background-color:#1e7e34;border-color:#1c7430}.btn-success:not(:disabled):not(.disabled).active:focus,.btn-success:not(:disabled):not(.disabled):active:focus,.show>.btn-success.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(72,180,97,.5)}.btn-info{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-info:hover{color:#fff;background-color:#138496;border-color:#117a8b}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#138496;border-color:#117a8b;box-shadow:0 0 0 .2rem rgba(58,176,195,.5)}.btn-info.disabled,.btn-info:disabled{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-info:not(:disabled):not(.disabled).active,.btn-info:not(:disabled):not(.disabled):active,.show>.btn-info.dropdown-toggle{color:#fff;background-color:#117a8b;border-color:#10707f}.btn-info:not(:disabled):not(.disabled).active:focus,.btn-info:not(:disabled):not(.disabled):active:focus,.show>.btn-info.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(58,176,195,.5)}.btn-warning{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-warning:hover{color:#212529;background-color:#e0a800;border-color:#d39e00}.btn-warning.focus,.btn-warning:focus{color:#212529;background-color:#e0a800;border-color:#d39e00;box-shadow:0 0 0 .2rem rgba(222,170,12,.5)}.btn-warning.disabled,.btn-warning:disabled{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-warning:not(:disabled):not(.disabled).active,.btn-warning:not(:disabled):not(.disabled):active,.show>.btn-warning.dropdown-toggle{color:#212529;background-color:#d39e00;border-color:#c69500}.btn-warning:not(:disabled):not(.disabled).active:focus,.btn-warning:not(:disabled):not(.disabled):active:focus,.show>.btn-warning.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(222,170,12,.5)}.btn-danger{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-danger:hover{color:#fff;background-color:#c82333;border-color:#bd2130}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c82333;border-color:#bd2130;box-shadow:0 0 0 .2rem rgba(225,83,97,.5)}.btn-danger.disabled,.btn-danger:disabled{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-danger:not(:disabled):not(.disabled).active,.btn-danger:not(:disabled):not(.disabled):active,.show>.btn-danger.dropdown-toggle{color:#fff;background-color:#bd2130;border-color:#b21f2d}.btn-danger:not(:disabled):not(.disabled).active:focus,.btn-danger:not(:disabled):not(.disabled):active:focus,.show>.btn-danger.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(225,83,97,.5)}.btn-light{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-light:hover{color:#212529;background-color:#e2e6ea;border-color:#dae0e5}.btn-light.focus,.btn-light:focus{color:#212529;background-color:#e2e6ea;border-color:#dae0e5;box-shadow:0 0 0 .2rem rgba(216,217,219,.5)}.btn-light.disabled,.btn-light:disabled{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-light:not(:disabled):not(.disabled).active,.btn-light:not(:disabled):not(.disabled):active,.show>.btn-light.dropdown-toggle{color:#212529;background-color:#dae0e5;border-color:#d3d9df}.btn-light:not(:disabled):not(.disabled).active:focus,.btn-light:not(:disabled):not(.disabled):active:focus,.show>.btn-light.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(216,217,219,.5)}.btn-dark{color:#fff;background-color:#343a40;border-color:#343a40}.btn-dark:hover{color:#fff;background-color:#23272b;border-color:#1d2124}.btn-dark.focus,.btn-dark:focus{color:#fff;background-color:#23272b;border-color:#1d2124;box-shadow:0 0 0 .2rem rgba(82,88,93,.5)}.btn-dark.disabled,.btn-dark:disabled{color:#fff;background-color:#343a40;border-color:#343a40}.btn-dark:not(:disabled):not(.disabled).active,.btn-dark:not(:disabled):not(.disabled):active,.show>.btn-dark.dropdown-toggle{color:#fff;background-color:#1d2124;border-color:#171a1d}.btn-dark:not(:disabled):not(.disabled).active:focus,.btn-dark:not(:disabled):not(.disabled):active:focus,.show>.btn-dark.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(82,88,93,.5)}.btn-outline-primary{color:#007bff;border-color:#007bff}.btn-outline-primary:hover{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-primary.focus,.btn-outline-primary:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-outline-primary.disabled,.btn-outline-primary:disabled{color:#007bff;background-color:transparent}.btn-outline-primary:not(:disabled):not(.disabled).active,.btn-outline-primary:not(:disabled):not(.disabled):active,.show>.btn-outline-primary.dropdown-toggle{color:#fff;background-color:#007bff;border-color:#007bff}.btn-outline-primary:not(:disabled):not(.disabled).active:focus,.btn-outline-primary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-primary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.btn-outline-secondary{color:#6c757d;border-color:#6c757d}.btn-outline-secondary:hover{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-outline-secondary.focus,.btn-outline-secondary:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-outline-secondary.disabled,.btn-outline-secondary:disabled{color:#6c757d;background-color:transparent}.btn-outline-secondary:not(:disabled):not(.disabled).active,.btn-outline-secondary:not(:disabled):not(.disabled):active,.show>.btn-outline-secondary.dropdown-toggle{color:#fff;background-color:#6c757d;border-color:#6c757d}.btn-outline-secondary:not(:disabled):not(.disabled).active:focus,.btn-outline-secondary:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-secondary.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.btn-outline-success{color:#28a745;border-color:#28a745}.btn-outline-success:hover{color:#fff;background-color:#28a745;border-color:#28a745}.btn-outline-success.focus,.btn-outline-success:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-outline-success.disabled,.btn-outline-success:disabled{color:#28a745;background-color:transparent}.btn-outline-success:not(:disabled):not(.disabled).active,.btn-outline-success:not(:disabled):not(.disabled):active,.show>.btn-outline-success.dropdown-toggle{color:#fff;background-color:#28a745;border-color:#28a745}.btn-outline-success:not(:disabled):not(.disabled).active:focus,.btn-outline-success:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-success.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.btn-outline-info{color:#17a2b8;border-color:#17a2b8}.btn-outline-info:hover{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-outline-info.focus,.btn-outline-info:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-outline-info.disabled,.btn-outline-info:disabled{color:#17a2b8;background-color:transparent}.btn-outline-info:not(:disabled):not(.disabled).active,.btn-outline-info:not(:disabled):not(.disabled):active,.show>.btn-outline-info.dropdown-toggle{color:#fff;background-color:#17a2b8;border-color:#17a2b8}.btn-outline-info:not(:disabled):not(.disabled).active:focus,.btn-outline-info:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-info.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.btn-outline-warning{color:#ffc107;border-color:#ffc107}.btn-outline-warning:hover{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-outline-warning.focus,.btn-outline-warning:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-outline-warning.disabled,.btn-outline-warning:disabled{color:#ffc107;background-color:transparent}.btn-outline-warning:not(:disabled):not(.disabled).active,.btn-outline-warning:not(:disabled):not(.disabled):active,.show>.btn-outline-warning.dropdown-toggle{color:#212529;background-color:#ffc107;border-color:#ffc107}.btn-outline-warning:not(:disabled):not(.disabled).active:focus,.btn-outline-warning:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-warning.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.btn-outline-danger{color:#dc3545;border-color:#dc3545}.btn-outline-danger:hover{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-outline-danger.focus,.btn-outline-danger:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-outline-danger.disabled,.btn-outline-danger:disabled{color:#dc3545;background-color:transparent}.btn-outline-danger:not(:disabled):not(.disabled).active,.btn-outline-danger:not(:disabled):not(.disabled):active,.show>.btn-outline-danger.dropdown-toggle{color:#fff;background-color:#dc3545;border-color:#dc3545}.btn-outline-danger:not(:disabled):not(.disabled).active:focus,.btn-outline-danger:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-danger.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.btn-outline-light{color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light:hover{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light.focus,.btn-outline-light:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-outline-light.disabled,.btn-outline-light:disabled{color:#f8f9fa;background-color:transparent}.btn-outline-light:not(:disabled):not(.disabled).active,.btn-outline-light:not(:disabled):not(.disabled):active,.show>.btn-outline-light.dropdown-toggle{color:#212529;background-color:#f8f9fa;border-color:#f8f9fa}.btn-outline-light:not(:disabled):not(.disabled).active:focus,.btn-outline-light:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-light.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.btn-outline-dark{color:#343a40;border-color:#343a40}.btn-outline-dark:hover{color:#fff;background-color:#343a40;border-color:#343a40}.btn-outline-dark.focus,.btn-outline-dark:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-outline-dark.disabled,.btn-outline-dark:disabled{color:#343a40;background-color:transparent}.btn-outline-dark:not(:disabled):not(.disabled).active,.btn-outline-dark:not(:disabled):not(.disabled):active,.show>.btn-outline-dark.dropdown-toggle{color:#fff;background-color:#343a40;border-color:#343a40}.btn-outline-dark:not(:disabled):not(.disabled).active:focus,.btn-outline-dark:not(:disabled):not(.disabled):active:focus,.show>.btn-outline-dark.dropdown-toggle:focus{box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.btn-link{font-weight:400;color:#007bff;text-decoration:none}.btn-link:hover{color:#0056b3;text-decoration:underline}.btn-link.focus,.btn-link:focus{text-decoration:underline}.btn-link.disabled,.btn-link:disabled{color:#6c757d;pointer-events:none}.btn-group-lg>.btn,.btn-lg{padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}.btn-group-sm>.btn,.btn-sm{padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:.5rem}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{transition:opacity .15s linear}@media (prefers-reduced-motion:reduce){.fade{transition:none}}.fade:not(.show){opacity:0}.collapse:not(.show){display:none}.collapsing{position:relative;height:0;overflow:hidden;transition:height .35s ease}@media (prefers-reduced-motion:reduce){.collapsing{transition:none}}.dropdown,.dropleft,.dropright,.dropup{position:relative}.dropdown-toggle{white-space:nowrap}.dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:"";border-top:.3em solid;border-right:.3em solid transparent;border-bottom:0;border-left:.3em solid transparent}.dropdown-toggle:empty::after{margin-left:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:10rem;padding:.5rem 0;margin:.125rem 0 0;font-size:1rem;color:#212529;text-align:left;list-style:none;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.15);border-radius:.25rem}.dropdown-menu-left{right:auto;left:0}.dropdown-menu-right{right:0;left:auto}@media (min-width:576px){.dropdown-menu-sm-left{right:auto;left:0}.dropdown-menu-sm-right{right:0;left:auto}}@media (min-width:768px){.dropdown-menu-md-left{right:auto;left:0}.dropdown-menu-md-right{right:0;left:auto}}@media (min-width:992px){.dropdown-menu-lg-left{right:auto;left:0}.dropdown-menu-lg-right{right:0;left:auto}}@media (min-width:1200px){.dropdown-menu-xl-left{right:auto;left:0}.dropdown-menu-xl-right{right:0;left:auto}}.dropup .dropdown-menu{top:auto;bottom:100%;margin-top:0;margin-bottom:.125rem}.dropup .dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:"";border-top:0;border-right:.3em solid transparent;border-bottom:.3em solid;border-left:.3em solid transparent}.dropup .dropdown-toggle:empty::after{margin-left:0}.dropright .dropdown-menu{top:0;right:auto;left:100%;margin-top:0;margin-left:.125rem}.dropright .dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:"";border-top:.3em solid transparent;border-right:0;border-bottom:.3em solid transparent;border-left:.3em solid}.dropright .dropdown-toggle:empty::after{margin-left:0}.dropright .dropdown-toggle::after{vertical-align:0}.dropleft .dropdown-menu{top:0;right:100%;left:auto;margin-top:0;margin-right:.125rem}.dropleft .dropdown-toggle::after{display:inline-block;margin-left:.255em;vertical-align:.255em;content:""}.dropleft .dropdown-toggle::after{display:none}.dropleft .dropdown-toggle::before{display:inline-block;margin-right:.255em;vertical-align:.255em;content:"";border-top:.3em solid transparent;border-right:.3em solid;border-bottom:.3em solid transparent}.dropleft .dropdown-toggle:empty::after{margin-left:0}.dropleft .dropdown-toggle::before{vertical-align:0}.dropdown-menu[x-placement^=bottom],.dropdown-menu[x-placement^=left],.dropdown-menu[x-placement^=right],.dropdown-menu[x-placement^=top]{right:auto;bottom:auto}.dropdown-divider{height:0;margin:.5rem 0;overflow:hidden;border-top:1px solid #e9ecef}.dropdown-item{display:block;width:100%;padding:.25rem 1.5rem;clear:both;font-weight:400;color:#212529;text-align:inherit;white-space:nowrap;background-color:transparent;border:0}.dropdown-item:focus,.dropdown-item:hover{color:#16181b;text-decoration:none;background-color:#f8f9fa}.dropdown-item.active,.dropdown-item:active{color:#fff;text-decoration:none;background-color:#007bff}.dropdown-item.disabled,.dropdown-item:disabled{color:#6c757d;pointer-events:none;background-color:transparent}.dropdown-menu.show{display:block}.dropdown-header{display:block;padding:.5rem 1.5rem;margin-bottom:0;font-size:.875rem;color:#6c757d;white-space:nowrap}.dropdown-item-text{display:block;padding:.25rem 1.5rem;color:#212529}.btn-group,.btn-group-vertical{position:relative;display:-ms-inline-flexbox;display:inline-flex;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;-ms-flex:1 1 auto;flex:1 1 auto}.btn-group-vertical>.btn:hover,.btn-group>.btn:hover{z-index:1}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus{z-index:1}.btn-toolbar{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-pack:start;justify-content:flex-start}.btn-toolbar .input-group{width:auto}.btn-group>.btn-group:not(:first-child),.btn-group>.btn:not(:first-child){margin-left:-1px}.btn-group>.btn-group:not(:last-child)>.btn,.btn-group>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:not(:first-child)>.btn,.btn-group>.btn:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.dropdown-toggle-split{padding-right:.5625rem;padding-left:.5625rem}.dropdown-toggle-split::after,.dropright .dropdown-toggle-split::after,.dropup .dropdown-toggle-split::after{margin-left:0}.dropleft .dropdown-toggle-split::before{margin-right:0}.btn-group-sm>.btn+.dropdown-toggle-split,.btn-sm+.dropdown-toggle-split{padding-right:.375rem;padding-left:.375rem}.btn-group-lg>.btn+.dropdown-toggle-split,.btn-lg+.dropdown-toggle-split{padding-right:.75rem;padding-left:.75rem}.btn-group-vertical{-ms-flex-direction:column;flex-direction:column;-ms-flex-align:start;align-items:flex-start;-ms-flex-pack:center;justify-content:center}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group{width:100%}.btn-group-vertical>.btn-group:not(:first-child),.btn-group-vertical>.btn:not(:first-child){margin-top:-1px}.btn-group-vertical>.btn-group:not(:last-child)>.btn,.btn-group-vertical>.btn:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:not(:first-child)>.btn,.btn-group-vertical>.btn:not(:first-child){border-top-left-radius:0;border-top-right-radius:0}.btn-group-toggle>.btn,.btn-group-toggle>.btn-group>.btn{margin-bottom:0}.btn-group-toggle>.btn input[type=checkbox],.btn-group-toggle>.btn input[type=radio],.btn-group-toggle>.btn-group>.btn input[type=checkbox],.btn-group-toggle>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:stretch;align-items:stretch;width:100%}.input-group>.custom-file,.input-group>.custom-select,.input-group>.form-control,.input-group>.form-control-plaintext{position:relative;-ms-flex:1 1 auto;flex:1 1 auto;width:1%;min-width:0;margin-bottom:0}.input-group>.custom-file+.custom-file,.input-group>.custom-file+.custom-select,.input-group>.custom-file+.form-control,.input-group>.custom-select+.custom-file,.input-group>.custom-select+.custom-select,.input-group>.custom-select+.form-control,.input-group>.form-control+.custom-file,.input-group>.form-control+.custom-select,.input-group>.form-control+.form-control,.input-group>.form-control-plaintext+.custom-file,.input-group>.form-control-plaintext+.custom-select,.input-group>.form-control-plaintext+.form-control{margin-left:-1px}.input-group>.custom-file .custom-file-input:focus~.custom-file-label,.input-group>.custom-select:focus,.input-group>.form-control:focus{z-index:3}.input-group>.custom-file .custom-file-input:focus{z-index:4}.input-group>.custom-select:not(:last-child),.input-group>.form-control:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-select:not(:first-child),.input-group>.form-control:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.input-group>.custom-file{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.input-group>.custom-file:not(:last-child) .custom-file-label,.input-group>.custom-file:not(:last-child) .custom-file-label::after{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.custom-file:not(:first-child) .custom-file-label{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-append,.input-group-prepend{display:-ms-flexbox;display:flex}.input-group-append .btn,.input-group-prepend .btn{position:relative;z-index:2}.input-group-append .btn:focus,.input-group-prepend .btn:focus{z-index:3}.input-group-append .btn+.btn,.input-group-append .btn+.input-group-text,.input-group-append .input-group-text+.btn,.input-group-append .input-group-text+.input-group-text,.input-group-prepend .btn+.btn,.input-group-prepend .btn+.input-group-text,.input-group-prepend .input-group-text+.btn,.input-group-prepend .input-group-text+.input-group-text{margin-left:-1px}.input-group-prepend{margin-right:-1px}.input-group-append{margin-left:-1px}.input-group-text{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;padding:.375rem .75rem;margin-bottom:0;font-size:1rem;font-weight:400;line-height:1.5;color:#495057;text-align:center;white-space:nowrap;background-color:#e9ecef;border:1px solid #ced4da;border-radius:.25rem}.input-group-text input[type=checkbox],.input-group-text input[type=radio]{margin-top:0}.input-group-lg>.custom-select,.input-group-lg>.form-control:not(textarea){height:calc(1.5em + 1rem + 2px)}.input-group-lg>.custom-select,.input-group-lg>.form-control,.input-group-lg>.input-group-append>.btn,.input-group-lg>.input-group-append>.input-group-text,.input-group-lg>.input-group-prepend>.btn,.input-group-lg>.input-group-prepend>.input-group-text{padding:.5rem 1rem;font-size:1.25rem;line-height:1.5;border-radius:.3rem}.input-group-sm>.custom-select,.input-group-sm>.form-control:not(textarea){height:calc(1.5em + .5rem + 2px)}.input-group-sm>.custom-select,.input-group-sm>.form-control,.input-group-sm>.input-group-append>.btn,.input-group-sm>.input-group-append>.input-group-text,.input-group-sm>.input-group-prepend>.btn,.input-group-sm>.input-group-prepend>.input-group-text{padding:.25rem .5rem;font-size:.875rem;line-height:1.5;border-radius:.2rem}.input-group-lg>.custom-select,.input-group-sm>.custom-select{padding-right:1.75rem}.input-group>.input-group-append:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group>.input-group-append:last-child>.input-group-text:not(:last-child),.input-group>.input-group-append:not(:last-child)>.btn,.input-group>.input-group-append:not(:last-child)>.input-group-text,.input-group>.input-group-prepend>.btn,.input-group>.input-group-prepend>.input-group-text{border-top-right-radius:0;border-bottom-right-radius:0}.input-group>.input-group-append>.btn,.input-group>.input-group-append>.input-group-text,.input-group>.input-group-prepend:first-child>.btn:not(:first-child),.input-group>.input-group-prepend:first-child>.input-group-text:not(:first-child),.input-group>.input-group-prepend:not(:first-child)>.btn,.input-group>.input-group-prepend:not(:first-child)>.input-group-text{border-top-left-radius:0;border-bottom-left-radius:0}.custom-control{position:relative;display:block;min-height:1.5rem;padding-left:1.5rem}.custom-control-inline{display:-ms-inline-flexbox;display:inline-flex;margin-right:1rem}.custom-control-input{position:absolute;left:0;z-index:-1;width:1rem;height:1.25rem;opacity:0}.custom-control-input:checked~.custom-control-label::before{color:#fff;border-color:#007bff;background-color:#007bff}.custom-control-input:focus~.custom-control-label::before{box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.custom-control-input:focus:not(:checked)~.custom-control-label::before{border-color:#80bdff}.custom-control-input:not(:disabled):active~.custom-control-label::before{color:#fff;background-color:#b3d7ff;border-color:#b3d7ff}.custom-control-input:disabled~.custom-control-label,.custom-control-input[disabled]~.custom-control-label{color:#6c757d}.custom-control-input:disabled~.custom-control-label::before,.custom-control-input[disabled]~.custom-control-label::before{background-color:#e9ecef}.custom-control-label{position:relative;margin-bottom:0;vertical-align:top}.custom-control-label::before{position:absolute;top:.25rem;left:-1.5rem;display:block;width:1rem;height:1rem;pointer-events:none;content:"";background-color:#fff;border:#adb5bd solid 1px}.custom-control-label::after{position:absolute;top:.25rem;left:-1.5rem;display:block;width:1rem;height:1rem;content:"";background:no-repeat 50%/50% 50%}.custom-checkbox .custom-control-label::before{border-radius:.25rem}.custom-checkbox .custom-control-input:checked~.custom-control-label::after{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26l2.974 2.99L8 2.193z'/%3e%3c/svg%3e")}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::before{border-color:#007bff;background-color:#007bff}.custom-checkbox .custom-control-input:indeterminate~.custom-control-label::after{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3e%3cpath stroke='%23fff' d='M0 2h4'/%3e%3c/svg%3e")}.custom-checkbox .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-checkbox .custom-control-input:disabled:indeterminate~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-radio .custom-control-label::before{border-radius:50%}.custom-radio .custom-control-input:checked~.custom-control-label::after{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e")}.custom-radio .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-switch{padding-left:2.25rem}.custom-switch .custom-control-label::before{left:-2.25rem;width:1.75rem;pointer-events:all;border-radius:.5rem}.custom-switch .custom-control-label::after{top:calc(.25rem + 2px);left:calc(-2.25rem + 2px);width:calc(1rem - 4px);height:calc(1rem - 4px);background-color:#adb5bd;border-radius:.5rem;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out,-webkit-transform .15s ease-in-out;transition:transform .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:transform .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out,-webkit-transform .15s ease-in-out}@media (prefers-reduced-motion:reduce){.custom-switch .custom-control-label::after{transition:none}}.custom-switch .custom-control-input:checked~.custom-control-label::after{background-color:#fff;-webkit-transform:translateX(.75rem);transform:translateX(.75rem)}.custom-switch .custom-control-input:disabled:checked~.custom-control-label::before{background-color:rgba(0,123,255,.5)}.custom-select{display:inline-block;width:100%;height:calc(1.5em + .75rem + 2px);padding:.375rem 1.75rem .375rem .75rem;font-size:1rem;font-weight:400;line-height:1.5;color:#495057;vertical-align:middle;background:#fff url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23343a40' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right .75rem center/8px 10px;border:1px solid #ced4da;border-radius:.25rem;-webkit-appearance:none;-moz-appearance:none;appearance:none}.custom-select:focus{border-color:#80bdff;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.custom-select:focus::-ms-value{color:#495057;background-color:#fff}.custom-select[multiple],.custom-select[size]:not([size="1"]){height:auto;padding-right:.75rem;background-image:none}.custom-select:disabled{color:#6c757d;background-color:#e9ecef}.custom-select::-ms-expand{display:none}.custom-select:-moz-focusring{color:transparent;text-shadow:0 0 0 #495057}.custom-select-sm{height:calc(1.5em + .5rem + 2px);padding-top:.25rem;padding-bottom:.25rem;padding-left:.5rem;font-size:.875rem}.custom-select-lg{height:calc(1.5em + 1rem + 2px);padding-top:.5rem;padding-bottom:.5rem;padding-left:1rem;font-size:1.25rem}.custom-file{position:relative;display:inline-block;width:100%;height:calc(1.5em + .75rem + 2px);margin-bottom:0}.custom-file-input{position:relative;z-index:2;width:100%;height:calc(1.5em + .75rem + 2px);margin:0;opacity:0}.custom-file-input:focus~.custom-file-label{border-color:#80bdff;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.custom-file-input:disabled~.custom-file-label,.custom-file-input[disabled]~.custom-file-label{background-color:#e9ecef}.custom-file-input:lang(en)~.custom-file-label::after{content:"Browse"}.custom-file-input~.custom-file-label[data-browse]::after{content:attr(data-browse)}.custom-file-label{position:absolute;top:0;right:0;left:0;z-index:1;height:calc(1.5em + .75rem + 2px);padding:.375rem .75rem;font-weight:400;line-height:1.5;color:#495057;background-color:#fff;border:1px solid #ced4da;border-radius:.25rem}.custom-file-label::after{position:absolute;top:0;right:0;bottom:0;z-index:3;display:block;height:calc(1.5em + .75rem);padding:.375rem .75rem;line-height:1.5;color:#495057;content:"Browse";background-color:#e9ecef;border-left:inherit;border-radius:0 .25rem .25rem 0}.custom-range{width:100%;height:1.4rem;padding:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none}.custom-range:focus{outline:0}.custom-range:focus::-webkit-slider-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range:focus::-moz-range-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range:focus::-ms-thumb{box-shadow:0 0 0 1px #fff,0 0 0 .2rem rgba(0,123,255,.25)}.custom-range::-moz-focus-outer{border:0}.custom-range::-webkit-slider-thumb{width:1rem;height:1rem;margin-top:-.25rem;background-color:#007bff;border:0;border-radius:1rem;-webkit-transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;-webkit-appearance:none;appearance:none}@media (prefers-reduced-motion:reduce){.custom-range::-webkit-slider-thumb{-webkit-transition:none;transition:none}}.custom-range::-webkit-slider-thumb:active{background-color:#b3d7ff}.custom-range::-webkit-slider-runnable-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:#dee2e6;border-color:transparent;border-radius:1rem}.custom-range::-moz-range-thumb{width:1rem;height:1rem;background-color:#007bff;border:0;border-radius:1rem;-moz-transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;-moz-appearance:none;appearance:none}@media (prefers-reduced-motion:reduce){.custom-range::-moz-range-thumb{-moz-transition:none;transition:none}}.custom-range::-moz-range-thumb:active{background-color:#b3d7ff}.custom-range::-moz-range-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:#dee2e6;border-color:transparent;border-radius:1rem}.custom-range::-ms-thumb{width:1rem;height:1rem;margin-top:0;margin-right:.2rem;margin-left:.2rem;background-color:#007bff;border:0;border-radius:1rem;-ms-transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;appearance:none}@media (prefers-reduced-motion:reduce){.custom-range::-ms-thumb{-ms-transition:none;transition:none}}.custom-range::-ms-thumb:active{background-color:#b3d7ff}.custom-range::-ms-track{width:100%;height:.5rem;color:transparent;cursor:pointer;background-color:transparent;border-color:transparent;border-width:.5rem}.custom-range::-ms-fill-lower{background-color:#dee2e6;border-radius:1rem}.custom-range::-ms-fill-upper{margin-right:15px;background-color:#dee2e6;border-radius:1rem}.custom-range:disabled::-webkit-slider-thumb{background-color:#adb5bd}.custom-range:disabled::-webkit-slider-runnable-track{cursor:default}.custom-range:disabled::-moz-range-thumb{background-color:#adb5bd}.custom-range:disabled::-moz-range-track{cursor:default}.custom-range:disabled::-ms-thumb{background-color:#adb5bd}.custom-control-label::before,.custom-file-label,.custom-select{transition:background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.custom-control-label::before,.custom-file-label,.custom-select{transition:none}}.nav{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;padding-left:0;margin-bottom:0;list-style:none}.nav-link{display:block;padding:.5rem 1rem}.nav-link:focus,.nav-link:hover{text-decoration:none}.nav-link.disabled{color:#6c757d;pointer-events:none;cursor:default}.nav-tabs{border-bottom:1px solid #dee2e6}.nav-tabs .nav-item{margin-bottom:-1px}.nav-tabs .nav-link{border:1px solid transparent;border-top-left-radius:.25rem;border-top-right-radius:.25rem}.nav-tabs .nav-link:focus,.nav-tabs .nav-link:hover{border-color:#e9ecef #e9ecef #dee2e6}.nav-tabs .nav-link.disabled{color:#6c757d;background-color:transparent;border-color:transparent}.nav-tabs .nav-item.show .nav-link,.nav-tabs .nav-link.active{color:#495057;background-color:#fff;border-color:#dee2e6 #dee2e6 #fff}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.nav-pills .nav-link{border-radius:.25rem}.nav-pills .nav-link.active,.nav-pills .show>.nav-link{color:#fff;background-color:#007bff}.nav-fill .nav-item{-ms-flex:1 1 auto;flex:1 1 auto;text-align:center}.nav-justified .nav-item{-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;text-align:center}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.navbar{position:relative;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;padding:.5rem 1rem}.navbar .container,.navbar .container-fluid,.navbar .container-lg,.navbar .container-md,.navbar .container-sm,.navbar .container-xl{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between}.navbar-brand{display:inline-block;padding-top:.3125rem;padding-bottom:.3125rem;margin-right:1rem;font-size:1.25rem;line-height:inherit;white-space:nowrap}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-nav{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;padding-left:0;margin-bottom:0;list-style:none}.navbar-nav .nav-link{padding-right:0;padding-left:0}.navbar-nav .dropdown-menu{position:static;float:none}.navbar-text{display:inline-block;padding-top:.5rem;padding-bottom:.5rem}.navbar-collapse{-ms-flex-preferred-size:100%;flex-basis:100%;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center}.navbar-toggler{padding:.25rem .75rem;font-size:1.25rem;line-height:1;background-color:transparent;border:1px solid transparent;border-radius:.25rem}.navbar-toggler:focus,.navbar-toggler:hover{text-decoration:none}.navbar-toggler-icon{display:inline-block;width:1.5em;height:1.5em;vertical-align:middle;content:"";background:no-repeat center center;background-size:100% 100%}@media (max-width:575.98px){.navbar-expand-sm>.container,.navbar-expand-sm>.container-fluid,.navbar-expand-sm>.container-lg,.navbar-expand-sm>.container-md,.navbar-expand-sm>.container-sm,.navbar-expand-sm>.container-xl{padding-right:0;padding-left:0}}@media (min-width:576px){.navbar-expand-sm{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-sm .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-sm .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-sm .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-sm>.container,.navbar-expand-sm>.container-fluid,.navbar-expand-sm>.container-lg,.navbar-expand-sm>.container-md,.navbar-expand-sm>.container-sm,.navbar-expand-sm>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-sm .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-sm .navbar-toggler{display:none}}@media (max-width:767.98px){.navbar-expand-md>.container,.navbar-expand-md>.container-fluid,.navbar-expand-md>.container-lg,.navbar-expand-md>.container-md,.navbar-expand-md>.container-sm,.navbar-expand-md>.container-xl{padding-right:0;padding-left:0}}@media (min-width:768px){.navbar-expand-md{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-md .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-md .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-md .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-md>.container,.navbar-expand-md>.container-fluid,.navbar-expand-md>.container-lg,.navbar-expand-md>.container-md,.navbar-expand-md>.container-sm,.navbar-expand-md>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-md .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-md .navbar-toggler{display:none}}@media (max-width:991.98px){.navbar-expand-lg>.container,.navbar-expand-lg>.container-fluid,.navbar-expand-lg>.container-lg,.navbar-expand-lg>.container-md,.navbar-expand-lg>.container-sm,.navbar-expand-lg>.container-xl{padding-right:0;padding-left:0}}@media (min-width:992px){.navbar-expand-lg{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-lg .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-lg .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-lg .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-lg>.container,.navbar-expand-lg>.container-fluid,.navbar-expand-lg>.container-lg,.navbar-expand-lg>.container-md,.navbar-expand-lg>.container-sm,.navbar-expand-lg>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-lg .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-lg .navbar-toggler{display:none}}@media (max-width:1199.98px){.navbar-expand-xl>.container,.navbar-expand-xl>.container-fluid,.navbar-expand-xl>.container-lg,.navbar-expand-xl>.container-md,.navbar-expand-xl>.container-sm,.navbar-expand-xl>.container-xl{padding-right:0;padding-left:0}}@media (min-width:1200px){.navbar-expand-xl{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand-xl .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand-xl .navbar-nav .dropdown-menu{position:absolute}.navbar-expand-xl .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand-xl>.container,.navbar-expand-xl>.container-fluid,.navbar-expand-xl>.container-lg,.navbar-expand-xl>.container-md,.navbar-expand-xl>.container-sm,.navbar-expand-xl>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand-xl .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand-xl .navbar-toggler{display:none}}.navbar-expand{-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-pack:start;justify-content:flex-start}.navbar-expand>.container,.navbar-expand>.container-fluid,.navbar-expand>.container-lg,.navbar-expand>.container-md,.navbar-expand>.container-sm,.navbar-expand>.container-xl{padding-right:0;padding-left:0}.navbar-expand .navbar-nav{-ms-flex-direction:row;flex-direction:row}.navbar-expand .navbar-nav .dropdown-menu{position:absolute}.navbar-expand .navbar-nav .nav-link{padding-right:.5rem;padding-left:.5rem}.navbar-expand>.container,.navbar-expand>.container-fluid,.navbar-expand>.container-lg,.navbar-expand>.container-md,.navbar-expand>.container-sm,.navbar-expand>.container-xl{-ms-flex-wrap:nowrap;flex-wrap:nowrap}.navbar-expand .navbar-collapse{display:-ms-flexbox!important;display:flex!important;-ms-flex-preferred-size:auto;flex-basis:auto}.navbar-expand .navbar-toggler{display:none}.navbar-light .navbar-brand{color:rgba(0,0,0,.9)}.navbar-light .navbar-brand:focus,.navbar-light .navbar-brand:hover{color:rgba(0,0,0,.9)}.navbar-light .navbar-nav .nav-link{color:rgba(0,0,0,.5)}.navbar-light .navbar-nav .nav-link:focus,.navbar-light .navbar-nav .nav-link:hover{color:rgba(0,0,0,.7)}.navbar-light .navbar-nav .nav-link.disabled{color:rgba(0,0,0,.3)}.navbar-light .navbar-nav .active>.nav-link,.navbar-light .navbar-nav .nav-link.active,.navbar-light .navbar-nav .nav-link.show,.navbar-light .navbar-nav .show>.nav-link{color:rgba(0,0,0,.9)}.navbar-light .navbar-toggler{color:rgba(0,0,0,.5);border-color:rgba(0,0,0,.1)}.navbar-light .navbar-toggler-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%280, 0, 0, 0.5%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e")}.navbar-light .navbar-text{color:rgba(0,0,0,.5)}.navbar-light .navbar-text a{color:rgba(0,0,0,.9)}.navbar-light .navbar-text a:focus,.navbar-light .navbar-text a:hover{color:rgba(0,0,0,.9)}.navbar-dark .navbar-brand{color:#fff}.navbar-dark .navbar-brand:focus,.navbar-dark .navbar-brand:hover{color:#fff}.navbar-dark .navbar-nav .nav-link{color:rgba(255,255,255,.5)}.navbar-dark .navbar-nav .nav-link:focus,.navbar-dark .navbar-nav .nav-link:hover{color:rgba(255,255,255,.75)}.navbar-dark .navbar-nav .nav-link.disabled{color:rgba(255,255,255,.25)}.navbar-dark .navbar-nav .active>.nav-link,.navbar-dark .navbar-nav .nav-link.active,.navbar-dark .navbar-nav .nav-link.show,.navbar-dark .navbar-nav .show>.nav-link{color:#fff}.navbar-dark .navbar-toggler{color:rgba(255,255,255,.5);border-color:rgba(255,255,255,.1)}.navbar-dark .navbar-toggler-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 0.5%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e")}.navbar-dark .navbar-text{color:rgba(255,255,255,.5)}.navbar-dark .navbar-text a{color:#fff}.navbar-dark .navbar-text a:focus,.navbar-dark .navbar-text a:hover{color:#fff}.card{position:relative;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-width:0;word-wrap:break-word;background-color:#fff;background-clip:border-box;border:1px solid rgba(0,0,0,.125);border-radius:.25rem}.card>hr{margin-right:0;margin-left:0}.card>.list-group{border-top:inherit;border-bottom:inherit}.card>.list-group:first-child{border-top-width:0;border-top-left-radius:calc(.25rem - 1px);border-top-right-radius:calc(.25rem - 1px)}.card>.list-group:last-child{border-bottom-width:0;border-bottom-right-radius:calc(.25rem - 1px);border-bottom-left-radius:calc(.25rem - 1px)}.card-body{-ms-flex:1 1 auto;flex:1 1 auto;min-height:1px;padding:1.25rem}.card-title{margin-bottom:.75rem}.card-subtitle{margin-top:-.375rem;margin-bottom:0}.card-text:last-child{margin-bottom:0}.card-link:hover{text-decoration:none}.card-link+.card-link{margin-left:1.25rem}.card-header{padding:.75rem 1.25rem;margin-bottom:0;background-color:rgba(0,0,0,.03);border-bottom:1px solid rgba(0,0,0,.125)}.card-header:first-child{border-radius:calc(.25rem - 1px) calc(.25rem - 1px) 0 0}.card-header+.list-group .list-group-item:first-child{border-top:0}.card-footer{padding:.75rem 1.25rem;background-color:rgba(0,0,0,.03);border-top:1px solid rgba(0,0,0,.125)}.card-footer:last-child{border-radius:0 0 calc(.25rem - 1px) calc(.25rem - 1px)}.card-header-tabs{margin-right:-.625rem;margin-bottom:-.75rem;margin-left:-.625rem;border-bottom:0}.card-header-pills{margin-right:-.625rem;margin-left:-.625rem}.card-img-overlay{position:absolute;top:0;right:0;bottom:0;left:0;padding:1.25rem}.card-img,.card-img-bottom,.card-img-top{-ms-flex-negative:0;flex-shrink:0;width:100%}.card-img,.card-img-top{border-top-left-radius:calc(.25rem - 1px);border-top-right-radius:calc(.25rem - 1px)}.card-img,.card-img-bottom{border-bottom-right-radius:calc(.25rem - 1px);border-bottom-left-radius:calc(.25rem - 1px)}.card-deck .card{margin-bottom:15px}@media (min-width:576px){.card-deck{display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap;margin-right:-15px;margin-left:-15px}.card-deck .card{-ms-flex:1 0 0%;flex:1 0 0%;margin-right:15px;margin-bottom:0;margin-left:15px}}.card-group>.card{margin-bottom:15px}@media (min-width:576px){.card-group{display:-ms-flexbox;display:flex;-ms-flex-flow:row wrap;flex-flow:row wrap}.card-group>.card{-ms-flex:1 0 0%;flex:1 0 0%;margin-bottom:0}.card-group>.card+.card{margin-left:0;border-left:0}.card-group>.card:not(:last-child){border-top-right-radius:0;border-bottom-right-radius:0}.card-group>.card:not(:last-child) .card-header,.card-group>.card:not(:last-child) .card-img-top{border-top-right-radius:0}.card-group>.card:not(:last-child) .card-footer,.card-group>.card:not(:last-child) .card-img-bottom{border-bottom-right-radius:0}.card-group>.card:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.card-group>.card:not(:first-child) .card-header,.card-group>.card:not(:first-child) .card-img-top{border-top-left-radius:0}.card-group>.card:not(:first-child) .card-footer,.card-group>.card:not(:first-child) .card-img-bottom{border-bottom-left-radius:0}}.card-columns .card{margin-bottom:.75rem}@media (min-width:576px){.card-columns{-webkit-column-count:3;-moz-column-count:3;column-count:3;-webkit-column-gap:1.25rem;-moz-column-gap:1.25rem;column-gap:1.25rem;orphans:1;widows:1}.card-columns .card{display:inline-block;width:100%}}.accordion>.card{overflow:hidden}.accordion>.card:not(:last-of-type){border-bottom:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.accordion>.card:not(:first-of-type){border-top-left-radius:0;border-top-right-radius:0}.accordion>.card>.card-header{border-radius:0;margin-bottom:-1px}.breadcrumb{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;padding:.75rem 1rem;margin-bottom:1rem;list-style:none;background-color:#e9ecef;border-radius:.25rem}.breadcrumb-item{display:-ms-flexbox;display:flex}.breadcrumb-item+.breadcrumb-item{padding-left:.5rem}.breadcrumb-item+.breadcrumb-item::before{display:inline-block;padding-right:.5rem;color:#6c757d;content:"/"}.breadcrumb-item+.breadcrumb-item:hover::before{text-decoration:underline}.breadcrumb-item+.breadcrumb-item:hover::before{text-decoration:none}.breadcrumb-item.active{color:#6c757d}.pagination{display:-ms-flexbox;display:flex;padding-left:0;list-style:none;border-radius:.25rem}.page-link{position:relative;display:block;padding:.5rem .75rem;margin-left:-1px;line-height:1.25;color:#007bff;background-color:#fff;border:1px solid #dee2e6}.page-link:hover{z-index:2;color:#0056b3;text-decoration:none;background-color:#e9ecef;border-color:#dee2e6}.page-link:focus{z-index:3;outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.25)}.page-item:first-child .page-link{margin-left:0;border-top-left-radius:.25rem;border-bottom-left-radius:.25rem}.page-item:last-child .page-link{border-top-right-radius:.25rem;border-bottom-right-radius:.25rem}.page-item.active .page-link{z-index:3;color:#fff;background-color:#007bff;border-color:#007bff}.page-item.disabled .page-link{color:#6c757d;pointer-events:none;cursor:auto;background-color:#fff;border-color:#dee2e6}.pagination-lg .page-link{padding:.75rem 1.5rem;font-size:1.25rem;line-height:1.5}.pagination-lg .page-item:first-child .page-link{border-top-left-radius:.3rem;border-bottom-left-radius:.3rem}.pagination-lg .page-item:last-child .page-link{border-top-right-radius:.3rem;border-bottom-right-radius:.3rem}.pagination-sm .page-link{padding:.25rem .5rem;font-size:.875rem;line-height:1.5}.pagination-sm .page-item:first-child .page-link{border-top-left-radius:.2rem;border-bottom-left-radius:.2rem}.pagination-sm .page-item:last-child .page-link{border-top-right-radius:.2rem;border-bottom-right-radius:.2rem}.badge{display:inline-block;padding:.25em .4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25rem;transition:color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:focus,a.badge:hover{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:.6em;padding-left:.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:focus,a.badge-primary:hover{color:#fff;background-color:#0062cc}a.badge-primary.focus,a.badge-primary:focus{outline:0;box-shadow:0 0 0 .2rem rgba(0,123,255,.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:focus,a.badge-secondary:hover{color:#fff;background-color:#545b62}a.badge-secondary.focus,a.badge-secondary:focus{outline:0;box-shadow:0 0 0 .2rem rgba(108,117,125,.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:focus,a.badge-success:hover{color:#fff;background-color:#1e7e34}a.badge-success.focus,a.badge-success:focus{outline:0;box-shadow:0 0 0 .2rem rgba(40,167,69,.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:focus,a.badge-info:hover{color:#fff;background-color:#117a8b}a.badge-info.focus,a.badge-info:focus{outline:0;box-shadow:0 0 0 .2rem rgba(23,162,184,.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:focus,a.badge-warning:hover{color:#212529;background-color:#d39e00}a.badge-warning.focus,a.badge-warning:focus{outline:0;box-shadow:0 0 0 .2rem rgba(255,193,7,.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:focus,a.badge-danger:hover{color:#fff;background-color:#bd2130}a.badge-danger.focus,a.badge-danger:focus{outline:0;box-shadow:0 0 0 .2rem rgba(220,53,69,.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:focus,a.badge-light:hover{color:#212529;background-color:#dae0e5}a.badge-light.focus,a.badge-light:focus{outline:0;box-shadow:0 0 0 .2rem rgba(248,249,250,.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:focus,a.badge-dark:hover{color:#fff;background-color:#1d2124}a.badge-dark.focus,a.badge-dark:focus{outline:0;box-shadow:0 0 0 .2rem rgba(52,58,64,.5)}.jumbotron{padding:2rem 1rem;margin-bottom:2rem;background-color:#e9ecef;border-radius:.3rem}@media (min-width:576px){.jumbotron{padding:4rem 2rem}}.jumbotron-fluid{padding-right:0;padding-left:0;border-radius:0}.alert{position:relative;padding:.75rem 1.25rem;margin-bottom:1rem;border:1px solid transparent;border-radius:.25rem}.alert-heading{color:inherit}.alert-link{font-weight:700}.alert-dismissible{padding-right:4rem}.alert-dismissible .close{position:absolute;top:0;right:0;padding:.75rem 1.25rem;color:inherit}.alert-primary{color:#004085;background-color:#cce5ff;border-color:#b8daff}.alert-primary hr{border-top-color:#9fcdff}.alert-primary .alert-link{color:#002752}.alert-secondary{color:#383d41;background-color:#e2e3e5;border-color:#d6d8db}.alert-secondary hr{border-top-color:#c8cbcf}.alert-secondary .alert-link{color:#202326}.alert-success{color:#155724;background-color:#d4edda;border-color:#c3e6cb}.alert-success hr{border-top-color:#b1dfbb}.alert-success .alert-link{color:#0b2e13}.alert-info{color:#0c5460;background-color:#d1ecf1;border-color:#bee5eb}.alert-info hr{border-top-color:#abdde5}.alert-info .alert-link{color:#062c33}.alert-warning{color:#856404;background-color:#fff3cd;border-color:#ffeeba}.alert-warning hr{border-top-color:#ffe8a1}.alert-warning .alert-link{color:#533f03}.alert-danger{color:#721c24;background-color:#f8d7da;border-color:#f5c6cb}.alert-danger hr{border-top-color:#f1b0b7}.alert-danger .alert-link{color:#491217}.alert-light{color:#818182;background-color:#fefefe;border-color:#fdfdfe}.alert-light hr{border-top-color:#ececf6}.alert-light .alert-link{color:#686868}.alert-dark{color:#1b1e21;background-color:#d6d8d9;border-color:#c6c8ca}.alert-dark hr{border-top-color:#b9bbbe}.alert-dark .alert-link{color:#040505}@-webkit-keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:1rem 0}to{background-position:0 0}}.progress{display:-ms-flexbox;display:flex;height:1rem;overflow:hidden;line-height:0;font-size:.75rem;background-color:#e9ecef;border-radius:.25rem}.progress-bar{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;overflow:hidden;color:#fff;text-align:center;white-space:nowrap;background-color:#007bff;transition:width .6s ease}@media (prefers-reduced-motion:reduce){.progress-bar{transition:none}}.progress-bar-striped{background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-size:1rem 1rem}.progress-bar-animated{-webkit-animation:progress-bar-stripes 1s linear infinite;animation:progress-bar-stripes 1s linear infinite}@media (prefers-reduced-motion:reduce){.progress-bar-animated{-webkit-animation:none;animation:none}}.media{display:-ms-flexbox;display:flex;-ms-flex-align:start;align-items:flex-start}.media-body{-ms-flex:1;flex:1}.list-group{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;padding-left:0;margin-bottom:0;border-radius:.25rem}.list-group-item-action{width:100%;color:#495057;text-align:inherit}.list-group-item-action:focus,.list-group-item-action:hover{z-index:1;color:#495057;text-decoration:none;background-color:#f8f9fa}.list-group-item-action:active{color:#212529;background-color:#e9ecef}.list-group-item{position:relative;display:block;padding:.75rem 1.25rem;background-color:#fff;border:1px solid rgba(0,0,0,.125)}.list-group-item:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.list-group-item:last-child{border-bottom-right-radius:inherit;border-bottom-left-radius:inherit}.list-group-item.disabled,.list-group-item:disabled{color:#6c757d;pointer-events:none;background-color:#fff}.list-group-item.active{z-index:2;color:#fff;background-color:#007bff;border-color:#007bff}.list-group-item+.list-group-item{border-top-width:0}.list-group-item+.list-group-item.active{margin-top:-1px;border-top-width:1px}.list-group-horizontal{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal>.list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal>.list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal>.list-group-item.active{margin-top:0}.list-group-horizontal>.list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal>.list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}@media (min-width:576px){.list-group-horizontal-sm{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-sm>.list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-sm>.list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-sm>.list-group-item.active{margin-top:0}.list-group-horizontal-sm>.list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-sm>.list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}@media (min-width:768px){.list-group-horizontal-md{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-md>.list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-md>.list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-md>.list-group-item.active{margin-top:0}.list-group-horizontal-md>.list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-md>.list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}@media (min-width:992px){.list-group-horizontal-lg{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-lg>.list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-lg>.list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-lg>.list-group-item.active{margin-top:0}.list-group-horizontal-lg>.list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-lg>.list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}@media (min-width:1200px){.list-group-horizontal-xl{-ms-flex-direction:row;flex-direction:row}.list-group-horizontal-xl>.list-group-item:first-child{border-bottom-left-radius:.25rem;border-top-right-radius:0}.list-group-horizontal-xl>.list-group-item:last-child{border-top-right-radius:.25rem;border-bottom-left-radius:0}.list-group-horizontal-xl>.list-group-item.active{margin-top:0}.list-group-horizontal-xl>.list-group-item+.list-group-item{border-top-width:1px;border-left-width:0}.list-group-horizontal-xl>.list-group-item+.list-group-item.active{margin-left:-1px;border-left-width:1px}}.list-group-flush{border-radius:0}.list-group-flush>.list-group-item{border-width:0 0 1px}.list-group-flush>.list-group-item:last-child{border-bottom-width:0}.list-group-item-primary{color:#004085;background-color:#b8daff}.list-group-item-primary.list-group-item-action:focus,.list-group-item-primary.list-group-item-action:hover{color:#004085;background-color:#9fcdff}.list-group-item-primary.list-group-item-action.active{color:#fff;background-color:#004085;border-color:#004085}.list-group-item-secondary{color:#383d41;background-color:#d6d8db}.list-group-item-secondary.list-group-item-action:focus,.list-group-item-secondary.list-group-item-action:hover{color:#383d41;background-color:#c8cbcf}.list-group-item-secondary.list-group-item-action.active{color:#fff;background-color:#383d41;border-color:#383d41}.list-group-item-success{color:#155724;background-color:#c3e6cb}.list-group-item-success.list-group-item-action:focus,.list-group-item-success.list-group-item-action:hover{color:#155724;background-color:#b1dfbb}.list-group-item-success.list-group-item-action.active{color:#fff;background-color:#155724;border-color:#155724}.list-group-item-info{color:#0c5460;background-color:#bee5eb}.list-group-item-info.list-group-item-action:focus,.list-group-item-info.list-group-item-action:hover{color:#0c5460;background-color:#abdde5}.list-group-item-info.list-group-item-action.active{color:#fff;background-color:#0c5460;border-color:#0c5460}.list-group-item-warning{color:#856404;background-color:#ffeeba}.list-group-item-warning.list-group-item-action:focus,.list-group-item-warning.list-group-item-action:hover{color:#856404;background-color:#ffe8a1}.list-group-item-warning.list-group-item-action.active{color:#fff;background-color:#856404;border-color:#856404}.list-group-item-danger{color:#721c24;background-color:#f5c6cb}.list-group-item-danger.list-group-item-action:focus,.list-group-item-danger.list-group-item-action:hover{color:#721c24;background-color:#f1b0b7}.list-group-item-danger.list-group-item-action.active{color:#fff;background-color:#721c24;border-color:#721c24}.list-group-item-light{color:#818182;background-color:#fdfdfe}.list-group-item-light.list-group-item-action:focus,.list-group-item-light.list-group-item-action:hover{color:#818182;background-color:#ececf6}.list-group-item-light.list-group-item-action.active{color:#fff;background-color:#818182;border-color:#818182}.list-group-item-dark{color:#1b1e21;background-color:#c6c8ca}.list-group-item-dark.list-group-item-action:focus,.list-group-item-dark.list-group-item-action:hover{color:#1b1e21;background-color:#b9bbbe}.list-group-item-dark.list-group-item-action.active{color:#fff;background-color:#1b1e21;border-color:#1b1e21}.close{float:right;font-size:1.5rem;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.5}.close:hover{color:#000;text-decoration:none}.close:not(:disabled):not(.disabled):focus,.close:not(:disabled):not(.disabled):hover{opacity:.75}button.close{padding:0;background-color:transparent;border:0}a.close.disabled{pointer-events:none}.toast{max-width:350px;overflow:hidden;font-size:.875rem;background-color:rgba(255,255,255,.85);background-clip:padding-box;border:1px solid rgba(0,0,0,.1);box-shadow:0 .25rem .75rem rgba(0,0,0,.1);-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);opacity:0;border-radius:.25rem}.toast:not(:last-child){margin-bottom:.75rem}.toast.showing{opacity:1}.toast.show{display:block;opacity:1}.toast.hide{display:none}.toast-header{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;padding:.25rem .75rem;color:#6c757d;background-color:rgba(255,255,255,.85);background-clip:padding-box;border-bottom:1px solid rgba(0,0,0,.05)}.toast-body{padding:.75rem}.modal-open{overflow:hidden}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal{position:fixed;top:0;left:0;z-index:1050;display:none;width:100%;height:100%;overflow:hidden;outline:0}.modal-dialog{position:relative;width:auto;margin:.5rem;pointer-events:none}.modal.fade .modal-dialog{transition:-webkit-transform .3s ease-out;transition:transform .3s ease-out;transition:transform .3s ease-out,-webkit-transform .3s ease-out;-webkit-transform:translate(0,-50px);transform:translate(0,-50px)}@media (prefers-reduced-motion:reduce){.modal.fade .modal-dialog{transition:none}}.modal.show .modal-dialog{-webkit-transform:none;transform:none}.modal.modal-static .modal-dialog{-webkit-transform:scale(1.02);transform:scale(1.02)}.modal-dialog-scrollable{display:-ms-flexbox;display:flex;max-height:calc(100% - 1rem)}.modal-dialog-scrollable .modal-content{max-height:calc(100vh - 1rem);overflow:hidden}.modal-dialog-scrollable .modal-footer,.modal-dialog-scrollable .modal-header{-ms-flex-negative:0;flex-shrink:0}.modal-dialog-scrollable .modal-body{overflow-y:auto}.modal-dialog-centered{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;min-height:calc(100% - 1rem)}.modal-dialog-centered::before{display:block;height:calc(100vh - 1rem);height:-webkit-min-content;height:-moz-min-content;height:min-content;content:""}.modal-dialog-centered.modal-dialog-scrollable{-ms-flex-direction:column;flex-direction:column;-ms-flex-pack:center;justify-content:center;height:100%}.modal-dialog-centered.modal-dialog-scrollable .modal-content{max-height:none}.modal-dialog-centered.modal-dialog-scrollable::before{content:none}.modal-content{position:relative;display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:100%;pointer-events:auto;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem;outline:0}.modal-backdrop{position:fixed;top:0;left:0;z-index:1040;width:100vw;height:100vh;background-color:#000}.modal-backdrop.fade{opacity:0}.modal-backdrop.show{opacity:.5}.modal-header{display:-ms-flexbox;display:flex;-ms-flex-align:start;align-items:flex-start;-ms-flex-pack:justify;justify-content:space-between;padding:1rem 1rem;border-bottom:1px solid #dee2e6;border-top-left-radius:calc(.3rem - 1px);border-top-right-radius:calc(.3rem - 1px)}.modal-header .close{padding:1rem 1rem;margin:-1rem -1rem -1rem auto}.modal-title{margin-bottom:0;line-height:1.5}.modal-body{position:relative;-ms-flex:1 1 auto;flex:1 1 auto;padding:1rem}.modal-footer{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:center;align-items:center;-ms-flex-pack:end;justify-content:flex-end;padding:.75rem;border-top:1px solid #dee2e6;border-bottom-right-radius:calc(.3rem - 1px);border-bottom-left-radius:calc(.3rem - 1px)}.modal-footer>*{margin:.25rem}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:576px){.modal-dialog{max-width:500px;margin:1.75rem auto}.modal-dialog-scrollable{max-height:calc(100% - 3.5rem)}.modal-dialog-scrollable .modal-content{max-height:calc(100vh - 3.5rem)}.modal-dialog-centered{min-height:calc(100% - 3.5rem)}.modal-dialog-centered::before{height:calc(100vh - 3.5rem);height:-webkit-min-content;height:-moz-min-content;height:min-content}.modal-sm{max-width:300px}}@media (min-width:992px){.modal-lg,.modal-xl{max-width:800px}}@media (min-width:1200px){.modal-xl{max-width:1140px}}.tooltip{position:absolute;z-index:1070;display:block;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.875rem;word-wrap:break-word;opacity:0}.tooltip.show{opacity:.9}.tooltip .arrow{position:absolute;display:block;width:.8rem;height:.4rem}.tooltip .arrow::before{position:absolute;content:"";border-color:transparent;border-style:solid}.bs-tooltip-auto[x-placement^=top],.bs-tooltip-top{padding:.4rem 0}.bs-tooltip-auto[x-placement^=top] .arrow,.bs-tooltip-top .arrow{bottom:0}.bs-tooltip-auto[x-placement^=top] .arrow::before,.bs-tooltip-top .arrow::before{top:0;border-width:.4rem .4rem 0;border-top-color:#000}.bs-tooltip-auto[x-placement^=right],.bs-tooltip-right{padding:0 .4rem}.bs-tooltip-auto[x-placement^=right] .arrow,.bs-tooltip-right .arrow{left:0;width:.4rem;height:.8rem}.bs-tooltip-auto[x-placement^=right] .arrow::before,.bs-tooltip-right .arrow::before{right:0;border-width:.4rem .4rem .4rem 0;border-right-color:#000}.bs-tooltip-auto[x-placement^=bottom],.bs-tooltip-bottom{padding:.4rem 0}.bs-tooltip-auto[x-placement^=bottom] .arrow,.bs-tooltip-bottom .arrow{top:0}.bs-tooltip-auto[x-placement^=bottom] .arrow::before,.bs-tooltip-bottom .arrow::before{bottom:0;border-width:0 .4rem .4rem;border-bottom-color:#000}.bs-tooltip-auto[x-placement^=left],.bs-tooltip-left{padding:0 .4rem}.bs-tooltip-auto[x-placement^=left] .arrow,.bs-tooltip-left .arrow{right:0;width:.4rem;height:.8rem}.bs-tooltip-auto[x-placement^=left] .arrow::before,.bs-tooltip-left .arrow::before{left:0;border-width:.4rem 0 .4rem .4rem;border-left-color:#000}.tooltip-inner{max-width:200px;padding:.25rem .5rem;color:#fff;text-align:center;background-color:#000;border-radius:.25rem}.popover{position:absolute;top:0;left:0;z-index:1060;display:block;max-width:276px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-style:normal;font-weight:400;line-height:1.5;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;white-space:normal;line-break:auto;font-size:.875rem;word-wrap:break-word;background-color:#fff;background-clip:padding-box;border:1px solid rgba(0,0,0,.2);border-radius:.3rem}.popover .arrow{position:absolute;display:block;width:1rem;height:.5rem;margin:0 .3rem}.popover .arrow::after,.popover .arrow::before{position:absolute;display:block;content:"";border-color:transparent;border-style:solid}.bs-popover-auto[x-placement^=top],.bs-popover-top{margin-bottom:.5rem}.bs-popover-auto[x-placement^=top]>.arrow,.bs-popover-top>.arrow{bottom:calc(-.5rem - 1px)}.bs-popover-auto[x-placement^=top]>.arrow::before,.bs-popover-top>.arrow::before{bottom:0;border-width:.5rem .5rem 0;border-top-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=top]>.arrow::after,.bs-popover-top>.arrow::after{bottom:1px;border-width:.5rem .5rem 0;border-top-color:#fff}.bs-popover-auto[x-placement^=right],.bs-popover-right{margin-left:.5rem}.bs-popover-auto[x-placement^=right]>.arrow,.bs-popover-right>.arrow{left:calc(-.5rem - 1px);width:.5rem;height:1rem;margin:.3rem 0}.bs-popover-auto[x-placement^=right]>.arrow::before,.bs-popover-right>.arrow::before{left:0;border-width:.5rem .5rem .5rem 0;border-right-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=right]>.arrow::after,.bs-popover-right>.arrow::after{left:1px;border-width:.5rem .5rem .5rem 0;border-right-color:#fff}.bs-popover-auto[x-placement^=bottom],.bs-popover-bottom{margin-top:.5rem}.bs-popover-auto[x-placement^=bottom]>.arrow,.bs-popover-bottom>.arrow{top:calc(-.5rem - 1px)}.bs-popover-auto[x-placement^=bottom]>.arrow::before,.bs-popover-bottom>.arrow::before{top:0;border-width:0 .5rem .5rem .5rem;border-bottom-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=bottom]>.arrow::after,.bs-popover-bottom>.arrow::after{top:1px;border-width:0 .5rem .5rem .5rem;border-bottom-color:#fff}.bs-popover-auto[x-placement^=bottom] .popover-header::before,.bs-popover-bottom .popover-header::before{position:absolute;top:0;left:50%;display:block;width:1rem;margin-left:-.5rem;content:"";border-bottom:1px solid #f7f7f7}.bs-popover-auto[x-placement^=left],.bs-popover-left{margin-right:.5rem}.bs-popover-auto[x-placement^=left]>.arrow,.bs-popover-left>.arrow{right:calc(-.5rem - 1px);width:.5rem;height:1rem;margin:.3rem 0}.bs-popover-auto[x-placement^=left]>.arrow::before,.bs-popover-left>.arrow::before{right:0;border-width:.5rem 0 .5rem .5rem;border-left-color:rgba(0,0,0,.25)}.bs-popover-auto[x-placement^=left]>.arrow::after,.bs-popover-left>.arrow::after{right:1px;border-width:.5rem 0 .5rem .5rem;border-left-color:#fff}.popover-header{padding:.5rem .75rem;margin-bottom:0;font-size:1rem;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-top-left-radius:calc(.3rem - 1px);border-top-right-radius:calc(.3rem - 1px)}.popover-header:empty{display:none}.popover-body{padding:.5rem .75rem;color:#212529}.carousel{position:relative}.carousel.pointer-event{-ms-touch-action:pan-y;touch-action:pan-y}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner::after{display:block;clear:both;content:""}.carousel-item{position:relative;display:none;float:left;width:100%;margin-right:-100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;transition:-webkit-transform .6s ease-in-out;transition:transform .6s ease-in-out;transition:transform .6s ease-in-out,-webkit-transform .6s ease-in-out}@media (prefers-reduced-motion:reduce){.carousel-item{transition:none}}.carousel-item-next,.carousel-item-prev,.carousel-item.active{display:block}.active.carousel-item-right,.carousel-item-next:not(.carousel-item-left){-webkit-transform:translateX(100%);transform:translateX(100%)}.active.carousel-item-left,.carousel-item-prev:not(.carousel-item-right){-webkit-transform:translateX(-100%);transform:translateX(-100%)}.carousel-fade .carousel-item{opacity:0;transition-property:opacity;-webkit-transform:none;transform:none}.carousel-fade .carousel-item-next.carousel-item-left,.carousel-fade .carousel-item-prev.carousel-item-right,.carousel-fade .carousel-item.active{z-index:1;opacity:1}.carousel-fade .active.carousel-item-left,.carousel-fade .active.carousel-item-right{z-index:0;opacity:0;transition:opacity 0s .6s}@media (prefers-reduced-motion:reduce){.carousel-fade .active.carousel-item-left,.carousel-fade .active.carousel-item-right{transition:none}}.carousel-control-next,.carousel-control-prev{position:absolute;top:0;bottom:0;z-index:1;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:15%;color:#fff;text-align:center;opacity:.5;transition:opacity .15s ease}@media (prefers-reduced-motion:reduce){.carousel-control-next,.carousel-control-prev{transition:none}}.carousel-control-next:focus,.carousel-control-next:hover,.carousel-control-prev:focus,.carousel-control-prev:hover{color:#fff;text-decoration:none;outline:0;opacity:.9}.carousel-control-prev{left:0}.carousel-control-next{right:0}.carousel-control-next-icon,.carousel-control-prev-icon{display:inline-block;width:20px;height:20px;background:no-repeat 50%/100% 100%}.carousel-control-prev-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath d='M5.25 0l-4 4 4 4 1.5-1.5L4.25 4l2.5-2.5L5.25 0z'/%3e%3c/svg%3e")}.carousel-control-next-icon{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath d='M2.75 0l-1.5 1.5L3.75 4l-2.5 2.5L2.75 8l4-4-4-4z'/%3e%3c/svg%3e")}.carousel-indicators{position:absolute;right:0;bottom:0;left:0;z-index:15;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;padding-left:0;margin-right:15%;margin-left:15%;list-style:none}.carousel-indicators li{box-sizing:content-box;-ms-flex:0 1 auto;flex:0 1 auto;width:30px;height:3px;margin-right:3px;margin-left:3px;text-indent:-999px;cursor:pointer;background-color:#fff;background-clip:padding-box;border-top:10px solid transparent;border-bottom:10px solid transparent;opacity:.5;transition:opacity .6s ease}@media (prefers-reduced-motion:reduce){.carousel-indicators li{transition:none}}.carousel-indicators .active{opacity:1}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center}@-webkit-keyframes spinner-border{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-border{to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.spinner-border{display:inline-block;width:2rem;height:2rem;vertical-align:text-bottom;border:.25em solid currentColor;border-right-color:transparent;border-radius:50%;-webkit-animation:spinner-border .75s linear infinite;animation:spinner-border .75s linear infinite}.spinner-border-sm{width:1rem;height:1rem;border-width:.2em}@-webkit-keyframes spinner-grow{0%{-webkit-transform:scale(0);transform:scale(0)}50%{opacity:1;-webkit-transform:none;transform:none}}@keyframes spinner-grow{0%{-webkit-transform:scale(0);transform:scale(0)}50%{opacity:1;-webkit-transform:none;transform:none}}.spinner-grow{display:inline-block;width:2rem;height:2rem;vertical-align:text-bottom;background-color:currentColor;border-radius:50%;opacity:0;-webkit-animation:spinner-grow .75s linear infinite;animation:spinner-grow .75s linear infinite}.spinner-grow-sm{width:1rem;height:1rem}.align-baseline{vertical-align:baseline!important}.align-top{vertical-align:top!important}.align-middle{vertical-align:middle!important}.align-bottom{vertical-align:bottom!important}.align-text-bottom{vertical-align:text-bottom!important}.align-text-top{vertical-align:text-top!important}.bg-primary{background-color:#007bff!important}a.bg-primary:focus,a.bg-primary:hover,button.bg-primary:focus,button.bg-primary:hover{background-color:#0062cc!important}.bg-secondary{background-color:#6c757d!important}a.bg-secondary:focus,a.bg-secondary:hover,button.bg-secondary:focus,button.bg-secondary:hover{background-color:#545b62!important}.bg-success{background-color:#28a745!important}a.bg-success:focus,a.bg-success:hover,button.bg-success:focus,button.bg-success:hover{background-color:#1e7e34!important}.bg-info{background-color:#17a2b8!important}a.bg-info:focus,a.bg-info:hover,button.bg-info:focus,button.bg-info:hover{background-color:#117a8b!important}.bg-warning{background-color:#ffc107!important}a.bg-warning:focus,a.bg-warning:hover,button.bg-warning:focus,button.bg-warning:hover{background-color:#d39e00!important}.bg-danger{background-color:#dc3545!important}a.bg-danger:focus,a.bg-danger:hover,button.bg-danger:focus,button.bg-danger:hover{background-color:#bd2130!important}.bg-light{background-color:#f8f9fa!important}a.bg-light:focus,a.bg-light:hover,button.bg-light:focus,button.bg-light:hover{background-color:#dae0e5!important}.bg-dark{background-color:#343a40!important}a.bg-dark:focus,a.bg-dark:hover,button.bg-dark:focus,button.bg-dark:hover{background-color:#1d2124!important}.bg-white{background-color:#fff!important}.bg-transparent{background-color:transparent!important}.border{border:1px solid #dee2e6!important}.border-top{border-top:1px solid #dee2e6!important}.border-right{border-right:1px solid #dee2e6!important}.border-bottom{border-bottom:1px solid #dee2e6!important}.border-left{border-left:1px solid #dee2e6!important}.border-0{border:0!important}.border-top-0{border-top:0!important}.border-right-0{border-right:0!important}.border-bottom-0{border-bottom:0!important}.border-left-0{border-left:0!important}.border-primary{border-color:#007bff!important}.border-secondary{border-color:#6c757d!important}.border-success{border-color:#28a745!important}.border-info{border-color:#17a2b8!important}.border-warning{border-color:#ffc107!important}.border-danger{border-color:#dc3545!important}.border-light{border-color:#f8f9fa!important}.border-dark{border-color:#343a40!important}.border-white{border-color:#fff!important}.rounded-sm{border-radius:.2rem!important}.rounded{border-radius:.25rem!important}.rounded-top{border-top-left-radius:.25rem!important;border-top-right-radius:.25rem!important}.rounded-right{border-top-right-radius:.25rem!important;border-bottom-right-radius:.25rem!important}.rounded-bottom{border-bottom-right-radius:.25rem!important;border-bottom-left-radius:.25rem!important}.rounded-left{border-top-left-radius:.25rem!important;border-bottom-left-radius:.25rem!important}.rounded-lg{border-radius:.3rem!important}.rounded-circle{border-radius:50%!important}.rounded-pill{border-radius:50rem!important}.rounded-0{border-radius:0!important}.clearfix::after{display:block;clear:both;content:""}.d-none{display:none!important}.d-inline{display:inline!important}.d-inline-block{display:inline-block!important}.d-block{display:block!important}.d-table{display:table!important}.d-table-row{display:table-row!important}.d-table-cell{display:table-cell!important}.d-flex{display:-ms-flexbox!important;display:flex!important}.d-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}@media (min-width:576px){.d-sm-none{display:none!important}.d-sm-inline{display:inline!important}.d-sm-inline-block{display:inline-block!important}.d-sm-block{display:block!important}.d-sm-table{display:table!important}.d-sm-table-row{display:table-row!important}.d-sm-table-cell{display:table-cell!important}.d-sm-flex{display:-ms-flexbox!important;display:flex!important}.d-sm-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:768px){.d-md-none{display:none!important}.d-md-inline{display:inline!important}.d-md-inline-block{display:inline-block!important}.d-md-block{display:block!important}.d-md-table{display:table!important}.d-md-table-row{display:table-row!important}.d-md-table-cell{display:table-cell!important}.d-md-flex{display:-ms-flexbox!important;display:flex!important}.d-md-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:992px){.d-lg-none{display:none!important}.d-lg-inline{display:inline!important}.d-lg-inline-block{display:inline-block!important}.d-lg-block{display:block!important}.d-lg-table{display:table!important}.d-lg-table-row{display:table-row!important}.d-lg-table-cell{display:table-cell!important}.d-lg-flex{display:-ms-flexbox!important;display:flex!important}.d-lg-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media (min-width:1200px){.d-xl-none{display:none!important}.d-xl-inline{display:inline!important}.d-xl-inline-block{display:inline-block!important}.d-xl-block{display:block!important}.d-xl-table{display:table!important}.d-xl-table-row{display:table-row!important}.d-xl-table-cell{display:table-cell!important}.d-xl-flex{display:-ms-flexbox!important;display:flex!important}.d-xl-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}@media print{.d-print-none{display:none!important}.d-print-inline{display:inline!important}.d-print-inline-block{display:inline-block!important}.d-print-block{display:block!important}.d-print-table{display:table!important}.d-print-table-row{display:table-row!important}.d-print-table-cell{display:table-cell!important}.d-print-flex{display:-ms-flexbox!important;display:flex!important}.d-print-inline-flex{display:-ms-inline-flexbox!important;display:inline-flex!important}}.embed-responsive{position:relative;display:block;width:100%;padding:0;overflow:hidden}.embed-responsive::before{display:block;content:""}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-21by9::before{padding-top:42.857143%}.embed-responsive-16by9::before{padding-top:56.25%}.embed-responsive-4by3::before{padding-top:75%}.embed-responsive-1by1::before{padding-top:100%}.flex-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-center{-ms-flex-align:center!important;align-items:center!important}.align-items-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}@media (min-width:576px){.flex-sm-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-sm-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-sm-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-sm-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-sm-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-sm-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-sm-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-sm-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-sm-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-sm-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-sm-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-sm-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-sm-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-sm-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-sm-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-sm-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-sm-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-sm-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-sm-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-sm-center{-ms-flex-align:center!important;align-items:center!important}.align-items-sm-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-sm-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-sm-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-sm-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-sm-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-sm-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-sm-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-sm-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-sm-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-sm-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-sm-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-sm-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-sm-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-sm-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:768px){.flex-md-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-md-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-md-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-md-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-md-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-md-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-md-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-md-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-md-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-md-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-md-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-md-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-md-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-md-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-md-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-md-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-md-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-md-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-md-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-md-center{-ms-flex-align:center!important;align-items:center!important}.align-items-md-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-md-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-md-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-md-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-md-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-md-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-md-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-md-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-md-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-md-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-md-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-md-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-md-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-md-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:992px){.flex-lg-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-lg-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-lg-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-lg-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-lg-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-lg-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-lg-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-lg-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-lg-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-lg-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-lg-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-lg-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-lg-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-lg-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-lg-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-lg-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-lg-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-lg-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-lg-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-lg-center{-ms-flex-align:center!important;align-items:center!important}.align-items-lg-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-lg-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-lg-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-lg-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-lg-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-lg-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-lg-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-lg-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-lg-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-lg-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-lg-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-lg-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-lg-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-lg-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}@media (min-width:1200px){.flex-xl-row{-ms-flex-direction:row!important;flex-direction:row!important}.flex-xl-column{-ms-flex-direction:column!important;flex-direction:column!important}.flex-xl-row-reverse{-ms-flex-direction:row-reverse!important;flex-direction:row-reverse!important}.flex-xl-column-reverse{-ms-flex-direction:column-reverse!important;flex-direction:column-reverse!important}.flex-xl-wrap{-ms-flex-wrap:wrap!important;flex-wrap:wrap!important}.flex-xl-nowrap{-ms-flex-wrap:nowrap!important;flex-wrap:nowrap!important}.flex-xl-wrap-reverse{-ms-flex-wrap:wrap-reverse!important;flex-wrap:wrap-reverse!important}.flex-xl-fill{-ms-flex:1 1 auto!important;flex:1 1 auto!important}.flex-xl-grow-0{-ms-flex-positive:0!important;flex-grow:0!important}.flex-xl-grow-1{-ms-flex-positive:1!important;flex-grow:1!important}.flex-xl-shrink-0{-ms-flex-negative:0!important;flex-shrink:0!important}.flex-xl-shrink-1{-ms-flex-negative:1!important;flex-shrink:1!important}.justify-content-xl-start{-ms-flex-pack:start!important;justify-content:flex-start!important}.justify-content-xl-end{-ms-flex-pack:end!important;justify-content:flex-end!important}.justify-content-xl-center{-ms-flex-pack:center!important;justify-content:center!important}.justify-content-xl-between{-ms-flex-pack:justify!important;justify-content:space-between!important}.justify-content-xl-around{-ms-flex-pack:distribute!important;justify-content:space-around!important}.align-items-xl-start{-ms-flex-align:start!important;align-items:flex-start!important}.align-items-xl-end{-ms-flex-align:end!important;align-items:flex-end!important}.align-items-xl-center{-ms-flex-align:center!important;align-items:center!important}.align-items-xl-baseline{-ms-flex-align:baseline!important;align-items:baseline!important}.align-items-xl-stretch{-ms-flex-align:stretch!important;align-items:stretch!important}.align-content-xl-start{-ms-flex-line-pack:start!important;align-content:flex-start!important}.align-content-xl-end{-ms-flex-line-pack:end!important;align-content:flex-end!important}.align-content-xl-center{-ms-flex-line-pack:center!important;align-content:center!important}.align-content-xl-between{-ms-flex-line-pack:justify!important;align-content:space-between!important}.align-content-xl-around{-ms-flex-line-pack:distribute!important;align-content:space-around!important}.align-content-xl-stretch{-ms-flex-line-pack:stretch!important;align-content:stretch!important}.align-self-xl-auto{-ms-flex-item-align:auto!important;align-self:auto!important}.align-self-xl-start{-ms-flex-item-align:start!important;align-self:flex-start!important}.align-self-xl-end{-ms-flex-item-align:end!important;align-self:flex-end!important}.align-self-xl-center{-ms-flex-item-align:center!important;align-self:center!important}.align-self-xl-baseline{-ms-flex-item-align:baseline!important;align-self:baseline!important}.align-self-xl-stretch{-ms-flex-item-align:stretch!important;align-self:stretch!important}}.float-left{float:left!important}.float-right{float:right!important}.float-none{float:none!important}@media (min-width:576px){.float-sm-left{float:left!important}.float-sm-right{float:right!important}.float-sm-none{float:none!important}}@media (min-width:768px){.float-md-left{float:left!important}.float-md-right{float:right!important}.float-md-none{float:none!important}}@media (min-width:992px){.float-lg-left{float:left!important}.float-lg-right{float:right!important}.float-lg-none{float:none!important}}@media (min-width:1200px){.float-xl-left{float:left!important}.float-xl-right{float:right!important}.float-xl-none{float:none!important}}.user-select-all{-webkit-user-select:all!important;-moz-user-select:all!important;-ms-user-select:all!important;user-select:all!important}.user-select-auto{-webkit-user-select:auto!important;-moz-user-select:auto!important;-ms-user-select:auto!important;user-select:auto!important}.user-select-none{-webkit-user-select:none!important;-moz-user-select:none!important;-ms-user-select:none!important;user-select:none!important}.overflow-auto{overflow:auto!important}.overflow-hidden{overflow:hidden!important}.position-static{position:static!important}.position-relative{position:relative!important}.position-absolute{position:absolute!important}.position-fixed{position:fixed!important}.position-sticky{position:-webkit-sticky!important;position:sticky!important}.fixed-top{position:fixed;top:0;right:0;left:0;z-index:1030}.fixed-bottom{position:fixed;right:0;bottom:0;left:0;z-index:1030}@supports ((position:-webkit-sticky) or (position:sticky)){.sticky-top{position:-webkit-sticky;position:sticky;top:0;z-index:1020}}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;overflow:visible;clip:auto;white-space:normal}.shadow-sm{box-shadow:0 .125rem .25rem rgba(0,0,0,.075)!important}.shadow{box-shadow:0 .5rem 1rem rgba(0,0,0,.15)!important}.shadow-lg{box-shadow:0 1rem 3rem rgba(0,0,0,.175)!important}.shadow-none{box-shadow:none!important}.w-25{width:25%!important}.w-50{width:50%!important}.w-75{width:75%!important}.w-100{width:100%!important}.w-auto{width:auto!important}.h-25{height:25%!important}.h-50{height:50%!important}.h-75{height:75%!important}.h-100{height:100%!important}.h-auto{height:auto!important}.mw-100{max-width:100%!important}.mh-100{max-height:100%!important}.min-vw-100{min-width:100vw!important}.min-vh-100{min-height:100vh!important}.vw-100{width:100vw!important}.vh-100{height:100vh!important}.m-0{margin:0!important}.mt-0,.my-0{margin-top:0!important}.mr-0,.mx-0{margin-right:0!important}.mb-0,.my-0{margin-bottom:0!important}.ml-0,.mx-0{margin-left:0!important}.m-1{margin:.25rem!important}.mt-1,.my-1{margin-top:.25rem!important}.mr-1,.mx-1{margin-right:.25rem!important}.mb-1,.my-1{margin-bottom:.25rem!important}.ml-1,.mx-1{margin-left:.25rem!important}.m-2{margin:.5rem!important}.mt-2,.my-2{margin-top:.5rem!important}.mr-2,.mx-2{margin-right:.5rem!important}.mb-2,.my-2{margin-bottom:.5rem!important}.ml-2,.mx-2{margin-left:.5rem!important}.m-3{margin:1rem!important}.mt-3,.my-3{margin-top:1rem!important}.mr-3,.mx-3{margin-right:1rem!important}.mb-3,.my-3{margin-bottom:1rem!important}.ml-3,.mx-3{margin-left:1rem!important}.m-4{margin:1.5rem!important}.mt-4,.my-4{margin-top:1.5rem!important}.mr-4,.mx-4{margin-right:1.5rem!important}.mb-4,.my-4{margin-bottom:1.5rem!important}.ml-4,.mx-4{margin-left:1.5rem!important}.m-5{margin:3rem!important}.mt-5,.my-5{margin-top:3rem!important}.mr-5,.mx-5{margin-right:3rem!important}.mb-5,.my-5{margin-bottom:3rem!important}.ml-5,.mx-5{margin-left:3rem!important}.p-0{padding:0!important}.pt-0,.py-0{padding-top:0!important}.pr-0,.px-0{padding-right:0!important}.pb-0,.py-0{padding-bottom:0!important}.pl-0,.px-0{padding-left:0!important}.p-1{padding:.25rem!important}.pt-1,.py-1{padding-top:.25rem!important}.pr-1,.px-1{padding-right:.25rem!important}.pb-1,.py-1{padding-bottom:.25rem!important}.pl-1,.px-1{padding-left:.25rem!important}.p-2{padding:.5rem!important}.pt-2,.py-2{padding-top:.5rem!important}.pr-2,.px-2{padding-right:.5rem!important}.pb-2,.py-2{padding-bottom:.5rem!important}.pl-2,.px-2{padding-left:.5rem!important}.p-3{padding:1rem!important}.pt-3,.py-3{padding-top:1rem!important}.pr-3,.px-3{padding-right:1rem!important}.pb-3,.py-3{padding-bottom:1rem!important}.pl-3,.px-3{padding-left:1rem!important}.p-4{padding:1.5rem!important}.pt-4,.py-4{padding-top:1.5rem!important}.pr-4,.px-4{padding-right:1.5rem!important}.pb-4,.py-4{padding-bottom:1.5rem!important}.pl-4,.px-4{padding-left:1.5rem!important}.p-5{padding:3rem!important}.pt-5,.py-5{padding-top:3rem!important}.pr-5,.px-5{padding-right:3rem!important}.pb-5,.py-5{padding-bottom:3rem!important}.pl-5,.px-5{padding-left:3rem!important}.m-n1{margin:-.25rem!important}.mt-n1,.my-n1{margin-top:-.25rem!important}.mr-n1,.mx-n1{margin-right:-.25rem!important}.mb-n1,.my-n1{margin-bottom:-.25rem!important}.ml-n1,.mx-n1{margin-left:-.25rem!important}.m-n2{margin:-.5rem!important}.mt-n2,.my-n2{margin-top:-.5rem!important}.mr-n2,.mx-n2{margin-right:-.5rem!important}.mb-n2,.my-n2{margin-bottom:-.5rem!important}.ml-n2,.mx-n2{margin-left:-.5rem!important}.m-n3{margin:-1rem!important}.mt-n3,.my-n3{margin-top:-1rem!important}.mr-n3,.mx-n3{margin-right:-1rem!important}.mb-n3,.my-n3{margin-bottom:-1rem!important}.ml-n3,.mx-n3{margin-left:-1rem!important}.m-n4{margin:-1.5rem!important}.mt-n4,.my-n4{margin-top:-1.5rem!important}.mr-n4,.mx-n4{margin-right:-1.5rem!important}.mb-n4,.my-n4{margin-bottom:-1.5rem!important}.ml-n4,.mx-n4{margin-left:-1.5rem!important}.m-n5{margin:-3rem!important}.mt-n5,.my-n5{margin-top:-3rem!important}.mr-n5,.mx-n5{margin-right:-3rem!important}.mb-n5,.my-n5{margin-bottom:-3rem!important}.ml-n5,.mx-n5{margin-left:-3rem!important}.m-auto{margin:auto!important}.mt-auto,.my-auto{margin-top:auto!important}.mr-auto,.mx-auto{margin-right:auto!important}.mb-auto,.my-auto{margin-bottom:auto!important}.ml-auto,.mx-auto{margin-left:auto!important}@media (min-width:576px){.m-sm-0{margin:0!important}.mt-sm-0,.my-sm-0{margin-top:0!important}.mr-sm-0,.mx-sm-0{margin-right:0!important}.mb-sm-0,.my-sm-0{margin-bottom:0!important}.ml-sm-0,.mx-sm-0{margin-left:0!important}.m-sm-1{margin:.25rem!important}.mt-sm-1,.my-sm-1{margin-top:.25rem!important}.mr-sm-1,.mx-sm-1{margin-right:.25rem!important}.mb-sm-1,.my-sm-1{margin-bottom:.25rem!important}.ml-sm-1,.mx-sm-1{margin-left:.25rem!important}.m-sm-2{margin:.5rem!important}.mt-sm-2,.my-sm-2{margin-top:.5rem!important}.mr-sm-2,.mx-sm-2{margin-right:.5rem!important}.mb-sm-2,.my-sm-2{margin-bottom:.5rem!important}.ml-sm-2,.mx-sm-2{margin-left:.5rem!important}.m-sm-3{margin:1rem!important}.mt-sm-3,.my-sm-3{margin-top:1rem!important}.mr-sm-3,.mx-sm-3{margin-right:1rem!important}.mb-sm-3,.my-sm-3{margin-bottom:1rem!important}.ml-sm-3,.mx-sm-3{margin-left:1rem!important}.m-sm-4{margin:1.5rem!important}.mt-sm-4,.my-sm-4{margin-top:1.5rem!important}.mr-sm-4,.mx-sm-4{margin-right:1.5rem!important}.mb-sm-4,.my-sm-4{margin-bottom:1.5rem!important}.ml-sm-4,.mx-sm-4{margin-left:1.5rem!important}.m-sm-5{margin:3rem!important}.mt-sm-5,.my-sm-5{margin-top:3rem!important}.mr-sm-5,.mx-sm-5{margin-right:3rem!important}.mb-sm-5,.my-sm-5{margin-bottom:3rem!important}.ml-sm-5,.mx-sm-5{margin-left:3rem!important}.p-sm-0{padding:0!important}.pt-sm-0,.py-sm-0{padding-top:0!important}.pr-sm-0,.px-sm-0{padding-right:0!important}.pb-sm-0,.py-sm-0{padding-bottom:0!important}.pl-sm-0,.px-sm-0{padding-left:0!important}.p-sm-1{padding:.25rem!important}.pt-sm-1,.py-sm-1{padding-top:.25rem!important}.pr-sm-1,.px-sm-1{padding-right:.25rem!important}.pb-sm-1,.py-sm-1{padding-bottom:.25rem!important}.pl-sm-1,.px-sm-1{padding-left:.25rem!important}.p-sm-2{padding:.5rem!important}.pt-sm-2,.py-sm-2{padding-top:.5rem!important}.pr-sm-2,.px-sm-2{padding-right:.5rem!important}.pb-sm-2,.py-sm-2{padding-bottom:.5rem!important}.pl-sm-2,.px-sm-2{padding-left:.5rem!important}.p-sm-3{padding:1rem!important}.pt-sm-3,.py-sm-3{padding-top:1rem!important}.pr-sm-3,.px-sm-3{padding-right:1rem!important}.pb-sm-3,.py-sm-3{padding-bottom:1rem!important}.pl-sm-3,.px-sm-3{padding-left:1rem!important}.p-sm-4{padding:1.5rem!important}.pt-sm-4,.py-sm-4{padding-top:1.5rem!important}.pr-sm-4,.px-sm-4{padding-right:1.5rem!important}.pb-sm-4,.py-sm-4{padding-bottom:1.5rem!important}.pl-sm-4,.px-sm-4{padding-left:1.5rem!important}.p-sm-5{padding:3rem!important}.pt-sm-5,.py-sm-5{padding-top:3rem!important}.pr-sm-5,.px-sm-5{padding-right:3rem!important}.pb-sm-5,.py-sm-5{padding-bottom:3rem!important}.pl-sm-5,.px-sm-5{padding-left:3rem!important}.m-sm-n1{margin:-.25rem!important}.mt-sm-n1,.my-sm-n1{margin-top:-.25rem!important}.mr-sm-n1,.mx-sm-n1{margin-right:-.25rem!important}.mb-sm-n1,.my-sm-n1{margin-bottom:-.25rem!important}.ml-sm-n1,.mx-sm-n1{margin-left:-.25rem!important}.m-sm-n2{margin:-.5rem!important}.mt-sm-n2,.my-sm-n2{margin-top:-.5rem!important}.mr-sm-n2,.mx-sm-n2{margin-right:-.5rem!important}.mb-sm-n2,.my-sm-n2{margin-bottom:-.5rem!important}.ml-sm-n2,.mx-sm-n2{margin-left:-.5rem!important}.m-sm-n3{margin:-1rem!important}.mt-sm-n3,.my-sm-n3{margin-top:-1rem!important}.mr-sm-n3,.mx-sm-n3{margin-right:-1rem!important}.mb-sm-n3,.my-sm-n3{margin-bottom:-1rem!important}.ml-sm-n3,.mx-sm-n3{margin-left:-1rem!important}.m-sm-n4{margin:-1.5rem!important}.mt-sm-n4,.my-sm-n4{margin-top:-1.5rem!important}.mr-sm-n4,.mx-sm-n4{margin-right:-1.5rem!important}.mb-sm-n4,.my-sm-n4{margin-bottom:-1.5rem!important}.ml-sm-n4,.mx-sm-n4{margin-left:-1.5rem!important}.m-sm-n5{margin:-3rem!important}.mt-sm-n5,.my-sm-n5{margin-top:-3rem!important}.mr-sm-n5,.mx-sm-n5{margin-right:-3rem!important}.mb-sm-n5,.my-sm-n5{margin-bottom:-3rem!important}.ml-sm-n5,.mx-sm-n5{margin-left:-3rem!important}.m-sm-auto{margin:auto!important}.mt-sm-auto,.my-sm-auto{margin-top:auto!important}.mr-sm-auto,.mx-sm-auto{margin-right:auto!important}.mb-sm-auto,.my-sm-auto{margin-bottom:auto!important}.ml-sm-auto,.mx-sm-auto{margin-left:auto!important}}@media (min-width:768px){.m-md-0{margin:0!important}.mt-md-0,.my-md-0{margin-top:0!important}.mr-md-0,.mx-md-0{margin-right:0!important}.mb-md-0,.my-md-0{margin-bottom:0!important}.ml-md-0,.mx-md-0{margin-left:0!important}.m-md-1{margin:.25rem!important}.mt-md-1,.my-md-1{margin-top:.25rem!important}.mr-md-1,.mx-md-1{margin-right:.25rem!important}.mb-md-1,.my-md-1{margin-bottom:.25rem!important}.ml-md-1,.mx-md-1{margin-left:.25rem!important}.m-md-2{margin:.5rem!important}.mt-md-2,.my-md-2{margin-top:.5rem!important}.mr-md-2,.mx-md-2{margin-right:.5rem!important}.mb-md-2,.my-md-2{margin-bottom:.5rem!important}.ml-md-2,.mx-md-2{margin-left:.5rem!important}.m-md-3{margin:1rem!important}.mt-md-3,.my-md-3{margin-top:1rem!important}.mr-md-3,.mx-md-3{margin-right:1rem!important}.mb-md-3,.my-md-3{margin-bottom:1rem!important}.ml-md-3,.mx-md-3{margin-left:1rem!important}.m-md-4{margin:1.5rem!important}.mt-md-4,.my-md-4{margin-top:1.5rem!important}.mr-md-4,.mx-md-4{margin-right:1.5rem!important}.mb-md-4,.my-md-4{margin-bottom:1.5rem!important}.ml-md-4,.mx-md-4{margin-left:1.5rem!important}.m-md-5{margin:3rem!important}.mt-md-5,.my-md-5{margin-top:3rem!important}.mr-md-5,.mx-md-5{margin-right:3rem!important}.mb-md-5,.my-md-5{margin-bottom:3rem!important}.ml-md-5,.mx-md-5{margin-left:3rem!important}.p-md-0{padding:0!important}.pt-md-0,.py-md-0{padding-top:0!important}.pr-md-0,.px-md-0{padding-right:0!important}.pb-md-0,.py-md-0{padding-bottom:0!important}.pl-md-0,.px-md-0{padding-left:0!important}.p-md-1{padding:.25rem!important}.pt-md-1,.py-md-1{padding-top:.25rem!important}.pr-md-1,.px-md-1{padding-right:.25rem!important}.pb-md-1,.py-md-1{padding-bottom:.25rem!important}.pl-md-1,.px-md-1{padding-left:.25rem!important}.p-md-2{padding:.5rem!important}.pt-md-2,.py-md-2{padding-top:.5rem!important}.pr-md-2,.px-md-2{padding-right:.5rem!important}.pb-md-2,.py-md-2{padding-bottom:.5rem!important}.pl-md-2,.px-md-2{padding-left:.5rem!important}.p-md-3{padding:1rem!important}.pt-md-3,.py-md-3{padding-top:1rem!important}.pr-md-3,.px-md-3{padding-right:1rem!important}.pb-md-3,.py-md-3{padding-bottom:1rem!important}.pl-md-3,.px-md-3{padding-left:1rem!important}.p-md-4{padding:1.5rem!important}.pt-md-4,.py-md-4{padding-top:1.5rem!important}.pr-md-4,.px-md-4{padding-right:1.5rem!important}.pb-md-4,.py-md-4{padding-bottom:1.5rem!important}.pl-md-4,.px-md-4{padding-left:1.5rem!important}.p-md-5{padding:3rem!important}.pt-md-5,.py-md-5{padding-top:3rem!important}.pr-md-5,.px-md-5{padding-right:3rem!important}.pb-md-5,.py-md-5{padding-bottom:3rem!important}.pl-md-5,.px-md-5{padding-left:3rem!important}.m-md-n1{margin:-.25rem!important}.mt-md-n1,.my-md-n1{margin-top:-.25rem!important}.mr-md-n1,.mx-md-n1{margin-right:-.25rem!important}.mb-md-n1,.my-md-n1{margin-bottom:-.25rem!important}.ml-md-n1,.mx-md-n1{margin-left:-.25rem!important}.m-md-n2{margin:-.5rem!important}.mt-md-n2,.my-md-n2{margin-top:-.5rem!important}.mr-md-n2,.mx-md-n2{margin-right:-.5rem!important}.mb-md-n2,.my-md-n2{margin-bottom:-.5rem!important}.ml-md-n2,.mx-md-n2{margin-left:-.5rem!important}.m-md-n3{margin:-1rem!important}.mt-md-n3,.my-md-n3{margin-top:-1rem!important}.mr-md-n3,.mx-md-n3{margin-right:-1rem!important}.mb-md-n3,.my-md-n3{margin-bottom:-1rem!important}.ml-md-n3,.mx-md-n3{margin-left:-1rem!important}.m-md-n4{margin:-1.5rem!important}.mt-md-n4,.my-md-n4{margin-top:-1.5rem!important}.mr-md-n4,.mx-md-n4{margin-right:-1.5rem!important}.mb-md-n4,.my-md-n4{margin-bottom:-1.5rem!important}.ml-md-n4,.mx-md-n4{margin-left:-1.5rem!important}.m-md-n5{margin:-3rem!important}.mt-md-n5,.my-md-n5{margin-top:-3rem!important}.mr-md-n5,.mx-md-n5{margin-right:-3rem!important}.mb-md-n5,.my-md-n5{margin-bottom:-3rem!important}.ml-md-n5,.mx-md-n5{margin-left:-3rem!important}.m-md-auto{margin:auto!important}.mt-md-auto,.my-md-auto{margin-top:auto!important}.mr-md-auto,.mx-md-auto{margin-right:auto!important}.mb-md-auto,.my-md-auto{margin-bottom:auto!important}.ml-md-auto,.mx-md-auto{margin-left:auto!important}}@media (min-width:992px){.m-lg-0{margin:0!important}.mt-lg-0,.my-lg-0{margin-top:0!important}.mr-lg-0,.mx-lg-0{margin-right:0!important}.mb-lg-0,.my-lg-0{margin-bottom:0!important}.ml-lg-0,.mx-lg-0{margin-left:0!important}.m-lg-1{margin:.25rem!important}.mt-lg-1,.my-lg-1{margin-top:.25rem!important}.mr-lg-1,.mx-lg-1{margin-right:.25rem!important}.mb-lg-1,.my-lg-1{margin-bottom:.25rem!important}.ml-lg-1,.mx-lg-1{margin-left:.25rem!important}.m-lg-2{margin:.5rem!important}.mt-lg-2,.my-lg-2{margin-top:.5rem!important}.mr-lg-2,.mx-lg-2{margin-right:.5rem!important}.mb-lg-2,.my-lg-2{margin-bottom:.5rem!important}.ml-lg-2,.mx-lg-2{margin-left:.5rem!important}.m-lg-3{margin:1rem!important}.mt-lg-3,.my-lg-3{margin-top:1rem!important}.mr-lg-3,.mx-lg-3{margin-right:1rem!important}.mb-lg-3,.my-lg-3{margin-bottom:1rem!important}.ml-lg-3,.mx-lg-3{margin-left:1rem!important}.m-lg-4{margin:1.5rem!important}.mt-lg-4,.my-lg-4{margin-top:1.5rem!important}.mr-lg-4,.mx-lg-4{margin-right:1.5rem!important}.mb-lg-4,.my-lg-4{margin-bottom:1.5rem!important}.ml-lg-4,.mx-lg-4{margin-left:1.5rem!important}.m-lg-5{margin:3rem!important}.mt-lg-5,.my-lg-5{margin-top:3rem!important}.mr-lg-5,.mx-lg-5{margin-right:3rem!important}.mb-lg-5,.my-lg-5{margin-bottom:3rem!important}.ml-lg-5,.mx-lg-5{margin-left:3rem!important}.p-lg-0{padding:0!important}.pt-lg-0,.py-lg-0{padding-top:0!important}.pr-lg-0,.px-lg-0{padding-right:0!important}.pb-lg-0,.py-lg-0{padding-bottom:0!important}.pl-lg-0,.px-lg-0{padding-left:0!important}.p-lg-1{padding:.25rem!important}.pt-lg-1,.py-lg-1{padding-top:.25rem!important}.pr-lg-1,.px-lg-1{padding-right:.25rem!important}.pb-lg-1,.py-lg-1{padding-bottom:.25rem!important}.pl-lg-1,.px-lg-1{padding-left:.25rem!important}.p-lg-2{padding:.5rem!important}.pt-lg-2,.py-lg-2{padding-top:.5rem!important}.pr-lg-2,.px-lg-2{padding-right:.5rem!important}.pb-lg-2,.py-lg-2{padding-bottom:.5rem!important}.pl-lg-2,.px-lg-2{padding-left:.5rem!important}.p-lg-3{padding:1rem!important}.pt-lg-3,.py-lg-3{padding-top:1rem!important}.pr-lg-3,.px-lg-3{padding-right:1rem!important}.pb-lg-3,.py-lg-3{padding-bottom:1rem!important}.pl-lg-3,.px-lg-3{padding-left:1rem!important}.p-lg-4{padding:1.5rem!important}.pt-lg-4,.py-lg-4{padding-top:1.5rem!important}.pr-lg-4,.px-lg-4{padding-right:1.5rem!important}.pb-lg-4,.py-lg-4{padding-bottom:1.5rem!important}.pl-lg-4,.px-lg-4{padding-left:1.5rem!important}.p-lg-5{padding:3rem!important}.pt-lg-5,.py-lg-5{padding-top:3rem!important}.pr-lg-5,.px-lg-5{padding-right:3rem!important}.pb-lg-5,.py-lg-5{padding-bottom:3rem!important}.pl-lg-5,.px-lg-5{padding-left:3rem!important}.m-lg-n1{margin:-.25rem!important}.mt-lg-n1,.my-lg-n1{margin-top:-.25rem!important}.mr-lg-n1,.mx-lg-n1{margin-right:-.25rem!important}.mb-lg-n1,.my-lg-n1{margin-bottom:-.25rem!important}.ml-lg-n1,.mx-lg-n1{margin-left:-.25rem!important}.m-lg-n2{margin:-.5rem!important}.mt-lg-n2,.my-lg-n2{margin-top:-.5rem!important}.mr-lg-n2,.mx-lg-n2{margin-right:-.5rem!important}.mb-lg-n2,.my-lg-n2{margin-bottom:-.5rem!important}.ml-lg-n2,.mx-lg-n2{margin-left:-.5rem!important}.m-lg-n3{margin:-1rem!important}.mt-lg-n3,.my-lg-n3{margin-top:-1rem!important}.mr-lg-n3,.mx-lg-n3{margin-right:-1rem!important}.mb-lg-n3,.my-lg-n3{margin-bottom:-1rem!important}.ml-lg-n3,.mx-lg-n3{margin-left:-1rem!important}.m-lg-n4{margin:-1.5rem!important}.mt-lg-n4,.my-lg-n4{margin-top:-1.5rem!important}.mr-lg-n4,.mx-lg-n4{margin-right:-1.5rem!important}.mb-lg-n4,.my-lg-n4{margin-bottom:-1.5rem!important}.ml-lg-n4,.mx-lg-n4{margin-left:-1.5rem!important}.m-lg-n5{margin:-3rem!important}.mt-lg-n5,.my-lg-n5{margin-top:-3rem!important}.mr-lg-n5,.mx-lg-n5{margin-right:-3rem!important}.mb-lg-n5,.my-lg-n5{margin-bottom:-3rem!important}.ml-lg-n5,.mx-lg-n5{margin-left:-3rem!important}.m-lg-auto{margin:auto!important}.mt-lg-auto,.my-lg-auto{margin-top:auto!important}.mr-lg-auto,.mx-lg-auto{margin-right:auto!important}.mb-lg-auto,.my-lg-auto{margin-bottom:auto!important}.ml-lg-auto,.mx-lg-auto{margin-left:auto!important}}@media (min-width:1200px){.m-xl-0{margin:0!important}.mt-xl-0,.my-xl-0{margin-top:0!important}.mr-xl-0,.mx-xl-0{margin-right:0!important}.mb-xl-0,.my-xl-0{margin-bottom:0!important}.ml-xl-0,.mx-xl-0{margin-left:0!important}.m-xl-1{margin:.25rem!important}.mt-xl-1,.my-xl-1{margin-top:.25rem!important}.mr-xl-1,.mx-xl-1{margin-right:.25rem!important}.mb-xl-1,.my-xl-1{margin-bottom:.25rem!important}.ml-xl-1,.mx-xl-1{margin-left:.25rem!important}.m-xl-2{margin:.5rem!important}.mt-xl-2,.my-xl-2{margin-top:.5rem!important}.mr-xl-2,.mx-xl-2{margin-right:.5rem!important}.mb-xl-2,.my-xl-2{margin-bottom:.5rem!important}.ml-xl-2,.mx-xl-2{margin-left:.5rem!important}.m-xl-3{margin:1rem!important}.mt-xl-3,.my-xl-3{margin-top:1rem!important}.mr-xl-3,.mx-xl-3{margin-right:1rem!important}.mb-xl-3,.my-xl-3{margin-bottom:1rem!important}.ml-xl-3,.mx-xl-3{margin-left:1rem!important}.m-xl-4{margin:1.5rem!important}.mt-xl-4,.my-xl-4{margin-top:1.5rem!important}.mr-xl-4,.mx-xl-4{margin-right:1.5rem!important}.mb-xl-4,.my-xl-4{margin-bottom:1.5rem!important}.ml-xl-4,.mx-xl-4{margin-left:1.5rem!important}.m-xl-5{margin:3rem!important}.mt-xl-5,.my-xl-5{margin-top:3rem!important}.mr-xl-5,.mx-xl-5{margin-right:3rem!important}.mb-xl-5,.my-xl-5{margin-bottom:3rem!important}.ml-xl-5,.mx-xl-5{margin-left:3rem!important}.p-xl-0{padding:0!important}.pt-xl-0,.py-xl-0{padding-top:0!important}.pr-xl-0,.px-xl-0{padding-right:0!important}.pb-xl-0,.py-xl-0{padding-bottom:0!important}.pl-xl-0,.px-xl-0{padding-left:0!important}.p-xl-1{padding:.25rem!important}.pt-xl-1,.py-xl-1{padding-top:.25rem!important}.pr-xl-1,.px-xl-1{padding-right:.25rem!important}.pb-xl-1,.py-xl-1{padding-bottom:.25rem!important}.pl-xl-1,.px-xl-1{padding-left:.25rem!important}.p-xl-2{padding:.5rem!important}.pt-xl-2,.py-xl-2{padding-top:.5rem!important}.pr-xl-2,.px-xl-2{padding-right:.5rem!important}.pb-xl-2,.py-xl-2{padding-bottom:.5rem!important}.pl-xl-2,.px-xl-2{padding-left:.5rem!important}.p-xl-3{padding:1rem!important}.pt-xl-3,.py-xl-3{padding-top:1rem!important}.pr-xl-3,.px-xl-3{padding-right:1rem!important}.pb-xl-3,.py-xl-3{padding-bottom:1rem!important}.pl-xl-3,.px-xl-3{padding-left:1rem!important}.p-xl-4{padding:1.5rem!important}.pt-xl-4,.py-xl-4{padding-top:1.5rem!important}.pr-xl-4,.px-xl-4{padding-right:1.5rem!important}.pb-xl-4,.py-xl-4{padding-bottom:1.5rem!important}.pl-xl-4,.px-xl-4{padding-left:1.5rem!important}.p-xl-5{padding:3rem!important}.pt-xl-5,.py-xl-5{padding-top:3rem!important}.pr-xl-5,.px-xl-5{padding-right:3rem!important}.pb-xl-5,.py-xl-5{padding-bottom:3rem!important}.pl-xl-5,.px-xl-5{padding-left:3rem!important}.m-xl-n1{margin:-.25rem!important}.mt-xl-n1,.my-xl-n1{margin-top:-.25rem!important}.mr-xl-n1,.mx-xl-n1{margin-right:-.25rem!important}.mb-xl-n1,.my-xl-n1{margin-bottom:-.25rem!important}.ml-xl-n1,.mx-xl-n1{margin-left:-.25rem!important}.m-xl-n2{margin:-.5rem!important}.mt-xl-n2,.my-xl-n2{margin-top:-.5rem!important}.mr-xl-n2,.mx-xl-n2{margin-right:-.5rem!important}.mb-xl-n2,.my-xl-n2{margin-bottom:-.5rem!important}.ml-xl-n2,.mx-xl-n2{margin-left:-.5rem!important}.m-xl-n3{margin:-1rem!important}.mt-xl-n3,.my-xl-n3{margin-top:-1rem!important}.mr-xl-n3,.mx-xl-n3{margin-right:-1rem!important}.mb-xl-n3,.my-xl-n3{margin-bottom:-1rem!important}.ml-xl-n3,.mx-xl-n3{margin-left:-1rem!important}.m-xl-n4{margin:-1.5rem!important}.mt-xl-n4,.my-xl-n4{margin-top:-1.5rem!important}.mr-xl-n4,.mx-xl-n4{margin-right:-1.5rem!important}.mb-xl-n4,.my-xl-n4{margin-bottom:-1.5rem!important}.ml-xl-n4,.mx-xl-n4{margin-left:-1.5rem!important}.m-xl-n5{margin:-3rem!important}.mt-xl-n5,.my-xl-n5{margin-top:-3rem!important}.mr-xl-n5,.mx-xl-n5{margin-right:-3rem!important}.mb-xl-n5,.my-xl-n5{margin-bottom:-3rem!important}.ml-xl-n5,.mx-xl-n5{margin-left:-3rem!important}.m-xl-auto{margin:auto!important}.mt-xl-auto,.my-xl-auto{margin-top:auto!important}.mr-xl-auto,.mx-xl-auto{margin-right:auto!important}.mb-xl-auto,.my-xl-auto{margin-bottom:auto!important}.ml-xl-auto,.mx-xl-auto{margin-left:auto!important}}.stretched-link::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:1;pointer-events:auto;content:"";background-color:rgba(0,0,0,0)}.text-monospace{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace!important}.text-justify{text-align:justify!important}.text-wrap{white-space:normal!important}.text-nowrap{white-space:nowrap!important}.text-truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.text-left{text-align:left!important}.text-right{text-align:right!important}.text-center{text-align:center!important}@media (min-width:576px){.text-sm-left{text-align:left!important}.text-sm-right{text-align:right!important}.text-sm-center{text-align:center!important}}@media (min-width:768px){.text-md-left{text-align:left!important}.text-md-right{text-align:right!important}.text-md-center{text-align:center!important}}@media (min-width:992px){.text-lg-left{text-align:left!important}.text-lg-right{text-align:right!important}.text-lg-center{text-align:center!important}}@media (min-width:1200px){.text-xl-left{text-align:left!important}.text-xl-right{text-align:right!important}.text-xl-center{text-align:center!important}}.text-lowercase{text-transform:lowercase!important}.text-uppercase{text-transform:uppercase!important}.text-capitalize{text-transform:capitalize!important}.font-weight-light{font-weight:300!important}.font-weight-lighter{font-weight:lighter!important}.font-weight-normal{font-weight:400!important}.font-weight-bold{font-weight:700!important}.font-weight-bolder{font-weight:bolder!important}.font-italic{font-style:italic!important}.text-white{color:#fff!important}.text-primary{color:#007bff!important}a.text-primary:focus,a.text-primary:hover{color:#0056b3!important}.text-secondary{color:#6c757d!important}a.text-secondary:focus,a.text-secondary:hover{color:#494f54!important}.text-success{color:#28a745!important}a.text-success:focus,a.text-success:hover{color:#19692c!important}.text-info{color:#17a2b8!important}a.text-info:focus,a.text-info:hover{color:#0f6674!important}.text-warning{color:#ffc107!important}a.text-warning:focus,a.text-warning:hover{color:#ba8b00!important}.text-danger{color:#dc3545!important}a.text-danger:focus,a.text-danger:hover{color:#a71d2a!important}.text-light{color:#f8f9fa!important}a.text-light:focus,a.text-light:hover{color:#cbd3da!important}.text-dark{color:#343a40!important}a.text-dark:focus,a.text-dark:hover{color:#121416!important}.text-body{color:#212529!important}.text-muted{color:#6c757d!important}.text-black-50{color:rgba(0,0,0,.5)!important}.text-white-50{color:rgba(255,255,255,.5)!important}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.text-decoration-none{text-decoration:none!important}.text-break{word-wrap:break-word!important}.text-reset{color:inherit!important}.visible{visibility:visible!important}.invisible{visibility:hidden!important}@media print{*,::after,::before{text-shadow:none!important;box-shadow:none!important}a:not(.btn){text-decoration:underline}abbr[title]::after{content:" (" attr(title) ")"}pre{white-space:pre-wrap!important}blockquote,pre{border:1px solid #adb5bd;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}@page{size:a3}body{min-width:992px!important}.container{min-width:992px!important}.navbar{display:none}.badge{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #dee2e6!important}.table-dark{color:inherit}.table-dark tbody+tbody,.table-dark td,.table-dark th,.table-dark thead th{border-color:#dee2e6}.table .thead-dark th{color:inherit;border-color:#dee2e6}}
/*# sourceMappingURL=bootstrap.min.css.map */.nvd3 .nv-axis{pointer-events:none;opacity:1}.nvd3 .nv-axis path{fill:none;stroke:#000;stroke-opacity:.75;shape-rendering:crispEdges}.nvd3 .nv-axis path.domain{stroke-opacity:.75}.nvd3 .nv-axis.nv-x path.domain{stroke-opacity:0}.nvd3 .nv-axis line{fill:none;stroke:#e5e5e5;shape-rendering:crispEdges}.nvd3 .nv-axis .zero line,.nvd3 .nv-axis line.zero{stroke-opacity:.75}.nvd3 .nv-axis .nv-axisMaxMin text{font-weight:700}.nvd3 .x .nv-axis .nv-axisMaxMin text,.nvd3 .x2 .nv-axis .nv-axisMaxMin text,.nvd3 .x3 .nv-axis .nv-axisMaxMin text{text-anchor:middle}.nvd3 .nv-axis.nv-disabled{opacity:0}.nvd3 .nv-bars rect{fill-opacity:.75;transition:fill-opacity 250ms linear;-moz-transition:fill-opacity 250ms linear;-webkit-transition:fill-opacity 250ms linear}.nvd3 .nv-bars rect.hover{fill-opacity:1}.nvd3 .nv-bars .hover rect{fill:#add8e6}.nvd3 .nv-bars text{fill:rgba(0,0,0,0)}.nvd3 .nv-bars .hover text{fill:rgba(0,0,0,1)}.nvd3 .nv-multibar .nv-groups rect,.nvd3 .nv-multibarHorizontal .nv-groups rect,.nvd3 .nv-discretebar .nv-groups rect{stroke-opacity:0;transition:fill-opacity 250ms linear;-moz-transition:fill-opacity 250ms linear;-webkit-transition:fill-opacity 250ms linear}.nvd3 .nv-multibar .nv-groups rect:hover,.nvd3 .nv-multibarHorizontal .nv-groups rect:hover,.nvd3 .nv-candlestickBar .nv-ticks rect:hover,.nvd3 .nv-discretebar .nv-groups rect:hover{fill-opacity:1}.nvd3 .nv-discretebar .nv-groups text,.nvd3 .nv-multibarHorizontal .nv-groups text{font-weight:700;fill:rgba(0,0,0,1);stroke:rgba(0,0,0,0)}.nvd3 .nv-boxplot circle{fill-opacity:.5}.nvd3 .nv-boxplot circle:hover{fill-opacity:1}.nvd3 .nv-boxplot rect:hover{fill-opacity:1}.nvd3 line.nv-boxplot-median{stroke:#000}.nv-boxplot-tick:hover{stroke-width:2.5px}.nvd3.nv-bullet{font:10px sans-serif}.nvd3.nv-bullet .nv-measure{fill-opacity:.8}.nvd3.nv-bullet .nv-measure:hover{fill-opacity:1}.nvd3.nv-bullet .nv-marker{stroke:#000;stroke-width:2px}.nvd3.nv-bullet .nv-markerTriangle{stroke:#000;fill:#fff;stroke-width:1.5px}.nvd3.nv-bullet .nv-tick line{stroke:#666;stroke-width:.5px}.nvd3.nv-bullet .nv-range.nv-s0{fill:#eee}.nvd3.nv-bullet .nv-range.nv-s1{fill:#ddd}.nvd3.nv-bullet .nv-range.nv-s2{fill:#ccc}.nvd3.nv-bullet .nv-title{font-size:14px;font-weight:700}.nvd3.nv-bullet .nv-subtitle{fill:#999}.nvd3.nv-bullet .nv-range{fill:#bababa;fill-opacity:.4}.nvd3.nv-bullet .nv-range:hover{fill-opacity:.7}.nvd3.nv-candlestickBar .nv-ticks .nv-tick{stroke-width:1px}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.hover{stroke-width:2px}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.positive rect{stroke:#2ca02c;fill:#2ca02c}.nvd3.nv-candlestickBar .nv-ticks .nv-tick.negative rect{stroke:#d62728;fill:#d62728}.with-transitions .nv-candlestickBar .nv-ticks .nv-tick{transition:stroke-width 250ms linear,stroke-opacity 250ms linear;-moz-transition:stroke-width 250ms linear,stroke-opacity 250ms linear;-webkit-transition:stroke-width 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-candlestickBar .nv-ticks line{stroke:#333}.nvd3 .nv-legend .nv-disabled rect{}.nvd3 .nv-check-box .nv-box{fill-opacity:0;stroke-width:2}.nvd3 .nv-check-box .nv-check{fill-opacity:0;stroke-width:4}.nvd3 .nv-series.nv-disabled .nv-check-box .nv-check{fill-opacity:0;stroke-opacity:0}.nvd3 .nv-controlsWrap .nv-legend .nv-check-box .nv-check{opacity:0}.nvd3.nv-linePlusBar .nv-bar rect{fill-opacity:.75}.nvd3.nv-linePlusBar .nv-bar rect:hover{fill-opacity:1}.nvd3 .nv-groups path.nv-line{fill:none}.nvd3 .nv-groups path.nv-area{stroke:none}.nvd3.nv-line .nvd3.nv-scatter .nv-groups .nv-point{fill-opacity:0;stroke-opacity:0}.nvd3.nv-scatter.nv-single-point .nv-groups .nv-point{fill-opacity:.5!important;stroke-opacity:.5!important}.with-transitions .nvd3 .nv-groups .nv-point{transition:stroke-width 250ms linear,stroke-opacity 250ms linear;-moz-transition:stroke-width 250ms linear,stroke-opacity 250ms linear;-webkit-transition:stroke-width 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-scatter .nv-groups .nv-point.hover,.nvd3 .nv-groups .nv-point.hover{stroke-width:7px;fill-opacity:.95!important;stroke-opacity:.95!important}.nvd3 .nv-point-paths path{stroke:#aaa;stroke-opacity:0;fill:#eee;fill-opacity:0}.nvd3 .nv-indexLine{cursor:ew-resize}svg.nvd3-svg{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-ms-user-select:none;-moz-user-select:none;user-select:none;display:block;width:100%;height:100%}.nvtooltip.with-3d-shadow,.with-3d-shadow .nvtooltip{-moz-box-shadow:0 5px 10px rgba(0,0,0,.2);-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2);-webkit-border-radius:5px;-moz-border-radius:5px;border-radius:5px}.nvd3 text{font:400 12px Arial}.nvd3 .title{font:700 14px Arial}.nvd3 .nv-background{fill:#fff;fill-opacity:0}.nvd3.nv-noData{font-size:18px;font-weight:700}.nv-brush .extent{fill-opacity:.125;shape-rendering:crispEdges}.nv-brush .resize path{fill:#eee;stroke:#666}.nvd3 .nv-legend .nv-series{cursor:pointer}.nvd3 .nv-legend .nv-disabled circle{fill-opacity:0}.nvd3 .nv-brush .extent{fill-opacity:0!important}.nvd3 .nv-brushBackground rect{stroke:#000;stroke-width:.4;fill:#fff;fill-opacity:.7}.nvd3.nv-ohlcBar .nv-ticks .nv-tick{stroke-width:1px}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.hover{stroke-width:2px}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.positive{stroke:#2ca02c}.nvd3.nv-ohlcBar .nv-ticks .nv-tick.negative{stroke:#d62728}.nvd3 .background path{fill:none;stroke:#EEE;stroke-opacity:.4;shape-rendering:crispEdges}.nvd3 .foreground path{fill:none;stroke-opacity:.7}.nvd3 .nv-parallelCoordinates-brush .extent{fill:#fff;fill-opacity:.6;stroke:gray;shape-rendering:crispEdges}.nvd3 .nv-parallelCoordinates .hover{fill-opacity:1;stroke-width:3px}.nvd3 .missingValuesline line{fill:none;stroke:#000;stroke-width:1;stroke-opacity:1;stroke-dasharray:5,5}.nvd3.nv-pie path{stroke-opacity:0;transition:fill-opacity 250ms linear,stroke-width 250ms linear,stroke-opacity 250ms linear;-moz-transition:fill-opacity 250ms linear,stroke-width 250ms linear,stroke-opacity 250ms linear;-webkit-transition:fill-opacity 250ms linear,stroke-width 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-pie .nv-pie-title{font-size:24px;fill:rgba(19,196,249,.59)}.nvd3.nv-pie .nv-slice text{stroke:#000;stroke-width:0}.nvd3.nv-pie path{stroke:#fff;stroke-width:1px;stroke-opacity:1}.nvd3.nv-pie .hover path{fill-opacity:.7}.nvd3.nv-pie .nv-label{pointer-events:none}.nvd3.nv-pie .nv-label rect{fill-opacity:0;stroke-opacity:0}.nvd3 .nv-groups .nv-point.hover{stroke-width:20px;stroke-opacity:.5}.nvd3 .nv-scatter .nv-point.hover{fill-opacity:1}.nv-noninteractive{pointer-events:none}.nv-distx,.nv-disty{pointer-events:none}.nvd3.nv-sparkline path{fill:none}.nvd3.nv-sparklineplus g.nv-hoverValue{pointer-events:none}.nvd3.nv-sparklineplus .nv-hoverValue line{stroke:#333;stroke-width:1.5px}.nvd3.nv-sparklineplus,.nvd3.nv-sparklineplus g{pointer-events:all}.nvd3 .nv-hoverArea{fill-opacity:0;stroke-opacity:0}.nvd3.nv-sparklineplus .nv-xValue,.nvd3.nv-sparklineplus .nv-yValue{stroke-width:0;font-size:.9em;font-weight:400}.nvd3.nv-sparklineplus .nv-yValue{stroke:#f66}.nvd3.nv-sparklineplus .nv-maxValue{stroke:#2ca02c;fill:#2ca02c}.nvd3.nv-sparklineplus .nv-minValue{stroke:#d62728;fill:#d62728}.nvd3.nv-sparklineplus .nv-currentValue{font-weight:700;font-size:1.1em}.nvd3.nv-stackedarea path.nv-area{fill-opacity:.7;stroke-opacity:0;transition:fill-opacity 250ms linear,stroke-opacity 250ms linear;-moz-transition:fill-opacity 250ms linear,stroke-opacity 250ms linear;-webkit-transition:fill-opacity 250ms linear,stroke-opacity 250ms linear}.nvd3.nv-stackedarea path.nv-area.hover{fill-opacity:.9}.nvd3.nv-stackedarea .nv-groups .nv-point{stroke-opacity:0;fill-opacity:0}.nvtooltip{position:absolute;background-color:rgba(255,255,255,1);color:rgba(0,0,0,1);padding:1px;border:1px solid rgba(0,0,0,.2);z-index:10000;display:block;font-family:Arial;font-size:13px;text-align:left;pointer-events:none;white-space:nowrap;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.nvtooltip{background:rgba(255,255,255,.8);border:1px solid rgba(0,0,0,.5);border-radius:4px}.nvtooltip.with-transitions,.with-transitions .nvtooltip{transition:opacity 50ms linear;-moz-transition:opacity 50ms linear;-webkit-transition:opacity 50ms linear;transition-delay:200ms;-moz-transition-delay:200ms;-webkit-transition-delay:200ms}.nvtooltip.x-nvtooltip,.nvtooltip.y-nvtooltip{padding:8px}.nvtooltip h3{margin:0;padding:4px 14px;line-height:18px;font-weight:400;background-color:rgba(247,247,247,.75);color:rgba(0,0,0,1);text-align:center;border-bottom:1px solid #ebebeb;-webkit-border-radius:5px 5px 0 0;-moz-border-radius:5px 5px 0 0;border-radius:5px 5px 0 0}.nvtooltip p{margin:0;padding:5px 14px;text-align:center}.nvtooltip span{display:inline-block;margin:2px 0}.nvtooltip table{margin:6px;border-spacing:0}.nvtooltip table td{padding:2px 9px 2px 0;vertical-align:middle}.nvtooltip table td.key{font-weight:400}.nvtooltip table td.value{text-align:right;font-weight:700}.nvtooltip table tr.highlight td{padding:1px 9px 1px 0;border-bottom-style:solid;border-bottom-width:1px;border-top-style:solid;border-top-width:1px}.nvtooltip table td.legend-color-guide div{width:8px;height:8px;vertical-align:middle}.nvtooltip table td.legend-color-guide div{width:12px;height:12px;border:1px solid #999}.nvtooltip .footer{padding:3px;text-align:center}.nvtooltip-pending-removal{pointer-events:none;display:none}.nvd3 .nv-interactiveGuideLine{pointer-events:none}.nvd3 line.nv-guideline{stroke:#ccc}.octicon {
  display: inline-block;
  vertical-align: text-top;
  fill: currentColor;
}
body {
 padding-top: 10px;
}

.popover {
 max-width: none;
}

.octicon {
 margin-right:.25em;
}

.table-bordered>thead>tr>td {
 border-bottom-width: 1px;
}

.table tbody>tr>td, .table thead>tr>td {
 padding-top: 3px;
 padding-bottom: 3px;
}

.table-condensed tbody>tr>td {
 padding-top: 0;
 padding-bottom: 0;
}

.table .progress {
 margin-bottom: inherit;
}

.table-borderless th, .table-borderless td {
 border: 0 !important;
}

.table tbody tr.covered-by-large-tests, li.covered-by-large-tests, tr.success, td.success, li.success, span.success {
 background-color: #dff0d8;
}

.table tbody tr.covered-by-medium-tests, li.covered-by-medium-tests {
 background-color: #c3e3b5;
}

.table tbody tr.covered-by-small-tests, li.covered-by-small-tests {
 background-color: #99cb84;
}

.table tbody tr.danger, .table tbody td.danger, li.danger, span.danger {
 background-color: #f2dede;
}

.table tbody tr.warning, .table tbody td.warning, li.warning, span.warning {
 background-color: #fcf8e3;
}

.table tbody td.info {
 background-color: #d9edf7;
}

td.big {
 width: 117px;
}

td.small {
}

td.codeLine {
 font-family: "Source Code Pro", "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
 white-space: pre-wrap;
}

td span.comment {
 color: #888a85;
}

td span.default {
 color: #2e3436;
}

td span.html {
 color: #888a85;
}

td span.keyword {
 color: #2e3436;
 font-weight: bold;
}

pre span.string {
 color: #2e3436;
}

span.success, span.warning, span.danger {
 margin-right: 2px;
 padding-left: 10px;
 padding-right: 10px;
 text-align: center;
}

#classCoverageDistribution, #classComplexity {
 height: 200px;
 width: 475px;
}

#toplink {
 position: fixed;
 left: 5px;
 bottom: 5px;
 outline: 0;
}

svg text {
 font-family: "Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif;
 font-size: 11px;
 color: #666;
 fill: #666;
}

.scrollbox {
 height:245px;
 overflow-x:hidden;
 overflow-y:scroll;
}

table + .structure-heading {
 border-top: 1px solid lightgrey;
 padding-top: 0.5em;
}
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Dashboard for {{full_path}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="{{path_to_root}}_css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/nv.d3.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/style.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/custom.css" rel="stylesheet" type="text/css">
 </head>
 <body>
  <header>
   <div class="container-fluid">
    <div class="row">
     <div class="col-md-12">
      <nav aria-label="breadcrumb">
       <ol class="breadcrumb">
{{breadcrumbs}}
       </ol>
      </nav>
     </div>
    </div>
   </div>
  </header>
  <div class="container-fluid">
   <div class="row">
    <div class="col-md-12">
     <h2>Classes</h2>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Coverage Distribution</h3>
     <div id="classCoverageDistribution" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Complexity</h3>
     <div id="classComplexity" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Insufficient Coverage</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Class</th>
         <th class="text-right">Coverage</th>
        </tr>
       </thead>
       <tbody>
{{insufficient_coverage_classes}}
       </tbody>
      </table>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Project Risks</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Class</th>
         <th class="text-right"><abbr title="Change Risk Anti-Patterns (CRAP) Index">CRAP</abbr></th>
        </tr>
       </thead>
       <tbody>
{{project_risks_classes}}
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="row">
    <div class="col-md-12">
     <h2>Methods</h2>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Coverage Distribution</h3>
     <div id="methodCoverageDistribution" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Complexity</h3>
     <div id="methodComplexity" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Insufficient Coverage</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Method</th>
         <th class="text-right">Coverage</th>
        </tr>
       </thead>
       <tbody>
{{insufficient_coverage_methods}}
       </tbody>
      </table>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Project Risks</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Method</th>
         <th class="text-right"><abbr title="Change Risk Anti-Patterns (CRAP) Index">CRAP</abbr></th>
        </tr>
       </thead>
       <tbody>
{{project_risks_methods}}
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <footer>
    <hr/>
    <p>
     <small>Generated by <a href="https://github.com/sebastianbergmann/php-code-coverage" target="_top">php-code-coverage {{version}}</a> using {{runtime}}{{generator}} at {{date}}.</small>
    </p>
   </footer>
  </div>
  <script src="{{path_to_root}}_js/jquery.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/d3.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/nv.d3.min.js" type="text/javascript"></script>
  <script type="text/javascript">
$(document).ready(function() {
  nv.addGraph(function() {
    var chart = nv.models.multiBarChart();
    chart.tooltips(false)
      .showControls(false)
      .showLegend(false)
      .reduceXTicks(false)
      .staggerLabels(true)
      .yAxis.tickFormat(d3.format('d'));

    d3.select('#classCoverageDistribution svg')
      .datum(getCoverageDistributionData({{class_coverage_distribution}}, "Class Coverage"))
      .transition().duration(500).call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  nv.addGraph(function() {
    var chart = nv.models.multiBarChart();
    chart.tooltips(false)
      .showControls(false)
      .showLegend(false)
      .reduceXTicks(false)
      .staggerLabels(true)
      .yAxis.tickFormat(d3.format('d'));

    d3.select('#methodCoverageDistribution svg')
      .datum(getCoverageDistributionData({{method_coverage_distribution}}, "Method Coverage"))
      .transition().duration(500).call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  function getCoverageDistributionData(data, label) {
    var labels = [
      '0%',
      '0-10%',
      '10-20%',
      '20-30%',
      '30-40%',
      '40-50%',
      '50-60%',
      '60-70%',
      '70-80%',
      '80-90%',
      '90-100%',
      '100%'
    ];
    var values = [];
    $.each(labels, function(key) {
      values.push({x: labels[key], y: data[key]});
    });

    return [
      {
        key: label,
        values: values,
        color: "#4572A7"
      }
    ];
  }
  nv.addGraph(function() {
    var chart = nv.models.scatterChart()
      .showDistX(true)
      .showDistY(true)
      .showLegend(false)
      .forceX([0, 100]);
    chart.tooltipContent(function(graph) {
      return '<p>' + graph.point.class + '</p>';
    });

    chart.xAxis.axisLabel('Code Coverage (in percent)');
    chart.yAxis.axisLabel('Cyclomatic Complexity');

    d3.select('#classComplexity svg')
      .datum(getComplexityData({{complexity_class}}, 'Class Complexity'))
      .transition()
      .duration(500)
      .call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  nv.addGraph(function() {
    var chart = nv.models.scatterChart()
      .showDistX(true)
      .showDistY(true)
      .showLegend(false)
      .forceX([0, 100]);
    chart.tooltipContent(function(graph) {
      return '<p>' + graph.point.class + '</p>';
    });

    chart.xAxis.axisLabel('Code Coverage (in percent)');
    chart.yAxis.axisLabel('Method Complexity');

    d3.select('#methodComplexity svg')
      .datum(getComplexityData({{complexity_method}}, 'Method Complexity'))
      .transition()
      .duration(500)
      .call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  function getComplexityData(data, label) {
    var values = [];
    $.each(data, function(key) {
      var value = Math.round(data[key][0]*100) / 100;
      values.push({
        x: value,
        y: data[key][1],
        class: data[key][2],
        size: 0.05,
        shape: 'diamond'
      });
    });

    return [
      {
        key: label,
        values: values,
        color: "#4572A7"
      }
    ];
  }
});
  </script>
 </body>
</html>
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Dashboard for {{full_path}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="{{path_to_root}}_css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/nv.d3.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/style.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/custom.css" rel="stylesheet" type="text/css">
 </head>
 <body>
  <header>
   <div class="container-fluid">
    <div class="row">
     <div class="col-md-12">
      <nav aria-label="breadcrumb">
       <ol class="breadcrumb">
{{breadcrumbs}}
       </ol>
      </nav>
     </div>
    </div>
   </div>
  </header>
  <div class="container-fluid">
   <div class="row">
    <div class="col-md-12">
     <h2>Classes</h2>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Coverage Distribution</h3>
     <div id="classCoverageDistribution" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Complexity</h3>
     <div id="classComplexity" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Insufficient Coverage</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Class</th>
         <th class="text-right">Coverage</th>
        </tr>
       </thead>
       <tbody>
{{insufficient_coverage_classes}}
       </tbody>
      </table>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Project Risks</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Class</th>
         <th class="text-right"><abbr title="Change Risk Anti-Patterns (CRAP) Index">CRAP</abbr></th>
        </tr>
       </thead>
       <tbody>
{{project_risks_classes}}
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <div class="row">
    <div class="col-md-12">
     <h2>Methods</h2>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Coverage Distribution</h3>
     <div id="methodCoverageDistribution" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Complexity</h3>
     <div id="methodComplexity" style="height: 300px;">
       <svg></svg>
     </div>
    </div>
   </div>
   <div class="row">
    <div class="col-md-6">
     <h3>Insufficient Coverage</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Method</th>
         <th class="text-right">Coverage</th>
        </tr>
       </thead>
       <tbody>
{{insufficient_coverage_methods}}
       </tbody>
      </table>
     </div>
    </div>
    <div class="col-md-6">
     <h3>Project Risks</h3>
     <div class="scrollbox">
      <table class="table">
       <thead>
        <tr>
         <th>Method</th>
         <th class="text-right"><abbr title="Change Risk Anti-Patterns (CRAP) Index">CRAP</abbr></th>
        </tr>
       </thead>
       <tbody>
{{project_risks_methods}}
       </tbody>
      </table>
     </div>
    </div>
   </div>
   <footer>
    <hr/>
    <p>
     <small>Generated by <a href="https://github.com/sebastianbergmann/php-code-coverage" target="_top">php-code-coverage {{version}}</a> using {{runtime}}{{generator}} at {{date}}.</small>
    </p>
   </footer>
  </div>
  <script src="{{path_to_root}}_js/jquery.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/d3.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/nv.d3.min.js" type="text/javascript"></script>
  <script type="text/javascript">
$(document).ready(function() {
  nv.addGraph(function() {
    var chart = nv.models.multiBarChart();
    chart.tooltips(false)
      .showControls(false)
      .showLegend(false)
      .reduceXTicks(false)
      .staggerLabels(true)
      .yAxis.tickFormat(d3.format('d'));

    d3.select('#classCoverageDistribution svg')
      .datum(getCoverageDistributionData({{class_coverage_distribution}}, "Class Coverage"))
      .transition().duration(500).call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  nv.addGraph(function() {
    var chart = nv.models.multiBarChart();
    chart.tooltips(false)
      .showControls(false)
      .showLegend(false)
      .reduceXTicks(false)
      .staggerLabels(true)
      .yAxis.tickFormat(d3.format('d'));

    d3.select('#methodCoverageDistribution svg')
      .datum(getCoverageDistributionData({{method_coverage_distribution}}, "Method Coverage"))
      .transition().duration(500).call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  function getCoverageDistributionData(data, label) {
    var labels = [
      '0%',
      '0-10%',
      '10-20%',
      '20-30%',
      '30-40%',
      '40-50%',
      '50-60%',
      '60-70%',
      '70-80%',
      '80-90%',
      '90-100%',
      '100%'
    ];
    var values = [];
    $.each(labels, function(key) {
      values.push({x: labels[key], y: data[key]});
    });

    return [
      {
        key: label,
        values: values,
        color: "#4572A7"
      }
    ];
  }
  nv.addGraph(function() {
    var chart = nv.models.scatterChart()
      .showDistX(true)
      .showDistY(true)
      .showLegend(false)
      .forceX([0, 100]);
    chart.tooltipContent(function(graph) {
      return '<p>' + graph.point.class + '</p>';
    });

    chart.xAxis.axisLabel('Code Coverage (in percent)');
    chart.yAxis.axisLabel('Cyclomatic Complexity');

    d3.select('#classComplexity svg')
      .datum(getComplexityData({{complexity_class}}, 'Class Complexity'))
      .transition()
      .duration(500)
      .call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  nv.addGraph(function() {
    var chart = nv.models.scatterChart()
      .showDistX(true)
      .showDistY(true)
      .showLegend(false)
      .forceX([0, 100]);
    chart.tooltipContent(function(graph) {
      return '<p>' + graph.point.class + '</p>';
    });

    chart.xAxis.axisLabel('Code Coverage (in percent)');
    chart.yAxis.axisLabel('Method Complexity');

    d3.select('#methodComplexity svg')
      .datum(getComplexityData({{complexity_method}}, 'Method Complexity'))
      .transition()
      .duration(500)
      .call(chart);

    nv.utils.windowResize(chart.update);

    return chart;
  });

  function getComplexityData(data, label) {
    var values = [];
    $.each(data, function(key) {
      var value = Math.round(data[key][0]*100) / 100;
      values.push({
        x: value,
        y: data[key][1],
        class: data[key][2],
        size: 0.05,
        shape: 'diamond'
      });
    });

    return [
      {
        key: label,
        values: values,
        color: "#4572A7"
      }
    ];
  }
});
  </script>
 </body>
</html>
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Code Coverage for {{full_path}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="{{path_to_root}}_css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/octicons.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/style.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/custom.css" rel="stylesheet" type="text/css">
 </head>
 <body>
  <header>
   <div class="container-fluid">
    <div class="row">
     <div class="col-md-12">
      <nav aria-label="breadcrumb">
       <ol class="breadcrumb">
{{breadcrumbs}}
       </ol>
      </nav>
     </div>
    </div>
   </div>
  </header>
  <div class="container-fluid">
   <div class="table-responsive">
    <table class="table table-bordered">
     <thead>
      <tr>
       <td>&nbsp;</td>
       <td colspan="9"><div align="center"><strong>Code Coverage</strong></div></td>
      </tr>
      <tr>
       <td>&nbsp;</td>
       <td colspan="3"><div align="center"><strong>Lines</strong></div></td>
       <td colspan="3"><div align="center"><strong>Functions and Methods</strong></div></td>
       <td colspan="3"><div align="center"><strong>Classes and Traits</strong></div></td>
      </tr>
     </thead>
     <tbody>
{{items}}
     </tbody>
    </table>
   </div>
   <footer>
    <hr/>
    <h4>Legend</h4>
    <p>
     <span class="danger"><strong>Low</strong>: 0% to {{low_upper_bound}}%</span>
     <span class="warning"><strong>Medium</strong>: {{low_upper_bound}}% to {{high_lower_bound}}%</span>
     <span class="success"><strong>High</strong>: {{high_lower_bound}}% to 100%</span>
    </p>
    <p>
     <small>Generated by <a href="https://github.com/sebastianbergmann/php-code-coverage" target="_top">php-code-coverage {{version}}</a> using {{runtime}}{{generator}} at {{date}}.</small>
    </p>
   </footer>
  </div>
 </body>
</html>
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Code Coverage for {{full_path}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="{{path_to_root}}_css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/octicons.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/style.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/custom.css" rel="stylesheet" type="text/css">
 </head>
 <body>
  <header>
   <div class="container-fluid">
    <div class="row">
     <div class="col-md-12">
      <nav aria-label="breadcrumb">
       <ol class="breadcrumb">
{{breadcrumbs}}
       </ol>
      </nav>
     </div>
    </div>
   </div>
  </header>
  <div class="container-fluid">
   <div class="table-responsive">
    <table class="table table-bordered">
     <thead>
      <tr>
       <td>&nbsp;</td>
       <td colspan="15"><div align="center"><strong>Code Coverage</strong></div></td>
      </tr>
      <tr>
       <td>&nbsp;</td>
       <td colspan="3"><div align="center"><strong>Lines</strong></div></td>
       <td colspan="3"><div align="center"><strong>Branches</strong></div></td>
       <td colspan="3"><div align="center"><strong>Paths</strong></div></td>
       <td colspan="3"><div align="center"><strong>Functions and Methods</strong></div></td>
       <td colspan="3"><div align="center"><strong>Classes and Traits</strong></div></td>
      </tr>
     </thead>
     <tbody>
{{items}}
     </tbody>
    </table>
   </div>
   <footer>
    <hr/>
    <h4>Legend</h4>
    <p>
     <span class="danger"><strong>Low</strong>: 0% to {{low_upper_bound}}%</span>
     <span class="warning"><strong>Medium</strong>: {{low_upper_bound}}% to {{high_lower_bound}}%</span>
     <span class="success"><strong>High</strong>: {{high_lower_bound}}% to 100%</span>
    </p>
    <p>
     <small>Generated by <a href="https://github.com/sebastianbergmann/php-code-coverage" target="_top">php-code-coverage {{version}}</a> using {{runtime}}{{generator}} at {{date}}.</small>
    </p>
   </footer>
  </div>
 </body>
</html>
      <tr>
       <td class="{{lines_level}}">{{icon}}{{name}}</td>
       <td class="{{lines_level}} big">{{lines_bar}}</td>
       <td class="{{lines_level}} small"><div align="right">{{lines_executed_percent}}</div></td>
       <td class="{{lines_level}} small"><div align="right">{{lines_number}}</div></td>
       <td class="{{methods_level}} big">{{methods_bar}}</td>
       <td class="{{methods_level}} small"><div align="right">{{methods_tested_percent}}</div></td>
       <td class="{{methods_level}} small"><div align="right">{{methods_number}}</div></td>
       <td class="{{classes_level}} big">{{classes_bar}}</td>
       <td class="{{classes_level}} small"><div align="right">{{classes_tested_percent}}</div></td>
       <td class="{{classes_level}} small"><div align="right">{{classes_number}}</div></td>
      </tr>

      <tr>
       <td class="{{lines_level}}">{{icon}}{{name}}</td>
       <td class="{{lines_level}} big">{{lines_bar}}</td>
       <td class="{{lines_level}} small"><div align="right">{{lines_executed_percent}}</div></td>
       <td class="{{lines_level}} small"><div align="right">{{lines_number}}</div></td>
       <td class="{{branches_level}} big">{{branches_bar}}</td>
       <td class="{{branches_level}} small"><div align="right">{{branches_executed_percent}}</div></td>
       <td class="{{branches_level}} small"><div align="right">{{branches_number}}</div></td>
       <td class="{{paths_level}} big">{{paths_bar}}</td>
       <td class="{{paths_level}} small"><div align="right">{{paths_executed_percent}}</div></td>
       <td class="{{paths_level}} small"><div align="right">{{paths_number}}</div></td>
       <td class="{{methods_level}} big">{{methods_bar}}</td>
       <td class="{{methods_level}} small"><div align="right">{{methods_tested_percent}}</div></td>
       <td class="{{methods_level}} small"><div align="right">{{methods_number}}</div></td>
       <td class="{{classes_level}} big">{{classes_bar}}</td>
       <td class="{{classes_level}} small"><div align="right">{{classes_tested_percent}}</div></td>
       <td class="{{classes_level}} small"><div align="right">{{classes_number}}</div></td>
      </tr>

<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Code Coverage for {{full_path}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="{{path_to_root}}_css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/octicons.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/style.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/custom.css" rel="stylesheet" type="text/css">
 </head>
 <body>
  <header>
   <div class="container-fluid">
    <div class="row">
     <div class="col-md-12">
      <nav aria-label="breadcrumb">
       <ol class="breadcrumb">
{{breadcrumbs}}
       </ol>
      </nav>
     </div>
    </div>
   </div>
  </header>
  <div class="container-fluid">
   <div class="table-responsive">
    <table class="table table-bordered">
     <thead>
      <tr>
       <td>&nbsp;</td>
       <td colspan="10"><div align="center"><strong>Code Coverage</strong></div></td>
      </tr>
      <tr>
       <td>&nbsp;</td>
       <td colspan="3"><div align="center"><strong>Classes and Traits</strong></div></td>
       <td colspan="4"><div align="center"><strong>Functions and Methods</strong></div></td>
       <td colspan="3"><div align="center"><strong>Lines</strong></div></td>
      </tr>
     </thead>
     <tbody>
{{items}}
     </tbody>
    </table>
   </div>
{{lines}}
{{structure}}
   <footer>
    <hr/>
    <h4>Legend</h4>
    {{legend}}
    <p>
     <small>Generated by <a href="https://github.com/sebastianbergmann/php-code-coverage" target="_top">php-code-coverage {{version}}</a> using {{runtime}}{{generator}} at {{date}}.</small>
    </p>
    <a title="Back to the top" id="toplink" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M12 11L6 5l-6 6h12z"/></svg>
    </a>
   </footer>
  </div>
  <script src="{{path_to_root}}_js/jquery.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/popper.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/bootstrap.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/file.js" type="text/javascript"></script>
 </body>
</html>
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <title>Code Coverage for {{full_path}}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="{{path_to_root}}_css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/octicons.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/style.css" rel="stylesheet" type="text/css">
  <link href="{{path_to_root}}_css/custom.css" rel="stylesheet" type="text/css">
 </head>
 <body>
  <header>
   <div class="container-fluid">
    <div class="row">
     <div class="col-md-12">
      <nav aria-label="breadcrumb">
       <ol class="breadcrumb">
{{breadcrumbs}}
       </ol>
      </nav>
     </div>
    </div>
   </div>
  </header>
  <div class="container-fluid">
   <div class="table-responsive">
    <table class="table table-bordered">
     <thead>
      <tr>
       <td>&nbsp;</td>
       <td colspan="16"><div align="center"><strong>Code Coverage</strong></div></td>
      </tr>
      <tr>
       <td>&nbsp;</td>
       <td colspan="3"><div align="center"><strong>Classes and Traits</strong></div></td>
       <td colspan="4"><div align="center"><strong>Functions and Methods</strong></div></td>
       <td colspan="3"><div align="center"><strong>Paths</strong></div></td>
       <td colspan="3"><div align="center"><strong>Branches</strong></div></td>
       <td colspan="3"><div align="center"><strong>Lines</strong></div></td>
      </tr>
     </thead>
     <tbody>
{{items}}
     </tbody>
    </table>
   </div>
{{lines}}
{{structure}}
   <footer>
    <hr/>
    <h4>Legend</h4>
    {{legend}}
    <p>
     <small>Generated by <a href="https://github.com/sebastianbergmann/php-code-coverage" target="_top">php-code-coverage {{version}}</a> using {{runtime}}{{generator}} at {{date}}.</small>
    </p>
    <a title="Back to the top" id="toplink" href="#">
        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M12 11L6 5l-6 6h12z"/></svg>
    </a>
   </footer>
  </div>
  <script src="{{path_to_root}}_js/jquery.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/popper.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/bootstrap.min.js" type="text/javascript"></script>
  <script src="{{path_to_root}}_js/file.js" type="text/javascript"></script>
 </body>
</html>
      <tr>
       <td class="{{classes_level}}">{{name}}</td>
       <td class="{{classes_level}} big">{{classes_bar}}</td>
       <td class="{{classes_level}} small"><div align="right">{{classes_tested_percent}}</div></td>
       <td class="{{classes_level}} small"><div align="right">{{classes_number}}</div></td>
       <td class="{{methods_level}} big">{{methods_bar}}</td>
       <td class="{{methods_level}} small"><div align="right">{{methods_tested_percent}}</div></td>
       <td class="{{methods_level}} small"><div align="right">{{methods_number}}</div></td>
       <td class="{{methods_level}} small">{{crap}}</td>
       <td class="{{lines_level}} big">{{lines_bar}}</td>
       <td class="{{lines_level}} small"><div align="right">{{lines_executed_percent}}</div></td>
       <td class="{{lines_level}} small"><div align="right">{{lines_number}}</div></td>
      </tr>

      <tr>
       <td class="{{classes_level}}">{{name}}</td>
       <td class="{{classes_level}} big">{{classes_bar}}</td>
       <td class="{{classes_level}} small"><div align="right">{{classes_tested_percent}}</div></td>
       <td class="{{classes_level}} small"><div align="right">{{classes_number}}</div></td>
       <td class="{{methods_level}} big">{{methods_bar}}</td>
       <td class="{{methods_level}} small"><div align="right">{{methods_tested_percent}}</div></td>
       <td class="{{methods_level}} small"><div align="right">{{methods_number}}</div></td>
       <td class="{{methods_level}} small">{{crap}}</td>
       <td class="{{paths_level}} big">{{paths_bar}}</td>
       <td class="{{paths_level}} small"><div align="right">{{paths_executed_percent}}</div></td>
       <td class="{{paths_level}} small"><div align="right">{{paths_number}}</div></td>
       <td class="{{branches_level}} big">{{branches_bar}}</td>
       <td class="{{branches_level}} small"><div align="right">{{branches_executed_percent}}</div></td>
       <td class="{{branches_level}} small"><div align="right">{{branches_number}}</div></td>
       <td class="{{lines_level}} big">{{lines_bar}}</td>
       <td class="{{lines_level}} small"><div align="right">{{lines_executed_percent}}</div></td>
       <td class="{{lines_level}} small"><div align="right">{{lines_number}}</div></td>
      </tr>

<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M8.5 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V4.5L8.5 1zM11 14H1V2h7l3 3v9zM5 6.98L3.5 8.5 5 10l-.5 1L2 8.5 4.5 6l.5.98zM7.5 6L10 8.5 7.5 11l-.5-.98L8.5 8.5 7 7l.5-1z"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M13 4H7V3c0-.66-.31-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zM6 4H1V3h5v1z"/></svg>/*!
  * Bootstrap v4.5.0 (https://getbootstrap.com/)
  * Copyright 2011-2020 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("jquery"),require("popper.js")):"function"==typeof define&&define.amd?define(["exports","jquery","popper.js"],e):e((t=t||self).bootstrap={},t.jQuery,t.Popper)}(this,(function(t,e,n){"use strict";function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function o(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function s(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function a(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){s(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e,n=n&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n;function l(t){var n=this,i=!1;return e(this).one(c.TRANSITION_END,(function(){i=!0})),setTimeout((function(){i||c.triggerTransitionEnd(n)}),t),this}var c={TRANSITION_END:"bsTransitionEnd",getUID:function(t){do{t+=~~(1e6*Math.random())}while(document.getElementById(t));return t},getSelectorFromElement:function(t){var e=t.getAttribute("data-target");if(!e||"#"===e){var n=t.getAttribute("href");e=n&&"#"!==n?n.trim():""}try{return document.querySelector(e)?e:null}catch(t){return null}},getTransitionDurationFromElement:function(t){if(!t)return 0;var n=e(t).css("transition-duration"),i=e(t).css("transition-delay"),o=parseFloat(n),s=parseFloat(i);return o||s?(n=n.split(",")[0],i=i.split(",")[0],1e3*(parseFloat(n)+parseFloat(i))):0},reflow:function(t){return t.offsetHeight},triggerTransitionEnd:function(t){e(t).trigger("transitionend")},supportsTransitionEnd:function(){return Boolean("transitionend")},isElement:function(t){return(t[0]||t).nodeType},typeCheckConfig:function(t,e,n){for(var i in n)if(Object.prototype.hasOwnProperty.call(n,i)){var o=n[i],s=e[i],r=s&&c.isElement(s)?"element":null===(a=s)||"undefined"==typeof a?""+a:{}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase();if(!new RegExp(o).test(r))throw new Error(t.toUpperCase()+': Option "'+i+'" provided type "'+r+'" but expected type "'+o+'".')}var a},findShadowRoot:function(t){if(!document.documentElement.attachShadow)return null;if("function"==typeof t.getRootNode){var e=t.getRootNode();return e instanceof ShadowRoot?e:null}return t instanceof ShadowRoot?t:t.parentNode?c.findShadowRoot(t.parentNode):null},jQueryDetection:function(){if("undefined"==typeof e)throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");var t=e.fn.jquery.split(" ")[0].split(".");if(t[0]<2&&t[1]<9||1===t[0]&&9===t[1]&&t[2]<1||t[0]>=4)throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")}};c.jQueryDetection(),e.fn.emulateTransitionEnd=l,e.event.special[c.TRANSITION_END]={bindType:"transitionend",delegateType:"transitionend",handle:function(t){if(e(t.target).is(this))return t.handleObj.handler.apply(this,arguments)}};var h="alert",u=e.fn[h],d=function(){function t(t){this._element=t}var n=t.prototype;return n.close=function(t){var e=this._element;t&&(e=this._getRootElement(t)),this._triggerCloseEvent(e).isDefaultPrevented()||this._removeElement(e)},n.dispose=function(){e.removeData(this._element,"bs.alert"),this._element=null},n._getRootElement=function(t){var n=c.getSelectorFromElement(t),i=!1;return n&&(i=document.querySelector(n)),i||(i=e(t).closest(".alert")[0]),i},n._triggerCloseEvent=function(t){var n=e.Event("close.bs.alert");return e(t).trigger(n),n},n._removeElement=function(t){var n=this;if(e(t).removeClass("show"),e(t).hasClass("fade")){var i=c.getTransitionDurationFromElement(t);e(t).one(c.TRANSITION_END,(function(e){return n._destroyElement(t,e)})).emulateTransitionEnd(i)}else this._destroyElement(t)},n._destroyElement=function(t){e(t).detach().trigger("closed.bs.alert").remove()},t._jQueryInterface=function(n){return this.each((function(){var i=e(this),o=i.data("bs.alert");o||(o=new t(this),i.data("bs.alert",o)),"close"===n&&o[n](this)}))},t._handleDismiss=function(t){return function(e){e&&e.preventDefault(),t.close(this)}},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}}]),t}();e(document).on("click.bs.alert.data-api",'[data-dismiss="alert"]',d._handleDismiss(new d)),e.fn[h]=d._jQueryInterface,e.fn[h].Constructor=d,e.fn[h].noConflict=function(){return e.fn[h]=u,d._jQueryInterface};var f=e.fn.button,g=function(){function t(t){this._element=t}var n=t.prototype;return n.toggle=function(){var t=!0,n=!0,i=e(this._element).closest('[data-toggle="buttons"]')[0];if(i){var o=this._element.querySelector('input:not([type="hidden"])');if(o){if("radio"===o.type)if(o.checked&&this._element.classList.contains("active"))t=!1;else{var s=i.querySelector(".active");s&&e(s).removeClass("active")}t&&("checkbox"!==o.type&&"radio"!==o.type||(o.checked=!this._element.classList.contains("active")),e(o).trigger("change")),o.focus(),n=!1}}this._element.hasAttribute("disabled")||this._element.classList.contains("disabled")||(n&&this._element.setAttribute("aria-pressed",!this._element.classList.contains("active")),t&&e(this._element).toggleClass("active"))},n.dispose=function(){e.removeData(this._element,"bs.button"),this._element=null},t._jQueryInterface=function(n){return this.each((function(){var i=e(this).data("bs.button");i||(i=new t(this),e(this).data("bs.button",i)),"toggle"===n&&i[n]()}))},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}}]),t}();e(document).on("click.bs.button.data-api",'[data-toggle^="button"]',(function(t){var n=t.target,i=n;if(e(n).hasClass("btn")||(n=e(n).closest(".btn")[0]),!n||n.hasAttribute("disabled")||n.classList.contains("disabled"))t.preventDefault();else{var o=n.querySelector('input:not([type="hidden"])');if(o&&(o.hasAttribute("disabled")||o.classList.contains("disabled")))return void t.preventDefault();"LABEL"===i.tagName&&o&&"checkbox"===o.type&&t.preventDefault(),g._jQueryInterface.call(e(n),"toggle")}})).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',(function(t){var n=e(t.target).closest(".btn")[0];e(n).toggleClass("focus",/^focus(in)?$/.test(t.type))})),e(window).on("load.bs.button.data-api",(function(){for(var t=[].slice.call(document.querySelectorAll('[data-toggle="buttons"] .btn')),e=0,n=t.length;e<n;e++){var i=t[e],o=i.querySelector('input:not([type="hidden"])');o.checked||o.hasAttribute("checked")?i.classList.add("active"):i.classList.remove("active")}for(var s=0,r=(t=[].slice.call(document.querySelectorAll('[data-toggle="button"]'))).length;s<r;s++){var a=t[s];"true"===a.getAttribute("aria-pressed")?a.classList.add("active"):a.classList.remove("active")}})),e.fn.button=g._jQueryInterface,e.fn.button.Constructor=g,e.fn.button.noConflict=function(){return e.fn.button=f,g._jQueryInterface};var m="carousel",p=".bs.carousel",_=e.fn[m],v={interval:5e3,keyboard:!0,slide:!1,pause:"hover",wrap:!0,touch:!0},b={interval:"(number|boolean)",keyboard:"boolean",slide:"(boolean|string)",pause:"(string|boolean)",wrap:"boolean",touch:"boolean"},y={TOUCH:"touch",PEN:"pen"},E=function(){function t(t,e){this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this.touchStartX=0,this.touchDeltaX=0,this._config=this._getConfig(e),this._element=t,this._indicatorsElement=this._element.querySelector(".carousel-indicators"),this._touchSupported="ontouchstart"in document.documentElement||navigator.maxTouchPoints>0,this._pointerEvent=Boolean(window.PointerEvent||window.MSPointerEvent),this._addEventListeners()}var n=t.prototype;return n.next=function(){this._isSliding||this._slide("next")},n.nextWhenVisible=function(){!document.hidden&&e(this._element).is(":visible")&&"hidden"!==e(this._element).css("visibility")&&this.next()},n.prev=function(){this._isSliding||this._slide("prev")},n.pause=function(t){t||(this._isPaused=!0),this._element.querySelector(".carousel-item-next, .carousel-item-prev")&&(c.triggerTransitionEnd(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},n.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},n.to=function(t){var n=this;this._activeElement=this._element.querySelector(".active.carousel-item");var i=this._getItemIndex(this._activeElement);if(!(t>this._items.length-1||t<0))if(this._isSliding)e(this._element).one("slid.bs.carousel",(function(){return n.to(t)}));else{if(i===t)return this.pause(),void this.cycle();var o=t>i?"next":"prev";this._slide(o,this._items[t])}},n.dispose=function(){e(this._element).off(p),e.removeData(this._element,"bs.carousel"),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},n._getConfig=function(t){return t=a(a({},v),t),c.typeCheckConfig(m,t,b),t},n._handleSwipe=function(){var t=Math.abs(this.touchDeltaX);if(!(t<=40)){var e=t/this.touchDeltaX;this.touchDeltaX=0,e>0&&this.prev(),e<0&&this.next()}},n._addEventListeners=function(){var t=this;this._config.keyboard&&e(this._element).on("keydown.bs.carousel",(function(e){return t._keydown(e)})),"hover"===this._config.pause&&e(this._element).on("mouseenter.bs.carousel",(function(e){return t.pause(e)})).on("mouseleave.bs.carousel",(function(e){return t.cycle(e)})),this._config.touch&&this._addTouchEventListeners()},n._addTouchEventListeners=function(){var t=this;if(this._touchSupported){var n=function(e){t._pointerEvent&&y[e.originalEvent.pointerType.toUpperCase()]?t.touchStartX=e.originalEvent.clientX:t._pointerEvent||(t.touchStartX=e.originalEvent.touches[0].clientX)},i=function(e){t._pointerEvent&&y[e.originalEvent.pointerType.toUpperCase()]&&(t.touchDeltaX=e.originalEvent.clientX-t.touchStartX),t._handleSwipe(),"hover"===t._config.pause&&(t.pause(),t.touchTimeout&&clearTimeout(t.touchTimeout),t.touchTimeout=setTimeout((function(e){return t.cycle(e)}),500+t._config.interval))};e(this._element.querySelectorAll(".carousel-item img")).on("dragstart.bs.carousel",(function(t){return t.preventDefault()})),this._pointerEvent?(e(this._element).on("pointerdown.bs.carousel",(function(t){return n(t)})),e(this._element).on("pointerup.bs.carousel",(function(t){return i(t)})),this._element.classList.add("pointer-event")):(e(this._element).on("touchstart.bs.carousel",(function(t){return n(t)})),e(this._element).on("touchmove.bs.carousel",(function(e){return function(e){e.originalEvent.touches&&e.originalEvent.touches.length>1?t.touchDeltaX=0:t.touchDeltaX=e.originalEvent.touches[0].clientX-t.touchStartX}(e)})),e(this._element).on("touchend.bs.carousel",(function(t){return i(t)})))}},n._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.which){case 37:t.preventDefault(),this.prev();break;case 39:t.preventDefault(),this.next()}},n._getItemIndex=function(t){return this._items=t&&t.parentNode?[].slice.call(t.parentNode.querySelectorAll(".carousel-item")):[],this._items.indexOf(t)},n._getItemByDirection=function(t,e){var n="next"===t,i="prev"===t,o=this._getItemIndex(e),s=this._items.length-1;if((i&&0===o||n&&o===s)&&!this._config.wrap)return e;var r=(o+("prev"===t?-1:1))%this._items.length;return-1===r?this._items[this._items.length-1]:this._items[r]},n._triggerSlideEvent=function(t,n){var i=this._getItemIndex(t),o=this._getItemIndex(this._element.querySelector(".active.carousel-item")),s=e.Event("slide.bs.carousel",{relatedTarget:t,direction:n,from:o,to:i});return e(this._element).trigger(s),s},n._setActiveIndicatorElement=function(t){if(this._indicatorsElement){var n=[].slice.call(this._indicatorsElement.querySelectorAll(".active"));e(n).removeClass("active");var i=this._indicatorsElement.children[this._getItemIndex(t)];i&&e(i).addClass("active")}},n._slide=function(t,n){var i,o,s,r=this,a=this._element.querySelector(".active.carousel-item"),l=this._getItemIndex(a),h=n||a&&this._getItemByDirection(t,a),u=this._getItemIndex(h),d=Boolean(this._interval);if("next"===t?(i="carousel-item-left",o="carousel-item-next",s="left"):(i="carousel-item-right",o="carousel-item-prev",s="right"),h&&e(h).hasClass("active"))this._isSliding=!1;else if(!this._triggerSlideEvent(h,s).isDefaultPrevented()&&a&&h){this._isSliding=!0,d&&this.pause(),this._setActiveIndicatorElement(h);var f=e.Event("slid.bs.carousel",{relatedTarget:h,direction:s,from:l,to:u});if(e(this._element).hasClass("slide")){e(h).addClass(o),c.reflow(h),e(a).addClass(i),e(h).addClass(i);var g=parseInt(h.getAttribute("data-interval"),10);g?(this._config.defaultInterval=this._config.defaultInterval||this._config.interval,this._config.interval=g):this._config.interval=this._config.defaultInterval||this._config.interval;var m=c.getTransitionDurationFromElement(a);e(a).one(c.TRANSITION_END,(function(){e(h).removeClass(i+" "+o).addClass("active"),e(a).removeClass("active "+o+" "+i),r._isSliding=!1,setTimeout((function(){return e(r._element).trigger(f)}),0)})).emulateTransitionEnd(m)}else e(a).removeClass("active"),e(h).addClass("active"),this._isSliding=!1,e(this._element).trigger(f);d&&this.cycle()}},t._jQueryInterface=function(n){return this.each((function(){var i=e(this).data("bs.carousel"),o=a(a({},v),e(this).data());"object"==typeof n&&(o=a(a({},o),n));var s="string"==typeof n?n:o.slide;if(i||(i=new t(this,o),e(this).data("bs.carousel",i)),"number"==typeof n)i.to(n);else if("string"==typeof s){if("undefined"==typeof i[s])throw new TypeError('No method named "'+s+'"');i[s]()}else o.interval&&o.ride&&(i.pause(),i.cycle())}))},t._dataApiClickHandler=function(n){var i=c.getSelectorFromElement(this);if(i){var o=e(i)[0];if(o&&e(o).hasClass("carousel")){var s=a(a({},e(o).data()),e(this).data()),r=this.getAttribute("data-slide-to");r&&(s.interval=!1),t._jQueryInterface.call(e(o),s),r&&e(o).data("bs.carousel").to(r),n.preventDefault()}}},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"Default",get:function(){return v}}]),t}();e(document).on("click.bs.carousel.data-api","[data-slide], [data-slide-to]",E._dataApiClickHandler),e(window).on("load.bs.carousel.data-api",(function(){for(var t=[].slice.call(document.querySelectorAll('[data-ride="carousel"]')),n=0,i=t.length;n<i;n++){var o=e(t[n]);E._jQueryInterface.call(o,o.data())}})),e.fn[m]=E._jQueryInterface,e.fn[m].Constructor=E,e.fn[m].noConflict=function(){return e.fn[m]=_,E._jQueryInterface};var w="collapse",T=e.fn[w],C={toggle:!0,parent:""},S={toggle:"boolean",parent:"(string|element)"},D=function(){function t(t,e){this._isTransitioning=!1,this._element=t,this._config=this._getConfig(e),this._triggerArray=[].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#'+t.id+'"],[data-toggle="collapse"][data-target="#'+t.id+'"]'));for(var n=[].slice.call(document.querySelectorAll('[data-toggle="collapse"]')),i=0,o=n.length;i<o;i++){var s=n[i],r=c.getSelectorFromElement(s),a=[].slice.call(document.querySelectorAll(r)).filter((function(e){return e===t}));null!==r&&a.length>0&&(this._selector=r,this._triggerArray.push(s))}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle()}var n=t.prototype;return n.toggle=function(){e(this._element).hasClass("show")?this.hide():this.show()},n.show=function(){var n,i,o=this;if(!this._isTransitioning&&!e(this._element).hasClass("show")&&(this._parent&&0===(n=[].slice.call(this._parent.querySelectorAll(".show, .collapsing")).filter((function(t){return"string"==typeof o._config.parent?t.getAttribute("data-parent")===o._config.parent:t.classList.contains("collapse")}))).length&&(n=null),!(n&&(i=e(n).not(this._selector).data("bs.collapse"))&&i._isTransitioning))){var s=e.Event("show.bs.collapse");if(e(this._element).trigger(s),!s.isDefaultPrevented()){n&&(t._jQueryInterface.call(e(n).not(this._selector),"hide"),i||e(n).data("bs.collapse",null));var r=this._getDimension();e(this._element).removeClass("collapse").addClass("collapsing"),this._element.style[r]=0,this._triggerArray.length&&e(this._triggerArray).removeClass("collapsed").attr("aria-expanded",!0),this.setTransitioning(!0);var a="scroll"+(r[0].toUpperCase()+r.slice(1)),l=c.getTransitionDurationFromElement(this._element);e(this._element).one(c.TRANSITION_END,(function(){e(o._element).removeClass("collapsing").addClass("collapse show"),o._element.style[r]="",o.setTransitioning(!1),e(o._element).trigger("shown.bs.collapse")})).emulateTransitionEnd(l),this._element.style[r]=this._element[a]+"px"}}},n.hide=function(){var t=this;if(!this._isTransitioning&&e(this._element).hasClass("show")){var n=e.Event("hide.bs.collapse");if(e(this._element).trigger(n),!n.isDefaultPrevented()){var i=this._getDimension();this._element.style[i]=this._element.getBoundingClientRect()[i]+"px",c.reflow(this._element),e(this._element).addClass("collapsing").removeClass("collapse show");var o=this._triggerArray.length;if(o>0)for(var s=0;s<o;s++){var r=this._triggerArray[s],a=c.getSelectorFromElement(r);if(null!==a)e([].slice.call(document.querySelectorAll(a))).hasClass("show")||e(r).addClass("collapsed").attr("aria-expanded",!1)}this.setTransitioning(!0);this._element.style[i]="";var l=c.getTransitionDurationFromElement(this._element);e(this._element).one(c.TRANSITION_END,(function(){t.setTransitioning(!1),e(t._element).removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")})).emulateTransitionEnd(l)}}},n.setTransitioning=function(t){this._isTransitioning=t},n.dispose=function(){e.removeData(this._element,"bs.collapse"),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},n._getConfig=function(t){return(t=a(a({},C),t)).toggle=Boolean(t.toggle),c.typeCheckConfig(w,t,S),t},n._getDimension=function(){return e(this._element).hasClass("width")?"width":"height"},n._getParent=function(){var n,i=this;c.isElement(this._config.parent)?(n=this._config.parent,"undefined"!=typeof this._config.parent.jquery&&(n=this._config.parent[0])):n=document.querySelector(this._config.parent);var o='[data-toggle="collapse"][data-parent="'+this._config.parent+'"]',s=[].slice.call(n.querySelectorAll(o));return e(s).each((function(e,n){i._addAriaAndCollapsedClass(t._getTargetFromElement(n),[n])})),n},n._addAriaAndCollapsedClass=function(t,n){var i=e(t).hasClass("show");n.length&&e(n).toggleClass("collapsed",!i).attr("aria-expanded",i)},t._getTargetFromElement=function(t){var e=c.getSelectorFromElement(t);return e?document.querySelector(e):null},t._jQueryInterface=function(n){return this.each((function(){var i=e(this),o=i.data("bs.collapse"),s=a(a(a({},C),i.data()),"object"==typeof n&&n?n:{});if(!o&&s.toggle&&"string"==typeof n&&/show|hide/.test(n)&&(s.toggle=!1),o||(o=new t(this,s),i.data("bs.collapse",o)),"string"==typeof n){if("undefined"==typeof o[n])throw new TypeError('No method named "'+n+'"');o[n]()}}))},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"Default",get:function(){return C}}]),t}();e(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',(function(t){"A"===t.currentTarget.tagName&&t.preventDefault();var n=e(this),i=c.getSelectorFromElement(this),o=[].slice.call(document.querySelectorAll(i));e(o).each((function(){var t=e(this),i=t.data("bs.collapse")?"toggle":n.data();D._jQueryInterface.call(t,i)}))})),e.fn[w]=D._jQueryInterface,e.fn[w].Constructor=D,e.fn[w].noConflict=function(){return e.fn[w]=T,D._jQueryInterface};var k="dropdown",N=e.fn[k],A=new RegExp("38|40|27"),I={offset:0,flip:!0,boundary:"scrollParent",reference:"toggle",display:"dynamic",popperConfig:null},O={offset:"(number|string|function)",flip:"boolean",boundary:"(string|element)",reference:"(string|element)",display:"string",popperConfig:"(null|object)"},j=function(){function t(t,e){this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._addEventListeners()}var i=t.prototype;return i.toggle=function(){if(!this._element.disabled&&!e(this._element).hasClass("disabled")){var n=e(this._menu).hasClass("show");t._clearMenus(),n||this.show(!0)}},i.show=function(i){if(void 0===i&&(i=!1),!(this._element.disabled||e(this._element).hasClass("disabled")||e(this._menu).hasClass("show"))){var o={relatedTarget:this._element},s=e.Event("show.bs.dropdown",o),r=t._getParentFromElement(this._element);if(e(r).trigger(s),!s.isDefaultPrevented()){if(!this._inNavbar&&i){if("undefined"==typeof n)throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");var a=this._element;"parent"===this._config.reference?a=r:c.isElement(this._config.reference)&&(a=this._config.reference,"undefined"!=typeof this._config.reference.jquery&&(a=this._config.reference[0])),"scrollParent"!==this._config.boundary&&e(r).addClass("position-static"),this._popper=new n(a,this._menu,this._getPopperConfig())}"ontouchstart"in document.documentElement&&0===e(r).closest(".navbar-nav").length&&e(document.body).children().on("mouseover",null,e.noop),this._element.focus(),this._element.setAttribute("aria-expanded",!0),e(this._menu).toggleClass("show"),e(r).toggleClass("show").trigger(e.Event("shown.bs.dropdown",o))}}},i.hide=function(){if(!this._element.disabled&&!e(this._element).hasClass("disabled")&&e(this._menu).hasClass("show")){var n={relatedTarget:this._element},i=e.Event("hide.bs.dropdown",n),o=t._getParentFromElement(this._element);e(o).trigger(i),i.isDefaultPrevented()||(this._popper&&this._popper.destroy(),e(this._menu).toggleClass("show"),e(o).toggleClass("show").trigger(e.Event("hidden.bs.dropdown",n)))}},i.dispose=function(){e.removeData(this._element,"bs.dropdown"),e(this._element).off(".bs.dropdown"),this._element=null,this._menu=null,null!==this._popper&&(this._popper.destroy(),this._popper=null)},i.update=function(){this._inNavbar=this._detectNavbar(),null!==this._popper&&this._popper.scheduleUpdate()},i._addEventListeners=function(){var t=this;e(this._element).on("click.bs.dropdown",(function(e){e.preventDefault(),e.stopPropagation(),t.toggle()}))},i._getConfig=function(t){return t=a(a(a({},this.constructor.Default),e(this._element).data()),t),c.typeCheckConfig(k,t,this.constructor.DefaultType),t},i._getMenuElement=function(){if(!this._menu){var e=t._getParentFromElement(this._element);e&&(this._menu=e.querySelector(".dropdown-menu"))}return this._menu},i._getPlacement=function(){var t=e(this._element.parentNode),n="bottom-start";return t.hasClass("dropup")?n=e(this._menu).hasClass("dropdown-menu-right")?"top-end":"top-start":t.hasClass("dropright")?n="right-start":t.hasClass("dropleft")?n="left-start":e(this._menu).hasClass("dropdown-menu-right")&&(n="bottom-end"),n},i._detectNavbar=function(){return e(this._element).closest(".navbar").length>0},i._getOffset=function(){var t=this,e={};return"function"==typeof this._config.offset?e.fn=function(e){return e.offsets=a(a({},e.offsets),t._config.offset(e.offsets,t._element)||{}),e}:e.offset=this._config.offset,e},i._getPopperConfig=function(){var t={placement:this._getPlacement(),modifiers:{offset:this._getOffset(),flip:{enabled:this._config.flip},preventOverflow:{boundariesElement:this._config.boundary}}};return"static"===this._config.display&&(t.modifiers.applyStyle={enabled:!1}),a(a({},t),this._config.popperConfig)},t._jQueryInterface=function(n){return this.each((function(){var i=e(this).data("bs.dropdown");if(i||(i=new t(this,"object"==typeof n?n:null),e(this).data("bs.dropdown",i)),"string"==typeof n){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}}))},t._clearMenus=function(n){if(!n||3!==n.which&&("keyup"!==n.type||9===n.which))for(var i=[].slice.call(document.querySelectorAll('[data-toggle="dropdown"]')),o=0,s=i.length;o<s;o++){var r=t._getParentFromElement(i[o]),a=e(i[o]).data("bs.dropdown"),l={relatedTarget:i[o]};if(n&&"click"===n.type&&(l.clickEvent=n),a){var c=a._menu;if(e(r).hasClass("show")&&!(n&&("click"===n.type&&/input|textarea/i.test(n.target.tagName)||"keyup"===n.type&&9===n.which)&&e.contains(r,n.target))){var h=e.Event("hide.bs.dropdown",l);e(r).trigger(h),h.isDefaultPrevented()||("ontouchstart"in document.documentElement&&e(document.body).children().off("mouseover",null,e.noop),i[o].setAttribute("aria-expanded","false"),a._popper&&a._popper.destroy(),e(c).removeClass("show"),e(r).removeClass("show").trigger(e.Event("hidden.bs.dropdown",l)))}}}},t._getParentFromElement=function(t){var e,n=c.getSelectorFromElement(t);return n&&(e=document.querySelector(n)),e||t.parentNode},t._dataApiKeydownHandler=function(n){if(!(/input|textarea/i.test(n.target.tagName)?32===n.which||27!==n.which&&(40!==n.which&&38!==n.which||e(n.target).closest(".dropdown-menu").length):!A.test(n.which))&&!this.disabled&&!e(this).hasClass("disabled")){var i=t._getParentFromElement(this),o=e(i).hasClass("show");if(o||27!==n.which){if(n.preventDefault(),n.stopPropagation(),!o||o&&(27===n.which||32===n.which))return 27===n.which&&e(i.querySelector('[data-toggle="dropdown"]')).trigger("focus"),void e(this).trigger("click");var s=[].slice.call(i.querySelectorAll(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)")).filter((function(t){return e(t).is(":visible")}));if(0!==s.length){var r=s.indexOf(n.target);38===n.which&&r>0&&r--,40===n.which&&r<s.length-1&&r++,r<0&&(r=0),s[r].focus()}}}},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"Default",get:function(){return I}},{key:"DefaultType",get:function(){return O}}]),t}();e(document).on("keydown.bs.dropdown.data-api",'[data-toggle="dropdown"]',j._dataApiKeydownHandler).on("keydown.bs.dropdown.data-api",".dropdown-menu",j._dataApiKeydownHandler).on("click.bs.dropdown.data-api keyup.bs.dropdown.data-api",j._clearMenus).on("click.bs.dropdown.data-api",'[data-toggle="dropdown"]',(function(t){t.preventDefault(),t.stopPropagation(),j._jQueryInterface.call(e(this),"toggle")})).on("click.bs.dropdown.data-api",".dropdown form",(function(t){t.stopPropagation()})),e.fn[k]=j._jQueryInterface,e.fn[k].Constructor=j,e.fn[k].noConflict=function(){return e.fn[k]=N,j._jQueryInterface};var P=e.fn.modal,x={backdrop:!0,keyboard:!0,focus:!0,show:!0},L={backdrop:"(boolean|string)",keyboard:"boolean",focus:"boolean",show:"boolean"},R=function(){function t(t,e){this._config=this._getConfig(e),this._element=t,this._dialog=t.querySelector(".modal-dialog"),this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._isTransitioning=!1,this._scrollbarWidth=0}var n=t.prototype;return n.toggle=function(t){return this._isShown?this.hide():this.show(t)},n.show=function(t){var n=this;if(!this._isShown&&!this._isTransitioning){e(this._element).hasClass("fade")&&(this._isTransitioning=!0);var i=e.Event("show.bs.modal",{relatedTarget:t});e(this._element).trigger(i),this._isShown||i.isDefaultPrevented()||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),this._adjustDialog(),this._setEscapeEvent(),this._setResizeEvent(),e(this._element).on("click.dismiss.bs.modal",'[data-dismiss="modal"]',(function(t){return n.hide(t)})),e(this._dialog).on("mousedown.dismiss.bs.modal",(function(){e(n._element).one("mouseup.dismiss.bs.modal",(function(t){e(t.target).is(n._element)&&(n._ignoreBackdropClick=!0)}))})),this._showBackdrop((function(){return n._showElement(t)})))}},n.hide=function(t){var n=this;if(t&&t.preventDefault(),this._isShown&&!this._isTransitioning){var i=e.Event("hide.bs.modal");if(e(this._element).trigger(i),this._isShown&&!i.isDefaultPrevented()){this._isShown=!1;var o=e(this._element).hasClass("fade");if(o&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),e(document).off("focusin.bs.modal"),e(this._element).removeClass("show"),e(this._element).off("click.dismiss.bs.modal"),e(this._dialog).off("mousedown.dismiss.bs.modal"),o){var s=c.getTransitionDurationFromElement(this._element);e(this._element).one(c.TRANSITION_END,(function(t){return n._hideModal(t)})).emulateTransitionEnd(s)}else this._hideModal()}}},n.dispose=function(){[window,this._element,this._dialog].forEach((function(t){return e(t).off(".bs.modal")})),e(document).off("focusin.bs.modal"),e.removeData(this._element,"bs.modal"),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._isTransitioning=null,this._scrollbarWidth=null},n.handleUpdate=function(){this._adjustDialog()},n._getConfig=function(t){return t=a(a({},x),t),c.typeCheckConfig("modal",t,L),t},n._triggerBackdropTransition=function(){var t=this;if("static"===this._config.backdrop){var n=e.Event("hidePrevented.bs.modal");if(e(this._element).trigger(n),n.defaultPrevented)return;this._element.classList.add("modal-static");var i=c.getTransitionDurationFromElement(this._element);e(this._element).one(c.TRANSITION_END,(function(){t._element.classList.remove("modal-static")})).emulateTransitionEnd(i),this._element.focus()}else this.hide()},n._showElement=function(t){var n=this,i=e(this._element).hasClass("fade"),o=this._dialog?this._dialog.querySelector(".modal-body"):null;this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.setAttribute("aria-modal",!0),e(this._dialog).hasClass("modal-dialog-scrollable")&&o?o.scrollTop=0:this._element.scrollTop=0,i&&c.reflow(this._element),e(this._element).addClass("show"),this._config.focus&&this._enforceFocus();var s=e.Event("shown.bs.modal",{relatedTarget:t}),r=function(){n._config.focus&&n._element.focus(),n._isTransitioning=!1,e(n._element).trigger(s)};if(i){var a=c.getTransitionDurationFromElement(this._dialog);e(this._dialog).one(c.TRANSITION_END,r).emulateTransitionEnd(a)}else r()},n._enforceFocus=function(){var t=this;e(document).off("focusin.bs.modal").on("focusin.bs.modal",(function(n){document!==n.target&&t._element!==n.target&&0===e(t._element).has(n.target).length&&t._element.focus()}))},n._setEscapeEvent=function(){var t=this;this._isShown?e(this._element).on("keydown.dismiss.bs.modal",(function(e){t._config.keyboard&&27===e.which?(e.preventDefault(),t.hide()):t._config.keyboard||27!==e.which||t._triggerBackdropTransition()})):this._isShown||e(this._element).off("keydown.dismiss.bs.modal")},n._setResizeEvent=function(){var t=this;this._isShown?e(window).on("resize.bs.modal",(function(e){return t.handleUpdate(e)})):e(window).off("resize.bs.modal")},n._hideModal=function(){var t=this;this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._element.removeAttribute("aria-modal"),this._isTransitioning=!1,this._showBackdrop((function(){e(document.body).removeClass("modal-open"),t._resetAdjustments(),t._resetScrollbar(),e(t._element).trigger("hidden.bs.modal")}))},n._removeBackdrop=function(){this._backdrop&&(e(this._backdrop).remove(),this._backdrop=null)},n._showBackdrop=function(t){var n=this,i=e(this._element).hasClass("fade")?"fade":"";if(this._isShown&&this._config.backdrop){if(this._backdrop=document.createElement("div"),this._backdrop.className="modal-backdrop",i&&this._backdrop.classList.add(i),e(this._backdrop).appendTo(document.body),e(this._element).on("click.dismiss.bs.modal",(function(t){n._ignoreBackdropClick?n._ignoreBackdropClick=!1:t.target===t.currentTarget&&n._triggerBackdropTransition()})),i&&c.reflow(this._backdrop),e(this._backdrop).addClass("show"),!t)return;if(!i)return void t();var o=c.getTransitionDurationFromElement(this._backdrop);e(this._backdrop).one(c.TRANSITION_END,t).emulateTransitionEnd(o)}else if(!this._isShown&&this._backdrop){e(this._backdrop).removeClass("show");var s=function(){n._removeBackdrop(),t&&t()};if(e(this._element).hasClass("fade")){var r=c.getTransitionDurationFromElement(this._backdrop);e(this._backdrop).one(c.TRANSITION_END,s).emulateTransitionEnd(r)}else s()}else t&&t()},n._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+"px"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+"px")},n._resetAdjustments=function(){this._element.style.paddingLeft="",this._element.style.paddingRight=""},n._checkScrollbar=function(){var t=document.body.getBoundingClientRect();this._isBodyOverflowing=Math.round(t.left+t.right)<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},n._setScrollbar=function(){var t=this;if(this._isBodyOverflowing){var n=[].slice.call(document.querySelectorAll(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top")),i=[].slice.call(document.querySelectorAll(".sticky-top"));e(n).each((function(n,i){var o=i.style.paddingRight,s=e(i).css("padding-right");e(i).data("padding-right",o).css("padding-right",parseFloat(s)+t._scrollbarWidth+"px")})),e(i).each((function(n,i){var o=i.style.marginRight,s=e(i).css("margin-right");e(i).data("margin-right",o).css("margin-right",parseFloat(s)-t._scrollbarWidth+"px")}));var o=document.body.style.paddingRight,s=e(document.body).css("padding-right");e(document.body).data("padding-right",o).css("padding-right",parseFloat(s)+this._scrollbarWidth+"px")}e(document.body).addClass("modal-open")},n._resetScrollbar=function(){var t=[].slice.call(document.querySelectorAll(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"));e(t).each((function(t,n){var i=e(n).data("padding-right");e(n).removeData("padding-right"),n.style.paddingRight=i||""}));var n=[].slice.call(document.querySelectorAll(".sticky-top"));e(n).each((function(t,n){var i=e(n).data("margin-right");"undefined"!=typeof i&&e(n).css("margin-right",i).removeData("margin-right")}));var i=e(document.body).data("padding-right");e(document.body).removeData("padding-right"),document.body.style.paddingRight=i||""},n._getScrollbarWidth=function(){var t=document.createElement("div");t.className="modal-scrollbar-measure",document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},t._jQueryInterface=function(n,i){return this.each((function(){var o=e(this).data("bs.modal"),s=a(a(a({},x),e(this).data()),"object"==typeof n&&n?n:{});if(o||(o=new t(this,s),e(this).data("bs.modal",o)),"string"==typeof n){if("undefined"==typeof o[n])throw new TypeError('No method named "'+n+'"');o[n](i)}else s.show&&o.show(i)}))},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"Default",get:function(){return x}}]),t}();e(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',(function(t){var n,i=this,o=c.getSelectorFromElement(this);o&&(n=document.querySelector(o));var s=e(n).data("bs.modal")?"toggle":a(a({},e(n).data()),e(this).data());"A"!==this.tagName&&"AREA"!==this.tagName||t.preventDefault();var r=e(n).one("show.bs.modal",(function(t){t.isDefaultPrevented()||r.one("hidden.bs.modal",(function(){e(i).is(":visible")&&i.focus()}))}));R._jQueryInterface.call(e(n),s,this)})),e.fn.modal=R._jQueryInterface,e.fn.modal.Constructor=R,e.fn.modal.noConflict=function(){return e.fn.modal=P,R._jQueryInterface};var q=["background","cite","href","itemtype","longdesc","poster","src","xlink:href"],F={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","srcset","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},Q=/^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,B=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;function H(t,e,n){if(0===t.length)return t;if(n&&"function"==typeof n)return n(t);for(var i=(new window.DOMParser).parseFromString(t,"text/html"),o=Object.keys(e),s=[].slice.call(i.body.querySelectorAll("*")),r=function(t,n){var i=s[t],r=i.nodeName.toLowerCase();if(-1===o.indexOf(i.nodeName.toLowerCase()))return i.parentNode.removeChild(i),"continue";var a=[].slice.call(i.attributes),l=[].concat(e["*"]||[],e[r]||[]);a.forEach((function(t){(function(t,e){var n=t.nodeName.toLowerCase();if(-1!==e.indexOf(n))return-1===q.indexOf(n)||Boolean(t.nodeValue.match(Q)||t.nodeValue.match(B));for(var i=e.filter((function(t){return t instanceof RegExp})),o=0,s=i.length;o<s;o++)if(n.match(i[o]))return!0;return!1})(t,l)||i.removeAttribute(t.nodeName)}))},a=0,l=s.length;a<l;a++)r(a);return i.body.innerHTML}var U="tooltip",M=e.fn[U],W=new RegExp("(^|\\s)bs-tooltip\\S+","g"),V=["sanitize","whiteList","sanitizeFn"],z={animation:"boolean",template:"string",title:"(string|element|function)",trigger:"string",delay:"(number|object)",html:"boolean",selector:"(string|boolean)",placement:"(string|function)",offset:"(number|string|function)",container:"(string|element|boolean)",fallbackPlacement:"(string|array)",boundary:"(string|element)",sanitize:"boolean",sanitizeFn:"(null|function)",whiteList:"object",popperConfig:"(null|object)"},K={AUTO:"auto",TOP:"top",RIGHT:"right",BOTTOM:"bottom",LEFT:"left"},X={animation:!0,template:'<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,selector:!1,placement:"top",offset:0,container:!1,fallbackPlacement:"flip",boundary:"scrollParent",sanitize:!0,sanitizeFn:null,whiteList:F,popperConfig:null},Y={HIDE:"hide.bs.tooltip",HIDDEN:"hidden.bs.tooltip",SHOW:"show.bs.tooltip",SHOWN:"shown.bs.tooltip",INSERTED:"inserted.bs.tooltip",CLICK:"click.bs.tooltip",FOCUSIN:"focusin.bs.tooltip",FOCUSOUT:"focusout.bs.tooltip",MOUSEENTER:"mouseenter.bs.tooltip",MOUSELEAVE:"mouseleave.bs.tooltip"},$=function(){function t(t,e){if("undefined"==typeof n)throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");this._isEnabled=!0,this._timeout=0,this._hoverState="",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners()}var i=t.prototype;return i.enable=function(){this._isEnabled=!0},i.disable=function(){this._isEnabled=!1},i.toggleEnabled=function(){this._isEnabled=!this._isEnabled},i.toggle=function(t){if(this._isEnabled)if(t){var n=this.constructor.DATA_KEY,i=e(t.currentTarget).data(n);i||(i=new this.constructor(t.currentTarget,this._getDelegateConfig()),e(t.currentTarget).data(n,i)),i._activeTrigger.click=!i._activeTrigger.click,i._isWithActiveTrigger()?i._enter(null,i):i._leave(null,i)}else{if(e(this.getTipElement()).hasClass("show"))return void this._leave(null,this);this._enter(null,this)}},i.dispose=function(){clearTimeout(this._timeout),e.removeData(this.element,this.constructor.DATA_KEY),e(this.element).off(this.constructor.EVENT_KEY),e(this.element).closest(".modal").off("hide.bs.modal",this._hideModalHandler),this.tip&&e(this.tip).remove(),this._isEnabled=null,this._timeout=null,this._hoverState=null,this._activeTrigger=null,this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},i.show=function(){var t=this;if("none"===e(this.element).css("display"))throw new Error("Please use show on visible elements");var i=e.Event(this.constructor.Event.SHOW);if(this.isWithContent()&&this._isEnabled){e(this.element).trigger(i);var o=c.findShadowRoot(this.element),s=e.contains(null!==o?o:this.element.ownerDocument.documentElement,this.element);if(i.isDefaultPrevented()||!s)return;var r=this.getTipElement(),a=c.getUID(this.constructor.NAME);r.setAttribute("id",a),this.element.setAttribute("aria-describedby",a),this.setContent(),this.config.animation&&e(r).addClass("fade");var l="function"==typeof this.config.placement?this.config.placement.call(this,r,this.element):this.config.placement,h=this._getAttachment(l);this.addAttachmentClass(h);var u=this._getContainer();e(r).data(this.constructor.DATA_KEY,this),e.contains(this.element.ownerDocument.documentElement,this.tip)||e(r).appendTo(u),e(this.element).trigger(this.constructor.Event.INSERTED),this._popper=new n(this.element,r,this._getPopperConfig(h)),e(r).addClass("show"),"ontouchstart"in document.documentElement&&e(document.body).children().on("mouseover",null,e.noop);var d=function(){t.config.animation&&t._fixTransition();var n=t._hoverState;t._hoverState=null,e(t.element).trigger(t.constructor.Event.SHOWN),"out"===n&&t._leave(null,t)};if(e(this.tip).hasClass("fade")){var f=c.getTransitionDurationFromElement(this.tip);e(this.tip).one(c.TRANSITION_END,d).emulateTransitionEnd(f)}else d()}},i.hide=function(t){var n=this,i=this.getTipElement(),o=e.Event(this.constructor.Event.HIDE),s=function(){"show"!==n._hoverState&&i.parentNode&&i.parentNode.removeChild(i),n._cleanTipClass(),n.element.removeAttribute("aria-describedby"),e(n.element).trigger(n.constructor.Event.HIDDEN),null!==n._popper&&n._popper.destroy(),t&&t()};if(e(this.element).trigger(o),!o.isDefaultPrevented()){if(e(i).removeClass("show"),"ontouchstart"in document.documentElement&&e(document.body).children().off("mouseover",null,e.noop),this._activeTrigger.click=!1,this._activeTrigger.focus=!1,this._activeTrigger.hover=!1,e(this.tip).hasClass("fade")){var r=c.getTransitionDurationFromElement(i);e(i).one(c.TRANSITION_END,s).emulateTransitionEnd(r)}else s();this._hoverState=""}},i.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},i.isWithContent=function(){return Boolean(this.getTitle())},i.addAttachmentClass=function(t){e(this.getTipElement()).addClass("bs-tooltip-"+t)},i.getTipElement=function(){return this.tip=this.tip||e(this.config.template)[0],this.tip},i.setContent=function(){var t=this.getTipElement();this.setElementContent(e(t.querySelectorAll(".tooltip-inner")),this.getTitle()),e(t).removeClass("fade show")},i.setElementContent=function(t,n){"object"!=typeof n||!n.nodeType&&!n.jquery?this.config.html?(this.config.sanitize&&(n=H(n,this.config.whiteList,this.config.sanitizeFn)),t.html(n)):t.text(n):this.config.html?e(n).parent().is(t)||t.empty().append(n):t.text(e(n).text())},i.getTitle=function(){var t=this.element.getAttribute("data-original-title");return t||(t="function"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},i._getPopperConfig=function(t){var e=this;return a(a({},{placement:t,modifiers:{offset:this._getOffset(),flip:{behavior:this.config.fallbackPlacement},arrow:{element:".arrow"},preventOverflow:{boundariesElement:this.config.boundary}},onCreate:function(t){t.originalPlacement!==t.placement&&e._handlePopperPlacementChange(t)},onUpdate:function(t){return e._handlePopperPlacementChange(t)}}),this.config.popperConfig)},i._getOffset=function(){var t=this,e={};return"function"==typeof this.config.offset?e.fn=function(e){return e.offsets=a(a({},e.offsets),t.config.offset(e.offsets,t.element)||{}),e}:e.offset=this.config.offset,e},i._getContainer=function(){return!1===this.config.container?document.body:c.isElement(this.config.container)?e(this.config.container):e(document).find(this.config.container)},i._getAttachment=function(t){return K[t.toUpperCase()]},i._setListeners=function(){var t=this;this.config.trigger.split(" ").forEach((function(n){if("click"===n)e(t.element).on(t.constructor.Event.CLICK,t.config.selector,(function(e){return t.toggle(e)}));else if("manual"!==n){var i="hover"===n?t.constructor.Event.MOUSEENTER:t.constructor.Event.FOCUSIN,o="hover"===n?t.constructor.Event.MOUSELEAVE:t.constructor.Event.FOCUSOUT;e(t.element).on(i,t.config.selector,(function(e){return t._enter(e)})).on(o,t.config.selector,(function(e){return t._leave(e)}))}})),this._hideModalHandler=function(){t.element&&t.hide()},e(this.element).closest(".modal").on("hide.bs.modal",this._hideModalHandler),this.config.selector?this.config=a(a({},this.config),{},{trigger:"manual",selector:""}):this._fixTitle()},i._fixTitle=function(){var t=typeof this.element.getAttribute("data-original-title");(this.element.getAttribute("title")||"string"!==t)&&(this.element.setAttribute("data-original-title",this.element.getAttribute("title")||""),this.element.setAttribute("title",""))},i._enter=function(t,n){var i=this.constructor.DATA_KEY;(n=n||e(t.currentTarget).data(i))||(n=new this.constructor(t.currentTarget,this._getDelegateConfig()),e(t.currentTarget).data(i,n)),t&&(n._activeTrigger["focusin"===t.type?"focus":"hover"]=!0),e(n.getTipElement()).hasClass("show")||"show"===n._hoverState?n._hoverState="show":(clearTimeout(n._timeout),n._hoverState="show",n.config.delay&&n.config.delay.show?n._timeout=setTimeout((function(){"show"===n._hoverState&&n.show()}),n.config.delay.show):n.show())},i._leave=function(t,n){var i=this.constructor.DATA_KEY;(n=n||e(t.currentTarget).data(i))||(n=new this.constructor(t.currentTarget,this._getDelegateConfig()),e(t.currentTarget).data(i,n)),t&&(n._activeTrigger["focusout"===t.type?"focus":"hover"]=!1),n._isWithActiveTrigger()||(clearTimeout(n._timeout),n._hoverState="out",n.config.delay&&n.config.delay.hide?n._timeout=setTimeout((function(){"out"===n._hoverState&&n.hide()}),n.config.delay.hide):n.hide())},i._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},i._getConfig=function(t){var n=e(this.element).data();return Object.keys(n).forEach((function(t){-1!==V.indexOf(t)&&delete n[t]})),"number"==typeof(t=a(a(a({},this.constructor.Default),n),"object"==typeof t&&t?t:{})).delay&&(t.delay={show:t.delay,hide:t.delay}),"number"==typeof t.title&&(t.title=t.title.toString()),"number"==typeof t.content&&(t.content=t.content.toString()),c.typeCheckConfig(U,t,this.constructor.DefaultType),t.sanitize&&(t.template=H(t.template,t.whiteList,t.sanitizeFn)),t},i._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},i._cleanTipClass=function(){var t=e(this.getTipElement()),n=t.attr("class").match(W);null!==n&&n.length&&t.removeClass(n.join(""))},i._handlePopperPlacementChange=function(t){this.tip=t.instance.popper,this._cleanTipClass(),this.addAttachmentClass(this._getAttachment(t.placement))},i._fixTransition=function(){var t=this.getTipElement(),n=this.config.animation;null===t.getAttribute("x-placement")&&(e(t).removeClass("fade"),this.config.animation=!1,this.hide(),this.show(),this.config.animation=n)},t._jQueryInterface=function(n){return this.each((function(){var i=e(this).data("bs.tooltip"),o="object"==typeof n&&n;if((i||!/dispose|hide/.test(n))&&(i||(i=new t(this,o),e(this).data("bs.tooltip",i)),"string"==typeof n)){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}}))},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"Default",get:function(){return X}},{key:"NAME",get:function(){return U}},{key:"DATA_KEY",get:function(){return"bs.tooltip"}},{key:"Event",get:function(){return Y}},{key:"EVENT_KEY",get:function(){return".bs.tooltip"}},{key:"DefaultType",get:function(){return z}}]),t}();e.fn[U]=$._jQueryInterface,e.fn[U].Constructor=$,e.fn[U].noConflict=function(){return e.fn[U]=M,$._jQueryInterface};var J="popover",G=e.fn[J],Z=new RegExp("(^|\\s)bs-popover\\S+","g"),tt=a(a({},$.Default),{},{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'}),et=a(a({},$.DefaultType),{},{content:"(string|element|function)"}),nt={HIDE:"hide.bs.popover",HIDDEN:"hidden.bs.popover",SHOW:"show.bs.popover",SHOWN:"shown.bs.popover",INSERTED:"inserted.bs.popover",CLICK:"click.bs.popover",FOCUSIN:"focusin.bs.popover",FOCUSOUT:"focusout.bs.popover",MOUSEENTER:"mouseenter.bs.popover",MOUSELEAVE:"mouseleave.bs.popover"},it=function(t){var n,i;function s(){return t.apply(this,arguments)||this}i=t,(n=s).prototype=Object.create(i.prototype),n.prototype.constructor=n,n.__proto__=i;var r=s.prototype;return r.isWithContent=function(){return this.getTitle()||this._getContent()},r.addAttachmentClass=function(t){e(this.getTipElement()).addClass("bs-popover-"+t)},r.getTipElement=function(){return this.tip=this.tip||e(this.config.template)[0],this.tip},r.setContent=function(){var t=e(this.getTipElement());this.setElementContent(t.find(".popover-header"),this.getTitle());var n=this._getContent();"function"==typeof n&&(n=n.call(this.element)),this.setElementContent(t.find(".popover-body"),n),t.removeClass("fade show")},r._getContent=function(){return this.element.getAttribute("data-content")||this.config.content},r._cleanTipClass=function(){var t=e(this.getTipElement()),n=t.attr("class").match(Z);null!==n&&n.length>0&&t.removeClass(n.join(""))},s._jQueryInterface=function(t){return this.each((function(){var n=e(this).data("bs.popover"),i="object"==typeof t?t:null;if((n||!/dispose|hide/.test(t))&&(n||(n=new s(this,i),e(this).data("bs.popover",n)),"string"==typeof t)){if("undefined"==typeof n[t])throw new TypeError('No method named "'+t+'"');n[t]()}}))},o(s,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"Default",get:function(){return tt}},{key:"NAME",get:function(){return J}},{key:"DATA_KEY",get:function(){return"bs.popover"}},{key:"Event",get:function(){return nt}},{key:"EVENT_KEY",get:function(){return".bs.popover"}},{key:"DefaultType",get:function(){return et}}]),s}($);e.fn[J]=it._jQueryInterface,e.fn[J].Constructor=it,e.fn[J].noConflict=function(){return e.fn[J]=G,it._jQueryInterface};var ot="scrollspy",st=e.fn[ot],rt={offset:10,method:"auto",target:""},at={offset:"number",method:"string",target:"(string|element)"},lt=function(){function t(t,n){var i=this;this._element=t,this._scrollElement="BODY"===t.tagName?window:t,this._config=this._getConfig(n),this._selector=this._config.target+" .nav-link,"+this._config.target+" .list-group-item,"+this._config.target+" .dropdown-item",this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,e(this._scrollElement).on("scroll.bs.scrollspy",(function(t){return i._process(t)})),this.refresh(),this._process()}var n=t.prototype;return n.refresh=function(){var t=this,n=this._scrollElement===this._scrollElement.window?"offset":"position",i="auto"===this._config.method?n:this._config.method,o="position"===i?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),[].slice.call(document.querySelectorAll(this._selector)).map((function(t){var n,s=c.getSelectorFromElement(t);if(s&&(n=document.querySelector(s)),n){var r=n.getBoundingClientRect();if(r.width||r.height)return[e(n)[i]().top+o,s]}return null})).filter((function(t){return t})).sort((function(t,e){return t[0]-e[0]})).forEach((function(e){t._offsets.push(e[0]),t._targets.push(e[1])}))},n.dispose=function(){e.removeData(this._element,"bs.scrollspy"),e(this._scrollElement).off(".bs.scrollspy"),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},n._getConfig=function(t){if("string"!=typeof(t=a(a({},rt),"object"==typeof t&&t?t:{})).target&&c.isElement(t.target)){var n=e(t.target).attr("id");n||(n=c.getUID(ot),e(t.target).attr("id",n)),t.target="#"+n}return c.typeCheckConfig(ot,t,at),t},n._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},n._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},n._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},n._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),t>=n){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&this._offsets[0]>0)return this._activeTarget=null,void this._clear();for(var o=this._offsets.length;o--;){this._activeTarget!==this._targets[o]&&t>=this._offsets[o]&&("undefined"==typeof this._offsets[o+1]||t<this._offsets[o+1])&&this._activate(this._targets[o])}}},n._activate=function(t){this._activeTarget=t,this._clear();var n=this._selector.split(",").map((function(e){return e+'[data-target="'+t+'"],'+e+'[href="'+t+'"]'})),i=e([].slice.call(document.querySelectorAll(n.join(","))));i.hasClass("dropdown-item")?(i.closest(".dropdown").find(".dropdown-toggle").addClass("active"),i.addClass("active")):(i.addClass("active"),i.parents(".nav, .list-group").prev(".nav-link, .list-group-item").addClass("active"),i.parents(".nav, .list-group").prev(".nav-item").children(".nav-link").addClass("active")),e(this._scrollElement).trigger("activate.bs.scrollspy",{relatedTarget:t})},n._clear=function(){[].slice.call(document.querySelectorAll(this._selector)).filter((function(t){return t.classList.contains("active")})).forEach((function(t){return t.classList.remove("active")}))},t._jQueryInterface=function(n){return this.each((function(){var i=e(this).data("bs.scrollspy");if(i||(i=new t(this,"object"==typeof n&&n),e(this).data("bs.scrollspy",i)),"string"==typeof n){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}}))},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"Default",get:function(){return rt}}]),t}();e(window).on("load.bs.scrollspy.data-api",(function(){for(var t=[].slice.call(document.querySelectorAll('[data-spy="scroll"]')),n=t.length;n--;){var i=e(t[n]);lt._jQueryInterface.call(i,i.data())}})),e.fn[ot]=lt._jQueryInterface,e.fn[ot].Constructor=lt,e.fn[ot].noConflict=function(){return e.fn[ot]=st,lt._jQueryInterface};var ct=e.fn.tab,ht=function(){function t(t){this._element=t}var n=t.prototype;return n.show=function(){var t=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&e(this._element).hasClass("active")||e(this._element).hasClass("disabled"))){var n,i,o=e(this._element).closest(".nav, .list-group")[0],s=c.getSelectorFromElement(this._element);if(o){var r="UL"===o.nodeName||"OL"===o.nodeName?"> li > .active":".active";i=(i=e.makeArray(e(o).find(r)))[i.length-1]}var a=e.Event("hide.bs.tab",{relatedTarget:this._element}),l=e.Event("show.bs.tab",{relatedTarget:i});if(i&&e(i).trigger(a),e(this._element).trigger(l),!l.isDefaultPrevented()&&!a.isDefaultPrevented()){s&&(n=document.querySelector(s)),this._activate(this._element,o);var h=function(){var n=e.Event("hidden.bs.tab",{relatedTarget:t._element}),o=e.Event("shown.bs.tab",{relatedTarget:i});e(i).trigger(n),e(t._element).trigger(o)};n?this._activate(n,n.parentNode,h):h()}}},n.dispose=function(){e.removeData(this._element,"bs.tab"),this._element=null},n._activate=function(t,n,i){var o=this,s=(!n||"UL"!==n.nodeName&&"OL"!==n.nodeName?e(n).children(".active"):e(n).find("> li > .active"))[0],r=i&&s&&e(s).hasClass("fade"),a=function(){return o._transitionComplete(t,s,i)};if(s&&r){var l=c.getTransitionDurationFromElement(s);e(s).removeClass("show").one(c.TRANSITION_END,a).emulateTransitionEnd(l)}else a()},n._transitionComplete=function(t,n,i){if(n){e(n).removeClass("active");var o=e(n.parentNode).find("> .dropdown-menu .active")[0];o&&e(o).removeClass("active"),"tab"===n.getAttribute("role")&&n.setAttribute("aria-selected",!1)}if(e(t).addClass("active"),"tab"===t.getAttribute("role")&&t.setAttribute("aria-selected",!0),c.reflow(t),t.classList.contains("fade")&&t.classList.add("show"),t.parentNode&&e(t.parentNode).hasClass("dropdown-menu")){var s=e(t).closest(".dropdown")[0];if(s){var r=[].slice.call(s.querySelectorAll(".dropdown-toggle"));e(r).addClass("active")}t.setAttribute("aria-expanded",!0)}i&&i()},t._jQueryInterface=function(n){return this.each((function(){var i=e(this),o=i.data("bs.tab");if(o||(o=new t(this),i.data("bs.tab",o)),"string"==typeof n){if("undefined"==typeof o[n])throw new TypeError('No method named "'+n+'"');o[n]()}}))},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}}]),t}();e(document).on("click.bs.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',(function(t){t.preventDefault(),ht._jQueryInterface.call(e(this),"show")})),e.fn.tab=ht._jQueryInterface,e.fn.tab.Constructor=ht,e.fn.tab.noConflict=function(){return e.fn.tab=ct,ht._jQueryInterface};var ut=e.fn.toast,dt={animation:"boolean",autohide:"boolean",delay:"number"},ft={animation:!0,autohide:!0,delay:500},gt=function(){function t(t,e){this._element=t,this._config=this._getConfig(e),this._timeout=null,this._setListeners()}var n=t.prototype;return n.show=function(){var t=this,n=e.Event("show.bs.toast");if(e(this._element).trigger(n),!n.isDefaultPrevented()){this._config.animation&&this._element.classList.add("fade");var i=function(){t._element.classList.remove("showing"),t._element.classList.add("show"),e(t._element).trigger("shown.bs.toast"),t._config.autohide&&(t._timeout=setTimeout((function(){t.hide()}),t._config.delay))};if(this._element.classList.remove("hide"),c.reflow(this._element),this._element.classList.add("showing"),this._config.animation){var o=c.getTransitionDurationFromElement(this._element);e(this._element).one(c.TRANSITION_END,i).emulateTransitionEnd(o)}else i()}},n.hide=function(){if(this._element.classList.contains("show")){var t=e.Event("hide.bs.toast");e(this._element).trigger(t),t.isDefaultPrevented()||this._close()}},n.dispose=function(){clearTimeout(this._timeout),this._timeout=null,this._element.classList.contains("show")&&this._element.classList.remove("show"),e(this._element).off("click.dismiss.bs.toast"),e.removeData(this._element,"bs.toast"),this._element=null,this._config=null},n._getConfig=function(t){return t=a(a(a({},ft),e(this._element).data()),"object"==typeof t&&t?t:{}),c.typeCheckConfig("toast",t,this.constructor.DefaultType),t},n._setListeners=function(){var t=this;e(this._element).on("click.dismiss.bs.toast",'[data-dismiss="toast"]',(function(){return t.hide()}))},n._close=function(){var t=this,n=function(){t._element.classList.add("hide"),e(t._element).trigger("hidden.bs.toast")};if(this._element.classList.remove("show"),this._config.animation){var i=c.getTransitionDurationFromElement(this._element);e(this._element).one(c.TRANSITION_END,n).emulateTransitionEnd(i)}else n()},t._jQueryInterface=function(n){return this.each((function(){var i=e(this),o=i.data("bs.toast");if(o||(o=new t(this,"object"==typeof n&&n),i.data("bs.toast",o)),"string"==typeof n){if("undefined"==typeof o[n])throw new TypeError('No method named "'+n+'"');o[n](this)}}))},o(t,null,[{key:"VERSION",get:function(){return"4.5.0"}},{key:"DefaultType",get:function(){return dt}},{key:"Default",get:function(){return ft}}]),t}();e.fn.toast=gt._jQueryInterface,e.fn.toast.Constructor=gt,e.fn.toast.noConflict=function(){return e.fn.toast=ut,gt._jQueryInterface},t.Alert=d,t.Button=g,t.Carousel=E,t.Collapse=D,t.Dropdown=j,t.Modal=R,t.Popover=it,t.Scrollspy=lt,t.Tab=ht,t.Toast=gt,t.Tooltip=$,t.Util=c,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=bootstrap.min.js.map!function(){function n(n){return n&&(n.ownerDocument||n.document||n).documentElement}function t(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}function e(n,t){return t>n?-1:n>t?1:n>=t?0:NaN}function r(n){return null===n?NaN:+n}function i(n){return!isNaN(n)}function u(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);i>r;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}function o(n){return n.length}function a(n){for(var t=1;n*t%1;)t*=10;return t}function l(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function c(){this._=Object.create(null)}function f(n){return(n+="")===bo||n[0]===_o?_o+n:n}function s(n){return(n+="")[0]===_o?n.slice(1):n}function h(n){return f(n)in this._}function p(n){return(n=f(n))in this._&&delete this._[n]}function g(){var n=[];for(var t in this._)n.push(s(t));return n}function v(){var n=0;for(var t in this._)++n;return n}function d(){for(var n in this._)return!1;return!0}function y(){this._=Object.create(null)}function m(n){return n}function M(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function x(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=wo.length;r>e;++e){var i=wo[e]+t;if(i in n)return i}}function b(){}function _(){}function w(n){function t(){for(var t,r=e,i=-1,u=r.length;++i<u;)(t=r[i].on)&&t.apply(this,arguments);return n}var e=[],r=new c;return t.on=function(t,i){var u,o=r.get(t);return arguments.length<2?o&&o.on:(o&&(o.on=null,e=e.slice(0,u=e.indexOf(o)).concat(e.slice(u+1)),r.remove(t)),i&&e.push(r.set(t,{on:i})),n)},t}function S(){ao.event.preventDefault()}function k(){for(var n,t=ao.event;n=t.sourceEvent;)t=n;return t}function N(n){for(var t=new _,e=0,r=arguments.length;++e<r;)t[arguments[e]]=w(t);return t.of=function(e,r){return function(i){try{var u=i.sourceEvent=ao.event;i.target=n,ao.event=i,t[i.type].apply(e,r)}finally{ao.event=u}}},t}function E(n){return ko(n,Co),n}function A(n){return"function"==typeof n?n:function(){return No(n,this)}}function C(n){return"function"==typeof n?n:function(){return Eo(n,this)}}function z(n,t){function e(){this.removeAttribute(n)}function r(){this.removeAttributeNS(n.space,n.local)}function i(){this.setAttribute(n,t)}function u(){this.setAttributeNS(n.space,n.local,t)}function o(){var e=t.apply(this,arguments);null==e?this.removeAttribute(n):this.setAttribute(n,e)}function a(){var e=t.apply(this,arguments);null==e?this.removeAttributeNS(n.space,n.local):this.setAttributeNS(n.space,n.local,e)}return n=ao.ns.qualify(n),null==t?n.local?r:e:"function"==typeof t?n.local?a:o:n.local?u:i}function L(n){return n.trim().replace(/\s+/g," ")}function q(n){return new RegExp("(?:^|\\s+)"+ao.requote(n)+"(?:\\s+|$)","g")}function T(n){return(n+"").trim().split(/^|\s+/)}function R(n,t){function e(){for(var e=-1;++e<i;)n[e](this,t)}function r(){for(var e=-1,r=t.apply(this,arguments);++e<i;)n[e](this,r)}n=T(n).map(D);var i=n.length;return"function"==typeof t?r:e}function D(n){var t=q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",L(i+" "+n))):e.setAttribute("class",L(i.replace(t," ")))}}function P(n,t,e){function r(){this.style.removeProperty(n)}function i(){this.style.setProperty(n,t,e)}function u(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}return null==t?r:"function"==typeof t?u:i}function U(n,t){function e(){delete this[n]}function r(){this[n]=t}function i(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}return null==t?e:"function"==typeof t?i:r}function j(n){function t(){var t=this.ownerDocument,e=this.namespaceURI;return e===zo&&t.documentElement.namespaceURI===zo?t.createElement(n):t.createElementNS(e,n)}function e(){return this.ownerDocument.createElementNS(n.space,n.local)}return"function"==typeof n?n:(n=ao.ns.qualify(n)).local?e:t}function F(){var n=this.parentNode;n&&n.removeChild(this)}function H(n){return{__data__:n}}function O(n){return function(){return Ao(this,n)}}function I(n){return arguments.length||(n=e),function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}function Y(n,t){for(var e=0,r=n.length;r>e;e++)for(var i,u=n[e],o=0,a=u.length;a>o;o++)(i=u[o])&&t(i,o,e);return n}function Z(n){return ko(n,qo),n}function V(n){var t,e;return function(r,i,u){var o,a=n[u].update,l=a.length;for(u!=e&&(e=u,t=0),i>=t&&(t=i+1);!(o=a[t])&&++t<l;);return o}}function X(n,t,e){function r(){var t=this[o];t&&(this.removeEventListener(n,t,t.$),delete this[o])}function i(){var i=l(t,co(arguments));r.call(this),this.addEventListener(n,this[o]=i,i.$=e),i._=t}function u(){var t,e=new RegExp("^__on([^.]+)"+ao.requote(n)+"$");for(var r in this)if(t=r.match(e)){var i=this[r];this.removeEventListener(t[1],i,i.$),delete this[r]}}var o="__on"+n,a=n.indexOf("."),l=$;a>0&&(n=n.slice(0,a));var c=To.get(n);return c&&(n=c,l=B),a?t?i:r:t?b:u}function $(n,t){return function(e){var r=ao.event;ao.event=e,t[0]=this.__data__;try{n.apply(this,t)}finally{ao.event=r}}}function B(n,t){var e=$(n,t);return function(n){var t=this,r=n.relatedTarget;r&&(r===t||8&r.compareDocumentPosition(t))||e.call(t,n)}}function W(e){var r=".dragsuppress-"+ ++Do,i="click"+r,u=ao.select(t(e)).on("touchmove"+r,S).on("dragstart"+r,S).on("selectstart"+r,S);if(null==Ro&&(Ro="onselectstart"in e?!1:x(e.style,"userSelect")),Ro){var o=n(e).style,a=o[Ro];o[Ro]="none"}return function(n){if(u.on(r,null),Ro&&(o[Ro]=a),n){var t=function(){u.on(i,null)};u.on(i,function(){S(),t()},!0),setTimeout(t,0)}}}function J(n,e){e.changedTouches&&(e=e.changedTouches[0]);var r=n.ownerSVGElement||n;if(r.createSVGPoint){var i=r.createSVGPoint();if(0>Po){var u=t(n);if(u.scrollX||u.scrollY){r=ao.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important");var o=r[0][0].getScreenCTM();Po=!(o.f||o.e),r.remove()}}return Po?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),i=i.matrixTransform(n.getScreenCTM().inverse()),[i.x,i.y]}var a=n.getBoundingClientRect();return[e.clientX-a.left-n.clientLeft,e.clientY-a.top-n.clientTop]}function G(){return ao.event.changedTouches[0].identifier}function K(n){return n>0?1:0>n?-1:0}function Q(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function nn(n){return n>1?0:-1>n?Fo:Math.acos(n)}function tn(n){return n>1?Io:-1>n?-Io:Math.asin(n)}function en(n){return((n=Math.exp(n))-1/n)/2}function rn(n){return((n=Math.exp(n))+1/n)/2}function un(n){return((n=Math.exp(2*n))-1)/(n+1)}function on(n){return(n=Math.sin(n/2))*n}function an(){}function ln(n,t,e){return this instanceof ln?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof ln?new ln(n.h,n.s,n.l):_n(""+n,wn,ln):new ln(n,t,e)}function cn(n,t,e){function r(n){return n>360?n-=360:0>n&&(n+=360),60>n?u+(o-u)*n/60:180>n?o:240>n?u+(o-u)*(240-n)/60:u}function i(n){return Math.round(255*r(n))}var u,o;return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:0>t?0:t>1?1:t,e=0>e?0:e>1?1:e,o=.5>=e?e*(1+t):e+t-e*t,u=2*e-o,new mn(i(n+120),i(n),i(n-120))}function fn(n,t,e){return this instanceof fn?(this.h=+n,this.c=+t,void(this.l=+e)):arguments.length<2?n instanceof fn?new fn(n.h,n.c,n.l):n instanceof hn?gn(n.l,n.a,n.b):gn((n=Sn((n=ao.rgb(n)).r,n.g,n.b)).l,n.a,n.b):new fn(n,t,e)}function sn(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new hn(e,Math.cos(n*=Yo)*t,Math.sin(n)*t)}function hn(n,t,e){return this instanceof hn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof hn?new hn(n.l,n.a,n.b):n instanceof fn?sn(n.h,n.c,n.l):Sn((n=mn(n)).r,n.g,n.b):new hn(n,t,e)}function pn(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return i=vn(i)*na,r=vn(r)*ta,u=vn(u)*ea,new mn(yn(3.2404542*i-1.5371385*r-.4985314*u),yn(-.969266*i+1.8760108*r+.041556*u),yn(.0556434*i-.2040259*r+1.0572252*u))}function gn(n,t,e){return n>0?new fn(Math.atan2(e,t)*Zo,Math.sqrt(t*t+e*e),n):new fn(NaN,NaN,n)}function vn(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function dn(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function yn(n){return Math.round(255*(.00304>=n?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function mn(n,t,e){return this instanceof mn?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof mn?new mn(n.r,n.g,n.b):_n(""+n,mn,cn):new mn(n,t,e)}function Mn(n){return new mn(n>>16,n>>8&255,255&n)}function xn(n){return Mn(n)+""}function bn(n){return 16>n?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function _n(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(Nn(i[0]),Nn(i[1]),Nn(i[2]))}return(u=ua.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o=o>>4|o,a=240&u,a=a>>4|a,l=15&u,l=l<<4|l):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function wn(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=.5>l?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(e>t?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&1>l?0:r),new ln(r,i,l)}function Sn(n,t,e){n=kn(n),t=kn(t),e=kn(e);var r=dn((.4124564*n+.3575761*t+.1804375*e)/na),i=dn((.2126729*n+.7151522*t+.072175*e)/ta),u=dn((.0193339*n+.119192*t+.9503041*e)/ea);return hn(116*i-16,500*(r-i),200*(i-u))}function kn(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function Nn(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}function En(n){return"function"==typeof n?n:function(){return n}}function An(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),Cn(t,e,n,r)}}function Cn(n,t,e,r){function i(){var n,t=l.status;if(!t&&Ln(l)||t>=200&&300>t||304===t){try{n=e.call(u,l)}catch(r){return void o.error.call(u,r)}o.load.call(u,n)}else o.error.call(u,l)}var u={},o=ao.dispatch("beforesend","progress","load","error"),a={},l=new XMLHttpRequest,c=null;return!this.XDomainRequest||"withCredentials"in l||!/^(http(s)?:)?\/\//.test(n)||(l=new XDomainRequest),"onload"in l?l.onload=l.onerror=i:l.onreadystatechange=function(){l.readyState>3&&i()},l.onprogress=function(n){var t=ao.event;ao.event=n;try{o.progress.call(u,l)}finally{ao.event=t}},u.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?a[n]:(null==t?delete a[n]:a[n]=t+"",u)},u.mimeType=function(n){return arguments.length?(t=null==n?null:n+"",u):t},u.responseType=function(n){return arguments.length?(c=n,u):c},u.response=function(n){return e=n,u},["get","post"].forEach(function(n){u[n]=function(){return u.send.apply(u,[n].concat(co(arguments)))}}),u.send=function(e,r,i){if(2===arguments.length&&"function"==typeof r&&(i=r,r=null),l.open(e,n,!0),null==t||"accept"in a||(a.accept=t+",*/*"),l.setRequestHeader)for(var f in a)l.setRequestHeader(f,a[f]);return null!=t&&l.overrideMimeType&&l.overrideMimeType(t),null!=c&&(l.responseType=c),null!=i&&u.on("error",i).on("load",function(n){i(null,n)}),o.beforesend.call(u,l),l.send(null==r?null:r),u},u.abort=function(){return l.abort(),u},ao.rebind(u,o,"on"),null==r?u:u.get(zn(r))}function zn(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}function Ln(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}function qn(n,t,e){var r=arguments.length;2>r&&(t=0),3>r&&(e=Date.now());var i=e+t,u={c:n,t:i,n:null};return aa?aa.n=u:oa=u,aa=u,la||(ca=clearTimeout(ca),la=1,fa(Tn)),u}function Tn(){var n=Rn(),t=Dn()-n;t>24?(isFinite(t)&&(clearTimeout(ca),ca=setTimeout(Tn,t)),la=0):(la=1,fa(Tn))}function Rn(){for(var n=Date.now(),t=oa;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Dn(){for(var n,t=oa,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:oa=t.n;return aa=n,e}function Pn(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}function Un(n,t){var e=Math.pow(10,3*xo(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}}function jn(n){var t=n.decimal,e=n.thousands,r=n.grouping,i=n.currency,u=r&&e?function(n,t){for(var i=n.length,u=[],o=0,a=r[0],l=0;i>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(i-=a,i+a)),!((l+=a+1)>t));)a=r[o=(o+1)%r.length];return u.reverse().join(e)}:m;return function(n){var e=ha.exec(n),r=e[1]||" ",o=e[2]||">",a=e[3]||"-",l=e[4]||"",c=e[5],f=+e[6],s=e[7],h=e[8],p=e[9],g=1,v="",d="",y=!1,m=!0;switch(h&&(h=+h.substring(1)),(c||"0"===r&&"="===o)&&(c=r="0",o="="),p){case"n":s=!0,p="g";break;case"%":g=100,d="%",p="f";break;case"p":g=100,d="%",p="r";break;case"b":case"o":case"x":case"X":"#"===l&&(v="0"+p.toLowerCase());case"c":m=!1;case"d":y=!0,h=0;break;case"s":g=-1,p="r"}"$"===l&&(v=i[0],d=i[1]),"r"!=p||h||(p="g"),null!=h&&("g"==p?h=Math.max(1,Math.min(21,h)):"e"!=p&&"f"!=p||(h=Math.max(0,Math.min(20,h)))),p=pa.get(p)||Fn;var M=c&&s;return function(n){var e=d;if(y&&n%1)return"";var i=0>n||0===n&&0>1/n?(n=-n,"-"):"-"===a?"":a;if(0>g){var l=ao.formatPrefix(n,h);n=l.scale(n),e=l.symbol+d}else n*=g;n=p(n,h);var x,b,_=n.lastIndexOf(".");if(0>_){var w=m?n.lastIndexOf("e"):-1;0>w?(x=n,b=""):(x=n.substring(0,w),b=n.substring(w))}else x=n.substring(0,_),b=t+n.substring(_+1);!c&&s&&(x=u(x,1/0));var S=v.length+x.length+b.length+(M?0:i.length),k=f>S?new Array(S=f-S+1).join(r):"";return M&&(x=u(k+x,k.length?f-b.length:1/0)),i+=v,n=x+b,("<"===o?i+n+k:">"===o?k+i+n:"^"===o?k.substring(0,S>>=1)+i+n+k.substring(S):i+(M?n:k+n))+e}}}function Fn(n){return n+""}function Hn(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}function On(n,t,e){function r(t){var e=n(t),r=u(e,1);return r-t>t-e?e:r}function i(e){return t(e=n(new va(e-1)),1),e}function u(n,e){return t(n=new va(+n),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;r>o;)e(o)%u||a.push(new Date(+o)),t(o,1);else for(;r>o;)a.push(new Date(+o)),t(o,1);return a}function a(n,t,e){try{va=Hn;var r=new Hn;return r._=n,o(r,t,e)}finally{va=Date}}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var l=n.utc=In(n);return l.floor=l,l.round=In(r),l.ceil=In(i),l.offset=In(u),l.range=a,n}function In(n){return function(t,e){try{va=Hn;var r=new Hn;return r._=t,n(r,e)._}finally{va=Date}}}function Yn(n){function t(n){function t(t){for(var e,i,u,o=[],a=-1,l=0;++a<r;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=ya[e=n.charAt(++a)])&&(e=n.charAt(++a)),(u=A[e])&&(e=u(t,null==i?"e"===e?" ":"0":i)),o.push(e),l=a+1);return o.push(n.slice(l,a)),o.join("")}var r=n.length;return t.parse=function(t){var r={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null},i=e(r,n,t,0);if(i!=t.length)return null;"p"in r&&(r.H=r.H%12+12*r.p);var u=null!=r.Z&&va!==Hn,o=new(u?Hn:va);return"j"in r?o.setFullYear(r.y,0,r.j):"W"in r||"U"in r?("w"in r||(r.w="W"in r?1:0),o.setFullYear(r.y,0,1),o.setFullYear(r.y,0,"W"in r?(r.w+6)%7+7*r.W-(o.getDay()+5)%7:r.w+7*r.U-(o.getDay()+6)%7)):o.setFullYear(r.y,r.m,r.d),o.setHours(r.H+(r.Z/100|0),r.M+r.Z%100,r.S,r.L),u?o._:o},t.toString=function(){return n},t}function e(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;l>a;){if(r>=c)return-1;if(i=t.charCodeAt(a++),37===i){if(o=t.charAt(a++),u=C[o in ya?t.charAt(a++):o],!u||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}function r(n,t,e){_.lastIndex=0;var r=_.exec(t.slice(e));return r?(n.w=w.get(r[0].toLowerCase()),e+r[0].length):-1}function i(n,t,e){x.lastIndex=0;var r=x.exec(t.slice(e));return r?(n.w=b.get(r[0].toLowerCase()),e+r[0].length):-1}function u(n,t,e){N.lastIndex=0;var r=N.exec(t.slice(e));return r?(n.m=E.get(r[0].toLowerCase()),e+r[0].length):-1}function o(n,t,e){S.lastIndex=0;var r=S.exec(t.slice(e));return r?(n.m=k.get(r[0].toLowerCase()),e+r[0].length):-1}function a(n,t,r){return e(n,A.c.toString(),t,r)}function l(n,t,r){return e(n,A.x.toString(),t,r)}function c(n,t,r){return e(n,A.X.toString(),t,r)}function f(n,t,e){var r=M.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)}var s=n.dateTime,h=n.date,p=n.time,g=n.periods,v=n.days,d=n.shortDays,y=n.months,m=n.shortMonths;t.utc=function(n){function e(n){try{va=Hn;var t=new va;return t._=n,r(t)}finally{va=Date}}var r=t(n);return e.parse=function(n){try{va=Hn;var t=r.parse(n);return t&&t._}finally{va=Date}},e.toString=r.toString,e},t.multi=t.utc.multi=ct;var M=ao.map(),x=Vn(v),b=Xn(v),_=Vn(d),w=Xn(d),S=Vn(y),k=Xn(y),N=Vn(m),E=Xn(m);g.forEach(function(n,t){M.set(n.toLowerCase(),t)});var A={a:function(n){return d[n.getDay()]},A:function(n){return v[n.getDay()]},b:function(n){return m[n.getMonth()]},B:function(n){return y[n.getMonth()]},c:t(s),d:function(n,t){return Zn(n.getDate(),t,2)},e:function(n,t){return Zn(n.getDate(),t,2)},H:function(n,t){return Zn(n.getHours(),t,2)},I:function(n,t){return Zn(n.getHours()%12||12,t,2)},j:function(n,t){return Zn(1+ga.dayOfYear(n),t,3)},L:function(n,t){return Zn(n.getMilliseconds(),t,3)},m:function(n,t){return Zn(n.getMonth()+1,t,2)},M:function(n,t){return Zn(n.getMinutes(),t,2)},p:function(n){return g[+(n.getHours()>=12)]},S:function(n,t){return Zn(n.getSeconds(),t,2)},U:function(n,t){return Zn(ga.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return Zn(ga.mondayOfYear(n),t,2)},x:t(h),X:t(p),y:function(n,t){return Zn(n.getFullYear()%100,t,2)},Y:function(n,t){return Zn(n.getFullYear()%1e4,t,4)},Z:at,"%":function(){return"%"}},C={a:r,A:i,b:u,B:o,c:a,d:tt,e:tt,H:rt,I:rt,j:et,L:ot,m:nt,M:it,p:f,S:ut,U:Bn,w:$n,W:Wn,x:l,X:c,y:Gn,Y:Jn,Z:Kn,"%":lt};return t}function Zn(n,t,e){var r=0>n?"-":"",i=(r?-n:n)+"",u=i.length;return r+(e>u?new Array(e-u+1).join(t)+i:i)}function Vn(n){return new RegExp("^(?:"+n.map(ao.requote).join("|")+")","i")}function Xn(n){for(var t=new c,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function $n(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Bn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function Wn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Jn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Gn(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.y=Qn(+r[0]),e+r[0].length):-1}function Kn(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Qn(n){return n+(n>68?1900:2e3)}function nt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function tt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function et(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function rt(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function it(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ut(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function ot(n,t,e){ma.lastIndex=0;var r=ma.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function at(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=xo(t)/60|0,i=xo(t)%60;return e+Zn(r,"0",2)+Zn(i,"0",2)}function lt(n,t,e){Ma.lastIndex=0;var r=Ma.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function ct(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}function ft(){}function st(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function ht(n,t){n&&wa.hasOwnProperty(n.type)&&wa[n.type](n,t)}function pt(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function gt(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)pt(n[e],t,1);t.polygonEnd()}function vt(){function n(n,t){n*=Yo,t=t*Yo/2+Fo/4;var e=n-r,o=e>=0?1:-1,a=o*e,l=Math.cos(t),c=Math.sin(t),f=u*c,s=i*l+f*Math.cos(a),h=f*o*Math.sin(a);ka.add(Math.atan2(h,s)),r=n,i=l,u=c}var t,e,r,i,u;Na.point=function(o,a){Na.point=n,r=(t=o)*Yo,i=Math.cos(a=(e=a)*Yo/2+Fo/4),u=Math.sin(a)},Na.lineEnd=function(){n(t,e)}}function dt(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function yt(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function mt(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Mt(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function xt(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function bt(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function _t(n){return[Math.atan2(n[1],n[0]),tn(n[2])]}function wt(n,t){return xo(n[0]-t[0])<Uo&&xo(n[1]-t[1])<Uo}function St(n,t){n*=Yo;var e=Math.cos(t*=Yo);kt(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function kt(n,t,e){++Ea,Ca+=(n-Ca)/Ea,za+=(t-za)/Ea,La+=(e-La)/Ea}function Nt(){function n(n,i){n*=Yo;var u=Math.cos(i*=Yo),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=e*l-r*a)*c+(c=r*o-t*l)*c+(c=t*a-e*o)*c),t*o+e*a+r*l);Aa+=c,qa+=c*(t+(t=o)),Ta+=c*(e+(e=a)),Ra+=c*(r+(r=l)),kt(t,e,r)}var t,e,r;ja.point=function(i,u){i*=Yo;var o=Math.cos(u*=Yo);t=o*Math.cos(i),e=o*Math.sin(i),r=Math.sin(u),ja.point=n,kt(t,e,r)}}function Et(){ja.point=St}function At(){function n(n,t){n*=Yo;var e=Math.cos(t*=Yo),o=e*Math.cos(n),a=e*Math.sin(n),l=Math.sin(t),c=i*l-u*a,f=u*o-r*l,s=r*a-i*o,h=Math.sqrt(c*c+f*f+s*s),p=r*o+i*a+u*l,g=h&&-nn(p)/h,v=Math.atan2(h,p);Da+=g*c,Pa+=g*f,Ua+=g*s,Aa+=v,qa+=v*(r+(r=o)),Ta+=v*(i+(i=a)),Ra+=v*(u+(u=l)),kt(r,i,u)}var t,e,r,i,u;ja.point=function(o,a){t=o,e=a,ja.point=n,o*=Yo;var l=Math.cos(a*=Yo);r=l*Math.cos(o),i=l*Math.sin(o),u=Math.sin(a),kt(r,i,u)},ja.lineEnd=function(){n(t,e),ja.lineEnd=Et,ja.point=St}}function Ct(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return e=t.invert(e,r),e&&n.invert(e[0],e[1])}),e}function zt(){return!0}function Lt(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(wt(e,r)){i.lineStart();for(var a=0;t>a;++a)i.point((e=n[a])[0],e[1]);return void i.lineEnd()}var l=new Tt(e,n,null,!0),c=new Tt(e,null,l,!1);l.o=c,u.push(l),o.push(c),l=new Tt(r,n,null,!1),c=new Tt(r,null,l,!0),l.o=c,u.push(l),o.push(c)}}),o.sort(t),qt(u),qt(o),u.length){for(var a=0,l=e,c=o.length;c>a;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(var a=0,c=f.length;c>a;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g){f=p.p.z;for(var a=f.length-1;a>=0;--a)i.point((s=f[a])[0],s[1])}else r(p.x,p.p.x,-1,i);p=p.p}p=p.o,f=p.z,g=!g}while(!p.v);i.lineEnd()}}}function qt(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function Tt(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Rt(n,t,e,r){return function(i,u){function o(t,e){var r=i(t,e);n(t=r[0],e=r[1])&&u.point(t,e)}function a(n,t){var e=i(n,t);d.point(e[0],e[1])}function l(){m.point=a,d.lineStart()}function c(){m.point=o,d.lineEnd()}function f(n,t){v.push([n,t]);var e=i(n,t);x.point(e[0],e[1])}function s(){x.lineStart(),v=[]}function h(){f(v[0][0],v[0][1]),x.lineEnd();var n,t=x.clean(),e=M.buffer(),r=e.length;if(v.pop(),g.push(v),v=null,r)if(1&t){n=e[0];var i,r=n.length-1,o=-1;if(r>0){for(b||(u.polygonStart(),b=!0),u.lineStart();++o<r;)u.point((i=n[o])[0],i[1]);u.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),p.push(e.filter(Dt))}var p,g,v,d=t(u),y=i.invert(r[0],r[1]),m={point:o,lineStart:l,lineEnd:c,polygonStart:function(){m.point=f,m.lineStart=s,m.lineEnd=h,p=[],g=[]},polygonEnd:function(){m.point=o,m.lineStart=l,m.lineEnd=c,p=ao.merge(p);var n=Ot(y,g);p.length?(b||(u.polygonStart(),b=!0),Lt(p,Ut,n,e,u)):n&&(b||(u.polygonStart(),b=!0),u.lineStart(),e(null,null,1,u),u.lineEnd()),b&&(u.polygonEnd(),b=!1),p=g=null},sphere:function(){u.polygonStart(),u.lineStart(),e(null,null,1,u),u.lineEnd(),u.polygonEnd()}},M=Pt(),x=t(M),b=!1;return m}}function Dt(n){return n.length>1}function Pt(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:b,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Ut(n,t){return((n=n.x)[0]<0?n[1]-Io-Uo:Io-n[1])-((t=t.x)[0]<0?t[1]-Io-Uo:Io-t[1])}function jt(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?Fo:-Fo,l=xo(u-e);xo(l-Fo)<Uo?(n.point(e,r=(r+o)/2>0?Io:-Io),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=Fo&&(xo(e-i)<Uo&&(e-=i*Uo),xo(u-a)<Uo&&(u-=a*Uo),r=Ft(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}}function Ft(n,t,e,r){var i,u,o=Math.sin(n-e);return xo(o)>Uo?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}function Ht(n,t,e,r){var i;if(null==n)i=e*Io,r.point(-Fo,i),r.point(0,i),r.point(Fo,i),r.point(Fo,0),r.point(Fo,-i),r.point(0,-i),r.point(-Fo,-i),r.point(-Fo,0),r.point(-Fo,i);else if(xo(n[0]-t[0])>Uo){var u=n[0]<t[0]?Fo:-Fo;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])}function Ot(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;ka.reset();for(var a=0,l=t.length;l>a;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+Fo/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0),n=c[d];var y=n[0],m=n[1]/2+Fo/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>Fo,k=g*M;if(ka.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Ho:b,S^h>=e^y>=e){var N=mt(dt(s),dt(n));bt(N);var E=mt(i,N);bt(E);var A=(S^b>=0?-1:1)*tn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(-Uo>u||Uo>u&&-Uo>ka)^1&o}function It(n){function t(n,t){return Math.cos(n)*Math.cos(t)>u}function e(n){var e,u,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=t(s,h),d=o?v?0:i(s,h):v?i(s+(0>s?Fo:-Fo),h):0;if(!e&&(c=l=v)&&n.lineStart(),v!==l&&(p=r(e,g),(wt(e,p)||wt(g,p))&&(g[0]+=Uo,g[1]+=Uo,v=t(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=r(g,e),n.point(p[0],p[1])):(p=r(e,g),n.point(p[0],p[1]),n.lineEnd()),e=p;else if(a&&e&&o^v){var y;d&u||!(y=r(g,e,!0))||(f=0,o?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||e&&wt(e,g)||n.point(g[0],g[1]),e=g,l=v,u=d},lineEnd:function(){l&&n.lineEnd(),e=null},clean:function(){return f|(c&&l)<<1}}}function r(n,t,e){var r=dt(n),i=dt(t),o=[1,0,0],a=mt(r,i),l=yt(a,a),c=a[0],f=l-c*c;if(!f)return!e&&n;var s=u*l/f,h=-u*c/f,p=mt(o,a),g=xt(o,s),v=xt(a,h);Mt(g,v);var d=p,y=yt(g,d),m=yt(d,d),M=y*y-m*(yt(g,g)-1);if(!(0>M)){var x=Math.sqrt(M),b=xt(d,(-y-x)/m);if(Mt(b,g),b=_t(b),!e)return b;var _,w=n[0],S=t[0],k=n[1],N=t[1];w>S&&(_=w,w=S,S=_);var E=S-w,A=xo(E-Fo)<Uo,C=A||Uo>E;if(!A&&k>N&&(_=k,k=N,N=_),C?A?k+N>0^b[1]<(xo(b[0]-w)<Uo?k:N):k<=b[1]&&b[1]<=N:E>Fo^(w<=b[0]&&b[0]<=S)){var z=xt(d,(-y+x)/m);return Mt(z,g),[b,_t(z)]}}}function i(t,e){var r=o?n:Fo-n,i=0;return-r>t?i|=1:t>r&&(i|=2),-r>e?i|=4:e>r&&(i|=8),i}var u=Math.cos(n),o=u>0,a=xo(u)>Uo,l=ve(n,6*Yo);return Rt(t,e,l,o?[0,-n]:[-Fo,n-Fo])}function Yt(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=a.x,s=a.y,h=0,p=1,g=f-l,v=s-c;if(u=n-l,g||!(u>0)){if(u/=g,0>g){if(h>u)return;p>u&&(p=u)}else if(g>0){if(u>p)return;u>h&&(h=u)}if(u=e-l,g||!(0>u)){if(u/=g,0>g){if(u>p)return;u>h&&(h=u)}else if(g>0){if(h>u)return;p>u&&(p=u)}if(u=t-c,v||!(u>0)){if(u/=v,0>v){if(h>u)return;p>u&&(p=u)}else if(v>0){if(u>p)return;u>h&&(h=u)}if(u=r-c,v||!(0>u)){if(u/=v,0>v){if(u>p)return;u>h&&(h=u)}else if(v>0){if(h>u)return;p>u&&(p=u)}return h>0&&(i.a={x:l+h*g,y:c+h*v}),1>p&&(i.b={x:l+p*g,y:c+p*v}),i}}}}}}function Zt(n,t,e,r){function i(r,i){return xo(r[0]-n)<Uo?i>0?0:3:xo(r[0]-e)<Uo?i>0?2:1:xo(r[1]-t)<Uo?i>0?1:0:i>0?3:2}function u(n,t){return o(n.x,t.x)}function o(n,t){var e=i(n,1),r=i(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}return function(a){function l(n){for(var t=0,e=d.length,r=n[1],i=0;e>i;++i)for(var u,o=1,a=d[i],l=a.length,c=a[0];l>o;++o)u=a[o],c[1]<=r?u[1]>r&&Q(c,u,n)>0&&++t:u[1]<=r&&Q(c,u,n)<0&&--t,c=u;return 0!==t}function c(u,a,l,c){var f=0,s=0;if(null==u||(f=i(u,l))!==(s=i(a,l))||o(u,a)<0^l>0){do c.point(0===f||3===f?n:e,f>1?r:t);while((f=(f+l+4)%4)!==s)}else c.point(a[0],a[1])}function f(i,u){return i>=n&&e>=i&&u>=t&&r>=u}function s(n,t){f(n,t)&&a.point(n,t)}function h(){C.point=g,d&&d.push(y=[]),S=!0,w=!1,b=_=NaN}function p(){v&&(g(m,M),x&&w&&E.rejoin(),v.push(E.buffer())),C.point=s,w&&a.lineEnd()}function g(n,t){n=Math.max(-Ha,Math.min(Ha,n)),t=Math.max(-Ha,Math.min(Ha,t));var e=f(n,t);if(d&&y.push([n,t]),S)m=n,M=t,x=e,S=!1,e&&(a.lineStart(),a.point(n,t));else if(e&&w)a.point(n,t);else{var r={a:{x:b,y:_},b:{x:n,y:t}};A(r)?(w||(a.lineStart(),a.point(r.a.x,r.a.y)),a.point(r.b.x,r.b.y),e||a.lineEnd(),k=!1):e&&(a.lineStart(),a.point(n,t),k=!1)}b=n,_=t,w=e}var v,d,y,m,M,x,b,_,w,S,k,N=a,E=Pt(),A=Yt(n,t,e,r),C={point:s,lineStart:h,lineEnd:p,polygonStart:function(){a=E,v=[],d=[],k=!0},polygonEnd:function(){a=N,v=ao.merge(v);var t=l([n,r]),e=k&&t,i=v.length;(e||i)&&(a.polygonStart(),e&&(a.lineStart(),c(null,null,1,a),a.lineEnd()),i&&Lt(v,u,t,c,a),a.polygonEnd()),v=d=y=null}};return C}}function Vt(n){var t=0,e=Fo/3,r=ae(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*Fo/180,e=n[1]*Fo/180):[t/Fo*180,e/Fo*180]},i}function Xt(n,t){function e(n,t){var e=Math.sqrt(u-2*i*Math.sin(t))/i;return[e*Math.sin(n*=i),o-e*Math.cos(n)]}var r=Math.sin(n),i=(r+Math.sin(t))/2,u=1+r*(2*i-r),o=Math.sqrt(u)/i;return e.invert=function(n,t){var e=o-t;return[Math.atan2(n,e)/i,tn((u-(n*n+e*e)*i*i)/(2*i))]},e}function $t(){function n(n,t){Ia+=i*n-r*t,r=n,i=t}var t,e,r,i;$a.point=function(u,o){$a.point=n,t=r=u,e=i=o},$a.lineEnd=function(){n(t,e)}}function Bt(n,t){Ya>n&&(Ya=n),n>Va&&(Va=n),Za>t&&(Za=t),t>Xa&&(Xa=t)}function Wt(){function n(n,t){o.push("M",n,",",t,u)}function t(n,t){o.push("M",n,",",t),a.point=e}function e(n,t){o.push("L",n,",",t)}function r(){a.point=n}function i(){o.push("Z")}var u=Jt(4.5),o=[],a={point:n,lineStart:function(){a.point=t},lineEnd:r,polygonStart:function(){a.lineEnd=i},polygonEnd:function(){a.lineEnd=r,a.point=n},pointRadius:function(n){return u=Jt(n),a},result:function(){if(o.length){var n=o.join("");return o=[],n}}};return a}function Jt(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}function Gt(n,t){Ca+=n,za+=t,++La}function Kt(){function n(n,r){var i=n-t,u=r-e,o=Math.sqrt(i*i+u*u);qa+=o*(t+n)/2,Ta+=o*(e+r)/2,Ra+=o,Gt(t=n,e=r)}var t,e;Wa.point=function(r,i){Wa.point=n,Gt(t=r,e=i)}}function Qt(){Wa.point=Gt}function ne(){function n(n,t){var e=n-r,u=t-i,o=Math.sqrt(e*e+u*u);qa+=o*(r+n)/2,Ta+=o*(i+t)/2,Ra+=o,o=i*n-r*t,Da+=o*(r+n),Pa+=o*(i+t),Ua+=3*o,Gt(r=n,i=t)}var t,e,r,i;Wa.point=function(u,o){Wa.point=n,Gt(t=r=u,e=i=o)},Wa.lineEnd=function(){n(t,e)}}function te(n){function t(t,e){n.moveTo(t+o,e),n.arc(t,e,o,0,Ho)}function e(t,e){n.moveTo(t,e),a.point=r}function r(t,e){n.lineTo(t,e)}function i(){a.point=t}function u(){n.closePath()}var o=4.5,a={point:t,lineStart:function(){a.point=e},lineEnd:i,polygonStart:function(){a.lineEnd=u},polygonEnd:function(){a.lineEnd=i,a.point=t},pointRadius:function(n){return o=n,a},result:b};return a}function ee(n){function t(n){return(a?r:e)(n)}function e(t){return ue(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})}function r(t){function e(e,r){e=n(e,r),t.point(e[0],e[1])}function r(){M=NaN,S.point=u,t.lineStart()}function u(e,r){var u=dt([e,r]),o=n(e,r);i(M,x,m,b,_,w,M=o[0],x=o[1],m=e,b=u[0],_=u[1],w=u[2],a,t),t.point(M,x)}function o(){S.point=e,t.lineEnd()}function l(){
r(),S.point=c,S.lineEnd=f}function c(n,t){u(s=n,h=t),p=M,g=x,v=b,d=_,y=w,S.point=u}function f(){i(M,x,m,b,_,w,p,g,s,v,d,y,a,t),S.lineEnd=o,o()}var s,h,p,g,v,d,y,m,M,x,b,_,w,S={point:e,lineStart:r,lineEnd:o,polygonStart:function(){t.polygonStart(),S.lineStart=l},polygonEnd:function(){t.polygonEnd(),S.lineStart=r}};return S}function i(t,e,r,a,l,c,f,s,h,p,g,v,d,y){var m=f-t,M=s-e,x=m*m+M*M;if(x>4*u&&d--){var b=a+p,_=l+g,w=c+v,S=Math.sqrt(b*b+_*_+w*w),k=Math.asin(w/=S),N=xo(xo(w)-1)<Uo||xo(r-h)<Uo?(r+h)/2:Math.atan2(_,b),E=n(N,k),A=E[0],C=E[1],z=A-t,L=C-e,q=M*z-m*L;(q*q/x>u||xo((m*z+M*L)/x-.5)>.3||o>a*p+l*g+c*v)&&(i(t,e,r,a,l,c,A,C,N,b/=S,_/=S,w,d,y),y.point(A,C),i(A,C,N,b,_,w,f,s,h,p,g,v,d,y))}}var u=.5,o=Math.cos(30*Yo),a=16;return t.precision=function(n){return arguments.length?(a=(u=n*n)>0&&16,t):Math.sqrt(u)},t}function re(n){var t=ee(function(t,e){return n([t*Zo,e*Zo])});return function(n){return le(t(n))}}function ie(n){this.stream=n}function ue(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function oe(n){return ae(function(){return n})()}function ae(n){function t(n){return n=a(n[0]*Yo,n[1]*Yo),[n[0]*h+l,c-n[1]*h]}function e(n){return n=a.invert((n[0]-l)/h,(c-n[1])/h),n&&[n[0]*Zo,n[1]*Zo]}function r(){a=Ct(o=se(y,M,x),u);var n=u(v,d);return l=p-n[0]*h,c=g+n[1]*h,i()}function i(){return f&&(f.valid=!1,f=null),t}var u,o,a,l,c,f,s=ee(function(n,t){return n=u(n,t),[n[0]*h+l,c-n[1]*h]}),h=150,p=480,g=250,v=0,d=0,y=0,M=0,x=0,b=Fa,_=m,w=null,S=null;return t.stream=function(n){return f&&(f.valid=!1),f=le(b(o,s(_(n)))),f.valid=!0,f},t.clipAngle=function(n){return arguments.length?(b=null==n?(w=n,Fa):It((w=+n)*Yo),i()):w},t.clipExtent=function(n){return arguments.length?(S=n,_=n?Zt(n[0][0],n[0][1],n[1][0],n[1][1]):m,i()):S},t.scale=function(n){return arguments.length?(h=+n,r()):h},t.translate=function(n){return arguments.length?(p=+n[0],g=+n[1],r()):[p,g]},t.center=function(n){return arguments.length?(v=n[0]%360*Yo,d=n[1]%360*Yo,r()):[v*Zo,d*Zo]},t.rotate=function(n){return arguments.length?(y=n[0]%360*Yo,M=n[1]%360*Yo,x=n.length>2?n[2]%360*Yo:0,r()):[y*Zo,M*Zo,x*Zo]},ao.rebind(t,s,"precision"),function(){return u=n.apply(this,arguments),t.invert=u.invert&&e,r()}}function le(n){return ue(n,function(t,e){n.point(t*Yo,e*Yo)})}function ce(n,t){return[n,t]}function fe(n,t){return[n>Fo?n-Ho:-Fo>n?n+Ho:n,t]}function se(n,t,e){return n?t||e?Ct(pe(n),ge(t,e)):pe(n):t||e?ge(t,e):fe}function he(n){return function(t,e){return t+=n,[t>Fo?t-Ho:-Fo>t?t+Ho:t,e]}}function pe(n){var t=he(n);return t.invert=he(-n),t}function ge(n,t){function e(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*r+a*i;return[Math.atan2(l*u-f*o,a*r-c*i),tn(f*u+l*o)]}var r=Math.cos(n),i=Math.sin(n),u=Math.cos(t),o=Math.sin(t);return e.invert=function(n,t){var e=Math.cos(t),a=Math.cos(n)*e,l=Math.sin(n)*e,c=Math.sin(t),f=c*u-l*o;return[Math.atan2(l*u+c*o,a*r+f*i),tn(f*r-a*i)]},e}function ve(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=de(e,i),u=de(e,u),(o>0?u>i:i>u)&&(i+=o*Ho)):(i=n+o*Ho,u=n-.5*l);for(var c,f=i;o>0?f>u:u>f;f-=l)a.point((c=_t([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function de(n,t){var e=dt(t);e[0]-=n,bt(e);var r=nn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-Uo)%(2*Math.PI)}function ye(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[n,t]})}}function me(n,t,e){var r=ao.range(n,t-Uo,e).concat(t);return function(n){return r.map(function(t){return[t,n]})}}function Me(n){return n.source}function xe(n){return n.target}function be(n,t,e,r){var i=Math.cos(t),u=Math.sin(t),o=Math.cos(r),a=Math.sin(r),l=i*Math.cos(n),c=i*Math.sin(n),f=o*Math.cos(e),s=o*Math.sin(e),h=2*Math.asin(Math.sqrt(on(r-t)+i*o*on(e-n))),p=1/Math.sin(h),g=h?function(n){var t=Math.sin(n*=h)*p,e=Math.sin(h-n)*p,r=e*l+t*f,i=e*c+t*s,o=e*u+t*a;return[Math.atan2(i,r)*Zo,Math.atan2(o,Math.sqrt(r*r+i*i))*Zo]}:function(){return[n*Zo,t*Zo]};return g.distance=h,g}function _e(){function n(n,i){var u=Math.sin(i*=Yo),o=Math.cos(i),a=xo((n*=Yo)-t),l=Math.cos(a);Ja+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=r*u-e*o*l)*a),e*u+r*o*l),t=n,e=u,r=o}var t,e,r;Ga.point=function(i,u){t=i*Yo,e=Math.sin(u*=Yo),r=Math.cos(u),Ga.point=n},Ga.lineEnd=function(){Ga.point=Ga.lineEnd=b}}function we(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}function Se(n,t){function e(n,t){o>0?-Io+Uo>t&&(t=-Io+Uo):t>Io-Uo&&(t=Io-Uo);var e=o/Math.pow(i(t),u);return[e*Math.sin(u*n),o-e*Math.cos(u*n)]}var r=Math.cos(n),i=function(n){return Math.tan(Fo/4+n/2)},u=n===t?Math.sin(n):Math.log(r/Math.cos(t))/Math.log(i(t)/i(n)),o=r*Math.pow(i(n),u)/u;return u?(e.invert=function(n,t){var e=o-t,r=K(u)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/u,2*Math.atan(Math.pow(o/r,1/u))-Io]},e):Ne}function ke(n,t){function e(n,t){var e=u-t;return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}var r=Math.cos(n),i=n===t?Math.sin(n):(r-Math.cos(t))/(t-n),u=r/i+n;return xo(i)<Uo?ce:(e.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/i,u-K(i)*Math.sqrt(n*n+e*e)]},e)}function Ne(n,t){return[n,Math.log(Math.tan(Fo/4+t/2))]}function Ee(n){var t,e=oe(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=Fo*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}function Ae(n,t){return[Math.log(Math.tan(Fo/4+t/2)),-n]}function Ce(n){return n[0]}function ze(n){return n[1]}function Le(n){for(var t=n.length,e=[0,1],r=2,i=2;t>i;i++){for(;r>1&&Q(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function qe(n,t){return n[0]-t[0]||n[1]-t[1]}function Te(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function Re(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function De(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}function Pe(){rr(this),this.edge=this.site=this.circle=null}function Ue(n){var t=cl.pop()||new Pe;return t.site=n,t}function je(n){Be(n),ol.remove(n),cl.push(n),rr(n)}function Fe(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];je(n);for(var l=u;l.circle&&xo(e-l.circle.x)<Uo&&xo(r-l.circle.cy)<Uo;)u=l.P,a.unshift(l),je(l),l=u;a.unshift(l),Be(l);for(var c=o;c.circle&&xo(e-c.circle.x)<Uo&&xo(r-c.circle.cy)<Uo;)o=c.N,a.push(c),je(c),c=o;a.push(c),Be(c);var f,s=a.length;for(f=1;s>f;++f)c=a[f],l=a[f-1],nr(c.edge,l.site,c.site,i);l=a[0],c=a[s-1],c.edge=Ke(l.site,c.site,null,i),$e(l),$e(c)}function He(n){for(var t,e,r,i,u=n.x,o=n.y,a=ol._;a;)if(r=Oe(a,o)-u,r>Uo)a=a.L;else{if(i=u-Ie(a,o),!(i>Uo)){r>-Uo?(t=a.P,e=a):i>-Uo?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=Ue(n);if(ol.insert(t,l),t||e){if(t===e)return Be(t),e=Ue(t.site),ol.insert(l,e),l.edge=e.edge=Ke(t.site,l.site),$e(t),void $e(e);if(!e)return void(l.edge=Ke(t.site,l.site));Be(t),Be(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};nr(e.edge,c,g,x),l.edge=Ke(c,n,null,x),e.edge=Ke(n,g,null,x),$e(t),$e(e)}}function Oe(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-(1/0);e=o.site;var a=e.x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function Ie(n,t){var e=n.N;if(e)return Oe(e,t);var r=n.site;return r.y===t?r.x:1/0}function Ye(n){this.site=n,this.edges=[]}function Ze(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ul,d=v.length;d--;)if(u=v[d],u&&u.prepare())for(a=u.edges,l=a.length,o=0;l>o;)f=a[o].end(),r=f.x,i=f.y,c=a[++o%l].start(),t=c.x,e=c.y,(xo(r-t)>Uo||xo(i-e)>Uo)&&(a.splice(o,0,new tr(Qe(u.site,f,xo(r-s)<Uo&&g-i>Uo?{x:s,y:xo(t-s)<Uo?e:g}:xo(i-g)<Uo&&h-r>Uo?{x:xo(e-g)<Uo?t:h,y:g}:xo(r-h)<Uo&&i-p>Uo?{x:h,y:xo(t-h)<Uo?e:p}:xo(i-p)<Uo&&r-s>Uo?{x:xo(e-p)<Uo?t:s,y:p}:null),u.site,null)),++l)}function Ve(n,t){return t.angle-n.angle}function Xe(){rr(this),this.x=this.y=this.arc=this.site=this.cy=null}function $e(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=u.y-a,h=2*(l*s-c*f);if(!(h>=-jo)){var p=l*l+c*c,g=f*f+s*s,v=(s*p-c*g)/h,d=(l*g-f*p)/h,s=d+a,y=fl.pop()||new Xe;y.arc=n,y.site=i,y.x=v+o,y.y=s+Math.sqrt(v*v+d*d),y.cy=s,n.circle=y;for(var m=null,M=ll._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}ll.insert(m,y),m||(al=y)}}}}function Be(n){var t=n.circle;t&&(t.P||(al=t.N),ll.remove(t),fl.push(t),rr(t),n.circle=null)}function We(n){for(var t,e=il,r=Yt(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)t=e[i],(!Je(t,n)||!r(t)||xo(t.a.x-t.b.x)<Uo&&xo(t.a.y-t.b.y)<Uo)&&(t.a=t.b=null,e.splice(i,1))}function Je(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(o>d||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(r=(h-g)/(v-p),i=y-r*d,-1>r||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(v>p){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Ge(n,t){this.l=n,this.r=t,this.a=this.b=null}function Ke(n,t,e,r){var i=new Ge(n,t);return il.push(i),e&&nr(i,n,t,e),r&&nr(i,t,n,r),ul[n.i].edges.push(new tr(i,n,t)),ul[t.i].edges.push(new tr(i,t,n)),i}function Qe(n,t,e){var r=new Ge(n,null);return r.a=t,r.b=e,il.push(r),r}function nr(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function tr(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function er(){this._=null}function rr(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function ir(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function ur(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function or(n){for(;n.L;)n=n.L;return n}function ar(n,t){var e,r,i,u=n.sort(lr).pop();for(il=[],ul=new Array(n.length),ol=new er,ll=new er;;)if(i=al,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ul[u.i]=new Ye(u),He(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;Fe(i.arc)}t&&(We(t),Ze(t));var o={cells:ul,edges:il};return ol=ll=il=ul=null,o}function lr(n,t){return t.y-n.y||t.x-n.x}function cr(n,t,e){return(n.x-e.x)*(t.y-n.y)-(n.x-t.x)*(e.y-n.y)}function fr(n){return n.x}function sr(n){return n.y}function hr(){return{leaf:!0,nodes:[],point:null,x:null,y:null}}function pr(n,t,e,r,i,u){if(!n(t,e,r,i,u)){var o=.5*(e+i),a=.5*(r+u),l=t.nodes;l[0]&&pr(n,l[0],e,r,o,a),l[1]&&pr(n,l[1],o,r,i,a),l[2]&&pr(n,l[2],e,a,o,u),l[3]&&pr(n,l[3],o,a,i,u)}}function gr(n,t,e,r,i,u,o){var a,l=1/0;return function c(n,f,s,h,p){if(!(f>u||s>o||r>h||i>p)){if(g=n.point){var g,v=t-n.x,d=e-n.y,y=v*v+d*d;if(l>y){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=n.nodes,x=.5*(f+h),b=.5*(s+p),_=t>=x,w=e>=b,S=w<<1|_,k=S+4;k>S;++S)if(n=M[3&S])switch(3&S){case 0:c(n,f,s,x,b);break;case 1:c(n,x,s,h,b);break;case 2:c(n,f,b,x,p);break;case 3:c(n,x,b,h,p)}}}(n,r,i,u,o),a}function vr(n,t){n=ao.rgb(n),t=ao.rgb(t);var e=n.r,r=n.g,i=n.b,u=t.r-e,o=t.g-r,a=t.b-i;return function(n){return"#"+bn(Math.round(e+u*n))+bn(Math.round(r+o*n))+bn(Math.round(i+a*n))}}function dr(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Mr(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function yr(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function mr(n,t){var e,r,i,u=hl.lastIndex=pl.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=hl.exec(n))&&(r=pl.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:yr(e,r)})),u=pl.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;t>r;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}function Mr(n,t){for(var e,r=ao.interpolators.length;--r>=0&&!(e=ao.interpolators[r](n,t)););return e}function xr(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;a>e;++e)r.push(Mr(n[e],t[e]));for(;u>e;++e)i[e]=n[e];for(;o>e;++e)i[e]=t[e];return function(n){for(e=0;a>e;++e)i[e]=r[e](n);return i}}function br(n){return function(t){return 0>=t?0:t>=1?1:n(t)}}function _r(n){return function(t){return 1-n(1-t)}}function wr(n){return function(t){return.5*(.5>t?n(2*t):2-n(2-2*t))}}function Sr(n){return n*n}function kr(n){return n*n*n}function Nr(n){if(0>=n)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(.5>n?e:3*(n-t)+e-.75)}function Er(n){return function(t){return Math.pow(t,n)}}function Ar(n){return 1-Math.cos(n*Io)}function Cr(n){return Math.pow(2,10*(n-1))}function zr(n){return 1-Math.sqrt(1-n*n)}function Lr(n,t){var e;return arguments.length<2&&(t=.45),arguments.length?e=t/Ho*Math.asin(1/n):(n=1,e=t/4),function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Ho/t)}}function qr(n){return n||(n=1.70158),function(t){return t*t*((n+1)*t-n)}}function Tr(n){return 1/2.75>n?7.5625*n*n:2/2.75>n?7.5625*(n-=1.5/2.75)*n+.75:2.5/2.75>n?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function Rr(n,t){n=ao.hcl(n),t=ao.hcl(t);var e=n.h,r=n.c,i=n.l,u=t.h-e,o=t.c-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.c:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return sn(e+u*n,r+o*n,i+a*n)+""}}function Dr(n,t){n=ao.hsl(n),t=ao.hsl(t);var e=n.h,r=n.s,i=n.l,u=t.h-e,o=t.s-r,a=t.l-i;return isNaN(o)&&(o=0,r=isNaN(r)?t.s:r),isNaN(u)?(u=0,e=isNaN(e)?t.h:e):u>180?u-=360:-180>u&&(u+=360),function(n){return cn(e+u*n,r+o*n,i+a*n)+""}}function Pr(n,t){n=ao.lab(n),t=ao.lab(t);var e=n.l,r=n.a,i=n.b,u=t.l-e,o=t.a-r,a=t.b-i;return function(n){return pn(e+u*n,r+o*n,i+a*n)+""}}function Ur(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function jr(n){var t=[n.a,n.b],e=[n.c,n.d],r=Hr(t),i=Fr(t,e),u=Hr(Or(e,t,-i))||0;t[0]*e[1]<e[0]*t[1]&&(t[0]*=-1,t[1]*=-1,r*=-1,i*=-1),this.rotate=(r?Math.atan2(t[1],t[0]):Math.atan2(-e[0],e[1]))*Zo,this.translate=[n.e,n.f],this.scale=[r,u],this.skew=u?Math.atan2(i,u)*Zo:0}function Fr(n,t){return n[0]*t[0]+n[1]*t[1]}function Hr(n){var t=Math.sqrt(Fr(n,n));return t&&(n[0]/=t,n[1]/=t),t}function Or(n,t,e){return n[0]+=e*t[0],n[1]+=e*t[1],n}function Ir(n){return n.length?n.pop()+",":""}function Yr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}function Zr(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(Ir(e)+"rotate(",null,")")-2,x:yr(n,t)})):t&&e.push(Ir(e)+"rotate("+t+")")}function Vr(n,t,e,r){n!==t?r.push({i:e.push(Ir(e)+"skewX(",null,")")-2,x:yr(n,t)}):t&&e.push(Ir(e)+"skewX("+t+")")}function Xr(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(Ir(e)+"scale(",null,",",null,")");r.push({i:i-4,x:yr(n[0],t[0])},{i:i-2,x:yr(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(Ir(e)+"scale("+t+")")}function $r(n,t){var e=[],r=[];return n=ao.transform(n),t=ao.transform(t),Yr(n.translate,t.translate,e,r),Zr(n.rotate,t.rotate,e,r),Vr(n.skew,t.skew,e,r),Xr(n.scale,t.scale,e,r),n=t=null,function(n){for(var t,i=-1,u=r.length;++i<u;)e[(t=r[i]).i]=t.x(n);return e.join("")}}function Br(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function Wr(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function Jr(n){for(var t=n.source,e=n.target,r=Kr(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function Gr(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function Kr(n,t){if(n===t)return n;for(var e=Gr(n),r=Gr(t),i=e.pop(),u=r.pop(),o=null;i===u;)o=i,i=e.pop(),u=r.pop();return o}function Qr(n){n.fixed|=2}function ni(n){n.fixed&=-7}function ti(n){n.fixed|=4,n.px=n.x,n.py=n.y}function ei(n){n.fixed&=-5}function ri(n,t,e){var r=0,i=0;if(n.charge=0,!n.leaf)for(var u,o=n.nodes,a=o.length,l=-1;++l<a;)u=o[l],null!=u&&(ri(u,t,e),n.charge+=u.charge,r+=u.charge*u.cx,i+=u.charge*u.cy);if(n.point){n.leaf||(n.point.x+=Math.random()-.5,n.point.y+=Math.random()-.5);var c=t*e[n.point.index];n.charge+=n.pointCharge=c,r+=c*n.point.x,i+=c*n.point.y}n.cx=r/n.charge,n.cy=i/n.charge}function ii(n,t){return ao.rebind(n,t,"sort","children","value"),n.nodes=n,n.links=fi,n}function ui(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function oi(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ai(n){return n.children}function li(n){return n.value}function ci(n,t){return t.value-n.value}function fi(n){return ao.merge(n.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}function si(n){return n.x}function hi(n){return n.y}function pi(n,t,e){n.y0=t,n.y=e}function gi(n){return ao.range(n.length)}function vi(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function di(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;u>e;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function yi(n){return n.reduce(mi,0)}function mi(n,t){return n+t[1]}function Mi(n,t){return xi(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function xi(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function bi(n){return[ao.min(n),ao.max(n)]}function _i(n,t){return n.value-t.value}function wi(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Si(n,t){n._pack_next=t,t._pack_prev=n}function ki(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function Ni(n){function t(n){f=Math.min(n.x-n.r,f),s=Math.max(n.x+n.r,s),h=Math.min(n.y-n.r,h),p=Math.max(n.y+n.r,p)}if((e=n.children)&&(c=e.length)){var e,r,i,u,o,a,l,c,f=1/0,s=-(1/0),h=1/0,p=-(1/0);if(e.forEach(Ei),r=e[0],r.x=-r.r,r.y=0,t(r),c>1&&(i=e[1],i.x=i.r,i.y=0,t(i),c>2))for(u=e[2],zi(r,i,u),t(u),wi(r,u),r._pack_prev=u,wi(u,i),i=r._pack_next,o=3;c>o;o++){zi(r,i,u=e[o]);var g=0,v=1,d=1;for(a=i._pack_next;a!==i;a=a._pack_next,v++)if(ki(a,u)){g=1;break}if(1==g)for(l=r._pack_prev;l!==a._pack_prev&&!ki(l,u);l=l._pack_prev,d++);g?(d>v||v==d&&i.r<r.r?Si(r,i=a):Si(r=l,i),o--):(wi(r,u),i=u,t(u))}var y=(f+s)/2,m=(h+p)/2,M=0;for(o=0;c>o;o++)u=e[o],u.x-=y,u.y-=m,M=Math.max(M,u.r+Math.sqrt(u.x*u.x+u.y*u.y));n.r=M,e.forEach(Ai)}}function Ei(n){n._pack_next=n._pack_prev=n}function Ai(n){delete n._pack_next,delete n._pack_prev}function Ci(n,t,e,r){var i=n.children;if(n.x=t+=r*n.x,n.y=e+=r*n.y,n.r*=r,i)for(var u=-1,o=i.length;++u<o;)Ci(i[u],t,e,r)}function zi(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u;o*=o,r*=r;var l=.5+(r-o)/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Li(n,t){return n.parent==t.parent?1:2}function qi(n){var t=n.children;return t.length?t[0]:n.t}function Ti(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function Ri(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function Di(n){for(var t,e=0,r=0,i=n.children,u=i.length;--u>=0;)t=i[u],t.z+=e,t.m+=e,e+=t.s+(r+=t.c)}function Pi(n,t,e){return n.a.parent===t.parent?n.a:e}function Ui(n){return 1+ao.max(n,function(n){return n.y})}function ji(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}function Fi(n){var t=n.children;return t&&t.length?Fi(t[0]):n}function Hi(n){var t,e=n.children;return e&&(t=e.length)?Hi(e[t-1]):n}function Oi(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function Ii(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return 0>i&&(e+=i/2,i=0),0>u&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function Yi(n){var t=n[0],e=n[n.length-1];return e>t?[t,e]:[e,t]}function Zi(n){return n.rangeExtent?n.rangeExtent():Yi(n.range())}function Vi(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function Xi(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return u>o&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function $i(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:Sl}function Bi(n,t,e,r){var i=[],u=[],o=0,a=Math.min(n.length,t.length)-1;for(n[a]<n[0]&&(n=n.slice().reverse(),t=t.slice().reverse());++o<=a;)i.push(e(n[o-1],n[o])),u.push(r(t[o-1],t[o]));return function(t){var e=ao.bisect(n,t,1,a)-1;return u[e](i[e](t))}}function Wi(n,t,e,r){function i(){var i=Math.min(n.length,t.length)>2?Bi:Vi,l=r?Wr:Br;return o=i(n,t,l,e),a=i(t,n,l,Mr),u}function u(n){return o(n)}var o,a;return u.invert=function(n){return a(n)},u.domain=function(t){return arguments.length?(n=t.map(Number),i()):n},u.range=function(n){return arguments.length?(t=n,i()):t},u.rangeRound=function(n){return u.range(n).interpolate(Ur)},u.clamp=function(n){return arguments.length?(r=n,i()):r},u.interpolate=function(n){return arguments.length?(e=n,i()):e},u.ticks=function(t){return Qi(n,t)},u.tickFormat=function(t,e){return nu(n,t,e)},u.nice=function(t){return Gi(n,t),i()},u.copy=function(){return Wi(n,t,e,r)},i()}function Ji(n,t){return ao.rebind(n,t,"range","rangeRound","interpolate","clamp")}function Gi(n,t){return Xi(n,$i(Ki(n,t)[2])),Xi(n,$i(Ki(n,t)[2])),n}function Ki(n,t){null==t&&(t=10);var e=Yi(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return.15>=u?i*=10:.35>=u?i*=5:.75>=u&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function Qi(n,t){return ao.range.apply(ao,Ki(n,t))}function nu(n,t,e){var r=Ki(n,t);if(e){var i=ha.exec(e);if(i.shift(),"s"===i[8]){var u=ao.formatPrefix(Math.max(xo(r[0]),xo(r[1])));return i[7]||(i[7]="."+tu(u.scale(r[2]))),i[8]="f",e=ao.format(i.join("")),function(n){return e(u.scale(n))+u.symbol}}i[7]||(i[7]="."+eu(i[8],r)),e=i.join("")}else e=",."+tu(r[2])+"f";return ao.format(e)}function tu(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}function eu(n,t){var e=tu(t[2]);return n in kl?Math.abs(e-tu(Math.max(xo(t[0]),xo(t[1]))))+ +("e"!==n):e-2*("%"===n)}function ru(n,t,e,r){function i(n){return(e?Math.log(0>n?0:n):-Math.log(n>0?0:-n))/Math.log(t)}function u(n){return e?Math.pow(t,n):-Math.pow(t,-n)}function o(t){return n(i(t))}return o.invert=function(t){return u(n.invert(t))},o.domain=function(t){return arguments.length?(e=t[0]>=0,n.domain((r=t.map(Number)).map(i)),o):r},o.base=function(e){return arguments.length?(t=+e,n.domain(r.map(i)),o):t},o.nice=function(){var t=Xi(r.map(i),e?Math:El);return n.domain(t),r=t.map(u),o},o.ticks=function(){var n=Yi(r),o=[],a=n[0],l=n[1],c=Math.floor(i(a)),f=Math.ceil(i(l)),s=t%1?2:t;if(isFinite(f-c)){if(e){for(;f>c;c++)for(var h=1;s>h;h++)o.push(u(c)*h);o.push(u(c))}else for(o.push(u(c));c++<f;)for(var h=s-1;h>0;h--)o.push(u(c)*h);for(c=0;o[c]<a;c++);for(f=o.length;o[f-1]>l;f--);o=o.slice(c,f)}return o},o.tickFormat=function(n,e){if(!arguments.length)return Nl;arguments.length<2?e=Nl:"function"!=typeof e&&(e=ao.format(e));var r=Math.max(1,t*n/o.ticks().length);return function(n){var o=n/u(Math.round(i(n)));return t-.5>o*t&&(o*=t),r>=o?e(n):""}},o.copy=function(){return ru(n.copy(),t,e,r)},Ji(o,n)}function iu(n,t,e){function r(t){return n(i(t))}var i=uu(t),u=uu(1/t);return r.invert=function(t){return u(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain((e=t.map(Number)).map(i)),r):e},r.ticks=function(n){return Qi(e,n)},r.tickFormat=function(n,t){return nu(e,n,t)},r.nice=function(n){return r.domain(Gi(e,n))},r.exponent=function(o){return arguments.length?(i=uu(t=o),u=uu(1/t),n.domain(e.map(i)),r):t},r.copy=function(){return iu(n.copy(),t,e)},Ji(r,n)}function uu(n){return function(t){return 0>t?-Math.pow(-t,n):Math.pow(t,n)}}function ou(n,t){function e(e){return u[((i.get(e)||("range"===t.t?i.set(e,n.push(e)):NaN))-1)%u.length]}function r(t,e){return ao.range(n.length).map(function(n){return t+e*n})}var i,u,o;return e.domain=function(r){if(!arguments.length)return n;n=[],i=new c;for(var u,o=-1,a=r.length;++o<a;)i.has(u=r[o])||i.set(u,n.push(u));return e[t.t].apply(e,t.a)},e.range=function(n){return arguments.length?(u=n,o=0,t={t:"range",a:arguments},e):u},e.rangePoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=(l+c)/2,0):(c-l)/(n.length-1+a);return u=r(l+f*a/2,f),o=0,t={t:"rangePoints",a:arguments},e},e.rangeRoundPoints=function(i,a){arguments.length<2&&(a=0);var l=i[0],c=i[1],f=n.length<2?(l=c=Math.round((l+c)/2),0):(c-l)/(n.length-1+a)|0;return u=r(l+Math.round(f*a/2+(c-l-(n.length-1+a)*f)/2),f),o=0,t={t:"rangeRoundPoints",a:arguments},e},e.rangeBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=(s-f)/(n.length-a+2*l);return u=r(f+h*l,h),c&&u.reverse(),o=h*(1-a),t={t:"rangeBands",a:arguments},e},e.rangeRoundBands=function(i,a,l){arguments.length<2&&(a=0),arguments.length<3&&(l=a);var c=i[1]<i[0],f=i[c-0],s=i[1-c],h=Math.floor((s-f)/(n.length-a+2*l));return u=r(f+Math.round((s-f-(n.length-a)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-a)),t={t:"rangeRoundBands",a:arguments},e},e.rangeBand=function(){return o},e.rangeExtent=function(){return Yi(t.a[0])},e.copy=function(){return ou(n,t)},e.domain(n)}function au(n,t){function u(){var e=0,r=t.length;for(a=[];++e<r;)a[e-1]=ao.quantile(n,e/r);return o}function o(n){return isNaN(n=+n)?void 0:t[ao.bisect(a,n)]}var a;return o.domain=function(t){return arguments.length?(n=t.map(r).filter(i).sort(e),u()):n},o.range=function(n){return arguments.length?(t=n,u()):t},o.quantiles=function(){return a},o.invertExtent=function(e){return e=t.indexOf(e),0>e?[NaN,NaN]:[e>0?a[e-1]:n[0],e<a.length?a[e]:n[n.length-1]]},o.copy=function(){return au(n,t)},u()}function lu(n,t,e){function r(t){return e[Math.max(0,Math.min(o,Math.floor(u*(t-n))))]}function i(){return u=e.length/(t-n),o=e.length-1,r}var u,o;return r.domain=function(e){return arguments.length?(n=+e[0],t=+e[e.length-1],i()):[n,t]},r.range=function(n){return arguments.length?(e=n,i()):e},r.invertExtent=function(t){return t=e.indexOf(t),t=0>t?NaN:t/u+n,[t,t+1/u]},r.copy=function(){return lu(n,t,e)},i()}function cu(n,t){function e(e){return e>=e?t[ao.bisect(n,e)]:void 0}return e.domain=function(t){return arguments.length?(n=t,e):n},e.range=function(n){return arguments.length?(t=n,e):t},e.invertExtent=function(e){return e=t.indexOf(e),[n[e-1],n[e]]},e.copy=function(){return cu(n,t)},e}function fu(n){function t(n){return+n}return t.invert=t,t.domain=t.range=function(e){return arguments.length?(n=e.map(t),t):n},t.ticks=function(t){return Qi(n,t)},t.tickFormat=function(t,e){return nu(n,t,e)},t.copy=function(){return fu(n)},t}function su(){return 0}function hu(n){return n.innerRadius}function pu(n){return n.outerRadius}function gu(n){return n.startAngle}function vu(n){return n.endAngle}function du(n){return n&&n.padAngle}function yu(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function mu(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(0>y?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Mu(n){function t(t){function o(){c.push("M",u(n(f),a))}for(var l,c=[],f=[],s=-1,h=t.length,p=En(e),g=En(r);++s<h;)i.call(this,l=t[s],s)?f.push([+p.call(this,l,s),+g.call(this,l,s)]):f.length&&(o(),f=[]);return f.length&&o(),c.length?c.join(""):null}var e=Ce,r=ze,i=zt,u=xu,o=u.key,a=.7;return t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t.defined=function(n){return arguments.length?(i=n,t):i},t.interpolate=function(n){return arguments.length?(o="function"==typeof n?u=n:(u=Tl.get(n)||xu).key,t):o},t.tension=function(n){return arguments.length?(a=n,t):a},t}function xu(n){return n.length>1?n.join("L"):n+"Z"}function bu(n){return n.join("L")+"Z"}function _u(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);return e>1&&i.push("H",r[0]),i.join("")}function wu(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Su(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function ku(n,t){return n.length<4?xu(n):n[1]+Au(n.slice(1,-1),Cu(n,t))}function Nu(n,t){return n.length<3?bu(n):n[0]+Au((n.push(n[0]),n),Cu([n[n.length-2]].concat(n,[n[1]]),t))}function Eu(n,t){return n.length<3?xu(n):n[0]+Au(n,Cu(n,t))}function Au(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return xu(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Cu(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function zu(n){if(n.length<3)return xu(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Ru(Pl,o),",",Ru(Pl,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Du(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Lu(n){if(n.length<4)return xu(n);for(var t,e=[],r=-1,i=n.length,u=[0],o=[0];++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);for(e.push(Ru(Pl,u)+","+Ru(Pl,o)),--r;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Du(e,u,o);return e.join("")}function qu(n){for(var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);for(t=[Ru(Pl,o),",",Ru(Pl,a)],--r;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Du(t,o,a);return t.join("")}function Tu(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return zu(n)}function Ru(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}function Du(n,t,e){n.push("C",Ru(Rl,t),",",Ru(Rl,e),",",Ru(Dl,t),",",Ru(Dl,e),",",Ru(Pl,t),",",Ru(Pl,e))}function Pu(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Uu(n){for(var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Pu(i,u);++t<e;)r[t]=(o+(o=Pu(i=u,u=n[t+1])))/2;return r[t]=o,r}function ju(n){for(var t,e,r,i,u=[],o=Uu(n),a=-1,l=n.length-1;++a<l;)t=Pu(n[a],n[a+1]),xo(t)<Uo?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,i=e*e+r*r,i>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));for(a=-1;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}function Fu(n){return n.length<3?xu(n):n[0]+Au(n,ju(n))}function Hu(n){for(var t,e,r,i=-1,u=n.length;++i<u;)t=n[i],e=t[0],r=t[1]-Io,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Ou(n){function t(t){function l(){v.push("M",a(n(y),s),f,c(n(d.reverse()),s),"Z")}for(var h,p,g,v=[],d=[],y=[],m=-1,M=t.length,x=En(e),b=En(i),_=e===r?function(){
return p}:En(r),w=i===u?function(){return g}:En(u);++m<M;)o.call(this,h=t[m],m)?(d.push([p=+x.call(this,h,m),g=+b.call(this,h,m)]),y.push([+_.call(this,h,m),+w.call(this,h,m)])):d.length&&(l(),d=[],y=[]);return d.length&&l(),v.length?v.join(""):null}var e=Ce,r=Ce,i=0,u=ze,o=zt,a=xu,l=a.key,c=a,f="L",s=.7;return t.x=function(n){return arguments.length?(e=r=n,t):r},t.x0=function(n){return arguments.length?(e=n,t):e},t.x1=function(n){return arguments.length?(r=n,t):r},t.y=function(n){return arguments.length?(i=u=n,t):u},t.y0=function(n){return arguments.length?(i=n,t):i},t.y1=function(n){return arguments.length?(u=n,t):u},t.defined=function(n){return arguments.length?(o=n,t):o},t.interpolate=function(n){return arguments.length?(l="function"==typeof n?a=n:(a=Tl.get(n)||xu).key,c=a.reverse||a,f=a.closed?"M":"L",t):l},t.tension=function(n){return arguments.length?(s=n,t):s},t}function Iu(n){return n.radius}function Yu(n){return[n.x,n.y]}function Zu(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-Io;return[e*Math.cos(r),e*Math.sin(r)]}}function Vu(){return 64}function Xu(){return"circle"}function $u(n){var t=Math.sqrt(n/Fo);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}function Bu(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function Wu(n,t,e){return ko(n,Yl),n.namespace=t,n.id=e,n}function Ju(n,t,e,r){var i=n.id,u=n.namespace;return Y(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function Gu(n){return null==n&&(n=""),function(){this.textContent=n}}function Ku(n){return null==n?"__transition__":"__transition_"+n+"__"}function Qu(n,t,e,r,i){function u(n){var t=v.delay;return f.t=t+l,n>=t?o(n-t):void(f.c=o)}function o(e){var i=g.active,u=g[i];u&&(u.timer.c=null,u.timer.t=NaN,--g.count,delete g[i],u.event&&u.event.interrupt.call(n,n.__data__,u.index));for(var o in g)if(r>+o){var c=g[o];c.timer.c=null,c.timer.t=NaN,--g.count,delete g[o]}f.c=a,qn(function(){return f.c&&a(e||1)&&(f.c=null,f.t=NaN),1},0,l),g.active=r,v.event&&v.event.start.call(n,n.__data__,t),p=[],v.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&p.push(r)}),h=v.ease,s=v.duration}function a(i){for(var u=i/s,o=h(u),a=p.length;a>0;)p[--a].call(n,o);return u>=1?(v.event&&v.event.end.call(n,n.__data__,t),--g.count?delete g[r]:delete n[e],1):void 0}var l,f,s,h,p,g=n[e]||(n[e]={active:0,count:0}),v=g[r];v||(l=i.time,f=qn(u,0,l),v=g[r]={tween:new c,time:l,timer:f,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++g.count)}function no(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function to(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}function eo(n){return n.toISOString()}function ro(n,t,e){function r(t){return n(t)}function i(n,e){var r=n[1]-n[0],i=r/e,u=ao.bisect(Kl,i);return u==Kl.length?[t.year,Ki(n.map(function(n){return n/31536e6}),e)[2]]:u?t[i/Kl[u-1]<Kl[u]/i?u-1:u]:[tc,Ki(n,e)[2]]}return r.invert=function(t){return io(n.invert(t))},r.domain=function(t){return arguments.length?(n.domain(t),r):n.domain().map(io)},r.nice=function(n,t){function e(e){return!isNaN(e)&&!n.range(e,io(+e+1),t).length}var u=r.domain(),o=Yi(u),a=null==n?i(o,10):"number"==typeof n&&i(o,n);return a&&(n=a[0],t=a[1]),r.domain(Xi(u,t>1?{floor:function(t){for(;e(t=n.floor(t));)t=io(t-1);return t},ceil:function(t){for(;e(t=n.ceil(t));)t=io(+t+1);return t}}:n))},r.ticks=function(n,t){var e=Yi(r.domain()),u=null==n?i(e,10):"number"==typeof n?i(e,n):!n.range&&[{range:n},t];return u&&(n=u[0],t=u[1]),n.range(e[0],io(+e[1]+1),1>t?1:t)},r.tickFormat=function(){return e},r.copy=function(){return ro(n.copy(),t,e)},Ji(r,n)}function io(n){return new Date(n)}function uo(n){return JSON.parse(n.responseText)}function oo(n){var t=fo.createRange();return t.selectNode(fo.body),t.createContextualFragment(n.responseText)}var ao={version:"3.5.17"},lo=[].slice,co=function(n){return lo.call(n)},fo=this.document;if(fo)try{co(fo.documentElement.childNodes)[0].nodeType}catch(so){co=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),fo)try{fo.createElement("DIV").style.setProperty("opacity",0,"")}catch(ho){var po=this.Element.prototype,go=po.setAttribute,vo=po.setAttributeNS,yo=this.CSSStyleDeclaration.prototype,mo=yo.setProperty;po.setAttribute=function(n,t){go.call(this,n,t+"")},po.setAttributeNS=function(n,t,e){vo.call(this,n,t,e+"")},yo.setProperty=function(n,t,e){mo.call(this,n,t+"",e)}}ao.ascending=e,ao.descending=function(n,t){return n>t?-1:t>n?1:t>=n?0:NaN},ao.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},ao.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},ao.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),r>i&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),r>i&&(i=r))}return[e,i]},ao.sum=function(n,t){var e,r=0,u=n.length,o=-1;if(1===arguments.length)for(;++o<u;)i(e=+n[o])&&(r+=e);else for(;++o<u;)i(e=+t.call(n,n[o],o))&&(r+=e);return r},ao.mean=function(n,t){var e,u=0,o=n.length,a=-1,l=o;if(1===arguments.length)for(;++a<o;)i(e=r(n[a]))?u+=e:--l;else for(;++a<o;)i(e=r(t.call(n,n[a],a)))?u+=e:--l;return l?u/l:void 0},ao.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},ao.median=function(n,t){var u,o=[],a=n.length,l=-1;if(1===arguments.length)for(;++l<a;)i(u=r(n[l]))&&o.push(u);else for(;++l<a;)i(u=r(t.call(n,n[l],l)))&&o.push(u);return o.length?ao.quantile(o.sort(e),.5):void 0},ao.variance=function(n,t){var e,u,o=n.length,a=0,l=0,c=-1,f=0;if(1===arguments.length)for(;++c<o;)i(e=r(n[c]))&&(u=e-a,a+=u/++f,l+=u*(e-a));else for(;++c<o;)i(e=r(t.call(n,n[c],c)))&&(u=e-a,a+=u/++f,l+=u*(e-a));return f>1?l/(f-1):void 0},ao.deviation=function(){var n=ao.variance.apply(this,arguments);return n?Math.sqrt(n):n};var Mo=u(e);ao.bisectLeft=Mo.left,ao.bisect=ao.bisectRight=Mo.right,ao.bisector=function(n){return u(1===n.length?function(t,r){return e(n(t),r)}:n)},ao.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,2>u&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},ao.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},ao.pairs=function(n){for(var t,e=0,r=n.length-1,i=n[0],u=new Array(0>r?0:r);r>e;)u[e]=[t=i,i=n[++e]];return u},ao.transpose=function(n){if(!(i=n.length))return[];for(var t=-1,e=ao.min(n,o),r=new Array(e);++t<e;)for(var i,u=-1,a=r[t]=new Array(i);++u<i;)a[u]=n[u][t];return r},ao.zip=function(){return ao.transpose(arguments)},ao.keys=function(n){var t=[];for(var e in n)t.push(e);return t},ao.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},ao.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},ao.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(r=n[i],t=r.length;--t>=0;)e[--o]=r[t];return e};var xo=Math.abs;ao.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e===1/0)throw new Error("infinite range");var r,i=[],u=a(xo(e)),o=-1;if(n*=u,t*=u,e*=u,0>e)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},ao.map=function(n,t){var e=new c;if(n instanceof c)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var bo="__proto__",_o="\x00";l(c,{has:h,get:function(n){return this._[f(n)]},set:function(n,t){return this._[f(n)]=t},remove:p,keys:g,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:s(t),value:this._[t]});return n},size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t),this._[t])}}),ao.nest=function(){function n(t,o,a){if(a>=u.length)return r?r.call(i,o):e?o.sort(e):o;for(var l,f,s,h,p=-1,g=o.length,v=u[a++],d=new c;++p<g;)(h=d.get(l=v(f=o[p])))?h.push(f):d.set(l,[f]);return t?(f=t(),s=function(e,r){f.set(e,n(t,r,a))}):(f={},s=function(e,r){f[e]=n(t,r,a)}),d.forEach(s),f}function t(n,e){if(e>=u.length)return n;var r=[],i=o[e++];return n.forEach(function(n,i){r.push({key:n,values:t(i,e)})}),i?r.sort(function(n,t){return i(n.key,t.key)}):r}var e,r,i={},u=[],o=[];return i.map=function(t,e){return n(e,t,0)},i.entries=function(e){return t(n(ao.map,e,0),0)},i.key=function(n){return u.push(n),i},i.sortKeys=function(n){return o[u.length-1]=n,i},i.sortValues=function(n){return e=n,i},i.rollup=function(n){return r=n,i},i},ao.set=function(n){var t=new y;if(n)for(var e=0,r=n.length;r>e;++e)t.add(n[e]);return t},l(y,{has:h,add:function(n){return this._[f(n+="")]=!0,n},remove:p,values:g,size:v,empty:d,forEach:function(n){for(var t in this._)n.call(this,s(t))}}),ao.behavior={},ao.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=M(n,t,t[e]);return n};var wo=["webkit","ms","moz","Moz","o","O"];ao.dispatch=function(){for(var n=new _,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=w(n);return n},_.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},ao.event=null,ao.requote=function(n){return n.replace(So,"\\$&")};var So=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,ko={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]},No=function(n,t){return t.querySelector(n)},Eo=function(n,t){return t.querySelectorAll(n)},Ao=function(n,t){var e=n.matches||n[x(n,"matchesSelector")];return(Ao=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(No=function(n,t){return Sizzle(n,t)[0]||null},Eo=Sizzle,Ao=Sizzle.matchesSelector),ao.selection=function(){return ao.select(fo.documentElement)};var Co=ao.selection.prototype=[];Co.select=function(n){var t,e,r,i,u=[];n=A(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return E(u)},Co.selectAll=function(n){var t,e,r=[];n=C(n);for(var i=-1,u=this.length;++i<u;)for(var o=this[i],a=-1,l=o.length;++a<l;)(e=o[a])&&(r.push(t=co(n.call(e,e.__data__,a,i))),t.parentNode=e);return E(r)};var zo="http://www.w3.org/1999/xhtml",Lo={svg:"http://www.w3.org/2000/svg",xhtml:zo,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};ao.ns={prefix:Lo,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),Lo.hasOwnProperty(e)?{space:Lo[e],local:n}:n}},Co.attr=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node();return n=ao.ns.qualify(n),n.local?e.getAttributeNS(n.space,n.local):e.getAttribute(n)}for(t in n)this.each(z(t,n[t]));return this}return this.each(z(n,t))},Co.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=T(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!q(n[i]).test(t))return!1;return!0}for(t in n)this.each(R(t,n[t]));return this}return this.each(R(n,t))},Co.style=function(n,e,r){var i=arguments.length;if(3>i){if("string"!=typeof n){2>i&&(e="");for(r in n)this.each(P(r,n[r],e));return this}if(2>i){var u=this.node();return t(u).getComputedStyle(u,null).getPropertyValue(n)}r=""}return this.each(P(n,e,r))},Co.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(U(t,n[t]));return this}return this.each(U(n,t))},Co.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},Co.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},Co.append=function(n){return n=j(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},Co.insert=function(n,t){return n=j(n),t=A(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},Co.remove=function(){return this.each(F)},Co.data=function(n,t){function e(n,e){var r,i,u,o=n.length,s=e.length,h=Math.min(o,s),p=new Array(s),g=new Array(s),v=new Array(o);if(t){var d,y=new c,m=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(y.has(d=t.call(i,i.__data__,r))?v[r]=i:y.set(d,i),m[r]=d);for(r=-1;++r<s;)(i=y.get(d=t.call(e,u=e[r],r)))?i!==!0&&(p[r]=i,i.__data__=u):g[r]=H(u),y.set(d,!0);for(r=-1;++r<o;)r in m&&y.get(m[r])!==!0&&(v[r]=n[r])}else{for(r=-1;++r<h;)i=n[r],u=e[r],i?(i.__data__=u,p[r]=i):g[r]=H(u);for(;s>r;++r)g[r]=H(e[r]);for(;o>r;++r)v[r]=n[r]}g.update=p,g.parentNode=p.parentNode=v.parentNode=n.parentNode,a.push(g),l.push(p),f.push(v)}var r,i,u=-1,o=this.length;if(!arguments.length){for(n=new Array(o=(r=this[0]).length);++u<o;)(i=r[u])&&(n[u]=i.__data__);return n}var a=Z([]),l=E([]),f=E([]);if("function"==typeof n)for(;++u<o;)e(r=this[u],n.call(r,r.parentNode.__data__,u));else for(;++u<o;)e(r=this[u],n);return l.enter=function(){return a},l.exit=function(){return f},l},Co.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},Co.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return E(i)},Co.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},Co.sort=function(n){n=I.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},Co.each=function(n){return Y(this,function(t,e,r){n.call(t,t.__data__,e,r)})},Co.call=function(n){var t=co(arguments);return n.apply(t[0]=this,t),this},Co.empty=function(){return!this.node()},Co.node=function(){for(var n=0,t=this.length;t>n;n++)for(var e=this[n],r=0,i=e.length;i>r;r++){var u=e[r];if(u)return u}return null},Co.size=function(){var n=0;return Y(this,function(){++n}),n};var qo=[];ao.selection.enter=Z,ao.selection.enter.prototype=qo,qo.append=Co.append,qo.empty=Co.empty,qo.node=Co.node,qo.call=Co.call,qo.size=Co.size,qo.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return E(o)},qo.insert=function(n,t){return arguments.length<2&&(t=V(this)),Co.insert.call(this,n,t)},ao.select=function(t){var e;return"string"==typeof t?(e=[No(t,fo)],e.parentNode=fo.documentElement):(e=[t],e.parentNode=n(t)),E([e])},ao.selectAll=function(n){var t;return"string"==typeof n?(t=co(Eo(n,fo)),t.parentNode=fo.documentElement):(t=co(n),t.parentNode=null),E([t])},Co.on=function(n,t,e){var r=arguments.length;if(3>r){if("string"!=typeof n){2>r&&(t=!1);for(e in n)this.each(X(e,n[e],t));return this}if(2>r)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(X(n,t,e))};var To=ao.map({mouseenter:"mouseover",mouseleave:"mouseout"});fo&&To.forEach(function(n){"on"+n in fo&&To.remove(n)});var Ro,Do=0;ao.mouse=function(n){return J(n,k())};var Po=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;ao.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=k().changedTouches),t)for(var r,i=0,u=t.length;u>i;++i)if((r=t[i]).identifier===e)return J(n,r)},ao.behavior.drag=function(){function n(){this.on("mousedown.drag",u).on("touchstart.drag",o)}function e(n,t,e,u,o){return function(){function a(){var n,e,r=t(h,v);r&&(n=r[0]-M[0],e=r[1]-M[1],g|=n|e,M=r,p({type:"drag",x:r[0]+c[0],y:r[1]+c[1],dx:n,dy:e}))}function l(){t(h,v)&&(y.on(u+d,null).on(o+d,null),m(g),p({type:"dragend"}))}var c,f=this,s=ao.event.target.correspondingElement||ao.event.target,h=f.parentNode,p=r.of(f,arguments),g=0,v=n(),d=".drag"+(null==v?"":"-"+v),y=ao.select(e(s)).on(u+d,a).on(o+d,l),m=W(s),M=t(h,v);i?(c=i.apply(f,arguments),c=[c.x-M[0],c.y-M[1]]):c=[0,0],p({type:"dragstart"})}}var r=N(n,"drag","dragstart","dragend"),i=null,u=e(b,ao.mouse,t,"mousemove","mouseup"),o=e(G,ao.touch,m,"touchmove","touchend");return n.origin=function(t){return arguments.length?(i=t,n):i},ao.rebind(n,r,"on")},ao.touches=function(n,t){return arguments.length<2&&(t=k().touches),t?co(t).map(function(t){var e=J(n,t);return e.identifier=t.identifier,e}):[]};var Uo=1e-6,jo=Uo*Uo,Fo=Math.PI,Ho=2*Fo,Oo=Ho-Uo,Io=Fo/2,Yo=Fo/180,Zo=180/Fo,Vo=Math.SQRT2,Xo=2,$o=4;ao.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(jo>h)r=Math.log(c/o)/Vo,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Vo*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+$o*h)/(2*o*Xo*p),v=(c*c-o*o-$o*h)/(2*c*Xo*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Vo,e=function(n){var t=n*r,e=rn(d),a=o/(Xo*p)*(e*un(Vo*t+d)-en(d));return[i+a*f,u+a*s,o*e/rn(Vo*t+d)]}}return e.duration=1e3*r,e},ao.behavior.zoom=function(){function n(n){n.on(L,s).on(Wo+".zoom",p).on("dblclick.zoom",g).on(R,h)}function e(n){return[(n[0]-k.x)/k.k,(n[1]-k.y)/k.k]}function r(n){return[n[0]*k.k+k.x,n[1]*k.k+k.y]}function i(n){k.k=Math.max(A[0],Math.min(A[1],n))}function u(n,t){t=r(t),k.x+=n[0]-t[0],k.y+=n[1]-t[1]}function o(t,e,r,o){t.__chart__={x:k.x,y:k.y,k:k.k},i(Math.pow(2,o)),u(d=e,r),t=ao.select(t),C>0&&(t=t.transition().duration(C)),t.call(n.event)}function a(){b&&b.domain(x.range().map(function(n){return(n-k.x)/k.k}).map(x.invert)),w&&w.domain(_.range().map(function(n){return(n-k.y)/k.k}).map(_.invert))}function l(n){z++||n({type:"zoomstart"})}function c(n){a(),n({type:"zoom",scale:k.k,translate:[k.x,k.y]})}function f(n){--z||(n({type:"zoomend"}),d=null)}function s(){function n(){a=1,u(ao.mouse(i),h),c(o)}function r(){s.on(q,null).on(T,null),p(a),f(o)}var i=this,o=D.of(i,arguments),a=0,s=ao.select(t(i)).on(q,n).on(T,r),h=e(ao.mouse(i)),p=W(i);Il.call(i),l(o)}function h(){function n(){var n=ao.touches(g);return p=k.k,n.forEach(function(n){n.identifier in d&&(d[n.identifier]=e(n))}),n}function t(){var t=ao.event.target;ao.select(t).on(x,r).on(b,a),_.push(t);for(var e=ao.event.changedTouches,i=0,u=e.length;u>i;++i)d[e[i].identifier]=null;var l=n(),c=Date.now();if(1===l.length){if(500>c-M){var f=l[0];o(g,f,d[f.identifier],Math.floor(Math.log(k.k)/Math.LN2)+1),S()}M=c}else if(l.length>1){var f=l[0],s=l[1],h=f[0]-s[0],p=f[1]-s[1];y=h*h+p*p}}function r(){var n,t,e,r,o=ao.touches(g);Il.call(g);for(var a=0,l=o.length;l>a;++a,r=null)if(e=o[a],r=d[e.identifier]){if(t)break;n=e,t=r}if(r){var f=(f=e[0]-n[0])*f+(f=e[1]-n[1])*f,s=y&&Math.sqrt(f/y);n=[(n[0]+e[0])/2,(n[1]+e[1])/2],t=[(t[0]+r[0])/2,(t[1]+r[1])/2],i(s*p)}M=null,u(n,t),c(v)}function a(){if(ao.event.touches.length){for(var t=ao.event.changedTouches,e=0,r=t.length;r>e;++e)delete d[t[e].identifier];for(var i in d)return void n()}ao.selectAll(_).on(m,null),w.on(L,s).on(R,h),N(),f(v)}var p,g=this,v=D.of(g,arguments),d={},y=0,m=".zoom-"+ao.event.changedTouches[0].identifier,x="touchmove"+m,b="touchend"+m,_=[],w=ao.select(g),N=W(g);t(),l(v),w.on(L,null).on(R,t)}function p(){var n=D.of(this,arguments);m?clearTimeout(m):(Il.call(this),v=e(d=y||ao.mouse(this)),l(n)),m=setTimeout(function(){m=null,f(n)},50),S(),i(Math.pow(2,.002*Bo())*k.k),u(d,v),c(n)}function g(){var n=ao.mouse(this),t=Math.log(k.k)/Math.LN2;o(this,n,e(n),ao.event.shiftKey?Math.ceil(t)-1:Math.floor(t)+1)}var v,d,y,m,M,x,b,_,w,k={x:0,y:0,k:1},E=[960,500],A=Jo,C=250,z=0,L="mousedown.zoom",q="mousemove.zoom",T="mouseup.zoom",R="touchstart.zoom",D=N(n,"zoomstart","zoom","zoomend");return Wo||(Wo="onwheel"in fo?(Bo=function(){return-ao.event.deltaY*(ao.event.deltaMode?120:1)},"wheel"):"onmousewheel"in fo?(Bo=function(){return ao.event.wheelDelta},"mousewheel"):(Bo=function(){return-ao.event.detail},"MozMousePixelScroll")),n.event=function(n){n.each(function(){var n=D.of(this,arguments),t=k;Hl?ao.select(this).transition().each("start.zoom",function(){k=this.__chart__||{x:0,y:0,k:1},l(n)}).tween("zoom:zoom",function(){var e=E[0],r=E[1],i=d?d[0]:e/2,u=d?d[1]:r/2,o=ao.interpolateZoom([(i-k.x)/k.k,(u-k.y)/k.k,e/k.k],[(i-t.x)/t.k,(u-t.y)/t.k,e/t.k]);return function(t){var r=o(t),a=e/r[2];this.__chart__=k={x:i-r[0]*a,y:u-r[1]*a,k:a},c(n)}}).each("interrupt.zoom",function(){f(n)}).each("end.zoom",function(){f(n)}):(this.__chart__=k,l(n),c(n),f(n))})},n.translate=function(t){return arguments.length?(k={x:+t[0],y:+t[1],k:k.k},a(),n):[k.x,k.y]},n.scale=function(t){return arguments.length?(k={x:k.x,y:k.y,k:null},i(+t),a(),n):k.k},n.scaleExtent=function(t){return arguments.length?(A=null==t?Jo:[+t[0],+t[1]],n):A},n.center=function(t){return arguments.length?(y=t&&[+t[0],+t[1]],n):y},n.size=function(t){return arguments.length?(E=t&&[+t[0],+t[1]],n):E},n.duration=function(t){return arguments.length?(C=+t,n):C},n.x=function(t){return arguments.length?(b=t,x=t.copy(),k={x:0,y:0,k:1},n):b},n.y=function(t){return arguments.length?(w=t,_=t.copy(),k={x:0,y:0,k:1},n):w},ao.rebind(n,D,"on")};var Bo,Wo,Jo=[0,1/0];ao.color=an,an.prototype.toString=function(){return this.rgb()+""},ao.hsl=ln;var Go=ln.prototype=new an;Go.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,this.l/n)},Go.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new ln(this.h,this.s,n*this.l)},Go.rgb=function(){return cn(this.h,this.s,this.l)},ao.hcl=fn;var Ko=fn.prototype=new an;Ko.brighter=function(n){return new fn(this.h,this.c,Math.min(100,this.l+Qo*(arguments.length?n:1)))},Ko.darker=function(n){return new fn(this.h,this.c,Math.max(0,this.l-Qo*(arguments.length?n:1)))},Ko.rgb=function(){return sn(this.h,this.c,this.l).rgb()},ao.lab=hn;var Qo=18,na=.95047,ta=1,ea=1.08883,ra=hn.prototype=new an;ra.brighter=function(n){return new hn(Math.min(100,this.l+Qo*(arguments.length?n:1)),this.a,this.b)},ra.darker=function(n){return new hn(Math.max(0,this.l-Qo*(arguments.length?n:1)),this.a,this.b)},ra.rgb=function(){return pn(this.l,this.a,this.b)},ao.rgb=mn;var ia=mn.prototype=new an;ia.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&i>t&&(t=i),e&&i>e&&(e=i),r&&i>r&&(r=i),new mn(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new mn(i,i,i)},ia.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new mn(n*this.r,n*this.g,n*this.b)},ia.hsl=function(){return wn(this.r,this.g,this.b)},ia.toString=function(){return"#"+bn(this.r)+bn(this.g)+bn(this.b)};var ua=ao.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});ua.forEach(function(n,t){ua.set(n,Mn(t))}),ao.functor=En,ao.xhr=An(m),ao.dsv=function(n,t){function e(n,e,u){arguments.length<3&&(u=e,e=null);var o=Cn(n,t,null==e?r:i(e),u);return o.row=function(n){return arguments.length?o.response(null==(e=n)?r:i(n)):e},o}function r(n){return e.parse(n.responseText)}function i(n){return function(t){return e.parse(t.responseText,n)}}function u(t){return t.map(o).join(n)}function o(n){return a.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}var a=new RegExp('["'+n+"\n]"),l=n.charCodeAt(0);return e.parse=function(n,t){var r;return e.parseRows(n,function(n,e){if(r)return r(n,e-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");r=t?function(n,e){return t(i(n),e)}:i})},e.parseRows=function(n,t){function e(){if(f>=c)return o;if(i)return i=!1,u;var t=f;if(34===n.charCodeAt(t)){for(var e=t;e++<c;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}f=e+2;var r=n.charCodeAt(e+1);return 13===r?(i=!0,10===n.charCodeAt(e+2)&&++f):10===r&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;c>f;){var r=n.charCodeAt(f++),a=1;if(10===r)i=!0;else if(13===r)i=!0,10===n.charCodeAt(f)&&(++f,++a);else if(r!==l)continue;return n.slice(t,f-a)}return n.slice(t)}for(var r,i,u={},o={},a=[],c=n.length,f=0,s=0;(r=e())!==o;){for(var h=[];r!==u&&r!==o;)h.push(r),r=e();t&&null==(h=t(h,s++))||a.push(h)}return a},e.format=function(t){if(Array.isArray(t[0]))return e.formatRows(t);var r=new y,i=[];return t.forEach(function(n){for(var t in n)r.has(t)||i.push(r.add(t))}),[i.map(o).join(n)].concat(t.map(function(t){return i.map(function(n){return o(t[n])}).join(n)})).join("\n")},e.formatRows=function(n){return n.map(u).join("\n")},e},ao.csv=ao.dsv(",","text/csv"),ao.tsv=ao.dsv("	","text/tab-separated-values");var oa,aa,la,ca,fa=this[x(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};ao.timer=function(){qn.apply(this,arguments)},ao.timer.flush=function(){Rn(),Dn()},ao.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var sa=["y","z","a","f","p","n","\xb5","m","","k","M","G","T","P","E","Z","Y"].map(Un);ao.formatPrefix=function(n,t){var e=0;return(n=+n)&&(0>n&&(n*=-1),t&&(n=ao.round(n,Pn(n,t))),e=1+Math.floor(1e-12+Math.log(n)/Math.LN10),e=Math.max(-24,Math.min(24,3*Math.floor((e-1)/3)))),sa[8+e/3]};var ha=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,pa=ao.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(n,t){return(n=ao.round(n,Pn(n,t))).toFixed(Math.max(0,Math.min(20,Pn(n*(1+1e-15),t))))}}),ga=ao.time={},va=Date;Hn.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){da.setUTCDate.apply(this._,arguments)},setDay:function(){da.setUTCDay.apply(this._,arguments)},setFullYear:function(){da.setUTCFullYear.apply(this._,arguments)},setHours:function(){da.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){da.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){da.setUTCMinutes.apply(this._,arguments)},setMonth:function(){da.setUTCMonth.apply(this._,arguments)},setSeconds:function(){da.setUTCSeconds.apply(this._,arguments)},setTime:function(){da.setTime.apply(this._,arguments)}};var da=Date.prototype;ga.year=On(function(n){return n=ga.day(n),n.setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),ga.years=ga.year.range,ga.years.utc=ga.year.utc.range,ga.day=On(function(n){var t=new va(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),ga.days=ga.day.range,ga.days.utc=ga.day.utc.range,ga.dayOfYear=function(n){var t=ga.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=ga[n]=On(function(n){return(n=ga.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});ga[n+"s"]=e.range,ga[n+"s"].utc=e.utc.range,ga[n+"OfYear"]=function(n){var e=ga.year(n).getDay();return Math.floor((ga.dayOfYear(n)+(e+t)%7)/7)}}),ga.week=ga.sunday,ga.weeks=ga.sunday.range,ga.weeks.utc=ga.sunday.utc.range,ga.weekOfYear=ga.sundayOfYear;var ya={"-":"",_:" ",0:"0"},ma=/^\s*\d+/,Ma=/^%/;ao.locale=function(n){return{numberFormat:jn(n),timeFormat:Yn(n)}};var xa=ao.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});ao.format=xa.numberFormat,ao.geo={},ft.prototype={s:0,t:0,add:function(n){st(n,this.t,ba),st(ba.s,this.s,this),this.s?this.t+=ba.t:this.s=ba.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ba=new ft;ao.geo.stream=function(n,t){n&&_a.hasOwnProperty(n.type)?_a[n.type](n,t):ht(n,t)};var _a={Feature:function(n,t){ht(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)ht(e[r].geometry,t)}},wa={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){pt(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)pt(e[r],t,0)},Polygon:function(n,t){gt(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)gt(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)ht(e[r],t)}};ao.geo.area=function(n){return Sa=0,ao.geo.stream(n,Na),Sa};var Sa,ka=new ft,Na={sphere:function(){Sa+=4*Fo},point:b,lineStart:b,lineEnd:b,polygonStart:function(){ka.reset(),Na.lineStart=vt},polygonEnd:function(){var n=2*ka;Sa+=0>n?4*Fo+n:n,Na.lineStart=Na.lineEnd=Na.point=b}};ao.geo.bounds=function(){function n(n,t){M.push(x=[f=n,h=n]),s>t&&(s=t),t>p&&(p=t)}function t(t,e){var r=dt([t*Yo,e*Yo]);if(y){var i=mt(y,r),u=[i[1],-i[0],0],o=mt(u,i);bt(o),o=_t(o);var l=t-g,c=l>0?1:-1,v=o[0]*Zo*c,d=xo(l)>180;if(d^(v>c*g&&c*t>v)){var m=o[1]*Zo;m>p&&(p=m)}else if(v=(v+360)%360-180,d^(v>c*g&&c*t>v)){var m=-o[1]*Zo;s>m&&(s=m)}else s>e&&(s=e),e>p&&(p=e);d?g>t?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t):h>=f?(f>t&&(f=t),t>h&&(h=t)):t>g?a(f,t)>a(f,h)&&(h=t):a(t,h)>a(f,h)&&(f=t)}else n(t,e);y=r,g=t}function e(){b.point=t}function r(){x[0]=f,x[1]=h,b.point=n,y=null}function i(n,e){if(y){var r=n-g;m+=xo(r)>180?r+(r>0?360:-360):r}else v=n,d=e;Na.point(n,e),t(n,e)}function u(){Na.lineStart()}function o(){i(v,d),Na.lineEnd(),xo(m)>Uo&&(f=-(h=180)),x[0]=f,x[1]=h,y=null}function a(n,t){return(t-=n)<0?t+360:t}function l(n,t){return n[0]-t[0]}function c(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}var f,s,h,p,g,v,d,y,m,M,x,b={point:n,lineStart:e,lineEnd:r,polygonStart:function(){b.point=i,b.lineStart=u,b.lineEnd=o,m=0,Na.polygonStart()},polygonEnd:function(){Na.polygonEnd(),b.point=n,b.lineStart=e,b.lineEnd=r,0>ka?(f=-(h=180),s=-(p=90)):m>Uo?p=90:-Uo>m&&(s=-90),x[0]=f,x[1]=h}};return function(n){p=h=-(f=s=1/0),M=[],ao.geo.stream(n,b);var t=M.length;if(t){M.sort(l);for(var e,r=1,i=M[0],u=[i];t>r;++r)e=M[r],c(e[0],i)||c(e[1],i)?(a(i[0],e[1])>a(i[0],i[1])&&(i[1]=e[1]),a(e[0],i[1])>a(i[0],i[1])&&(i[0]=e[0])):u.push(i=e);for(var o,e,g=-(1/0),t=u.length-1,r=0,i=u[t];t>=r;i=e,++r)e=u[r],(o=a(i[1],e[0]))>g&&(g=o,f=e[0],h=i[1])}return M=x=null,f===1/0||s===1/0?[[NaN,NaN],[NaN,NaN]]:[[f,s],[h,p]]}}(),ao.geo.centroid=function(n){Ea=Aa=Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,ja);var t=Da,e=Pa,r=Ua,i=t*t+e*e+r*r;return jo>i&&(t=qa,e=Ta,r=Ra,Uo>Aa&&(t=Ca,e=za,r=La),i=t*t+e*e+r*r,jo>i)?[NaN,NaN]:[Math.atan2(e,t)*Zo,tn(r/Math.sqrt(i))*Zo]};var Ea,Aa,Ca,za,La,qa,Ta,Ra,Da,Pa,Ua,ja={sphere:b,point:St,lineStart:Nt,lineEnd:Et,polygonStart:function(){ja.lineStart=At},polygonEnd:function(){ja.lineStart=Nt}},Fa=Rt(zt,jt,Ht,[-Fo,-Fo/2]),Ha=1e9;ao.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),i=u(n),i.valid=!0,i},extent:function(a){return arguments.length?(u=Zt(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(ao.geo.conicEqualArea=function(){return Vt(Xt)}).raw=Xt,ao.geo.albers=function(){return ao.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},ao.geo.albersUsa=function(){function n(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}var t,e,r,i,u=ao.geo.albers(),o=ao.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=ao.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};return n.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&.234>i&&r>=-.425&&-.214>r?o:i>=.166&&.234>i&&r>=-.214&&-.115>r?a:u).invert(n)},n.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},n.precision=function(t){return arguments.length?(u.precision(t),o.precision(t),a.precision(t),n):u.precision()},n.scale=function(t){return arguments.length?(u.scale(t),o.scale(.35*t),a.scale(t),n.translate(u.translate())):u.scale()},n.translate=function(t){if(!arguments.length)return u.translate();var c=u.scale(),f=+t[0],s=+t[1];return e=u.translate(t).clipExtent([[f-.455*c,s-.238*c],[f+.455*c,s+.238*c]]).stream(l).point,r=o.translate([f-.307*c,s+.201*c]).clipExtent([[f-.425*c+Uo,s+.12*c+Uo],[f-.214*c-Uo,s+.234*c-Uo]]).stream(l).point,i=a.translate([f-.205*c,s+.212*c]).clipExtent([[f-.214*c+Uo,s+.166*c+Uo],[f-.115*c-Uo,s+.234*c-Uo]]).stream(l).point,n},n.scale(1070)};var Oa,Ia,Ya,Za,Va,Xa,$a={point:b,lineStart:b,lineEnd:b,polygonStart:function(){Ia=0,$a.lineStart=$t},polygonEnd:function(){$a.lineStart=$a.lineEnd=$a.point=b,Oa+=xo(Ia/2)}},Ba={point:Bt,lineStart:b,lineEnd:b,polygonStart:b,polygonEnd:b},Wa={point:Gt,lineStart:Kt,lineEnd:Qt,polygonStart:function(){Wa.lineStart=ne},polygonEnd:function(){Wa.point=Gt,Wa.lineStart=Kt,Wa.lineEnd=Qt}};ao.geo.path=function(){function n(n){return n&&("function"==typeof a&&u.pointRadius(+a.apply(this,arguments)),o&&o.valid||(o=i(u)),ao.geo.stream(n,o)),u.result()}function t(){return o=null,n}var e,r,i,u,o,a=4.5;return n.area=function(n){return Oa=0,ao.geo.stream(n,i($a)),Oa},n.centroid=function(n){return Ca=za=La=qa=Ta=Ra=Da=Pa=Ua=0,ao.geo.stream(n,i(Wa)),Ua?[Da/Ua,Pa/Ua]:Ra?[qa/Ra,Ta/Ra]:La?[Ca/La,za/La]:[NaN,NaN]},n.bounds=function(n){return Va=Xa=-(Ya=Za=1/0),ao.geo.stream(n,i(Ba)),[[Ya,Za],[Va,Xa]]},n.projection=function(n){return arguments.length?(i=(e=n)?n.stream||re(n):m,t()):e},n.context=function(n){return arguments.length?(u=null==(r=n)?new Wt:new te(n),"function"!=typeof a&&u.pointRadius(a),t()):r},n.pointRadius=function(t){return arguments.length?(a="function"==typeof t?t:(u.pointRadius(+t),+t),n):a},n.projection(ao.geo.albersUsa()).context(null)},ao.geo.transform=function(n){return{stream:function(t){var e=new ie(t);for(var r in n)e[r]=n[r];return e}}},ie.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},ao.geo.projection=oe,ao.geo.projectionMutator=ae,(ao.geo.equirectangular=function(){return oe(ce)}).raw=ce.invert=ce,ao.geo.rotation=function(n){function t(t){return t=n(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t}return n=se(n[0]%360*Yo,n[1]*Yo,n.length>2?n[2]*Yo:0),t.invert=function(t){return t=n.invert(t[0]*Yo,t[1]*Yo),t[0]*=Zo,t[1]*=Zo,t},t},fe.invert=ce,ao.geo.circle=function(){function n(){var n="function"==typeof r?r.apply(this,arguments):r,t=se(-n[0]*Yo,-n[1]*Yo,0).invert,i=[];return e(null,null,1,{point:function(n,e){i.push(n=t(n,e)),n[0]*=Zo,n[1]*=Zo}}),{type:"Polygon",coordinates:[i]}}var t,e,r=[0,0],i=6;return n.origin=function(t){return arguments.length?(r=t,n):r},n.angle=function(r){return arguments.length?(e=ve((t=+r)*Yo,i*Yo),n):t},n.precision=function(r){return arguments.length?(e=ve(t*Yo,(i=+r)*Yo),n):i},n.angle(90)},ao.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Yo,i=n[1]*Yo,u=t[1]*Yo,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},ao.geo.graticule=function(){function n(){return{type:"MultiLineString",coordinates:t()}}function t(){return ao.range(Math.ceil(u/d)*d,i,d).map(h).concat(ao.range(Math.ceil(c/y)*y,l,y).map(p)).concat(ao.range(Math.ceil(r/g)*g,e,g).filter(function(n){return xo(n%d)>Uo}).map(f)).concat(ao.range(Math.ceil(a/v)*v,o,v).filter(function(n){return xo(n%y)>Uo}).map(s))}var e,r,i,u,o,a,l,c,f,s,h,p,g=10,v=g,d=90,y=360,m=2.5;return n.lines=function(){return t().map(function(n){return{type:"LineString",coordinates:n}})},n.outline=function(){return{type:"Polygon",coordinates:[h(u).concat(p(l).slice(1),h(i).reverse().slice(1),p(c).reverse().slice(1))]}},n.extent=function(t){return arguments.length?n.majorExtent(t).minorExtent(t):n.minorExtent()},n.majorExtent=function(t){return arguments.length?(u=+t[0][0],i=+t[1][0],c=+t[0][1],l=+t[1][1],u>i&&(t=u,u=i,i=t),c>l&&(t=c,c=l,l=t),n.precision(m)):[[u,c],[i,l]]},n.minorExtent=function(t){return arguments.length?(r=+t[0][0],e=+t[1][0],a=+t[0][1],o=+t[1][1],r>e&&(t=r,r=e,e=t),a>o&&(t=a,a=o,o=t),n.precision(m)):[[r,a],[e,o]]},n.step=function(t){return arguments.length?n.majorStep(t).minorStep(t):n.minorStep()},n.majorStep=function(t){return arguments.length?(d=+t[0],y=+t[1],n):[d,y]},n.minorStep=function(t){return arguments.length?(g=+t[0],v=+t[1],n):[g,v]},n.precision=function(t){return arguments.length?(m=+t,f=ye(a,o,90),s=me(r,e,m),h=ye(c,l,90),p=me(u,i,m),n):m},n.majorExtent([[-180,-90+Uo],[180,90-Uo]]).minorExtent([[-180,-80-Uo],[180,80+Uo]])},ao.geo.greatArc=function(){function n(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}var t,e,r=Me,i=xe;return n.distance=function(){return ao.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},n.source=function(e){return arguments.length?(r=e,t="function"==typeof e?null:e,n):r},n.target=function(t){return arguments.length?(i=t,e="function"==typeof t?null:t,n):i},n.precision=function(){return arguments.length?n:0},n},ao.geo.interpolate=function(n,t){return be(n[0]*Yo,n[1]*Yo,t[0]*Yo,t[1]*Yo)},ao.geo.length=function(n){return Ja=0,ao.geo.stream(n,Ga),Ja};var Ja,Ga={sphere:b,point:b,lineStart:_e,lineEnd:b,polygonStart:b,polygonEnd:b},Ka=we(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(ao.geo.azimuthalEqualArea=function(){return oe(Ka)}).raw=Ka;var Qa=we(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},m);(ao.geo.azimuthalEquidistant=function(){return oe(Qa)}).raw=Qa,(ao.geo.conicConformal=function(){return Vt(Se)}).raw=Se,(ao.geo.conicEquidistant=function(){return Vt(ke)}).raw=ke;var nl=we(function(n){return 1/n},Math.atan);(ao.geo.gnomonic=function(){return oe(nl)}).raw=nl,Ne.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-Io]},(ao.geo.mercator=function(){return Ee(Ne)}).raw=Ne;var tl=we(function(){return 1},Math.asin);(ao.geo.orthographic=function(){return oe(tl)}).raw=tl;var el=we(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});(ao.geo.stereographic=function(){return oe(el)}).raw=el,Ae.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-Io]},(ao.geo.transverseMercator=function(){var n=Ee(Ae),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):(n=t(),[n[1],-n[0]])},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):(n=e(),[n[0],n[1],n[2]-90])},e([0,0,90])}).raw=Ae,ao.geom={},ao.geom.hull=function(n){function t(n){if(n.length<3)return[];var t,i=En(e),u=En(r),o=n.length,a=[],l=[];for(t=0;o>t;t++)a.push([+i.call(this,n[t],t),+u.call(this,n[t],t),t]);for(a.sort(qe),t=0;o>t;t++)l.push([a[t][0],-a[t][1]]);var c=Le(a),f=Le(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(t=c.length-1;t>=0;--t)p.push(n[a[c[t]][2]]);for(t=+s;t<f.length-h;++t)p.push(n[a[f[t]][2]]);return p}var e=Ce,r=ze;return arguments.length?t(n):(t.x=function(n){return arguments.length?(e=n,t):e},t.y=function(n){return arguments.length?(r=n,t):r},t)},ao.geom.polygon=function(n){return ko(n,rl),n};var rl=ao.geom.polygon.prototype=[];rl.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},rl.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},rl.clip=function(n){for(var t,e,r,i,u,o,a=De(n),l=-1,c=this.length-De(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)o=t[e],Te(o,f,i)?(Te(u,f,i)||n.push(Re(u,o,f,i)),n.push(o)):Te(u,f,i)&&n.push(Re(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var il,ul,ol,al,ll,cl=[],fl=[];Ye.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)n=t[e].edge,n.b&&n.a||t.splice(e,1);return t.sort(Ve),t.length},tr.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},er.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=or(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)r=e.U,e===r.L?(i=r.R,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(ir(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ur(this,r))):(i=r.L,i&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(ur(this,e),n=e,e=n.U),e.C=!1,r.C=!0,ir(this,r))),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?or(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r){if(n&&n.C)return void(n.C=!1);do{if(n===this._)break;if(n===i.L){if(t=i.R,t.C&&(t.C=!1,i.C=!0,ir(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,ur(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,ir(this,i),n=this._;break}}else if(t=i.L,t.C&&(t.C=!1,i.C=!0,ur(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,ir(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,ur(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},ao.geom.voronoi=function(n){function t(n){var t=new Array(n.length),r=a[0][0],i=a[0][1],u=a[1][0],o=a[1][1];return ar(e(n),a).cells.forEach(function(e,a){var l=e.edges,c=e.site,f=t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=r&&c.x<=u&&c.y>=i&&c.y<=o?[[r,o],[u,o],[u,i],[r,i]]:[];f.point=n[a]}),t}function e(n){return n.map(function(n,t){return{x:Math.round(u(n,t)/Uo)*Uo,y:Math.round(o(n,t)/Uo)*Uo,i:t}})}var r=Ce,i=ze,u=r,o=i,a=sl;return n?t(n):(t.links=function(n){return ar(e(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},t.triangles=function(n){var t=[];return ar(e(n)).cells.forEach(function(e,r){for(var i,u,o=e.site,a=e.edges.sort(Ve),l=-1,c=a.length,f=a[c-1].edge,s=f.l===o?f.r:f.l;++l<c;)i=f,u=s,f=a[l].edge,s=f.l===o?f.r:f.l,r<u.i&&r<s.i&&cr(o,u,s)<0&&t.push([n[r],n[u.i],n[s.i]])}),t},t.x=function(n){return arguments.length?(u=En(r=n),t):r},t.y=function(n){return arguments.length?(o=En(i=n),t):i},t.clipExtent=function(n){return arguments.length?(a=null==n?sl:n,t):a===sl?null:a},t.size=function(n){return arguments.length?t.clipExtent(n&&[[0,0],n]):a===sl?null:a&&a[1]},t)};var sl=[[-1e6,-1e6],[1e6,1e6]];ao.geom.delaunay=function(n){return ao.geom.voronoi().triangles(n)},ao.geom.quadtree=function(n,t,e,r,i){function u(n){function u(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,f=n.y;if(null!=l)if(xo(l-e)+xo(f-r)<.01)c(n,t,e,r,i,u,o,a);else{var s=n.point;n.x=n.y=n.point=null,c(n,s,l,f,i,u,o,a),c(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else c(n,t,e,r,i,u,o,a)}function c(n,t,e,r,i,o,a,l){var c=.5*(i+a),f=.5*(o+l),s=e>=c,h=r>=f,p=h<<1|s;n.leaf=!1,n=n.nodes[p]||(n.nodes[p]=hr()),s?i=c:a=c,h?o=f:l=f,u(n,t,e,r,i,o,a,l)}var f,s,h,p,g,v,d,y,m,M=En(a),x=En(l);if(null!=t)v=t,d=e,y=r,m=i;else if(y=m=-(v=d=1/0),s=[],h=[],g=n.length,o)for(p=0;g>p;++p)f=n[p],f.x<v&&(v=f.x),f.y<d&&(d=f.y),f.x>y&&(y=f.x),f.y>m&&(m=f.y),s.push(f.x),h.push(f.y);else for(p=0;g>p;++p){var b=+M(f=n[p],p),_=+x(f,p);v>b&&(v=b),d>_&&(d=_),b>y&&(y=b),_>m&&(m=_),s.push(b),h.push(_)}var w=y-v,S=m-d;w>S?m=d+w:y=v+S;var k=hr();if(k.add=function(n){u(k,n,+M(n,++p),+x(n,p),v,d,y,m)},k.visit=function(n){pr(n,k,v,d,y,m)},k.find=function(n){return gr(k,n[0],n[1],v,d,y,m)},p=-1,null==t){for(;++p<g;)u(k,n[p],s[p],h[p],v,d,y,m);--p}else n.forEach(k.add);return s=h=n=f=null,k}var o,a=Ce,l=ze;return(o=arguments.length)?(a=fr,l=sr,3===o&&(i=e,r=t,e=t=0),u(n)):(u.x=function(n){return arguments.length?(a=n,u):a},u.y=function(n){return arguments.length?(l=n,u):l},u.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),u):null==t?null:[[t,e],[r,i]]},u.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),u):null==t?null:[r-t,i-e]},u)},ao.interpolateRgb=vr,ao.interpolateObject=dr,ao.interpolateNumber=yr,ao.interpolateString=mr;var hl=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,pl=new RegExp(hl.source,"g");ao.interpolate=Mr,ao.interpolators=[function(n,t){var e=typeof t;return("string"===e?ua.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?vr:mr:t instanceof an?vr:Array.isArray(t)?xr:"object"===e&&isNaN(t)?dr:yr)(n,t)}],ao.interpolateArray=xr;var gl=function(){return m},vl=ao.map({linear:gl,poly:Er,quad:function(){return Sr},cubic:function(){return kr},sin:function(){return Ar},exp:function(){return Cr},circle:function(){return zr},elastic:Lr,back:qr,bounce:function(){return Tr}}),dl=ao.map({"in":m,out:_r,"in-out":wr,"out-in":function(n){return wr(_r(n))}});ao.ease=function(n){var t=n.indexOf("-"),e=t>=0?n.slice(0,t):n,r=t>=0?n.slice(t+1):"in";return e=vl.get(e)||gl,r=dl.get(r)||m,br(r(e.apply(null,lo.call(arguments,1))))},ao.interpolateHcl=Rr,ao.interpolateHsl=Dr,ao.interpolateLab=Pr,ao.interpolateRound=Ur,ao.transform=function(n){var t=fo.createElementNS(ao.ns.prefix.svg,"g");return(ao.transform=function(n){if(null!=n){t.setAttribute("transform",n);var e=t.transform.baseVal.consolidate()}return new jr(e?e.matrix:yl)})(n)},jr.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var yl={a:1,b:0,c:0,d:1,e:0,f:0};ao.interpolateTransform=$r,ao.layout={},ao.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(Jr(n[e]));return t}},ao.layout.chord=function(){function n(){var n,c,s,h,p,g={},v=[],d=ao.range(u),y=[];for(e=[],r=[],n=0,h=-1;++h<u;){for(c=0,p=-1;++p<u;)c+=i[h][p];v.push(c),y.push(ao.range(u)),n+=c}for(o&&d.sort(function(n,t){return o(v[n],v[t])}),a&&y.forEach(function(n,t){n.sort(function(n,e){return a(i[t][n],i[t][e])})}),n=(Ho-f*u)/n,c=0,h=-1;++h<u;){for(s=c,p=-1;++p<u;){var m=d[h],M=y[m][p],x=i[m][M],b=c,_=c+=x*n;g[m+"-"+M]={index:m,subindex:M,startAngle:b,endAngle:_,value:x}}r[m]={index:m,startAngle:s,endAngle:c,value:v[m]},c+=f}for(h=-1;++h<u;)for(p=h-1;++p<u;){var w=g[h+"-"+p],S=g[p+"-"+h];(w.value||S.value)&&e.push(w.value<S.value?{source:S,target:w}:{source:w,target:S})}l&&t()}function t(){e.sort(function(n,t){return l((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}var e,r,i,u,o,a,l,c={},f=0;return c.matrix=function(n){return arguments.length?(u=(i=n)&&i.length,e=r=null,c):i},c.padding=function(n){return arguments.length?(f=n,e=r=null,c):f},c.sortGroups=function(n){return arguments.length?(o=n,e=r=null,c):o},c.sortSubgroups=function(n){return arguments.length?(a=n,e=null,c):a},c.sortChords=function(n){return arguments.length?(l=n,e&&t(),c):l},c.chords=function(){return e||n(),e},c.groups=function(){return r||n(),r},c},ao.layout.force=function(){function n(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(l>a*a/y){if(v>l){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&v>l){var c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function t(n){n.px=ao.event.x,n.py=ao.event.y,l.resume()}var e,r,i,u,o,a,l={},c=ao.dispatch("start","tick","end"),f=[1,1],s=.9,h=ml,p=Ml,g=-30,v=xl,d=.1,y=.64,M=[],x=[];return l.tick=function(){if((i*=.99)<.005)return e=null,c.end({type:"end",alpha:i=0}),!0;var t,r,l,h,p,v,y,m,b,_=M.length,w=x.length;for(r=0;w>r;++r)l=x[r],h=l.source,p=l.target,m=p.x-h.x,b=p.y-h.y,(v=m*m+b*b)&&(v=i*o[r]*((v=Math.sqrt(v))-u[r])/v,m*=v,b*=v,p.x-=m*(y=h.weight+p.weight?h.weight/(h.weight+p.weight):.5),p.y-=b*y,h.x+=m*(y=1-y),h.y+=b*y);if((y=i*d)&&(m=f[0]/2,b=f[1]/2,r=-1,y))for(;++r<_;)l=M[r],l.x+=(m-l.x)*y,l.y+=(b-l.y)*y;if(g)for(ri(t=ao.geom.quadtree(M),i,a),r=-1;++r<_;)(l=M[r]).fixed||t.visit(n(l));for(r=-1;++r<_;)l=M[r],l.fixed?(l.x=l.px,l.y=l.py):(l.x-=(l.px-(l.px=l.x))*s,l.y-=(l.py-(l.py=l.y))*s);c.tick({type:"tick",alpha:i})},l.nodes=function(n){return arguments.length?(M=n,l):M},l.links=function(n){return arguments.length?(x=n,l):x},l.size=function(n){return arguments.length?(f=n,l):f},l.linkDistance=function(n){return arguments.length?(h="function"==typeof n?n:+n,l):h},l.distance=l.linkDistance,l.linkStrength=function(n){return arguments.length?(p="function"==typeof n?n:+n,l):p},l.friction=function(n){return arguments.length?(s=+n,l):s},l.charge=function(n){return arguments.length?(g="function"==typeof n?n:+n,l):g},l.chargeDistance=function(n){return arguments.length?(v=n*n,l):Math.sqrt(v)},l.gravity=function(n){return arguments.length?(d=+n,l):d},l.theta=function(n){return arguments.length?(y=n*n,l):Math.sqrt(y)},l.alpha=function(n){return arguments.length?(n=+n,i?n>0?i=n:(e.c=null,e.t=NaN,e=null,c.end({type:"end",alpha:i=0})):n>0&&(c.start({type:"start",alpha:i=n}),e=qn(l.tick)),l):i},l.start=function(){function n(n,r){if(!e){for(e=new Array(i),l=0;i>l;++l)e[l]=[];for(l=0;c>l;++l){var u=x[l];e[u.source.index].push(u.target),e[u.target.index].push(u.source)}}for(var o,a=e[t],l=-1,f=a.length;++l<f;)if(!isNaN(o=a[l][n]))return o;return Math.random()*r}var t,e,r,i=M.length,c=x.length,s=f[0],v=f[1];for(t=0;i>t;++t)(r=M[t]).index=t,r.weight=0;for(t=0;c>t;++t)r=x[t],"number"==typeof r.source&&(r.source=M[r.source]),"number"==typeof r.target&&(r.target=M[r.target]),++r.source.weight,++r.target.weight;for(t=0;i>t;++t)r=M[t],isNaN(r.x)&&(r.x=n("x",s)),isNaN(r.y)&&(r.y=n("y",v)),isNaN(r.px)&&(r.px=r.x),isNaN(r.py)&&(r.py=r.y);if(u=[],"function"==typeof h)for(t=0;c>t;++t)u[t]=+h.call(this,x[t],t);else for(t=0;c>t;++t)u[t]=h;if(o=[],"function"==typeof p)for(t=0;c>t;++t)o[t]=+p.call(this,x[t],t);else for(t=0;c>t;++t)o[t]=p;if(a=[],"function"==typeof g)for(t=0;i>t;++t)a[t]=+g.call(this,M[t],t);else for(t=0;i>t;++t)a[t]=g;return l.resume()},l.resume=function(){return l.alpha(.1)},l.stop=function(){return l.alpha(0)},l.drag=function(){return r||(r=ao.behavior.drag().origin(m).on("dragstart.force",Qr).on("drag.force",t).on("dragend.force",ni)),arguments.length?void this.on("mouseover.force",ti).on("mouseout.force",ei).call(r):r},ao.rebind(l,c,"on")};var ml=20,Ml=1,xl=1/0;ao.layout.hierarchy=function(){function n(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=e.call(n,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;r&&(u.value=0),u.children=c}else r&&(u.value=+r.call(n,u,u.depth)||0),delete u.children;return oi(i,function(n){var e,i;t&&(e=n.children)&&e.sort(t),r&&(i=n.parent)&&(i.value+=n.value)}),a}var t=ci,e=ai,r=li;return n.sort=function(e){return arguments.length?(t=e,n):t},n.children=function(t){return arguments.length?(e=t,n):e},n.value=function(t){return arguments.length?(r=t,n):r},n.revalue=function(t){return r&&(ui(t,function(n){n.children&&(n.value=0)}),oi(t,function(t){var e;t.children||(t.value=+r.call(n,t,t.depth)||0),(e=t.parent)&&(e.value+=t.value)})),t},n},ao.layout.partition=function(){function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}function t(n){var e=n.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,t(e[u]));return 1+r}function e(e,u){var o=r.call(this,e,u);return n(o[0],0,i[0],i[1]/t(o[0])),o}var r=ao.layout.hierarchy(),i=[1,1];return e.size=function(n){return arguments.length?(i=n,e):i},ii(e,r)},ao.layout.pie=function(){function n(o){var a,l=o.length,c=o.map(function(e,r){return+t.call(n,e,r)}),f=+("function"==typeof r?r.apply(this,arguments):r),s=("function"==typeof i?i.apply(this,arguments):i)-f,h=Math.min(Math.abs(s)/l,+("function"==typeof u?u.apply(this,arguments):u)),p=h*(0>s?-1:1),g=ao.sum(c),v=g?(s-l*p)/g:0,d=ao.range(l),y=[];return null!=e&&d.sort(e===bl?function(n,t){return c[t]-c[n]}:function(n,t){return e(o[n],o[t])}),d.forEach(function(n){y[n]={data:o[n],value:a=c[n],startAngle:f,endAngle:f+=a*v+p,padAngle:h}}),y}var t=Number,e=bl,r=0,i=Ho,u=0;return n.value=function(e){return arguments.length?(t=e,n):t},n.sort=function(t){return arguments.length?(e=t,n):e},n.startAngle=function(t){return arguments.length?(r=t,n):r},n.endAngle=function(t){return arguments.length?(i=t,n):i},n.padAngle=function(t){return arguments.length?(u=t,n):u},n};var bl={};ao.layout.stack=function(){function n(a,l){if(!(h=a.length))return a;var c=a.map(function(e,r){return t.call(n,e,r)}),f=c.map(function(t){return t.map(function(t,e){return[u.call(n,t,e),o.call(n,t,e)]})}),s=e.call(n,f,l);c=ao.permute(c,s),f=ao.permute(f,s);var h,p,g,v,d=r.call(n,f,l),y=c[0].length;for(g=0;y>g;++g)for(i.call(n,c[0][g],v=d[g],f[0][g][1]),p=1;h>p;++p)i.call(n,c[p][g],v+=f[p-1][g][1],f[p][g][1]);return a}var t=m,e=gi,r=vi,i=pi,u=si,o=hi;return n.values=function(e){return arguments.length?(t=e,n):t},n.order=function(t){return arguments.length?(e="function"==typeof t?t:_l.get(t)||gi,n):e},n.offset=function(t){return arguments.length?(r="function"==typeof t?t:wl.get(t)||vi,n):r},n.x=function(t){return arguments.length?(u=t,n):u},n.y=function(t){return arguments.length?(o=t,n):o},n.out=function(t){return arguments.length?(i=t,n):i},n};var _l=ao.map({"inside-out":function(n){var t,e,r=n.length,i=n.map(di),u=n.map(yi),o=ao.range(r).sort(function(n,t){return i[n]-i[t]}),a=0,l=0,c=[],f=[];for(t=0;r>t;++t)e=o[t],l>a?(a+=u[e],c.push(e)):(l+=u[e],f.push(e));return f.reverse().concat(c)},reverse:function(n){return ao.range(n.length).reverse()},"default":gi}),wl=ao.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;u>e;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;h>e;++e){for(t=0,i=0;f>t;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];f>t;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);t>r;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,c>l&&(c=l)}for(e=0;h>e;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;u>e;++e){for(t=0,r=0;i>t;t++)r+=n[t][e][1];if(r)for(t=0;i>t;t++)n[t][e][1]/=r;else for(t=0;i>t;t++)n[t][e][1]=o}for(e=0;u>e;++e)a[e]=0;return a},zero:vi});ao.layout.histogram=function(){function n(n,u){for(var o,a,l=[],c=n.map(e,this),f=r.call(this,c,u),s=i.call(this,f,c,u),u=-1,h=c.length,p=s.length-1,g=t?1:1/h;++u<p;)o=l[u]=[],o.dx=s[u+1]-(o.x=s[u]),o.y=0;if(p>0)for(u=-1;++u<h;)a=c[u],a>=f[0]&&a<=f[1]&&(o=l[ao.bisect(s,a,1,p)-1],o.y+=g,o.push(n[u]));return l}var t=!0,e=Number,r=bi,i=Mi;return n.value=function(t){return arguments.length?(e=t,n):e},n.range=function(t){return arguments.length?(r=En(t),n):r},n.bins=function(t){return arguments.length?(i="number"==typeof t?function(n){return xi(n,t)}:En(t),n):i},n.frequency=function(e){return arguments.length?(t=!!e,n):t},n},ao.layout.pack=function(){function n(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,oi(a,function(n){n.r=+f(n.value)}),oi(a,Ni),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;oi(a,function(n){n.r+=s}),oi(a,Ni),oi(a,function(n){n.r-=s})}return Ci(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}var t,e=ao.layout.hierarchy().sort(_i),r=0,i=[1,1];return n.size=function(t){return arguments.length?(i=t,n):i},n.radius=function(e){return arguments.length?(t=null==e||"function"==typeof e?e:+e,n):t},n.padding=function(t){return arguments.length?(r=+t,n):r},ii(n,e)},ao.layout.tree=function(){function n(n,i){var f=o.call(this,n,i),s=f[0],h=t(s);if(oi(h,e),h.parent.m=-h.z,ui(h,r),c)ui(s,u);else{var p=s,g=s,v=s;ui(s,function(n){n.x<p.x&&(p=n),n.x>g.x&&(g=n),n.depth>v.depth&&(v=n)});var d=a(p,g)/2-p.x,y=l[0]/(g.x+a(g,p)/2+d),m=l[1]/(v.depth||1);ui(s,function(n){n.x=(n.x+d)*y,n.y=n.depth*m})}return f}function t(n){for(var t,e={A:null,children:[n]},r=[e];null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;a>o;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}function e(n){var t=n.children,e=n.parent.children,r=n.i?e[n.i-1]:null;if(t.length){Di(n);var u=(t[0].z+t[t.length-1].z)/2;r?(n.z=r.z+a(n._,r._),n.m=n.z-u):n.z=u}else r&&(n.z=r.z+a(n._,r._));n.parent.A=i(n,r,n.parent.A||e[0])}function r(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function i(n,t,e){if(t){for(var r,i=n,u=n,o=t,l=i.parent.children[0],c=i.m,f=u.m,s=o.m,h=l.m;o=Ti(o),i=qi(i),o&&i;)l=qi(l),u=Ti(u),u.a=n,r=o.z+s-i.z-c+a(o._,i._),r>0&&(Ri(Pi(o,n,e),n,r),c+=r,f+=r),s+=o.m,c+=i.m,h+=l.m,f+=u.m;o&&!Ti(u)&&(u.t=o,u.m+=s-f),i&&!qi(l)&&(l.t=i,l.m+=c-h,e=n)}return e}function u(n){n.x*=l[0],n.y=n.depth*l[1]}var o=ao.layout.hierarchy().sort(null).value(null),a=Li,l=[1,1],c=null;return n.separation=function(t){return arguments.length?(a=t,n):a},n.size=function(t){return arguments.length?(c=null==(l=t)?u:null,n):c?null:l},n.nodeSize=function(t){return arguments.length?(c=null==(l=t)?null:u,n):c?l:null},ii(n,o)},ao.layout.cluster=function(){function n(n,u){var o,a=t.call(this,n,u),l=a[0],c=0;oi(l,function(n){var t=n.children;t&&t.length?(n.x=ji(t),n.y=Ui(t)):(n.x=o?c+=e(n,o):0,n.y=0,o=n)});var f=Fi(l),s=Hi(l),h=f.x-e(f,s)/2,p=s.x+e(s,f)/2;return oi(l,i?function(n){n.x=(n.x-l.x)*r[0],n.y=(l.y-n.y)*r[1]}:function(n){n.x=(n.x-h)/(p-h)*r[0],n.y=(1-(l.y?n.y/l.y:1))*r[1]}),a}var t=ao.layout.hierarchy().sort(null).value(null),e=Li,r=[1,1],i=!1;return n.separation=function(t){return arguments.length?(e=t,n):e},n.size=function(t){return arguments.length?(i=null==(r=t),n):i?null:r},n.nodeSize=function(t){return arguments.length?(i=null!=(r=t),n):i?r:null},ii(n,t)},ao.layout.treemap=function(){function n(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(0>t?0:t),e.area=isNaN(r)||0>=r?0:r}function t(e){var u=e.children;if(u&&u.length){var o,a,l,c=s(e),f=[],h=u.slice(),g=1/0,v="slice"===p?c.dx:"dice"===p?c.dy:"slice-dice"===p?1&e.depth?c.dy:c.dx:Math.min(c.dx,c.dy);for(n(h,c.dx*c.dy/e.value),f.area=0;(l=h.length)>0;)f.push(o=h[l-1]),f.area+=o.area,"squarify"!==p||(a=r(f,v))<=g?(h.pop(),g=a):(f.area-=f.pop().area,i(f,v,c,!1),v=Math.min(c.dx,c.dy),f.length=f.area=0,g=1/0);f.length&&(i(f,v,c,!0),f.length=f.area=0),u.forEach(t)}}function e(t){var r=t.children;if(r&&r.length){var u,o=s(t),a=r.slice(),l=[];for(n(a,o.dx*o.dy/t.value),l.area=0;u=a.pop();)l.push(u),l.area+=u.area,null!=u.z&&(i(l,u.z?o.dx:o.dy,o,!a.length),l.length=l.area=0);r.forEach(e)}}function r(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(u>e&&(u=e),e>i&&(i=e));return r*=r,t*=t,r?Math.max(t*i*g/r,r/(t*u*g)):1/0}function i(n,t,e,r){var i,u=-1,o=n.length,a=e.x,c=e.y,f=t?l(n.area/t):0;
if(t==e.dx){for((r||f>e.dy)&&(f=e.dy);++u<o;)i=n[u],i.x=a,i.y=c,i.dy=f,a+=i.dx=Math.min(e.x+e.dx-a,f?l(i.area/f):0);i.z=!0,i.dx+=e.x+e.dx-a,e.y+=f,e.dy-=f}else{for((r||f>e.dx)&&(f=e.dx);++u<o;)i=n[u],i.x=a,i.y=c,i.dx=f,c+=i.dy=Math.min(e.y+e.dy-c,f?l(i.area/f):0);i.z=!1,i.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function u(r){var i=o||a(r),u=i[0];return u.x=u.y=0,u.value?(u.dx=c[0],u.dy=c[1]):u.dx=u.dy=0,o&&a.revalue(u),n([u],u.dx*u.dy/u.value),(o?e:t)(u),h&&(o=i),i}var o,a=ao.layout.hierarchy(),l=Math.round,c=[1,1],f=null,s=Oi,h=!1,p="squarify",g=.5*(1+Math.sqrt(5));return u.size=function(n){return arguments.length?(c=n,u):c},u.padding=function(n){function t(t){var e=n.call(u,t,t.depth);return null==e?Oi(t):Ii(t,"number"==typeof e?[e,e,e,e]:e)}function e(t){return Ii(t,n)}if(!arguments.length)return f;var r;return s=null==(f=n)?Oi:"function"==(r=typeof n)?t:"number"===r?(n=[n,n,n,n],e):e,u},u.round=function(n){return arguments.length?(l=n?Math.round:Number,u):l!=Number},u.sticky=function(n){return arguments.length?(h=n,o=null,u):h},u.ratio=function(n){return arguments.length?(g=n,u):g},u.mode=function(n){return arguments.length?(p=n+"",u):p},ii(u,a)},ao.random={normal:function(n,t){var e=arguments.length;return 2>e&&(t=1),1>e&&(n=0),function(){var e,r,i;do e=2*Math.random()-1,r=2*Math.random()-1,i=e*e+r*r;while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var n=ao.random.normal.apply(ao,arguments);return function(){return Math.exp(n())}},bates:function(n){var t=ao.random.irwinHall(n);return function(){return t()/n}},irwinHall:function(n){return function(){for(var t=0,e=0;n>e;e++)t+=Math.random();return t}}},ao.scale={};var Sl={floor:m,ceil:m};ao.scale.linear=function(){return Wi([0,1],[0,1],Mr,!1)};var kl={s:1,g:1,p:1,r:1,e:1};ao.scale.log=function(){return ru(ao.scale.linear().domain([0,1]),10,!0,[1,10])};var Nl=ao.format(".0e"),El={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};ao.scale.pow=function(){return iu(ao.scale.linear(),1,[0,1])},ao.scale.sqrt=function(){return ao.scale.pow().exponent(.5)},ao.scale.ordinal=function(){return ou([],{t:"range",a:[[]]})},ao.scale.category10=function(){return ao.scale.ordinal().range(Al)},ao.scale.category20=function(){return ao.scale.ordinal().range(Cl)},ao.scale.category20b=function(){return ao.scale.ordinal().range(zl)},ao.scale.category20c=function(){return ao.scale.ordinal().range(Ll)};var Al=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(xn),Cl=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(xn),zl=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(xn),Ll=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(xn);ao.scale.quantile=function(){return au([],[])},ao.scale.quantize=function(){return lu(0,1,[0,1])},ao.scale.threshold=function(){return cu([.5],[0,1])},ao.scale.identity=function(){return fu([0,1])},ao.svg={},ao.svg.arc=function(){function n(){var n=Math.max(0,+e.apply(this,arguments)),c=Math.max(0,+r.apply(this,arguments)),f=o.apply(this,arguments)-Io,s=a.apply(this,arguments)-Io,h=Math.abs(s-f),p=f>s?0:1;if(n>c&&(g=c,c=n,n=g),h>=Oo)return t(c,p)+(n?t(n,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+l.apply(this,arguments)||0)/2)&&(d=u===ql?Math.sqrt(n*n+c*c):+u.apply(this,arguments),p||(E*=-1),c&&(E=tn(d/c*Math.sin(y))),n&&(N=tn(d/n*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=Fo?0:1;if(E&&yu(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(n){_=n*Math.cos(s-N),w=n*Math.sin(s-N),S=n*Math.cos(f+N),k=n*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=Fo?0:1;if(N&&yu(_,w,S,k)===1-p^L){var q=(f+s)/2;_=n*Math.cos(q),w=n*Math.sin(q),S=k=null}}else _=w=0;if(h>Uo&&(g=Math.min(Math.abs(c-n)/2,+i.apply(this,arguments)))>.001){v=c>n^p?0:1;var T=g,R=g;if(Fo>h){var D=null==S?[_,w]:null==x?[m,M]:Re([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(n-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=mu(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=mu([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^yu(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=mu([m,M],[S,k],n,-R,p),V=mu([_,w],null==x?[m,M]:[x,b],n,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",n,",",n," 0 ",p^yu(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",n,",",n," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function t(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}var e=hu,r=pu,i=su,u=ql,o=gu,a=vu,l=du;return n.innerRadius=function(t){return arguments.length?(e=En(t),n):e},n.outerRadius=function(t){return arguments.length?(r=En(t),n):r},n.cornerRadius=function(t){return arguments.length?(i=En(t),n):i},n.padRadius=function(t){return arguments.length?(u=t==ql?ql:En(t),n):u},n.startAngle=function(t){return arguments.length?(o=En(t),n):o},n.endAngle=function(t){return arguments.length?(a=En(t),n):a},n.padAngle=function(t){return arguments.length?(l=En(t),n):l},n.centroid=function(){var n=(+e.apply(this,arguments)+ +r.apply(this,arguments))/2,t=(+o.apply(this,arguments)+ +a.apply(this,arguments))/2-Io;return[Math.cos(t)*n,Math.sin(t)*n]},n};var ql="auto";ao.svg.line=function(){return Mu(m)};var Tl=ao.map({linear:xu,"linear-closed":bu,step:_u,"step-before":wu,"step-after":Su,basis:zu,"basis-open":Lu,"basis-closed":qu,bundle:Tu,cardinal:Eu,"cardinal-open":ku,"cardinal-closed":Nu,monotone:Fu});Tl.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Rl=[0,2/3,1/3,0],Dl=[0,1/3,2/3,0],Pl=[0,1/6,2/3,1/6];ao.svg.line.radial=function(){var n=Mu(Hu);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},wu.reverse=Su,Su.reverse=wu,ao.svg.area=function(){return Ou(m)},ao.svg.area.radial=function(){var n=Ou(Hu);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},ao.svg.chord=function(){function n(n,a){var l=t(this,u,n,a),c=t(this,o,n,a);return"M"+l.p0+r(l.r,l.p1,l.a1-l.a0)+(e(l,c)?i(l.r,l.p1,l.r,l.p0):i(l.r,l.p1,c.r,c.p0)+r(c.r,c.p1,c.a1-c.a0)+i(c.r,c.p1,l.r,l.p0))+"Z"}function t(n,t,e,r){var i=t.call(n,e,r),u=a.call(n,i,r),o=l.call(n,i,r)-Io,f=c.call(n,i,r)-Io;return{r:u,a0:o,a1:f,p0:[u*Math.cos(o),u*Math.sin(o)],p1:[u*Math.cos(f),u*Math.sin(f)]}}function e(n,t){return n.a0==t.a0&&n.a1==t.a1}function r(n,t,e){return"A"+n+","+n+" 0 "+ +(e>Fo)+",1 "+t}function i(n,t,e,r){return"Q 0,0 "+r}var u=Me,o=xe,a=Iu,l=gu,c=vu;return n.radius=function(t){return arguments.length?(a=En(t),n):a},n.source=function(t){return arguments.length?(u=En(t),n):u},n.target=function(t){return arguments.length?(o=En(t),n):o},n.startAngle=function(t){return arguments.length?(l=En(t),n):l},n.endAngle=function(t){return arguments.length?(c=En(t),n):c},n},ao.svg.diagonal=function(){function n(n,i){var u=t.call(this,n,i),o=e.call(this,n,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return l=l.map(r),"M"+l[0]+"C"+l[1]+" "+l[2]+" "+l[3]}var t=Me,e=xe,r=Yu;return n.source=function(e){return arguments.length?(t=En(e),n):t},n.target=function(t){return arguments.length?(e=En(t),n):e},n.projection=function(t){return arguments.length?(r=t,n):r},n},ao.svg.diagonal.radial=function(){var n=ao.svg.diagonal(),t=Yu,e=n.projection;return n.projection=function(n){return arguments.length?e(Zu(t=n)):t},n},ao.svg.symbol=function(){function n(n,r){return(Ul.get(t.call(this,n,r))||$u)(e.call(this,n,r))}var t=Xu,e=Vu;return n.type=function(e){return arguments.length?(t=En(e),n):t},n.size=function(t){return arguments.length?(e=En(t),n):e},n};var Ul=ao.map({circle:$u,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*Fl)),e=t*Fl;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/jl),e=t*jl/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});ao.svg.symbolTypes=Ul.keys();var jl=Math.sqrt(3),Fl=Math.tan(30*Yo);Co.transition=function(n){for(var t,e,r=Hl||++Zl,i=Ku(n),u=[],o=Ol||{time:Date.now(),ease:Nr,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&Qu(e,f,i,r,o),t.push(e)}return Wu(u,i,r)},Co.interrupt=function(n){return this.each(null==n?Il:Bu(Ku(n)))};var Hl,Ol,Il=Bu(Ku()),Yl=[],Zl=0;Yl.call=Co.call,Yl.empty=Co.empty,Yl.node=Co.node,Yl.size=Co.size,ao.transition=function(n,t){return n&&n.transition?Hl?n.transition(t):n:ao.selection().transition(n)},ao.transition.prototype=Yl,Yl.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=A(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),Qu(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return Wu(o,u,i)},Yl.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=C(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&Qu(i,g,a,o,u),t.push(i)}return Wu(l,a,o)},Yl.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=O(n));for(var u=0,o=this.length;o>u;u++){i.push(t=[]);for(var e=this[u],a=0,l=e.length;l>a;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return Wu(i,this.namespace,this.id)},Yl.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):Y(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},Yl.attr=function(n,t){function e(){this.removeAttribute(a)}function r(){this.removeAttributeNS(a.space,a.local)}function i(n){return null==n?e:(n+="",function(){var t,e=this.getAttribute(a);return e!==n&&(t=o(e,n),function(n){this.setAttribute(a,t(n))})})}function u(n){return null==n?r:(n+="",function(){var t,e=this.getAttributeNS(a.space,a.local);return e!==n&&(t=o(e,n),function(n){this.setAttributeNS(a.space,a.local,t(n))})})}if(arguments.length<2){for(t in n)this.attr(t,n[t]);return this}var o="transform"==n?$r:Mr,a=ao.ns.qualify(n);return Ju(this,"attr."+n,t,a.local?u:i)},Yl.attrTween=function(n,t){function e(n,e){var r=t.call(this,n,e,this.getAttribute(i));return r&&function(n){this.setAttribute(i,r(n))}}function r(n,e){var r=t.call(this,n,e,this.getAttributeNS(i.space,i.local));return r&&function(n){this.setAttributeNS(i.space,i.local,r(n))}}var i=ao.ns.qualify(n);return this.tween("attr."+n,i.local?r:e)},Yl.style=function(n,e,r){function i(){this.style.removeProperty(n)}function u(e){return null==e?i:(e+="",function(){var i,u=t(this).getComputedStyle(this,null).getPropertyValue(n);return u!==e&&(i=Mr(u,e),function(t){this.style.setProperty(n,i(t),r)})})}var o=arguments.length;if(3>o){if("string"!=typeof n){2>o&&(e="");for(r in n)this.style(r,n[r],e);return this}r=""}return Ju(this,"style."+n,e,u)},Yl.styleTween=function(n,e,r){function i(i,u){var o=e.call(this,i,u,t(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),r)}}return arguments.length<3&&(r=""),this.tween("style."+n,i)},Yl.text=function(n){return Ju(this,"text",n,Gu)},Yl.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},Yl.ease=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].ease:("function"!=typeof n&&(n=ao.ease.apply(ao,arguments)),Y(this,function(r){r[e][t].ease=n}))},Yl.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:Y(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},Yl.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:Y(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},Yl.each=function(n,t){var e=this.id,r=this.namespace;if(arguments.length<2){var i=Ol,u=Hl;try{Hl=e,Y(this,function(t,i,u){Ol=t[r][e],n.call(t,t.__data__,i,u)})}finally{Ol=i,Hl=u}}else Y(this,function(i){var u=i[r][e];(u.event||(u.event=ao.dispatch("start","end","interrupt"))).on(n,t)});return this},Yl.transition=function(){for(var n,t,e,r,i=this.id,u=++Zl,o=this.namespace,a=[],l=0,c=this.length;c>l;l++){a.push(n=[]);for(var t=this[l],f=0,s=t.length;s>f;f++)(e=t[f])&&(r=e[o][i],Qu(e,f,o,u,{time:r.time,ease:r.ease,delay:r.delay+r.duration,duration:r.duration})),n.push(e)}return Wu(a,o,u)},ao.svg.axis=function(){function n(n){n.each(function(){var n,c=ao.select(this),f=this.__chart__||e,s=this.__chart__=e.copy(),h=null==l?s.ticks?s.ticks.apply(s,a):s.domain():l,p=null==t?s.tickFormat?s.tickFormat.apply(s,a):m:t,g=c.selectAll(".tick").data(h,s),v=g.enter().insert("g",".domain").attr("class","tick").style("opacity",Uo),d=ao.transition(g.exit()).style("opacity",Uo).remove(),y=ao.transition(g.order()).style("opacity",1),M=Math.max(i,0)+o,x=Zi(s),b=c.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),ao.transition(b));v.append("line"),v.append("text");var w,S,k,N,E=v.select("line"),A=y.select("line"),C=g.select("text").text(p),z=v.select("text"),L=y.select("text"),q="top"===r||"left"===r?-1:1;if("bottom"===r||"top"===r?(n=no,w="x",k="y",S="x2",N="y2",C.attr("dy",0>q?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+q*u+"V0H"+x[1]+"V"+q*u)):(n=to,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",0>q?"end":"start"),_.attr("d","M"+q*u+","+x[0]+"H0V"+x[1]+"H"+q*u)),E.attr(N,q*i),z.attr(k,q*M),A.attr(S,0).attr(N,q*i),L.attr(w,0).attr(k,q*M),s.rangeBand){var T=s,R=T.rangeBand()/2;f=s=function(n){return T(n)+R}}else f.rangeBand?f=s:d.call(n,s,f);v.call(n,f,s),y.call(n,s,s)})}var t,e=ao.scale.linear(),r=Vl,i=6,u=6,o=3,a=[10],l=null;return n.scale=function(t){return arguments.length?(e=t,n):e},n.orient=function(t){return arguments.length?(r=t in Xl?t+"":Vl,n):r},n.ticks=function(){return arguments.length?(a=co(arguments),n):a},n.tickValues=function(t){return arguments.length?(l=t,n):l},n.tickFormat=function(e){return arguments.length?(t=e,n):t},n.tickSize=function(t){var e=arguments.length;return e?(i=+t,u=+arguments[e-1],n):i},n.innerTickSize=function(t){return arguments.length?(i=+t,n):i},n.outerTickSize=function(t){return arguments.length?(u=+t,n):u},n.tickPadding=function(t){return arguments.length?(o=+t,n):o},n.tickSubdivide=function(){return arguments.length&&n},n};var Vl="bottom",Xl={top:1,right:1,bottom:1,left:1};ao.svg.brush=function(){function n(t){t.each(function(){var t=ao.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",u).on("touchstart.brush",u),o=t.selectAll(".background").data([0]);o.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var a=t.selectAll(".resize").data(v,m);a.exit().remove(),a.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return $l[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),a.style("display",n.empty()?"none":null);var l,s=ao.transition(t),h=ao.transition(o);c&&(l=Zi(c),h.attr("x",l[0]).attr("width",l[1]-l[0]),r(s)),f&&(l=Zi(f),h.attr("y",l[0]).attr("height",l[1]-l[0]),i(s)),e(s)})}function e(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+s[+/e$/.test(n)]+","+h[+/^s/.test(n)]+")"})}function r(n){n.select(".extent").attr("x",s[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",s[1]-s[0])}function i(n){n.select(".extent").attr("y",h[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",h[1]-h[0])}function u(){function u(){32==ao.event.keyCode&&(C||(M=null,L[0]-=s[1],L[1]-=h[1],C=2),S())}function v(){32==ao.event.keyCode&&2==C&&(L[0]+=s[1],L[1]+=h[1],C=0,S())}function d(){var n=ao.mouse(b),t=!1;x&&(n[0]+=x[0],n[1]+=x[1]),C||(ao.event.altKey?(M||(M=[(s[0]+s[1])/2,(h[0]+h[1])/2]),L[0]=s[+(n[0]<M[0])],L[1]=h[+(n[1]<M[1])]):M=null),E&&y(n,c,0)&&(r(k),t=!0),A&&y(n,f,1)&&(i(k),t=!0),t&&(e(k),w({type:"brush",mode:C?"move":"resize"}))}function y(n,t,e){var r,i,u=Zi(t),l=u[0],c=u[1],f=L[e],v=e?h:s,d=v[1]-v[0];return C&&(l-=f,c-=d+f),r=(e?g:p)?Math.max(l,Math.min(c,n[e])):n[e],C?i=(r+=f)+d:(M&&(f=Math.max(l,Math.min(c,2*M[e]-r))),r>f?(i=r,r=f):i=f),v[0]!=r||v[1]!=i?(e?a=null:o=null,v[0]=r,v[1]=i,!0):void 0}function m(){d(),k.style("pointer-events","all").selectAll(".resize").style("display",n.empty()?"none":null),ao.select("body").style("cursor",null),q.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),z(),w({type:"brushend"})}var M,x,b=this,_=ao.select(ao.event.target),w=l.of(b,arguments),k=ao.select(b),N=_.datum(),E=!/^(n|s)$/.test(N)&&c,A=!/^(e|w)$/.test(N)&&f,C=_.classed("extent"),z=W(b),L=ao.mouse(b),q=ao.select(t(b)).on("keydown.brush",u).on("keyup.brush",v);if(ao.event.changedTouches?q.on("touchmove.brush",d).on("touchend.brush",m):q.on("mousemove.brush",d).on("mouseup.brush",m),k.interrupt().selectAll("*").interrupt(),C)L[0]=s[0]-L[0],L[1]=h[0]-L[1];else if(N){var T=+/w$/.test(N),R=+/^n/.test(N);x=[s[1-T]-L[0],h[1-R]-L[1]],L[0]=s[T],L[1]=h[R]}else ao.event.altKey&&(M=L.slice());k.style("pointer-events","none").selectAll(".resize").style("display",null),ao.select("body").style("cursor",_.style("cursor")),w({type:"brushstart"}),d()}var o,a,l=N(n,"brushstart","brush","brushend"),c=null,f=null,s=[0,0],h=[0,0],p=!0,g=!0,v=Bl[0];return n.event=function(n){n.each(function(){var n=l.of(this,arguments),t={x:s,y:h,i:o,j:a},e=this.__chart__||t;this.__chart__=t,Hl?ao.select(this).transition().each("start.brush",function(){o=e.i,a=e.j,s=e.x,h=e.y,n({type:"brushstart"})}).tween("brush:brush",function(){var e=xr(s,t.x),r=xr(h,t.y);return o=a=null,function(i){s=t.x=e(i),h=t.y=r(i),n({type:"brush",mode:"resize"})}}).each("end.brush",function(){o=t.i,a=t.j,n({type:"brush",mode:"resize"}),n({type:"brushend"})}):(n({type:"brushstart"}),n({type:"brush",mode:"resize"}),n({type:"brushend"}))})},n.x=function(t){return arguments.length?(c=t,v=Bl[!c<<1|!f],n):c},n.y=function(t){return arguments.length?(f=t,v=Bl[!c<<1|!f],n):f},n.clamp=function(t){return arguments.length?(c&&f?(p=!!t[0],g=!!t[1]):c?p=!!t:f&&(g=!!t),n):c&&f?[p,g]:c?p:f?g:null},n.extent=function(t){var e,r,i,u,l;return arguments.length?(c&&(e=t[0],r=t[1],f&&(e=e[0],r=r[0]),o=[e,r],c.invert&&(e=c(e),r=c(r)),e>r&&(l=e,e=r,r=l),e==s[0]&&r==s[1]||(s=[e,r])),f&&(i=t[0],u=t[1],c&&(i=i[1],u=u[1]),a=[i,u],f.invert&&(i=f(i),u=f(u)),i>u&&(l=i,i=u,u=l),i==h[0]&&u==h[1]||(h=[i,u])),n):(c&&(o?(e=o[0],r=o[1]):(e=s[0],r=s[1],c.invert&&(e=c.invert(e),r=c.invert(r)),e>r&&(l=e,e=r,r=l))),f&&(a?(i=a[0],u=a[1]):(i=h[0],u=h[1],f.invert&&(i=f.invert(i),u=f.invert(u)),i>u&&(l=i,i=u,u=l))),c&&f?[[e,i],[r,u]]:c?[e,r]:f&&[i,u])},n.clear=function(){return n.empty()||(s=[0,0],h=[0,0],o=a=null),n},n.empty=function(){return!!c&&s[0]==s[1]||!!f&&h[0]==h[1]},ao.rebind(n,l,"on")};var $l={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},Bl=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],Wl=ga.format=xa.timeFormat,Jl=Wl.utc,Gl=Jl("%Y-%m-%dT%H:%M:%S.%LZ");Wl.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?eo:Gl,eo.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},eo.toString=Gl.toString,ga.second=On(function(n){return new va(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),ga.seconds=ga.second.range,ga.seconds.utc=ga.second.utc.range,ga.minute=On(function(n){return new va(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),ga.minutes=ga.minute.range,ga.minutes.utc=ga.minute.utc.range,ga.hour=On(function(n){var t=n.getTimezoneOffset()/60;return new va(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),ga.hours=ga.hour.range,ga.hours.utc=ga.hour.utc.range,ga.month=On(function(n){return n=ga.day(n),n.setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),ga.months=ga.month.range,ga.months.utc=ga.month.utc.range;var Kl=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],Ql=[[ga.second,1],[ga.second,5],[ga.second,15],[ga.second,30],[ga.minute,1],[ga.minute,5],[ga.minute,15],[ga.minute,30],[ga.hour,1],[ga.hour,3],[ga.hour,6],[ga.hour,12],[ga.day,1],[ga.day,2],[ga.week,1],[ga.month,1],[ga.month,3],[ga.year,1]],nc=Wl.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",zt]]),tc={range:function(n,t,e){return ao.range(Math.ceil(n/e)*e,+t,e).map(io)},floor:m,ceil:m};Ql.year=ga.year,ga.scale=function(){return ro(ao.scale.linear(),Ql,nc)};var ec=Ql.map(function(n){return[n[0].utc,n[1]]}),rc=Jl.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",zt]]);ec.year=ga.year.utc,ga.scale.utc=function(){return ro(ao.scale.linear(),ec,rc)},ao.text=An(function(n){return n.responseText}),ao.json=function(n,t){return Cn(n,"application/json",uo,t)},ao.html=function(n,t){return Cn(n,"text/html",oo,t)},ao.xml=An(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=ao,define(ao)):"object"==typeof module&&module.exports?module.exports=ao:this.d3=ao}();  $(function() {
   var $window     = $(window)
     , $top_link   = $('#toplink')
     , $body       = $('body, html')
     , offset      = $('#code').offset().top
     , hidePopover = function ($target) {
        $target.data('popover-hover', false);

        setTimeout(function () {
         if (!$target.data('popover-hover')) {
          $target.popover('hide');
         }
        }, 300);
     };

   $top_link.hide().click(function(event) {
    event.preventDefault();
    $body.animate({scrollTop:0}, 800);
   });

   $window.scroll(function() {
    if($window.scrollTop() > offset) {
     $top_link.fadeIn();
    } else {
     $top_link.fadeOut();
    }
   }).scroll();

   $('.popin')
    .popover({trigger: 'manual'})
    .on({
     'mouseenter.popover': function () {
      var $target = $(this);
      var $container = $target.children().first();

      $target.data('popover-hover', true);

      // popover already displayed
      if ($target.next('.popover').length) {
       return;
      }

      // show the popover
      $container.popover('show');

      // register mouse events on the popover
      $target.next('.popover:not(.popover-initialized)')
       .on({
        'mouseenter': function () {
         $target.data('popover-hover', true);
        },
        'mouseleave': function () {
         hidePopover($container);
        }
       })
       .addClass('popover-initialized');
     },
     'mouseleave.popover': function () {
      hidePopover($(this).children().first());
     }
    });
  });
/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.5.1",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(D).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function ke(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=/<script|<style|<link/i,De=/checked\s*(?:[^=]|=\s*.checked.)/i,je=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function qe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function Le(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function He(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(je,""),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join("|"),"i");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px",t.style.height="1px",n.style.height="9px",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=["Webkit","Moz","ms"],ze=E.createElement("div").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=/^(none|table(?!-c[ea]).+)/,Ge=/^--/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",y.checkOn=""!==rt.value,y.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",y.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function vt(e){return(e.match(P)||[]).join(" ")}function yt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr("class","");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=yt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+vt(yt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||S.error("Invalid XML: "+e),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)Dt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var jt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(jt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Et.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+It+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&"withCredentials"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):("number"==typeof f.top&&(f.top+="px"),"number"==typeof f.left&&(f.left+="px"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});
/* nvd3 version 1.8.1 (https://github.com/novus/nvd3) 2015-06-15 */
!function(){var a={};a.dev=!1,a.tooltip=a.tooltip||{},a.utils=a.utils||{},a.models=a.models||{},a.charts={},a.logs={},a.dom={},a.dispatch=d3.dispatch("render_start","render_end"),Function.prototype.bind||(Function.prototype.bind=function(a){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var b=Array.prototype.slice.call(arguments,1),c=this,d=function(){},e=function(){return c.apply(this instanceof d&&a?this:a,b.concat(Array.prototype.slice.call(arguments)))};return d.prototype=this.prototype,e.prototype=new d,e}),a.dev&&(a.dispatch.on("render_start",function(){a.logs.startTime=+new Date}),a.dispatch.on("render_end",function(){a.logs.endTime=+new Date,a.logs.totalTime=a.logs.endTime-a.logs.startTime,a.log("total",a.logs.totalTime)})),a.log=function(){if(a.dev&&window.console&&console.log&&console.log.apply)console.log.apply(console,arguments);else if(a.dev&&window.console&&"function"==typeof console.log&&Function.prototype.bind){var b=Function.prototype.bind.call(console.log,console);b.apply(console,arguments)}return arguments[arguments.length-1]},a.deprecated=function(a,b){console&&console.warn&&console.warn("nvd3 warning: `"+a+"` has been deprecated. ",b||"")},a.render=function(b){b=b||1,a.render.active=!0,a.dispatch.render_start();var c=function(){for(var d,e,f=0;b>f&&(e=a.render.queue[f]);f++)d=e.generate(),typeof e.callback==typeof Function&&e.callback(d);a.render.queue.splice(0,f),a.render.queue.length?setTimeout(c):(a.dispatch.render_end(),a.render.active=!1)};setTimeout(c)},a.render.active=!1,a.render.queue=[],a.addGraph=function(b){typeof arguments[0]==typeof Function&&(b={generate:arguments[0],callback:arguments[1]}),a.render.queue.push(b),a.render.active||a.render()},"undefined"!=typeof module&&"undefined"!=typeof exports&&(module.exports=a),"undefined"!=typeof window&&(window.nv=a),a.dom.write=function(a){return void 0!==window.fastdom?fastdom.write(a):a()},a.dom.read=function(a){return void 0!==window.fastdom?fastdom.read(a):a()},a.interactiveGuideline=function(){"use strict";function b(l){l.each(function(l){function m(){var a=d3.mouse(this),d=a[0],e=a[1],i=!0,j=!1;if(k&&(d=d3.event.offsetX,e=d3.event.offsetY,"svg"!==d3.event.target.tagName&&(i=!1),d3.event.target.className.baseVal.match("nv-legend")&&(j=!0)),i&&(d-=f.left,e-=f.top),0>d||0>e||d>o||e>p||d3.event.relatedTarget&&void 0===d3.event.relatedTarget.ownerSVGElement||j){if(k&&d3.event.relatedTarget&&void 0===d3.event.relatedTarget.ownerSVGElement&&(void 0===d3.event.relatedTarget.className||d3.event.relatedTarget.className.match(c.nvPointerEventsClass)))return;return h.elementMouseout({mouseX:d,mouseY:e}),b.renderGuideLine(null),void c.hidden(!0)}c.hidden(!1);var l=g.invert(d);h.elementMousemove({mouseX:d,mouseY:e,pointXValue:l}),"dblclick"===d3.event.type&&h.elementDblclick({mouseX:d,mouseY:e,pointXValue:l}),"click"===d3.event.type&&h.elementClick({mouseX:d,mouseY:e,pointXValue:l})}var n=d3.select(this),o=d||960,p=e||400,q=n.selectAll("g.nv-wrap.nv-interactiveLineLayer").data([l]),r=q.enter().append("g").attr("class"," nv-wrap nv-interactiveLineLayer");r.append("g").attr("class","nv-interactiveGuideLine"),j&&(j.on("touchmove",m).on("mousemove",m,!0).on("mouseout",m,!0).on("dblclick",m).on("click",m),b.guideLine=null,b.renderGuideLine=function(c){i&&(b.guideLine&&b.guideLine.attr("x1")===c||a.dom.write(function(){var b=q.select(".nv-interactiveGuideLine").selectAll("line").data(null!=c?[a.utils.NaNtoZero(c)]:[],String);b.enter().append("line").attr("class","nv-guideline").attr("x1",function(a){return a}).attr("x2",function(a){return a}).attr("y1",p).attr("y2",0),b.exit().remove()}))})})}var c=a.models.tooltip();c.duration(0).hideDelay(0)._isInteractiveLayer(!0).hidden(!1);var d=null,e=null,f={left:0,top:0},g=d3.scale.linear(),h=d3.dispatch("elementMousemove","elementMouseout","elementClick","elementDblclick"),i=!0,j=null,k="ActiveXObject"in window;return b.dispatch=h,b.tooltip=c,b.margin=function(a){return arguments.length?(f.top="undefined"!=typeof a.top?a.top:f.top,f.left="undefined"!=typeof a.left?a.left:f.left,b):f},b.width=function(a){return arguments.length?(d=a,b):d},b.height=function(a){return arguments.length?(e=a,b):e},b.xScale=function(a){return arguments.length?(g=a,b):g},b.showGuideLine=function(a){return arguments.length?(i=a,b):i},b.svgContainer=function(a){return arguments.length?(j=a,b):j},b},a.interactiveBisect=function(a,b,c){"use strict";if(!(a instanceof Array))return null;var d;d="function"!=typeof c?function(a){return a.x}:c;var e=function(a,b){return d(a)-b},f=d3.bisector(e).left,g=d3.max([0,f(a,b)-1]),h=d(a[g]);if("undefined"==typeof h&&(h=g),h===b)return g;var i=d3.min([g+1,a.length-1]),j=d(a[i]);return"undefined"==typeof j&&(j=i),Math.abs(j-b)>=Math.abs(h-b)?g:i},a.nearestValueIndex=function(a,b,c){"use strict";var d=1/0,e=null;return a.forEach(function(a,f){var g=Math.abs(b-a);null!=a&&d>=g&&c>g&&(d=g,e=f)}),e},function(){"use strict";a.models.tooltip=function(){function b(){if(k){var a=d3.select(k);"svg"!==a.node().tagName&&(a=a.select("svg"));var b=a.node()?a.attr("viewBox"):null;if(b){b=b.split(" ");var c=parseInt(a.style("width"),10)/b[2];p.left=p.left*c,p.top=p.top*c}}}function c(){if(!n){var a;a=k?k:document.body,n=d3.select(a).append("div").attr("class","nvtooltip "+(j?j:"xy-tooltip")).attr("id",v),n.style("top",0).style("left",0),n.style("opacity",0),n.selectAll("div, table, td, tr").classed(w,!0),n.classed(w,!0),o=n.node()}}function d(){if(r&&B(e)){b();var f=p.left,g=null!==i?i:p.top;return a.dom.write(function(){c();var b=A(e);b&&(o.innerHTML=b),k&&u?a.dom.read(function(){var a=k.getElementsByTagName("svg")[0],b={left:0,top:0};if(a){var c=a.getBoundingClientRect(),d=k.getBoundingClientRect(),e=c.top;if(0>e){var i=k.getBoundingClientRect();e=Math.abs(e)>i.height?0:e}b.top=Math.abs(e-d.top),b.left=Math.abs(c.left-d.left)}f+=k.offsetLeft+b.left-2*k.scrollLeft,g+=k.offsetTop+b.top-2*k.scrollTop,h&&h>0&&(g=Math.floor(g/h)*h),C([f,g])}):C([f,g])}),d}}var e=null,f="w",g=25,h=0,i=null,j=null,k=null,l=!0,m=400,n=null,o=null,p={left:null,top:null},q={left:0,top:0},r=!0,s=100,t=!0,u=!1,v="nvtooltip-"+Math.floor(1e5*Math.random()),w="nv-pointer-events-none",x=function(a){return a},y=function(a){return a},z=function(a){return a},A=function(a){if(null===a)return"";var b=d3.select(document.createElement("table"));if(t){var c=b.selectAll("thead").data([a]).enter().append("thead");c.append("tr").append("td").attr("colspan",3).append("strong").classed("x-value",!0).html(y(a.value))}var d=b.selectAll("tbody").data([a]).enter().append("tbody"),e=d.selectAll("tr").data(function(a){return a.series}).enter().append("tr").classed("highlight",function(a){return a.highlight});e.append("td").classed("legend-color-guide",!0).append("div").style("background-color",function(a){return a.color}),e.append("td").classed("key",!0).html(function(a,b){return z(a.key,b)}),e.append("td").classed("value",!0).html(function(a,b){return x(a.value,b)}),e.selectAll("td").each(function(a){if(a.highlight){var b=d3.scale.linear().domain([0,1]).range(["#fff",a.color]),c=.6;d3.select(this).style("border-bottom-color",b(c)).style("border-top-color",b(c))}});var f=b.node().outerHTML;return void 0!==a.footer&&(f+="<div class='footer'>"+a.footer+"</div>"),f},B=function(a){if(a&&a.series){if(a.series instanceof Array)return!!a.series.length;if(a.series instanceof Object)return a.series=[a.series],!0}return!1},C=function(b){o&&a.dom.read(function(){var c,d,e=parseInt(o.offsetHeight,10),h=parseInt(o.offsetWidth,10),i=a.utils.windowSize().width,j=a.utils.windowSize().height,k=window.pageYOffset,p=window.pageXOffset;j=window.innerWidth>=document.body.scrollWidth?j:j-16,i=window.innerHeight>=document.body.scrollHeight?i:i-16;var r,t,u=function(a){var b=d;do isNaN(a.offsetTop)||(b+=a.offsetTop),a=a.offsetParent;while(a);return b},v=function(a){var b=c;do isNaN(a.offsetLeft)||(b+=a.offsetLeft),a=a.offsetParent;while(a);return b};switch(f){case"e":c=b[0]-h-g,d=b[1]-e/2,r=v(o),t=u(o),p>r&&(c=b[0]+g>p?b[0]+g:p-r+c),k>t&&(d=k-t+d),t+e>k+j&&(d=k+j-t+d-e);break;case"w":c=b[0]+g,d=b[1]-e/2,r=v(o),t=u(o),r+h>i&&(c=b[0]-h-g),k>t&&(d=k+5),t+e>k+j&&(d=k+j-t+d-e);break;case"n":c=b[0]-h/2-5,d=b[1]+g,r=v(o),t=u(o),p>r&&(c=p+5),r+h>i&&(c=c-h/2+5),t+e>k+j&&(d=k+j-t+d-e);break;case"s":c=b[0]-h/2,d=b[1]-e-g,r=v(o),t=u(o),p>r&&(c=p+5),r+h>i&&(c=c-h/2+5),k>t&&(d=k);break;case"none":c=b[0],d=b[1]-g,r=v(o),t=u(o)}c-=q.left,d-=q.top;var w=o.getBoundingClientRect(),k=window.pageYOffset||document.documentElement.scrollTop,p=window.pageXOffset||document.documentElement.scrollLeft,x="translate("+(w.left+p)+"px, "+(w.top+k)+"px)",y="translate("+c+"px, "+d+"px)",z=d3.interpolateString(x,y),A=n.style("opacity")<.1;l?n.transition().delay(m).duration(0).style("opacity",0):n.interrupt().transition().duration(A?0:s).styleTween("transform",function(){return z},"important").style("-webkit-transform",y).style("opacity",1)})};return d.nvPointerEventsClass=w,d.options=a.utils.optionsFunc.bind(d),d._options=Object.create({},{duration:{get:function(){return s},set:function(a){s=a}},gravity:{get:function(){return f},set:function(a){f=a}},distance:{get:function(){return g},set:function(a){g=a}},snapDistance:{get:function(){return h},set:function(a){h=a}},classes:{get:function(){return j},set:function(a){j=a}},chartContainer:{get:function(){return k},set:function(a){k=a}},fixedTop:{get:function(){return i},set:function(a){i=a}},enabled:{get:function(){return r},set:function(a){r=a}},hideDelay:{get:function(){return m},set:function(a){m=a}},contentGenerator:{get:function(){return A},set:function(a){A=a}},valueFormatter:{get:function(){return x},set:function(a){x=a}},headerFormatter:{get:function(){return y},set:function(a){y=a}},keyFormatter:{get:function(){return z},set:function(a){z=a}},headerEnabled:{get:function(){return t},set:function(a){t=a}},_isInteractiveLayer:{get:function(){return u},set:function(a){u=!!a}},position:{get:function(){return p},set:function(a){p.left=void 0!==a.left?a.left:p.left,p.top=void 0!==a.top?a.top:p.top}},offset:{get:function(){return q},set:function(a){q.left=void 0!==a.left?a.left:q.left,q.top=void 0!==a.top?a.top:q.top}},hidden:{get:function(){return l},set:function(a){l!=a&&(l=!!a,d())}},data:{get:function(){return e},set:function(a){a.point&&(a.value=a.point.x,a.series=a.series||{},a.series.value=a.point.y,a.series.color=a.point.color||a.series.color),e=a}},tooltipElem:{get:function(){return o},set:function(){}},id:{get:function(){return v},set:function(){}}}),a.utils.initOptions(d),d}}(),a.utils.windowSize=function(){var a={width:640,height:480};return window.innerWidth&&window.innerHeight?(a.width=window.innerWidth,a.height=window.innerHeight,a):"CSS1Compat"==document.compatMode&&document.documentElement&&document.documentElement.offsetWidth?(a.width=document.documentElement.offsetWidth,a.height=document.documentElement.offsetHeight,a):document.body&&document.body.offsetWidth?(a.width=document.body.offsetWidth,a.height=document.body.offsetHeight,a):a},a.utils.windowResize=function(b){return window.addEventListener?window.addEventListener("resize",b):a.log("ERROR: Failed to bind to window.resize with: ",b),{callback:b,clear:function(){window.removeEventListener("resize",b)}}},a.utils.getColor=function(b){if(void 0===b)return a.utils.defaultColor();if(Array.isArray(b)){var c=d3.scale.ordinal().range(b);return function(a,b){var d=void 0===b?a:b;return a.color||c(d)}}return b},a.utils.defaultColor=function(){return a.utils.getColor(d3.scale.category20().range())},a.utils.customTheme=function(a,b,c){b=b||function(a){return a.key},c=c||d3.scale.category20().range();var d=c.length;return function(e){var f=b(e);return"function"==typeof a[f]?a[f]():void 0!==a[f]?a[f]:(d||(d=c.length),d-=1,c[d])}},a.utils.pjax=function(b,c){var d=function(d){d3.html(d,function(d){var e=d3.select(c).node();e.parentNode.replaceChild(d3.select(d).select(c).node(),e),a.utils.pjax(b,c)})};d3.selectAll(b).on("click",function(){history.pushState(this.href,this.textContent,this.href),d(this.href),d3.event.preventDefault()}),d3.select(window).on("popstate",function(){d3.event.state&&d(d3.event.state)})},a.utils.calcApproxTextWidth=function(a){if("function"==typeof a.style&&"function"==typeof a.text){var b=parseInt(a.style("font-size").replace("px",""),10),c=a.text().length;return c*b*.5}return 0},a.utils.NaNtoZero=function(a){return"number"!=typeof a||isNaN(a)||null===a||1/0===a||a===-1/0?0:a},d3.selection.prototype.watchTransition=function(a){var b=[this].concat([].slice.call(arguments,1));return a.transition.apply(a,b)},a.utils.renderWatch=function(b,c){if(!(this instanceof a.utils.renderWatch))return new a.utils.renderWatch(b,c);var d=void 0!==c?c:250,e=[],f=this;this.models=function(a){return a=[].slice.call(arguments,0),a.forEach(function(a){a.__rendered=!1,function(a){a.dispatch.on("renderEnd",function(){a.__rendered=!0,f.renderEnd("model")})}(a),e.indexOf(a)<0&&e.push(a)}),this},this.reset=function(a){void 0!==a&&(d=a),e=[]},this.transition=function(a,b,c){if(b=arguments.length>1?[].slice.call(arguments,1):[],c=b.length>1?b.pop():void 0!==d?d:250,a.__rendered=!1,e.indexOf(a)<0&&e.push(a),0===c)return a.__rendered=!0,a.delay=function(){return this},a.duration=function(){return this},a;a.__rendered=0===a.length?!0:a.every(function(a){return!a.length})?!0:!1;var g=0;return a.transition().duration(c).each(function(){++g}).each("end",function(){0===--g&&(a.__rendered=!0,f.renderEnd.apply(this,b))})},this.renderEnd=function(){e.every(function(a){return a.__rendered})&&(e.forEach(function(a){a.__rendered=!1}),b.renderEnd.apply(this,arguments))}},a.utils.deepExtend=function(b){var c=arguments.length>1?[].slice.call(arguments,1):[];c.forEach(function(c){for(var d in c){var e=b[d]instanceof Array,f="object"==typeof b[d],g="object"==typeof c[d];f&&!e&&g?a.utils.deepExtend(b[d],c[d]):b[d]=c[d]}})},a.utils.state=function(){if(!(this instanceof a.utils.state))return new a.utils.state;var b={},c=function(){},d=function(){return{}},e=null,f=null;this.dispatch=d3.dispatch("change","set"),this.dispatch.on("set",function(a){c(a,!0)}),this.getter=function(a){return d=a,this},this.setter=function(a,b){return b||(b=function(){}),c=function(c,d){a(c),d&&b()},this},this.init=function(b){e=e||{},a.utils.deepExtend(e,b)};var g=function(){var a=d();if(JSON.stringify(a)===JSON.stringify(b))return!1;for(var c in a)void 0===b[c]&&(b[c]={}),b[c]=a[c],f=!0;return!0};this.update=function(){e&&(c(e,!1),e=null),g.call(this)&&this.dispatch.change(b)}},a.utils.optionsFunc=function(a){return a&&d3.map(a).forEach(function(a,b){"function"==typeof this[a]&&this[a](b)}.bind(this)),this},a.utils.calcTicksX=function(b,c){var d=1,e=0;for(e;e<c.length;e+=1){var f=c[e]&&c[e].values?c[e].values.length:0;d=f>d?f:d}return a.log("Requested number of ticks: ",b),a.log("Calculated max values to be: ",d),b=b>d?b=d-1:b,b=1>b?1:b,b=Math.floor(b),a.log("Calculating tick count as: ",b),b},a.utils.calcTicksY=function(b,c){return a.utils.calcTicksX(b,c)},a.utils.initOption=function(a,b){a._calls&&a._calls[b]?a[b]=a._calls[b]:(a[b]=function(c){return arguments.length?(a._overrides[b]=!0,a._options[b]=c,a):a._options[b]},a["_"+b]=function(c){return arguments.length?(a._overrides[b]||(a._options[b]=c),a):a._options[b]})},a.utils.initOptions=function(b){b._overrides=b._overrides||{};var c=Object.getOwnPropertyNames(b._options||{}),d=Object.getOwnPropertyNames(b._calls||{});c=c.concat(d);for(var e in c)a.utils.initOption(b,c[e])},a.utils.inheritOptionsD3=function(a,b,c){a._d3options=c.concat(a._d3options||[]),c.unshift(b),c.unshift(a),d3.rebind.apply(this,c)},a.utils.arrayUnique=function(a){return a.sort().filter(function(b,c){return!c||b!=a[c-1]})},a.utils.symbolMap=d3.map(),a.utils.symbol=function(){function b(b,e){var f=c.call(this,b,e),g=d.call(this,b,e);return-1!==d3.svg.symbolTypes.indexOf(f)?d3.svg.symbol().type(f).size(g)():a.utils.symbolMap.get(f)(g)}var c,d=64;return b.type=function(a){return arguments.length?(c=d3.functor(a),b):c},b.size=function(a){return arguments.length?(d=d3.functor(a),b):d},b},a.utils.inheritOptions=function(b,c){var d=Object.getOwnPropertyNames(c._options||{}),e=Object.getOwnPropertyNames(c._calls||{}),f=c._inherited||[],g=c._d3options||[],h=d.concat(e).concat(f).concat(g);h.unshift(c),h.unshift(b),d3.rebind.apply(this,h),b._inherited=a.utils.arrayUnique(d.concat(e).concat(f).concat(d).concat(b._inherited||[])),b._d3options=a.utils.arrayUnique(g.concat(b._d3options||[]))},a.utils.initSVG=function(a){a.classed({"nvd3-svg":!0})},a.utils.sanitizeHeight=function(a,b){return a||parseInt(b.style("height"),10)||400},a.utils.sanitizeWidth=function(a,b){return a||parseInt(b.style("width"),10)||960},a.utils.availableHeight=function(b,c,d){return a.utils.sanitizeHeight(b,c)-d.top-d.bottom},a.utils.availableWidth=function(b,c,d){return a.utils.sanitizeWidth(b,c)-d.left-d.right},a.utils.noData=function(b,c){var d=b.options(),e=d.margin(),f=d.noData(),g=null==f?["No Data Available."]:[f],h=a.utils.availableHeight(d.height(),c,e),i=a.utils.availableWidth(d.width(),c,e),j=e.left+i/2,k=e.top+h/2;c.selectAll("g").remove();var l=c.selectAll(".nv-noData").data(g);l.enter().append("text").attr("class","nvd3 nv-noData").attr("dy","-.7em").style("text-anchor","middle"),l.attr("x",j).attr("y",k).text(function(a){return a})},a.models.axis=function(){"use strict";function b(g){return s.reset(),g.each(function(b){var g=d3.select(this);a.utils.initSVG(g);var p=g.selectAll("g.nv-wrap.nv-axis").data([b]),q=p.enter().append("g").attr("class","nvd3 nv-wrap nv-axis"),t=(q.append("g"),p.select("g"));null!==n?c.ticks(n):("top"==c.orient()||"bottom"==c.orient())&&c.ticks(Math.abs(d.range()[1]-d.range()[0])/100),t.watchTransition(s,"axis").call(c),r=r||c.scale();var u=c.tickFormat();null==u&&(u=r.tickFormat());var v=t.selectAll("text.nv-axislabel").data([h||null]);v.exit().remove();var w,x,y;switch(c.orient()){case"top":v.enter().append("text").attr("class","nv-axislabel"),y=d.range().length<2?0:2===d.range().length?d.range()[1]:d.range()[d.range().length-1]+(d.range()[1]-d.range()[0]),v.attr("text-anchor","middle").attr("y",0).attr("x",y/2),i&&(x=p.selectAll("g.nv-axisMaxMin").data(d.domain()),x.enter().append("g").attr("class",function(a,b){return["nv-axisMaxMin","nv-axisMaxMin-x",0==b?"nv-axisMin-x":"nv-axisMax-x"].join(" ")}).append("text"),x.exit().remove(),x.attr("transform",function(b){return"translate("+a.utils.NaNtoZero(d(b))+",0)"}).select("text").attr("dy","-0.5em").attr("y",-c.tickPadding()).attr("text-anchor","middle").text(function(a){var b=u(a);return(""+b).match("NaN")?"":b}),x.watchTransition(s,"min-max top").attr("transform",function(b,c){return"translate("+a.utils.NaNtoZero(d.range()[c])+",0)"}));break;case"bottom":w=o+36;var z=30,A=0,B=t.selectAll("g").select("text"),C="";if(j%360){B.each(function(){var a=this.getBoundingClientRect(),b=a.width;A=a.height,b>z&&(z=b)}),C="rotate("+j+" 0,"+(A/2+c.tickPadding())+")";var D=Math.abs(Math.sin(j*Math.PI/180));w=(D?D*z:z)+30,B.attr("transform",C).style("text-anchor",j%360>0?"start":"end")}v.enter().append("text").attr("class","nv-axislabel"),y=d.range().length<2?0:2===d.range().length?d.range()[1]:d.range()[d.range().length-1]+(d.range()[1]-d.range()[0]),v.attr("text-anchor","middle").attr("y",w).attr("x",y/2),i&&(x=p.selectAll("g.nv-axisMaxMin").data([d.domain()[0],d.domain()[d.domain().length-1]]),x.enter().append("g").attr("class",function(a,b){return["nv-axisMaxMin","nv-axisMaxMin-x",0==b?"nv-axisMin-x":"nv-axisMax-x"].join(" ")}).append("text"),x.exit().remove(),x.attr("transform",function(b){return"translate("+a.utils.NaNtoZero(d(b)+(m?d.rangeBand()/2:0))+",0)"}).select("text").attr("dy",".71em").attr("y",c.tickPadding()).attr("transform",C).style("text-anchor",j?j%360>0?"start":"end":"middle").text(function(a){var b=u(a);return(""+b).match("NaN")?"":b}),x.watchTransition(s,"min-max bottom").attr("transform",function(b){return"translate("+a.utils.NaNtoZero(d(b)+(m?d.rangeBand()/2:0))+",0)"})),l&&B.attr("transform",function(a,b){return"translate(0,"+(b%2==0?"0":"12")+")"});break;case"right":v.enter().append("text").attr("class","nv-axislabel"),v.style("text-anchor",k?"middle":"begin").attr("transform",k?"rotate(90)":"").attr("y",k?-Math.max(e.right,f)+12:-10).attr("x",k?d3.max(d.range())/2:c.tickPadding()),i&&(x=p.selectAll("g.nv-axisMaxMin").data(d.domain()),x.enter().append("g").attr("class",function(a,b){return["nv-axisMaxMin","nv-axisMaxMin-y",0==b?"nv-axisMin-y":"nv-axisMax-y"].join(" ")}).append("text").style("opacity",0),x.exit().remove(),x.attr("transform",function(b){return"translate(0,"+a.utils.NaNtoZero(d(b))+")"}).select("text").attr("dy",".32em").attr("y",0).attr("x",c.tickPadding()).style("text-anchor","start").text(function(a){var b=u(a);return(""+b).match("NaN")?"":b}),x.watchTransition(s,"min-max right").attr("transform",function(b,c){return"translate(0,"+a.utils.NaNtoZero(d.range()[c])+")"}).select("text").style("opacity",1));break;case"left":v.enter().append("text").attr("class","nv-axislabel"),v.style("text-anchor",k?"middle":"end").attr("transform",k?"rotate(-90)":"").attr("y",k?-Math.max(e.left,f)+25-(o||0):-10).attr("x",k?-d3.max(d.range())/2:-c.tickPadding()),i&&(x=p.selectAll("g.nv-axisMaxMin").data(d.domain()),x.enter().append("g").attr("class",function(a,b){return["nv-axisMaxMin","nv-axisMaxMin-y",0==b?"nv-axisMin-y":"nv-axisMax-y"].join(" ")}).append("text").style("opacity",0),x.exit().remove(),x.attr("transform",function(b){return"translate(0,"+a.utils.NaNtoZero(r(b))+")"}).select("text").attr("dy",".32em").attr("y",0).attr("x",-c.tickPadding()).attr("text-anchor","end").text(function(a){var b=u(a);return(""+b).match("NaN")?"":b}),x.watchTransition(s,"min-max right").attr("transform",function(b,c){return"translate(0,"+a.utils.NaNtoZero(d.range()[c])+")"}).select("text").style("opacity",1))}if(v.text(function(a){return a}),!i||"left"!==c.orient()&&"right"!==c.orient()||(t.selectAll("g").each(function(a){d3.select(this).select("text").attr("opacity",1),(d(a)<d.range()[1]+10||d(a)>d.range()[0]-10)&&((a>1e-10||-1e-10>a)&&d3.select(this).attr("opacity",0),d3.select(this).select("text").attr("opacity",0))}),d.domain()[0]==d.domain()[1]&&0==d.domain()[0]&&p.selectAll("g.nv-axisMaxMin").style("opacity",function(a,b){return b?0:1})),i&&("top"===c.orient()||"bottom"===c.orient())){var E=[];p.selectAll("g.nv-axisMaxMin").each(function(a,b){try{E.push(b?d(a)-this.getBoundingClientRect().width-4:d(a)+this.getBoundingClientRect().width+4)}catch(c){E.push(b?d(a)-4:d(a)+4)}}),t.selectAll("g").each(function(a){(d(a)<E[0]||d(a)>E[1])&&(a>1e-10||-1e-10>a?d3.select(this).remove():d3.select(this).select("text").remove())})}t.selectAll(".tick").filter(function(a){return!parseFloat(Math.round(1e5*a)/1e6)&&void 0!==a}).classed("zero",!0),r=d.copy()}),s.renderEnd("axis immediate"),b}var c=d3.svg.axis(),d=d3.scale.linear(),e={top:0,right:0,bottom:0,left:0},f=75,g=60,h=null,i=!0,j=0,k=!0,l=!1,m=!1,n=null,o=0,p=250,q=d3.dispatch("renderEnd");c.scale(d).orient("bottom").tickFormat(function(a){return a});var r,s=a.utils.renderWatch(q,p);return b.axis=c,b.dispatch=q,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{axisLabelDistance:{get:function(){return o},set:function(a){o=a}},staggerLabels:{get:function(){return l},set:function(a){l=a}},rotateLabels:{get:function(){return j},set:function(a){j=a}},rotateYLabel:{get:function(){return k},set:function(a){k=a}},showMaxMin:{get:function(){return i},set:function(a){i=a}},axisLabel:{get:function(){return h},set:function(a){h=a}},height:{get:function(){return g},set:function(a){g=a}},ticks:{get:function(){return n},set:function(a){n=a}},width:{get:function(){return f},set:function(a){f=a}},margin:{get:function(){return e},set:function(a){e.top=void 0!==a.top?a.top:e.top,e.right=void 0!==a.right?a.right:e.right,e.bottom=void 0!==a.bottom?a.bottom:e.bottom,e.left=void 0!==a.left?a.left:e.left}},duration:{get:function(){return p},set:function(a){p=a,s.reset(p)}},scale:{get:function(){return d},set:function(e){d=e,c.scale(d),m="function"==typeof d.rangeBands,a.utils.inheritOptionsD3(b,d,["domain","range","rangeBand","rangeBands"])}}}),a.utils.initOptions(b),a.utils.inheritOptionsD3(b,c,["orient","tickValues","tickSubdivide","tickSize","tickPadding","tickFormat"]),a.utils.inheritOptionsD3(b,d,["domain","range","rangeBand","rangeBands"]),b},a.models.boxPlot=function(){"use strict";function b(l){return v.reset(),l.each(function(b){var l=j-i.left-i.right,p=k-i.top-i.bottom;r=d3.select(this),a.utils.initSVG(r),m.domain(c||b.map(function(a,b){return o(a,b)})).rangeBands(e||[0,l],.1);var w=[];if(!d){var x=d3.min(b.map(function(a){var b=[];return b.push(a.values.Q1),a.values.hasOwnProperty("whisker_low")&&null!==a.values.whisker_low&&b.push(a.values.whisker_low),a.values.hasOwnProperty("outliers")&&null!==a.values.outliers&&(b=b.concat(a.values.outliers)),d3.min(b)})),y=d3.max(b.map(function(a){var b=[];return b.push(a.values.Q3),a.values.hasOwnProperty("whisker_high")&&null!==a.values.whisker_high&&b.push(a.values.whisker_high),a.values.hasOwnProperty("outliers")&&null!==a.values.outliers&&(b=b.concat(a.values.outliers)),d3.max(b)}));w=[x,y]}n.domain(d||w),n.range(f||[p,0]),g=g||m,h=h||n.copy().range([n(0),n(0)]);{var z=r.selectAll("g.nv-wrap").data([b]);z.enter().append("g").attr("class","nvd3 nv-wrap")}z.attr("transform","translate("+i.left+","+i.top+")");var A=z.selectAll(".nv-boxplot").data(function(a){return a}),B=A.enter().append("g").style("stroke-opacity",1e-6).style("fill-opacity",1e-6);A.attr("class","nv-boxplot").attr("transform",function(a,b){return"translate("+(m(o(a,b))+.05*m.rangeBand())+", 0)"}).classed("hover",function(a){return a.hover}),A.watchTransition(v,"nv-boxplot: boxplots").style("stroke-opacity",1).style("fill-opacity",.75).delay(function(a,c){return c*t/b.length}).attr("transform",function(a,b){return"translate("+(m(o(a,b))+.05*m.rangeBand())+", 0)"}),A.exit().remove(),B.each(function(a,b){var c=d3.select(this);["low","high"].forEach(function(d){a.values.hasOwnProperty("whisker_"+d)&&null!==a.values["whisker_"+d]&&(c.append("line").style("stroke",a.color?a.color:q(a,b)).attr("class","nv-boxplot-whisker nv-boxplot-"+d),c.append("line").style("stroke",a.color?a.color:q(a,b)).attr("class","nv-boxplot-tick nv-boxplot-"+d))})});var C=A.selectAll(".nv-boxplot-outlier").data(function(a){return a.values.hasOwnProperty("outliers")&&null!==a.values.outliers?a.values.outliers:[]});C.enter().append("circle").style("fill",function(a,b,c){return q(a,c)}).style("stroke",function(a,b,c){return q(a,c)}).on("mouseover",function(a,b,c){d3.select(this).classed("hover",!0),s.elementMouseover({series:{key:a,color:q(a,c)},e:d3.event})}).on("mouseout",function(a,b,c){d3.select(this).classed("hover",!1),s.elementMouseout({series:{key:a,color:q(a,c)},e:d3.event})}).on("mousemove",function(){s.elementMousemove({e:d3.event})}),C.attr("class","nv-boxplot-outlier"),C.watchTransition(v,"nv-boxplot: nv-boxplot-outlier").attr("cx",.45*m.rangeBand()).attr("cy",function(a){return n(a)}).attr("r","3"),C.exit().remove();var D=function(){return null===u?.9*m.rangeBand():Math.min(75,.9*m.rangeBand())},E=function(){return.45*m.rangeBand()-D()/2},F=function(){return.45*m.rangeBand()+D()/2};["low","high"].forEach(function(a){var b="low"===a?"Q1":"Q3";A.select("line.nv-boxplot-whisker.nv-boxplot-"+a).watchTransition(v,"nv-boxplot: boxplots").attr("x1",.45*m.rangeBand()).attr("y1",function(b){return n(b.values["whisker_"+a])}).attr("x2",.45*m.rangeBand()).attr("y2",function(a){return n(a.values[b])}),A.select("line.nv-boxplot-tick.nv-boxplot-"+a).watchTransition(v,"nv-boxplot: boxplots").attr("x1",E).attr("y1",function(b){return n(b.values["whisker_"+a])}).attr("x2",F).attr("y2",function(b){return n(b.values["whisker_"+a])})}),["low","high"].forEach(function(a){B.selectAll(".nv-boxplot-"+a).on("mouseover",function(b,c,d){d3.select(this).classed("hover",!0),s.elementMouseover({series:{key:b.values["whisker_"+a],color:q(b,d)},e:d3.event})}).on("mouseout",function(b,c,d){d3.select(this).classed("hover",!1),s.elementMouseout({series:{key:b.values["whisker_"+a],color:q(b,d)},e:d3.event})}).on("mousemove",function(){s.elementMousemove({e:d3.event})})}),B.append("rect").attr("class","nv-boxplot-box").on("mouseover",function(a,b){d3.select(this).classed("hover",!0),s.elementMouseover({key:a.label,value:a.label,series:[{key:"Q3",value:a.values.Q3,color:a.color||q(a,b)},{key:"Q2",value:a.values.Q2,color:a.color||q(a,b)},{key:"Q1",value:a.values.Q1,color:a.color||q(a,b)}],data:a,index:b,e:d3.event})}).on("mouseout",function(a,b){d3.select(this).classed("hover",!1),s.elementMouseout({key:a.label,value:a.label,series:[{key:"Q3",value:a.values.Q3,color:a.color||q(a,b)},{key:"Q2",value:a.values.Q2,color:a.color||q(a,b)},{key:"Q1",value:a.values.Q1,color:a.color||q(a,b)}],data:a,index:b,e:d3.event})}).on("mousemove",function(){s.elementMousemove({e:d3.event})}),A.select("rect.nv-boxplot-box").watchTransition(v,"nv-boxplot: boxes").attr("y",function(a){return n(a.values.Q3)}).attr("width",D).attr("x",E).attr("height",function(a){return Math.abs(n(a.values.Q3)-n(a.values.Q1))||1}).style("fill",function(a,b){return a.color||q(a,b)}).style("stroke",function(a,b){return a.color||q(a,b)}),B.append("line").attr("class","nv-boxplot-median"),A.select("line.nv-boxplot-median").watchTransition(v,"nv-boxplot: boxplots line").attr("x1",E).attr("y1",function(a){return n(a.values.Q2)}).attr("x2",F).attr("y2",function(a){return n(a.values.Q2)}),g=m.copy(),h=n.copy()}),v.renderEnd("nv-boxplot immediate"),b}var c,d,e,f,g,h,i={top:0,right:0,bottom:0,left:0},j=960,k=500,l=Math.floor(1e4*Math.random()),m=d3.scale.ordinal(),n=d3.scale.linear(),o=function(a){return a.x},p=function(a){return a.y},q=a.utils.defaultColor(),r=null,s=d3.dispatch("elementMouseover","elementMouseout","elementMousemove","renderEnd"),t=250,u=null,v=a.utils.renderWatch(s,t);return b.dispatch=s,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return j},set:function(a){j=a}},height:{get:function(){return k},set:function(a){k=a}},maxBoxWidth:{get:function(){return u},set:function(a){u=a}},x:{get:function(){return o},set:function(a){o=a}},y:{get:function(){return p},set:function(a){p=a}},xScale:{get:function(){return m},set:function(a){m=a}},yScale:{get:function(){return n},set:function(a){n=a}},xDomain:{get:function(){return c},set:function(a){c=a}},yDomain:{get:function(){return d},set:function(a){d=a}},xRange:{get:function(){return e},set:function(a){e=a}},yRange:{get:function(){return f},set:function(a){f=a}},id:{get:function(){return l},set:function(a){l=a}},margin:{get:function(){return i},set:function(a){i.top=void 0!==a.top?a.top:i.top,i.right=void 0!==a.right?a.right:i.right,i.bottom=void 0!==a.bottom?a.bottom:i.bottom,i.left=void 0!==a.left?a.left:i.left}},color:{get:function(){return q},set:function(b){q=a.utils.getColor(b)}},duration:{get:function(){return t},set:function(a){t=a,v.reset(t)}}}),a.utils.initOptions(b),b},a.models.boxPlotChart=function(){"use strict";function b(k){return t.reset(),t.models(e),l&&t.models(f),m&&t.models(g),k.each(function(k){var p=d3.select(this);a.utils.initSVG(p);var t=(i||parseInt(p.style("width"))||960)-h.left-h.right,u=(j||parseInt(p.style("height"))||400)-h.top-h.bottom;if(b.update=function(){r.beforeUpdate(),p.transition().duration(s).call(b)},b.container=this,!(k&&k.length&&k.filter(function(a){return a.values.hasOwnProperty("Q1")&&a.values.hasOwnProperty("Q2")&&a.values.hasOwnProperty("Q3")}).length)){var v=p.selectAll(".nv-noData").data([q]);return v.enter().append("text").attr("class","nvd3 nv-noData").attr("dy","-.7em").style("text-anchor","middle"),v.attr("x",h.left+t/2).attr("y",h.top+u/2).text(function(a){return a}),b}p.selectAll(".nv-noData").remove(),c=e.xScale(),d=e.yScale().clamp(!0);var w=p.selectAll("g.nv-wrap.nv-boxPlotWithAxes").data([k]),x=w.enter().append("g").attr("class","nvd3 nv-wrap nv-boxPlotWithAxes").append("g"),y=x.append("defs"),z=w.select("g");
x.append("g").attr("class","nv-x nv-axis"),x.append("g").attr("class","nv-y nv-axis").append("g").attr("class","nv-zeroLine").append("line"),x.append("g").attr("class","nv-barsWrap"),z.attr("transform","translate("+h.left+","+h.top+")"),n&&z.select(".nv-y.nv-axis").attr("transform","translate("+t+",0)"),e.width(t).height(u);var A=z.select(".nv-barsWrap").datum(k.filter(function(a){return!a.disabled}));if(A.transition().call(e),y.append("clipPath").attr("id","nv-x-label-clip-"+e.id()).append("rect"),z.select("#nv-x-label-clip-"+e.id()+" rect").attr("width",c.rangeBand()*(o?2:1)).attr("height",16).attr("x",-c.rangeBand()/(o?1:2)),l){f.scale(c).ticks(a.utils.calcTicksX(t/100,k)).tickSize(-u,0),z.select(".nv-x.nv-axis").attr("transform","translate(0,"+d.range()[0]+")"),z.select(".nv-x.nv-axis").call(f);var B=z.select(".nv-x.nv-axis").selectAll("g");o&&B.selectAll("text").attr("transform",function(a,b,c){return"translate(0,"+(c%2==0?"5":"17")+")"})}m&&(g.scale(d).ticks(Math.floor(u/36)).tickSize(-t,0),z.select(".nv-y.nv-axis").call(g)),z.select(".nv-zeroLine line").attr("x1",0).attr("x2",t).attr("y1",d(0)).attr("y2",d(0))}),t.renderEnd("nv-boxplot chart immediate"),b}var c,d,e=a.models.boxPlot(),f=a.models.axis(),g=a.models.axis(),h={top:15,right:10,bottom:50,left:60},i=null,j=null,k=a.utils.getColor(),l=!0,m=!0,n=!1,o=!1,p=a.models.tooltip(),q="No Data Available.",r=d3.dispatch("tooltipShow","tooltipHide","beforeUpdate","renderEnd"),s=250;f.orient("bottom").showMaxMin(!1).tickFormat(function(a){return a}),g.orient(n?"right":"left").tickFormat(d3.format(",.1f")),p.duration(0);var t=a.utils.renderWatch(r,s);return e.dispatch.on("elementMouseover.tooltip",function(a){p.data(a).hidden(!1)}),e.dispatch.on("elementMouseout.tooltip",function(a){p.data(a).hidden(!0)}),e.dispatch.on("elementMousemove.tooltip",function(){p.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.dispatch=r,b.boxplot=e,b.xAxis=f,b.yAxis=g,b.tooltip=p,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return i},set:function(a){i=a}},height:{get:function(){return j},set:function(a){j=a}},staggerLabels:{get:function(){return o},set:function(a){o=a}},showXAxis:{get:function(){return l},set:function(a){l=a}},showYAxis:{get:function(){return m},set:function(a){m=a}},tooltips:{get:function(){return tooltips},set:function(a){tooltips=a}},tooltipContent:{get:function(){return p},set:function(a){p=a}},noData:{get:function(){return q},set:function(a){q=a}},margin:{get:function(){return h},set:function(a){h.top=void 0!==a.top?a.top:h.top,h.right=void 0!==a.right?a.right:h.right,h.bottom=void 0!==a.bottom?a.bottom:h.bottom,h.left=void 0!==a.left?a.left:h.left}},duration:{get:function(){return s},set:function(a){s=a,t.reset(s),e.duration(s),f.duration(s),g.duration(s)}},color:{get:function(){return k},set:function(b){k=a.utils.getColor(b),e.color(k)}},rightAlignYAxis:{get:function(){return n},set:function(a){n=a,g.orient(a?"right":"left")}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.bullet=function(){"use strict";function b(d){return d.each(function(b,d){var p=m-c.left-c.right,s=n-c.top-c.bottom;o=d3.select(this),a.utils.initSVG(o);{var t=f.call(this,b,d).slice().sort(d3.descending),u=g.call(this,b,d).slice().sort(d3.descending),v=h.call(this,b,d).slice().sort(d3.descending),w=i.call(this,b,d).slice(),x=j.call(this,b,d).slice(),y=k.call(this,b,d).slice(),z=d3.scale.linear().domain(d3.extent(d3.merge([l,t]))).range(e?[p,0]:[0,p]);this.__chart__||d3.scale.linear().domain([0,1/0]).range(z.range())}this.__chart__=z;var A=d3.min(t),B=d3.max(t),C=t[1],D=o.selectAll("g.nv-wrap.nv-bullet").data([b]),E=D.enter().append("g").attr("class","nvd3 nv-wrap nv-bullet"),F=E.append("g"),G=D.select("g");F.append("rect").attr("class","nv-range nv-rangeMax"),F.append("rect").attr("class","nv-range nv-rangeAvg"),F.append("rect").attr("class","nv-range nv-rangeMin"),F.append("rect").attr("class","nv-measure"),D.attr("transform","translate("+c.left+","+c.top+")");var H=function(a){return Math.abs(z(a)-z(0))},I=function(a){return z(0>a?a:0)};G.select("rect.nv-rangeMax").attr("height",s).attr("width",H(B>0?B:A)).attr("x",I(B>0?B:A)).datum(B>0?B:A),G.select("rect.nv-rangeAvg").attr("height",s).attr("width",H(C)).attr("x",I(C)).datum(C),G.select("rect.nv-rangeMin").attr("height",s).attr("width",H(B)).attr("x",I(B)).attr("width",H(B>0?A:B)).attr("x",I(B>0?A:B)).datum(B>0?A:B),G.select("rect.nv-measure").style("fill",q).attr("height",s/3).attr("y",s/3).attr("width",0>v?z(0)-z(v[0]):z(v[0])-z(0)).attr("x",I(v)).on("mouseover",function(){r.elementMouseover({value:v[0],label:y[0]||"Current",color:d3.select(this).style("fill")})}).on("mousemove",function(){r.elementMousemove({value:v[0],label:y[0]||"Current",color:d3.select(this).style("fill")})}).on("mouseout",function(){r.elementMouseout({value:v[0],label:y[0]||"Current",color:d3.select(this).style("fill")})});var J=s/6,K=u.map(function(a,b){return{value:a,label:x[b]}});F.selectAll("path.nv-markerTriangle").data(K).enter().append("path").attr("class","nv-markerTriangle").attr("transform",function(a){return"translate("+z(a.value)+","+s/2+")"}).attr("d","M0,"+J+"L"+J+","+-J+" "+-J+","+-J+"Z").on("mouseover",function(a){r.elementMouseover({value:a.value,label:a.label||"Previous",color:d3.select(this).style("fill"),pos:[z(a.value),s/2]})}).on("mousemove",function(a){r.elementMousemove({value:a.value,label:a.label||"Previous",color:d3.select(this).style("fill")})}).on("mouseout",function(a){r.elementMouseout({value:a.value,label:a.label||"Previous",color:d3.select(this).style("fill")})}),D.selectAll(".nv-range").on("mouseover",function(a,b){var c=w[b]||(b?1==b?"Mean":"Minimum":"Maximum");r.elementMouseover({value:a,label:c,color:d3.select(this).style("fill")})}).on("mousemove",function(){r.elementMousemove({value:v[0],label:y[0]||"Previous",color:d3.select(this).style("fill")})}).on("mouseout",function(a,b){var c=w[b]||(b?1==b?"Mean":"Minimum":"Maximum");r.elementMouseout({value:a,label:c,color:d3.select(this).style("fill")})})}),b}var c={top:0,right:0,bottom:0,left:0},d="left",e=!1,f=function(a){return a.ranges},g=function(a){return a.markers?a.markers:[0]},h=function(a){return a.measures},i=function(a){return a.rangeLabels?a.rangeLabels:[]},j=function(a){return a.markerLabels?a.markerLabels:[]},k=function(a){return a.measureLabels?a.measureLabels:[]},l=[0],m=380,n=30,o=null,p=null,q=a.utils.getColor(["#1f77b4"]),r=d3.dispatch("elementMouseover","elementMouseout","elementMousemove");return b.dispatch=r,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{ranges:{get:function(){return f},set:function(a){f=a}},markers:{get:function(){return g},set:function(a){g=a}},measures:{get:function(){return h},set:function(a){h=a}},forceX:{get:function(){return l},set:function(a){l=a}},width:{get:function(){return m},set:function(a){m=a}},height:{get:function(){return n},set:function(a){n=a}},tickFormat:{get:function(){return p},set:function(a){p=a}},margin:{get:function(){return c},set:function(a){c.top=void 0!==a.top?a.top:c.top,c.right=void 0!==a.right?a.right:c.right,c.bottom=void 0!==a.bottom?a.bottom:c.bottom,c.left=void 0!==a.left?a.left:c.left}},orient:{get:function(){return d},set:function(a){d=a,e="right"==d||"bottom"==d}},color:{get:function(){return q},set:function(b){q=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.bulletChart=function(){"use strict";function b(d){return d.each(function(e,o){var p=d3.select(this);a.utils.initSVG(p);var q=a.utils.availableWidth(k,p,g),r=l-g.top-g.bottom;if(b.update=function(){b(d)},b.container=this,!e||!h.call(this,e,o))return a.utils.noData(b,p),b;p.selectAll(".nv-noData").remove();var s=h.call(this,e,o).slice().sort(d3.descending),t=i.call(this,e,o).slice().sort(d3.descending),u=j.call(this,e,o).slice().sort(d3.descending),v=p.selectAll("g.nv-wrap.nv-bulletChart").data([e]),w=v.enter().append("g").attr("class","nvd3 nv-wrap nv-bulletChart"),x=w.append("g"),y=v.select("g");x.append("g").attr("class","nv-bulletWrap"),x.append("g").attr("class","nv-titles"),v.attr("transform","translate("+g.left+","+g.top+")");var z=d3.scale.linear().domain([0,Math.max(s[0],t[0],u[0])]).range(f?[q,0]:[0,q]),A=this.__chart__||d3.scale.linear().domain([0,1/0]).range(z.range());this.__chart__=z;var B=x.select(".nv-titles").append("g").attr("text-anchor","end").attr("transform","translate(-6,"+(l-g.top-g.bottom)/2+")");B.append("text").attr("class","nv-title").text(function(a){return a.title}),B.append("text").attr("class","nv-subtitle").attr("dy","1em").text(function(a){return a.subtitle}),c.width(q).height(r);var C=y.select(".nv-bulletWrap");d3.transition(C).call(c);var D=m||z.tickFormat(q/100),E=y.selectAll("g.nv-tick").data(z.ticks(n?n:q/50),function(a){return this.textContent||D(a)}),F=E.enter().append("g").attr("class","nv-tick").attr("transform",function(a){return"translate("+A(a)+",0)"}).style("opacity",1e-6);F.append("line").attr("y1",r).attr("y2",7*r/6),F.append("text").attr("text-anchor","middle").attr("dy","1em").attr("y",7*r/6).text(D);var G=d3.transition(E).attr("transform",function(a){return"translate("+z(a)+",0)"}).style("opacity",1);G.select("line").attr("y1",r).attr("y2",7*r/6),G.select("text").attr("y",7*r/6),d3.transition(E.exit()).attr("transform",function(a){return"translate("+z(a)+",0)"}).style("opacity",1e-6).remove()}),d3.timer.flush(),b}var c=a.models.bullet(),d=a.models.tooltip(),e="left",f=!1,g={top:5,right:40,bottom:20,left:120},h=function(a){return a.ranges},i=function(a){return a.markers?a.markers:[0]},j=function(a){return a.measures},k=null,l=55,m=null,n=null,o=null,p=d3.dispatch("tooltipShow","tooltipHide");return d.duration(0).headerEnabled(!1),c.dispatch.on("elementMouseover.tooltip",function(a){a.series={key:a.label,value:a.value,color:a.color},d.data(a).hidden(!1)}),c.dispatch.on("elementMouseout.tooltip",function(){d.hidden(!0)}),c.dispatch.on("elementMousemove.tooltip",function(){d.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.bullet=c,b.dispatch=p,b.tooltip=d,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{ranges:{get:function(){return h},set:function(a){h=a}},markers:{get:function(){return i},set:function(a){i=a}},measures:{get:function(){return j},set:function(a){j=a}},width:{get:function(){return k},set:function(a){k=a}},height:{get:function(){return l},set:function(a){l=a}},tickFormat:{get:function(){return m},set:function(a){m=a}},ticks:{get:function(){return n},set:function(a){n=a}},noData:{get:function(){return o},set:function(a){o=a}},tooltips:{get:function(){return d.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),d.enabled(!!b)}},tooltipContent:{get:function(){return d.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),d.contentGenerator(b)}},margin:{get:function(){return g},set:function(a){g.top=void 0!==a.top?a.top:g.top,g.right=void 0!==a.right?a.right:g.right,g.bottom=void 0!==a.bottom?a.bottom:g.bottom,g.left=void 0!==a.left?a.left:g.left}},orient:{get:function(){return e},set:function(a){e=a,f="right"==e||"bottom"==e}}}),a.utils.inheritOptions(b,c),a.utils.initOptions(b),b},a.models.candlestickBar=function(){"use strict";function b(x){return x.each(function(b){c=d3.select(this);var x=a.utils.availableWidth(i,c,h),y=a.utils.availableHeight(j,c,h);a.utils.initSVG(c);var A=x/b[0].values.length*.45;l.domain(d||d3.extent(b[0].values.map(n).concat(t))),l.range(v?f||[.5*x/b[0].values.length,x*(b[0].values.length-.5)/b[0].values.length]:f||[5+A/2,x-A/2-5]),m.domain(e||[d3.min(b[0].values.map(s).concat(u)),d3.max(b[0].values.map(r).concat(u))]).range(g||[y,0]),l.domain()[0]===l.domain()[1]&&l.domain(l.domain()[0]?[l.domain()[0]-.01*l.domain()[0],l.domain()[1]+.01*l.domain()[1]]:[-1,1]),m.domain()[0]===m.domain()[1]&&m.domain(m.domain()[0]?[m.domain()[0]+.01*m.domain()[0],m.domain()[1]-.01*m.domain()[1]]:[-1,1]);var B=d3.select(this).selectAll("g.nv-wrap.nv-candlestickBar").data([b[0].values]),C=B.enter().append("g").attr("class","nvd3 nv-wrap nv-candlestickBar"),D=C.append("defs"),E=C.append("g"),F=B.select("g");E.append("g").attr("class","nv-ticks"),B.attr("transform","translate("+h.left+","+h.top+")"),c.on("click",function(a,b){z.chartClick({data:a,index:b,pos:d3.event,id:k})}),D.append("clipPath").attr("id","nv-chart-clip-path-"+k).append("rect"),B.select("#nv-chart-clip-path-"+k+" rect").attr("width",x).attr("height",y),F.attr("clip-path",w?"url(#nv-chart-clip-path-"+k+")":"");var G=B.select(".nv-ticks").selectAll(".nv-tick").data(function(a){return a});G.exit().remove();{var H=G.enter().append("g").attr("class",function(a,b,c){return(p(a,b)>q(a,b)?"nv-tick negative":"nv-tick positive")+" nv-tick-"+c+"-"+b});H.append("line").attr("class","nv-candlestick-lines").attr("transform",function(a,b){return"translate("+l(n(a,b))+",0)"}).attr("x1",0).attr("y1",function(a,b){return m(r(a,b))}).attr("x2",0).attr("y2",function(a,b){return m(s(a,b))}),H.append("rect").attr("class","nv-candlestick-rects nv-bars").attr("transform",function(a,b){return"translate("+(l(n(a,b))-A/2)+","+(m(o(a,b))-(p(a,b)>q(a,b)?m(q(a,b))-m(p(a,b)):0))+")"}).attr("x",0).attr("y",0).attr("width",A).attr("height",function(a,b){var c=p(a,b),d=q(a,b);return c>d?m(d)-m(c):m(c)-m(d)})}c.selectAll(".nv-candlestick-lines").transition().attr("transform",function(a,b){return"translate("+l(n(a,b))+",0)"}).attr("x1",0).attr("y1",function(a,b){return m(r(a,b))}).attr("x2",0).attr("y2",function(a,b){return m(s(a,b))}),c.selectAll(".nv-candlestick-rects").transition().attr("transform",function(a,b){return"translate("+(l(n(a,b))-A/2)+","+(m(o(a,b))-(p(a,b)>q(a,b)?m(q(a,b))-m(p(a,b)):0))+")"}).attr("x",0).attr("y",0).attr("width",A).attr("height",function(a,b){var c=p(a,b),d=q(a,b);return c>d?m(d)-m(c):m(c)-m(d)})}),b}var c,d,e,f,g,h={top:0,right:0,bottom:0,left:0},i=null,j=null,k=Math.floor(1e4*Math.random()),l=d3.scale.linear(),m=d3.scale.linear(),n=function(a){return a.x},o=function(a){return a.y},p=function(a){return a.open},q=function(a){return a.close},r=function(a){return a.high},s=function(a){return a.low},t=[],u=[],v=!1,w=!0,x=a.utils.defaultColor(),y=!1,z=d3.dispatch("tooltipShow","tooltipHide","stateChange","changeState","renderEnd","chartClick","elementClick","elementDblClick","elementMouseover","elementMouseout","elementMousemove");return b.highlightPoint=function(a,d){b.clearHighlights(),c.select(".nv-candlestickBar .nv-tick-0-"+a).classed("hover",d)},b.clearHighlights=function(){c.select(".nv-candlestickBar .nv-tick.hover").classed("hover",!1)},b.dispatch=z,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return i},set:function(a){i=a}},height:{get:function(){return j},set:function(a){j=a}},xScale:{get:function(){return l},set:function(a){l=a}},yScale:{get:function(){return m},set:function(a){m=a}},xDomain:{get:function(){return d},set:function(a){d=a}},yDomain:{get:function(){return e},set:function(a){e=a}},xRange:{get:function(){return f},set:function(a){f=a}},yRange:{get:function(){return g},set:function(a){g=a}},forceX:{get:function(){return t},set:function(a){t=a}},forceY:{get:function(){return u},set:function(a){u=a}},padData:{get:function(){return v},set:function(a){v=a}},clipEdge:{get:function(){return w},set:function(a){w=a}},id:{get:function(){return k},set:function(a){k=a}},interactive:{get:function(){return y},set:function(a){y=a}},x:{get:function(){return n},set:function(a){n=a}},y:{get:function(){return o},set:function(a){o=a}},open:{get:function(){return p()},set:function(a){p=a}},close:{get:function(){return q()},set:function(a){q=a}},high:{get:function(){return r},set:function(a){r=a}},low:{get:function(){return s},set:function(a){s=a}},margin:{get:function(){return h},set:function(a){h.top=void 0!=a.top?a.top:h.top,h.right=void 0!=a.right?a.right:h.right,h.bottom=void 0!=a.bottom?a.bottom:h.bottom,h.left=void 0!=a.left?a.left:h.left}},color:{get:function(){return x},set:function(b){x=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.cumulativeLineChart=function(){"use strict";function b(l){return H.reset(),H.models(f),r&&H.models(g),s&&H.models(h),l.each(function(l){function A(){d3.select(b.container).style("cursor","ew-resize")}function E(){G.x=d3.event.x,G.i=Math.round(F.invert(G.x)),K()}function H(){d3.select(b.container).style("cursor","auto"),y.index=G.i,C.stateChange(y)}function K(){bb.data([G]);var a=b.duration();b.duration(0),b.update(),b.duration(a)}var L=d3.select(this);a.utils.initSVG(L),L.classed("nv-chart-"+x,!0);var M=this,N=a.utils.availableWidth(o,L,m),O=a.utils.availableHeight(p,L,m);if(b.update=function(){0===D?L.call(b):L.transition().duration(D).call(b)},b.container=this,y.setter(J(l),b.update).getter(I(l)).update(),y.disabled=l.map(function(a){return!!a.disabled}),!z){var P;z={};for(P in y)z[P]=y[P]instanceof Array?y[P].slice(0):y[P]}var Q=d3.behavior.drag().on("dragstart",A).on("drag",E).on("dragend",H);if(!(l&&l.length&&l.filter(function(a){return a.values.length}).length))return a.utils.noData(b,L),b;if(L.selectAll(".nv-noData").remove(),d=f.xScale(),e=f.yScale(),w)f.yDomain(null);else{var R=l.filter(function(a){return!a.disabled}).map(function(a){var b=d3.extent(a.values,f.y());return b[0]<-.95&&(b[0]=-.95),[(b[0]-b[1])/(1+b[1]),(b[1]-b[0])/(1+b[0])]}),S=[d3.min(R,function(a){return a[0]}),d3.max(R,function(a){return a[1]})];f.yDomain(S)}F.domain([0,l[0].values.length-1]).range([0,N]).clamp(!0);var l=c(G.i,l),T=v?"none":"all",U=L.selectAll("g.nv-wrap.nv-cumulativeLine").data([l]),V=U.enter().append("g").attr("class","nvd3 nv-wrap nv-cumulativeLine").append("g"),W=U.select("g");if(V.append("g").attr("class","nv-interactive"),V.append("g").attr("class","nv-x nv-axis").style("pointer-events","none"),V.append("g").attr("class","nv-y nv-axis"),V.append("g").attr("class","nv-background"),V.append("g").attr("class","nv-linesWrap").style("pointer-events",T),V.append("g").attr("class","nv-avgLinesWrap").style("pointer-events","none"),V.append("g").attr("class","nv-legendWrap"),V.append("g").attr("class","nv-controlsWrap"),q&&(i.width(N),W.select(".nv-legendWrap").datum(l).call(i),m.top!=i.height()&&(m.top=i.height(),O=a.utils.availableHeight(p,L,m)),W.select(".nv-legendWrap").attr("transform","translate(0,"+-m.top+")")),u){var X=[{key:"Re-scale y-axis",disabled:!w}];j.width(140).color(["#444","#444","#444"]).rightAlign(!1).margin({top:5,right:0,bottom:5,left:20}),W.select(".nv-controlsWrap").datum(X).attr("transform","translate(0,"+-m.top+")").call(j)}U.attr("transform","translate("+m.left+","+m.top+")"),t&&W.select(".nv-y.nv-axis").attr("transform","translate("+N+",0)");var Y=l.filter(function(a){return a.tempDisabled});U.select(".tempDisabled").remove(),Y.length&&U.append("text").attr("class","tempDisabled").attr("x",N/2).attr("y","-.71em").style("text-anchor","end").text(Y.map(function(a){return a.key}).join(", ")+" values cannot be calculated for this time period."),v&&(k.width(N).height(O).margin({left:m.left,top:m.top}).svgContainer(L).xScale(d),U.select(".nv-interactive").call(k)),V.select(".nv-background").append("rect"),W.select(".nv-background rect").attr("width",N).attr("height",O),f.y(function(a){return a.display.y}).width(N).height(O).color(l.map(function(a,b){return a.color||n(a,b)}).filter(function(a,b){return!l[b].disabled&&!l[b].tempDisabled}));var Z=W.select(".nv-linesWrap").datum(l.filter(function(a){return!a.disabled&&!a.tempDisabled}));Z.call(f),l.forEach(function(a,b){a.seriesIndex=b});var $=l.filter(function(a){return!a.disabled&&!!B(a)}),_=W.select(".nv-avgLinesWrap").selectAll("line").data($,function(a){return a.key}),ab=function(a){var b=e(B(a));return 0>b?0:b>O?O:b};_.enter().append("line").style("stroke-width",2).style("stroke-dasharray","10,10").style("stroke",function(a){return f.color()(a,a.seriesIndex)}).attr("x1",0).attr("x2",N).attr("y1",ab).attr("y2",ab),_.style("stroke-opacity",function(a){var b=e(B(a));return 0>b||b>O?0:1}).attr("x1",0).attr("x2",N).attr("y1",ab).attr("y2",ab),_.exit().remove();var bb=Z.selectAll(".nv-indexLine").data([G]);bb.enter().append("rect").attr("class","nv-indexLine").attr("width",3).attr("x",-2).attr("fill","red").attr("fill-opacity",.5).style("pointer-events","all").call(Q),bb.attr("transform",function(a){return"translate("+F(a.i)+",0)"}).attr("height",O),r&&(g.scale(d)._ticks(a.utils.calcTicksX(N/70,l)).tickSize(-O,0),W.select(".nv-x.nv-axis").attr("transform","translate(0,"+e.range()[0]+")"),W.select(".nv-x.nv-axis").call(g)),s&&(h.scale(e)._ticks(a.utils.calcTicksY(O/36,l)).tickSize(-N,0),W.select(".nv-y.nv-axis").call(h)),W.select(".nv-background rect").on("click",function(){G.x=d3.mouse(this)[0],G.i=Math.round(F.invert(G.x)),y.index=G.i,C.stateChange(y),K()}),f.dispatch.on("elementClick",function(a){G.i=a.pointIndex,G.x=F(G.i),y.index=G.i,C.stateChange(y),K()}),j.dispatch.on("legendClick",function(a){a.disabled=!a.disabled,w=!a.disabled,y.rescaleY=w,C.stateChange(y),b.update()}),i.dispatch.on("stateChange",function(a){for(var c in a)y[c]=a[c];C.stateChange(y),b.update()}),k.dispatch.on("elementMousemove",function(c){f.clearHighlights();var d,e,i,j=[];if(l.filter(function(a,b){return a.seriesIndex=b,!a.disabled}).forEach(function(g,h){e=a.interactiveBisect(g.values,c.pointXValue,b.x()),f.highlightPoint(h,e,!0);var k=g.values[e];"undefined"!=typeof k&&("undefined"==typeof d&&(d=k),"undefined"==typeof i&&(i=b.xScale()(b.x()(k,e))),j.push({key:g.key,value:b.y()(k,e),color:n(g,g.seriesIndex)}))}),j.length>2){var o=b.yScale().invert(c.mouseY),p=Math.abs(b.yScale().domain()[0]-b.yScale().domain()[1]),q=.03*p,r=a.nearestValueIndex(j.map(function(a){return a.value}),o,q);null!==r&&(j[r].highlight=!0)}var s=g.tickFormat()(b.x()(d,e),e);k.tooltip.position({left:i+m.left,top:c.mouseY+m.top}).chartContainer(M.parentNode).valueFormatter(function(a){return h.tickFormat()(a)}).data({value:s,series:j})(),k.renderGuideLine(i)}),k.dispatch.on("elementMouseout",function(){f.clearHighlights()}),C.on("changeState",function(a){"undefined"!=typeof a.disabled&&(l.forEach(function(b,c){b.disabled=a.disabled[c]}),y.disabled=a.disabled),"undefined"!=typeof a.index&&(G.i=a.index,G.x=F(G.i),y.index=a.index,bb.data([G])),"undefined"!=typeof a.rescaleY&&(w=a.rescaleY),b.update()})}),H.renderEnd("cumulativeLineChart immediate"),b}function c(a,b){return K||(K=f.y()),b.map(function(b){if(!b.values)return b;var c=b.values[a];if(null==c)return b;var d=K(c,a);return-.95>d&&!E?(b.tempDisabled=!0,b):(b.tempDisabled=!1,b.values=b.values.map(function(a,b){return a.display={y:(K(a,b)-d)/(1+d)},a}),b)})}var d,e,f=a.models.line(),g=a.models.axis(),h=a.models.axis(),i=a.models.legend(),j=a.models.legend(),k=a.interactiveGuideline(),l=a.models.tooltip(),m={top:30,right:30,bottom:50,left:60},n=a.utils.defaultColor(),o=null,p=null,q=!0,r=!0,s=!0,t=!1,u=!0,v=!1,w=!0,x=f.id(),y=a.utils.state(),z=null,A=null,B=function(a){return a.average},C=d3.dispatch("stateChange","changeState","renderEnd"),D=250,E=!1;y.index=0,y.rescaleY=w,g.orient("bottom").tickPadding(7),h.orient(t?"right":"left"),l.valueFormatter(function(a,b){return h.tickFormat()(a,b)}).headerFormatter(function(a,b){return g.tickFormat()(a,b)}),j.updateState(!1);var F=d3.scale.linear(),G={i:0,x:0},H=a.utils.renderWatch(C,D),I=function(a){return function(){return{active:a.map(function(a){return!a.disabled}),index:G.i,rescaleY:w}}},J=function(a){return function(b){void 0!==b.index&&(G.i=b.index),void 0!==b.rescaleY&&(w=b.rescaleY),void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}};f.dispatch.on("elementMouseover.tooltip",function(a){var c={x:b.x()(a.point),y:b.y()(a.point),color:a.point.color};a.point=c,l.data(a).position(a.pos).hidden(!1)}),f.dispatch.on("elementMouseout.tooltip",function(){l.hidden(!0)});var K=null;return b.dispatch=C,b.lines=f,b.legend=i,b.controls=j,b.xAxis=g,b.yAxis=h,b.interactiveLayer=k,b.state=y,b.tooltip=l,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return o},set:function(a){o=a}},height:{get:function(){return p},set:function(a){p=a}},rescaleY:{get:function(){return w},set:function(a){w=a}},showControls:{get:function(){return u},set:function(a){u=a}},showLegend:{get:function(){return q},set:function(a){q=a}},average:{get:function(){return B},set:function(a){B=a}},defaultState:{get:function(){return z},set:function(a){z=a}},noData:{get:function(){return A},set:function(a){A=a}},showXAxis:{get:function(){return r},set:function(a){r=a}},showYAxis:{get:function(){return s},set:function(a){s=a}},noErrorCheck:{get:function(){return E},set:function(a){E=a}},tooltips:{get:function(){return l.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),l.enabled(!!b)}},tooltipContent:{get:function(){return l.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),l.contentGenerator(b)}},margin:{get:function(){return m},set:function(a){m.top=void 0!==a.top?a.top:m.top,m.right=void 0!==a.right?a.right:m.right,m.bottom=void 0!==a.bottom?a.bottom:m.bottom,m.left=void 0!==a.left?a.left:m.left}},color:{get:function(){return n},set:function(b){n=a.utils.getColor(b),i.color(n)}},useInteractiveGuideline:{get:function(){return v},set:function(a){v=a,a===!0&&(b.interactive(!1),b.useVoronoi(!1))}},rightAlignYAxis:{get:function(){return t},set:function(a){t=a,h.orient(a?"right":"left")}},duration:{get:function(){return D},set:function(a){D=a,f.duration(D),g.duration(D),h.duration(D),H.reset(D)}}}),a.utils.inheritOptions(b,f),a.utils.initOptions(b),b},a.models.discreteBar=function(){"use strict";function b(m){return y.reset(),m.each(function(b){var m=k-j.left-j.right,x=l-j.top-j.bottom;c=d3.select(this),a.utils.initSVG(c),b.forEach(function(a,b){a.values.forEach(function(a){a.series=b})});var z=d&&e?[]:b.map(function(a){return a.values.map(function(a,b){return{x:p(a,b),y:q(a,b),y0:a.y0}})});n.domain(d||d3.merge(z).map(function(a){return a.x})).rangeBands(f||[0,m],.1),o.domain(e||d3.extent(d3.merge(z).map(function(a){return a.y}).concat(r))),o.range(t?g||[x-(o.domain()[0]<0?12:0),o.domain()[1]>0?12:0]:g||[x,0]),h=h||n,i=i||o.copy().range([o(0),o(0)]);{var A=c.selectAll("g.nv-wrap.nv-discretebar").data([b]),B=A.enter().append("g").attr("class","nvd3 nv-wrap nv-discretebar"),C=B.append("g");A.select("g")}C.append("g").attr("class","nv-groups"),A.attr("transform","translate("+j.left+","+j.top+")");var D=A.select(".nv-groups").selectAll(".nv-group").data(function(a){return a},function(a){return a.key});D.enter().append("g").style("stroke-opacity",1e-6).style("fill-opacity",1e-6),D.exit().watchTransition(y,"discreteBar: exit groups").style("stroke-opacity",1e-6).style("fill-opacity",1e-6).remove(),D.attr("class",function(a,b){return"nv-group nv-series-"+b}).classed("hover",function(a){return a.hover}),D.watchTransition(y,"discreteBar: groups").style("stroke-opacity",1).style("fill-opacity",.75);var E=D.selectAll("g.nv-bar").data(function(a){return a.values});E.exit().remove();var F=E.enter().append("g").attr("transform",function(a,b){return"translate("+(n(p(a,b))+.05*n.rangeBand())+", "+o(0)+")"}).on("mouseover",function(a,b){d3.select(this).classed("hover",!0),v.elementMouseover({data:a,index:b,color:d3.select(this).style("fill")})}).on("mouseout",function(a,b){d3.select(this).classed("hover",!1),v.elementMouseout({data:a,index:b,color:d3.select(this).style("fill")})}).on("mousemove",function(a,b){v.elementMousemove({data:a,index:b,color:d3.select(this).style("fill")})}).on("click",function(a,b){v.elementClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation()}).on("dblclick",function(a,b){v.elementDblClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation()});F.append("rect").attr("height",0).attr("width",.9*n.rangeBand()/b.length),t?(F.append("text").attr("text-anchor","middle"),E.select("text").text(function(a,b){return u(q(a,b))}).watchTransition(y,"discreteBar: bars text").attr("x",.9*n.rangeBand()/2).attr("y",function(a,b){return q(a,b)<0?o(q(a,b))-o(0)+12:-4})):E.selectAll("text").remove(),E.attr("class",function(a,b){return q(a,b)<0?"nv-bar negative":"nv-bar positive"}).style("fill",function(a,b){return a.color||s(a,b)}).style("stroke",function(a,b){return a.color||s(a,b)}).select("rect").attr("class",w).watchTransition(y,"discreteBar: bars rect").attr("width",.9*n.rangeBand()/b.length),E.watchTransition(y,"discreteBar: bars").attr("transform",function(a,b){var c=n(p(a,b))+.05*n.rangeBand(),d=q(a,b)<0?o(0):o(0)-o(q(a,b))<1?o(0)-1:o(q(a,b));return"translate("+c+", "+d+")"}).select("rect").attr("height",function(a,b){return Math.max(Math.abs(o(q(a,b))-o(e&&e[0]||0))||1)}),h=n.copy(),i=o.copy()}),y.renderEnd("discreteBar immediate"),b}var c,d,e,f,g,h,i,j={top:0,right:0,bottom:0,left:0},k=960,l=500,m=Math.floor(1e4*Math.random()),n=d3.scale.ordinal(),o=d3.scale.linear(),p=function(a){return a.x},q=function(a){return a.y},r=[0],s=a.utils.defaultColor(),t=!1,u=d3.format(",.2f"),v=d3.dispatch("chartClick","elementClick","elementDblClick","elementMouseover","elementMouseout","elementMousemove","renderEnd"),w="discreteBar",x=250,y=a.utils.renderWatch(v,x);return b.dispatch=v,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return k},set:function(a){k=a}},height:{get:function(){return l},set:function(a){l=a}},forceY:{get:function(){return r},set:function(a){r=a}},showValues:{get:function(){return t},set:function(a){t=a}},x:{get:function(){return p},set:function(a){p=a}},y:{get:function(){return q},set:function(a){q=a}},xScale:{get:function(){return n},set:function(a){n=a}},yScale:{get:function(){return o},set:function(a){o=a}},xDomain:{get:function(){return d},set:function(a){d=a}},yDomain:{get:function(){return e},set:function(a){e=a}},xRange:{get:function(){return f},set:function(a){f=a}},yRange:{get:function(){return g},set:function(a){g=a}},valueFormat:{get:function(){return u},set:function(a){u=a}},id:{get:function(){return m},set:function(a){m=a}},rectClass:{get:function(){return w},set:function(a){w=a}},margin:{get:function(){return j},set:function(a){j.top=void 0!==a.top?a.top:j.top,j.right=void 0!==a.right?a.right:j.right,j.bottom=void 0!==a.bottom?a.bottom:j.bottom,j.left=void 0!==a.left?a.left:j.left}},color:{get:function(){return s},set:function(b){s=a.utils.getColor(b)}},duration:{get:function(){return x},set:function(a){x=a,y.reset(x)}}}),a.utils.initOptions(b),b},a.models.discreteBarChart=function(){"use strict";function b(h){return t.reset(),t.models(e),m&&t.models(f),n&&t.models(g),h.each(function(h){var l=d3.select(this);a.utils.initSVG(l);var q=a.utils.availableWidth(j,l,i),t=a.utils.availableHeight(k,l,i);if(b.update=function(){r.beforeUpdate(),l.transition().duration(s).call(b)},b.container=this,!(h&&h.length&&h.filter(function(a){return a.values.length}).length))return a.utils.noData(b,l),b;l.selectAll(".nv-noData").remove(),c=e.xScale(),d=e.yScale().clamp(!0);var u=l.selectAll("g.nv-wrap.nv-discreteBarWithAxes").data([h]),v=u.enter().append("g").attr("class","nvd3 nv-wrap nv-discreteBarWithAxes").append("g"),w=v.append("defs"),x=u.select("g");v.append("g").attr("class","nv-x nv-axis"),v.append("g").attr("class","nv-y nv-axis").append("g").attr("class","nv-zeroLine").append("line"),v.append("g").attr("class","nv-barsWrap"),x.attr("transform","translate("+i.left+","+i.top+")"),o&&x.select(".nv-y.nv-axis").attr("transform","translate("+q+",0)"),e.width(q).height(t);var y=x.select(".nv-barsWrap").datum(h.filter(function(a){return!a.disabled}));if(y.transition().call(e),w.append("clipPath").attr("id","nv-x-label-clip-"+e.id()).append("rect"),x.select("#nv-x-label-clip-"+e.id()+" rect").attr("width",c.rangeBand()*(p?2:1)).attr("height",16).attr("x",-c.rangeBand()/(p?1:2)),m){f.scale(c)._ticks(a.utils.calcTicksX(q/100,h)).tickSize(-t,0),x.select(".nv-x.nv-axis").attr("transform","translate(0,"+(d.range()[0]+(e.showValues()&&d.domain()[0]<0?16:0))+")"),x.select(".nv-x.nv-axis").call(f);
var z=x.select(".nv-x.nv-axis").selectAll("g");p&&z.selectAll("text").attr("transform",function(a,b,c){return"translate(0,"+(c%2==0?"5":"17")+")"})}n&&(g.scale(d)._ticks(a.utils.calcTicksY(t/36,h)).tickSize(-q,0),x.select(".nv-y.nv-axis").call(g)),x.select(".nv-zeroLine line").attr("x1",0).attr("x2",q).attr("y1",d(0)).attr("y2",d(0))}),t.renderEnd("discreteBar chart immediate"),b}var c,d,e=a.models.discreteBar(),f=a.models.axis(),g=a.models.axis(),h=a.models.tooltip(),i={top:15,right:10,bottom:50,left:60},j=null,k=null,l=a.utils.getColor(),m=!0,n=!0,o=!1,p=!1,q=null,r=d3.dispatch("beforeUpdate","renderEnd"),s=250;f.orient("bottom").showMaxMin(!1).tickFormat(function(a){return a}),g.orient(o?"right":"left").tickFormat(d3.format(",.1f")),h.duration(0).headerEnabled(!1).valueFormatter(function(a,b){return g.tickFormat()(a,b)}).keyFormatter(function(a,b){return f.tickFormat()(a,b)});var t=a.utils.renderWatch(r,s);return e.dispatch.on("elementMouseover.tooltip",function(a){a.series={key:b.x()(a.data),value:b.y()(a.data),color:a.color},h.data(a).hidden(!1)}),e.dispatch.on("elementMouseout.tooltip",function(){h.hidden(!0)}),e.dispatch.on("elementMousemove.tooltip",function(){h.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.dispatch=r,b.discretebar=e,b.xAxis=f,b.yAxis=g,b.tooltip=h,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return j},set:function(a){j=a}},height:{get:function(){return k},set:function(a){k=a}},staggerLabels:{get:function(){return p},set:function(a){p=a}},showXAxis:{get:function(){return m},set:function(a){m=a}},showYAxis:{get:function(){return n},set:function(a){n=a}},noData:{get:function(){return q},set:function(a){q=a}},tooltips:{get:function(){return h.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),h.enabled(!!b)}},tooltipContent:{get:function(){return h.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),h.contentGenerator(b)}},margin:{get:function(){return i},set:function(a){i.top=void 0!==a.top?a.top:i.top,i.right=void 0!==a.right?a.right:i.right,i.bottom=void 0!==a.bottom?a.bottom:i.bottom,i.left=void 0!==a.left?a.left:i.left}},duration:{get:function(){return s},set:function(a){s=a,t.reset(s),e.duration(s),f.duration(s),g.duration(s)}},color:{get:function(){return l},set:function(b){l=a.utils.getColor(b),e.color(l)}},rightAlignYAxis:{get:function(){return o},set:function(a){o=a,g.orient(a?"right":"left")}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.distribution=function(){"use strict";function b(k){return m.reset(),k.each(function(b){var k=(e-("x"===g?d.left+d.right:d.top+d.bottom),"x"==g?"y":"x"),l=d3.select(this);a.utils.initSVG(l),c=c||j;var n=l.selectAll("g.nv-distribution").data([b]),o=n.enter().append("g").attr("class","nvd3 nv-distribution"),p=(o.append("g"),n.select("g"));n.attr("transform","translate("+d.left+","+d.top+")");var q=p.selectAll("g.nv-dist").data(function(a){return a},function(a){return a.key});q.enter().append("g"),q.attr("class",function(a,b){return"nv-dist nv-series-"+b}).style("stroke",function(a,b){return i(a,b)});var r=q.selectAll("line.nv-dist"+g).data(function(a){return a.values});r.enter().append("line").attr(g+"1",function(a,b){return c(h(a,b))}).attr(g+"2",function(a,b){return c(h(a,b))}),m.transition(q.exit().selectAll("line.nv-dist"+g),"dist exit").attr(g+"1",function(a,b){return j(h(a,b))}).attr(g+"2",function(a,b){return j(h(a,b))}).style("stroke-opacity",0).remove(),r.attr("class",function(a,b){return"nv-dist"+g+" nv-dist"+g+"-"+b}).attr(k+"1",0).attr(k+"2",f),m.transition(r,"dist").attr(g+"1",function(a,b){return j(h(a,b))}).attr(g+"2",function(a,b){return j(h(a,b))}),c=j.copy()}),m.renderEnd("distribution immediate"),b}var c,d={top:0,right:0,bottom:0,left:0},e=400,f=8,g="x",h=function(a){return a[g]},i=a.utils.defaultColor(),j=d3.scale.linear(),k=250,l=d3.dispatch("renderEnd"),m=a.utils.renderWatch(l,k);return b.options=a.utils.optionsFunc.bind(b),b.dispatch=l,b.margin=function(a){return arguments.length?(d.top="undefined"!=typeof a.top?a.top:d.top,d.right="undefined"!=typeof a.right?a.right:d.right,d.bottom="undefined"!=typeof a.bottom?a.bottom:d.bottom,d.left="undefined"!=typeof a.left?a.left:d.left,b):d},b.width=function(a){return arguments.length?(e=a,b):e},b.axis=function(a){return arguments.length?(g=a,b):g},b.size=function(a){return arguments.length?(f=a,b):f},b.getData=function(a){return arguments.length?(h=d3.functor(a),b):h},b.scale=function(a){return arguments.length?(j=a,b):j},b.color=function(c){return arguments.length?(i=a.utils.getColor(c),b):i},b.duration=function(a){return arguments.length?(k=a,m.reset(k),b):k},b},a.models.furiousLegend=function(){"use strict";function b(p){function q(a,b){return"furious"!=o?"#000":m?a.disengaged?g(a,b):"#fff":m?void 0:a.disabled?g(a,b):"#fff"}function r(a,b){return m&&"furious"==o?a.disengaged?"#fff":g(a,b):a.disabled?"#fff":g(a,b)}return p.each(function(b){var p=d-c.left-c.right,s=d3.select(this);a.utils.initSVG(s);var t=s.selectAll("g.nv-legend").data([b]),u=(t.enter().append("g").attr("class","nvd3 nv-legend").append("g"),t.select("g"));t.attr("transform","translate("+c.left+","+c.top+")");var v,w=u.selectAll(".nv-series").data(function(a){return"furious"!=o?a:a.filter(function(a){return m?!0:!a.disengaged})}),x=w.enter().append("g").attr("class","nv-series");if("classic"==o)x.append("circle").style("stroke-width",2).attr("class","nv-legend-symbol").attr("r",5),v=w.select("circle");else if("furious"==o){x.append("rect").style("stroke-width",2).attr("class","nv-legend-symbol").attr("rx",3).attr("ry",3),v=w.select("rect"),x.append("g").attr("class","nv-check-box").property("innerHTML",'<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>').attr("transform","translate(-10,-8)scale(0.5)");var y=w.select(".nv-check-box");y.each(function(a,b){d3.select(this).selectAll("path").attr("stroke",q(a,b))})}x.append("text").attr("text-anchor","start").attr("class","nv-legend-text").attr("dy",".32em").attr("dx","8");var z=w.select("text.nv-legend-text");w.on("mouseover",function(a,b){n.legendMouseover(a,b)}).on("mouseout",function(a,b){n.legendMouseout(a,b)}).on("click",function(a,b){n.legendClick(a,b);var c=w.data();if(k){if("classic"==o)l?(c.forEach(function(a){a.disabled=!0}),a.disabled=!1):(a.disabled=!a.disabled,c.every(function(a){return a.disabled})&&c.forEach(function(a){a.disabled=!1}));else if("furious"==o)if(m)a.disengaged=!a.disengaged,a.userDisabled=void 0==a.userDisabled?!!a.disabled:a.userDisabled,a.disabled=a.disengaged||a.userDisabled;else if(!m){a.disabled=!a.disabled,a.userDisabled=a.disabled;var d=c.filter(function(a){return!a.disengaged});d.every(function(a){return a.userDisabled})&&c.forEach(function(a){a.disabled=a.userDisabled=!1})}n.stateChange({disabled:c.map(function(a){return!!a.disabled}),disengaged:c.map(function(a){return!!a.disengaged})})}}).on("dblclick",function(a,b){if(("furious"!=o||!m)&&(n.legendDblclick(a,b),k)){var c=w.data();c.forEach(function(a){a.disabled=!0,"furious"==o&&(a.userDisabled=a.disabled)}),a.disabled=!1,"furious"==o&&(a.userDisabled=a.disabled),n.stateChange({disabled:c.map(function(a){return!!a.disabled})})}}),w.classed("nv-disabled",function(a){return a.userDisabled}),w.exit().remove(),z.attr("fill",q).text(f);var A;switch(o){case"furious":A=23;break;case"classic":A=20}if(h){var B=[];w.each(function(){var b,c=d3.select(this).select("text");try{if(b=c.node().getComputedTextLength(),0>=b)throw Error()}catch(d){b=a.utils.calcApproxTextWidth(c)}B.push(b+i)});for(var C=0,D=0,E=[];p>D&&C<B.length;)E[C]=B[C],D+=B[C++];for(0===C&&(C=1);D>p&&C>1;){E=[],C--;for(var F=0;F<B.length;F++)B[F]>(E[F%C]||0)&&(E[F%C]=B[F]);D=E.reduce(function(a,b){return a+b})}for(var G=[],H=0,I=0;C>H;H++)G[H]=I,I+=E[H];w.attr("transform",function(a,b){return"translate("+G[b%C]+","+(5+Math.floor(b/C)*A)+")"}),j?u.attr("transform","translate("+(d-c.right-D)+","+c.top+")"):u.attr("transform","translate(0,"+c.top+")"),e=c.top+c.bottom+Math.ceil(B.length/C)*A}else{var J,K=5,L=5,M=0;w.attr("transform",function(){var a=d3.select(this).select("text").node().getComputedTextLength()+i;return J=L,d<c.left+c.right+J+a&&(L=J=5,K+=A),L+=a,L>M&&(M=L),"translate("+J+","+K+")"}),u.attr("transform","translate("+(d-c.right-M)+","+c.top+")"),e=c.top+c.bottom+K+15}"furious"==o&&v.attr("width",function(a,b){return z[0][b].getComputedTextLength()+27}).attr("height",18).attr("y",-9).attr("x",-15),v.style("fill",r).style("stroke",function(a,b){return a.color||g(a,b)})}),b}var c={top:5,right:0,bottom:5,left:0},d=400,e=20,f=function(a){return a.key},g=a.utils.getColor(),h=!0,i=28,j=!0,k=!0,l=!1,m=!1,n=d3.dispatch("legendClick","legendDblclick","legendMouseover","legendMouseout","stateChange"),o="classic";return b.dispatch=n,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return d},set:function(a){d=a}},height:{get:function(){return e},set:function(a){e=a}},key:{get:function(){return f},set:function(a){f=a}},align:{get:function(){return h},set:function(a){h=a}},rightAlign:{get:function(){return j},set:function(a){j=a}},padding:{get:function(){return i},set:function(a){i=a}},updateState:{get:function(){return k},set:function(a){k=a}},radioButtonMode:{get:function(){return l},set:function(a){l=a}},expanded:{get:function(){return m},set:function(a){m=a}},vers:{get:function(){return o},set:function(a){o=a}},margin:{get:function(){return c},set:function(a){c.top=void 0!==a.top?a.top:c.top,c.right=void 0!==a.right?a.right:c.right,c.bottom=void 0!==a.bottom?a.bottom:c.bottom,c.left=void 0!==a.left?a.left:c.left}},color:{get:function(){return g},set:function(b){g=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.historicalBar=function(){"use strict";function b(x){return x.each(function(b){w.reset(),k=d3.select(this);var x=a.utils.availableWidth(h,k,g),y=a.utils.availableHeight(i,k,g);a.utils.initSVG(k),l.domain(c||d3.extent(b[0].values.map(n).concat(p))),l.range(r?e||[.5*x/b[0].values.length,x*(b[0].values.length-.5)/b[0].values.length]:e||[0,x]),m.domain(d||d3.extent(b[0].values.map(o).concat(q))).range(f||[y,0]),l.domain()[0]===l.domain()[1]&&l.domain(l.domain()[0]?[l.domain()[0]-.01*l.domain()[0],l.domain()[1]+.01*l.domain()[1]]:[-1,1]),m.domain()[0]===m.domain()[1]&&m.domain(m.domain()[0]?[m.domain()[0]+.01*m.domain()[0],m.domain()[1]-.01*m.domain()[1]]:[-1,1]);var z=k.selectAll("g.nv-wrap.nv-historicalBar-"+j).data([b[0].values]),A=z.enter().append("g").attr("class","nvd3 nv-wrap nv-historicalBar-"+j),B=A.append("defs"),C=A.append("g"),D=z.select("g");C.append("g").attr("class","nv-bars"),z.attr("transform","translate("+g.left+","+g.top+")"),k.on("click",function(a,b){u.chartClick({data:a,index:b,pos:d3.event,id:j})}),B.append("clipPath").attr("id","nv-chart-clip-path-"+j).append("rect"),z.select("#nv-chart-clip-path-"+j+" rect").attr("width",x).attr("height",y),D.attr("clip-path",s?"url(#nv-chart-clip-path-"+j+")":"");var E=z.select(".nv-bars").selectAll(".nv-bar").data(function(a){return a},function(a,b){return n(a,b)});E.exit().remove(),E.enter().append("rect").attr("x",0).attr("y",function(b,c){return a.utils.NaNtoZero(m(Math.max(0,o(b,c))))}).attr("height",function(b,c){return a.utils.NaNtoZero(Math.abs(m(o(b,c))-m(0)))}).attr("transform",function(a,c){return"translate("+(l(n(a,c))-x/b[0].values.length*.45)+",0)"}).on("mouseover",function(a,b){v&&(d3.select(this).classed("hover",!0),u.elementMouseover({data:a,index:b,color:d3.select(this).style("fill")}))}).on("mouseout",function(a,b){v&&(d3.select(this).classed("hover",!1),u.elementMouseout({data:a,index:b,color:d3.select(this).style("fill")}))}).on("mousemove",function(a,b){v&&u.elementMousemove({data:a,index:b,color:d3.select(this).style("fill")})}).on("click",function(a,b){v&&(u.elementClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation())}).on("dblclick",function(a,b){v&&(u.elementDblClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation())}),E.attr("fill",function(a,b){return t(a,b)}).attr("class",function(a,b,c){return(o(a,b)<0?"nv-bar negative":"nv-bar positive")+" nv-bar-"+c+"-"+b}).watchTransition(w,"bars").attr("transform",function(a,c){return"translate("+(l(n(a,c))-x/b[0].values.length*.45)+",0)"}).attr("width",x/b[0].values.length*.9),E.watchTransition(w,"bars").attr("y",function(b,c){var d=o(b,c)<0?m(0):m(0)-m(o(b,c))<1?m(0)-1:m(o(b,c));return a.utils.NaNtoZero(d)}).attr("height",function(b,c){return a.utils.NaNtoZero(Math.max(Math.abs(m(o(b,c))-m(0)),1))})}),w.renderEnd("historicalBar immediate"),b}var c,d,e,f,g={top:0,right:0,bottom:0,left:0},h=null,i=null,j=Math.floor(1e4*Math.random()),k=null,l=d3.scale.linear(),m=d3.scale.linear(),n=function(a){return a.x},o=function(a){return a.y},p=[],q=[0],r=!1,s=!0,t=a.utils.defaultColor(),u=d3.dispatch("chartClick","elementClick","elementDblClick","elementMouseover","elementMouseout","elementMousemove","renderEnd"),v=!0,w=a.utils.renderWatch(u,0);return b.highlightPoint=function(a,b){k.select(".nv-bars .nv-bar-0-"+a).classed("hover",b)},b.clearHighlights=function(){k.select(".nv-bars .nv-bar.hover").classed("hover",!1)},b.dispatch=u,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return h},set:function(a){h=a}},height:{get:function(){return i},set:function(a){i=a}},forceX:{get:function(){return p},set:function(a){p=a}},forceY:{get:function(){return q},set:function(a){q=a}},padData:{get:function(){return r},set:function(a){r=a}},x:{get:function(){return n},set:function(a){n=a}},y:{get:function(){return o},set:function(a){o=a}},xScale:{get:function(){return l},set:function(a){l=a}},yScale:{get:function(){return m},set:function(a){m=a}},xDomain:{get:function(){return c},set:function(a){c=a}},yDomain:{get:function(){return d},set:function(a){d=a}},xRange:{get:function(){return e},set:function(a){e=a}},yRange:{get:function(){return f},set:function(a){f=a}},clipEdge:{get:function(){return s},set:function(a){s=a}},id:{get:function(){return j},set:function(a){j=a}},interactive:{get:function(){return v},set:function(a){v=a}},margin:{get:function(){return g},set:function(a){g.top=void 0!==a.top?a.top:g.top,g.right=void 0!==a.right?a.right:g.right,g.bottom=void 0!==a.bottom?a.bottom:g.bottom,g.left=void 0!==a.left?a.left:g.left}},color:{get:function(){return t},set:function(b){t=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.historicalBarChart=function(b){"use strict";function c(b){return b.each(function(k){z.reset(),z.models(f),q&&z.models(g),r&&z.models(h);var w=d3.select(this),A=this;a.utils.initSVG(w);var B=a.utils.availableWidth(n,w,l),C=a.utils.availableHeight(o,w,l);if(c.update=function(){w.transition().duration(y).call(c)},c.container=this,u.disabled=k.map(function(a){return!!a.disabled}),!v){var D;v={};for(D in u)v[D]=u[D]instanceof Array?u[D].slice(0):u[D]}if(!(k&&k.length&&k.filter(function(a){return a.values.length}).length))return a.utils.noData(c,w),c;w.selectAll(".nv-noData").remove(),d=f.xScale(),e=f.yScale();var E=w.selectAll("g.nv-wrap.nv-historicalBarChart").data([k]),F=E.enter().append("g").attr("class","nvd3 nv-wrap nv-historicalBarChart").append("g"),G=E.select("g");F.append("g").attr("class","nv-x nv-axis"),F.append("g").attr("class","nv-y nv-axis"),F.append("g").attr("class","nv-barsWrap"),F.append("g").attr("class","nv-legendWrap"),F.append("g").attr("class","nv-interactive"),p&&(i.width(B),G.select(".nv-legendWrap").datum(k).call(i),l.top!=i.height()&&(l.top=i.height(),C=a.utils.availableHeight(o,w,l)),E.select(".nv-legendWrap").attr("transform","translate(0,"+-l.top+")")),E.attr("transform","translate("+l.left+","+l.top+")"),s&&G.select(".nv-y.nv-axis").attr("transform","translate("+B+",0)"),t&&(j.width(B).height(C).margin({left:l.left,top:l.top}).svgContainer(w).xScale(d),E.select(".nv-interactive").call(j)),f.width(B).height(C).color(k.map(function(a,b){return a.color||m(a,b)}).filter(function(a,b){return!k[b].disabled}));var H=G.select(".nv-barsWrap").datum(k.filter(function(a){return!a.disabled}));H.transition().call(f),q&&(g.scale(d)._ticks(a.utils.calcTicksX(B/100,k)).tickSize(-C,0),G.select(".nv-x.nv-axis").attr("transform","translate(0,"+e.range()[0]+")"),G.select(".nv-x.nv-axis").transition().call(g)),r&&(h.scale(e)._ticks(a.utils.calcTicksY(C/36,k)).tickSize(-B,0),G.select(".nv-y.nv-axis").transition().call(h)),j.dispatch.on("elementMousemove",function(b){f.clearHighlights();var d,e,i,n=[];k.filter(function(a,b){return a.seriesIndex=b,!a.disabled}).forEach(function(g){e=a.interactiveBisect(g.values,b.pointXValue,c.x()),f.highlightPoint(e,!0);var h=g.values[e];void 0!==h&&(void 0===d&&(d=h),void 0===i&&(i=c.xScale()(c.x()(h,e))),n.push({key:g.key,value:c.y()(h,e),color:m(g,g.seriesIndex),data:g.values[e]}))});var o=g.tickFormat()(c.x()(d,e));j.tooltip.position({left:i+l.left,top:b.mouseY+l.top}).chartContainer(A.parentNode).valueFormatter(function(a){return h.tickFormat()(a)}).data({value:o,index:e,series:n})(),j.renderGuideLine(i)}),j.dispatch.on("elementMouseout",function(){x.tooltipHide(),f.clearHighlights()}),i.dispatch.on("legendClick",function(a){a.disabled=!a.disabled,k.filter(function(a){return!a.disabled}).length||k.map(function(a){return a.disabled=!1,E.selectAll(".nv-series").classed("disabled",!1),a}),u.disabled=k.map(function(a){return!!a.disabled}),x.stateChange(u),b.transition().call(c)}),i.dispatch.on("legendDblclick",function(a){k.forEach(function(a){a.disabled=!0}),a.disabled=!1,u.disabled=k.map(function(a){return!!a.disabled}),x.stateChange(u),c.update()}),x.on("changeState",function(a){"undefined"!=typeof a.disabled&&(k.forEach(function(b,c){b.disabled=a.disabled[c]}),u.disabled=a.disabled),c.update()})}),z.renderEnd("historicalBarChart immediate"),c}var d,e,f=b||a.models.historicalBar(),g=a.models.axis(),h=a.models.axis(),i=a.models.legend(),j=a.interactiveGuideline(),k=a.models.tooltip(),l={top:30,right:90,bottom:50,left:90},m=a.utils.defaultColor(),n=null,o=null,p=!1,q=!0,r=!0,s=!1,t=!1,u={},v=null,w=null,x=d3.dispatch("tooltipHide","stateChange","changeState","renderEnd"),y=250;g.orient("bottom").tickPadding(7),h.orient(s?"right":"left"),k.duration(0).headerEnabled(!1).valueFormatter(function(a,b){return h.tickFormat()(a,b)}).headerFormatter(function(a,b){return g.tickFormat()(a,b)});var z=a.utils.renderWatch(x,0);return f.dispatch.on("elementMouseover.tooltip",function(a){a.series={key:c.x()(a.data),value:c.y()(a.data),color:a.color},k.data(a).hidden(!1)}),f.dispatch.on("elementMouseout.tooltip",function(){k.hidden(!0)}),f.dispatch.on("elementMousemove.tooltip",function(){k.position({top:d3.event.pageY,left:d3.event.pageX})()}),c.dispatch=x,c.bars=f,c.legend=i,c.xAxis=g,c.yAxis=h,c.interactiveLayer=j,c.tooltip=k,c.options=a.utils.optionsFunc.bind(c),c._options=Object.create({},{width:{get:function(){return n},set:function(a){n=a}},height:{get:function(){return o},set:function(a){o=a}},showLegend:{get:function(){return p},set:function(a){p=a}},showXAxis:{get:function(){return q},set:function(a){q=a}},showYAxis:{get:function(){return r},set:function(a){r=a}},defaultState:{get:function(){return v},set:function(a){v=a}},noData:{get:function(){return w},set:function(a){w=a}},tooltips:{get:function(){return k.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),k.enabled(!!b)}},tooltipContent:{get:function(){return k.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),k.contentGenerator(b)}},margin:{get:function(){return l},set:function(a){l.top=void 0!==a.top?a.top:l.top,l.right=void 0!==a.right?a.right:l.right,l.bottom=void 0!==a.bottom?a.bottom:l.bottom,l.left=void 0!==a.left?a.left:l.left}},color:{get:function(){return m},set:function(b){m=a.utils.getColor(b),i.color(m),f.color(m)}},duration:{get:function(){return y},set:function(a){y=a,z.reset(y),h.duration(y),g.duration(y)}},rightAlignYAxis:{get:function(){return s},set:function(a){s=a,h.orient(a?"right":"left")}},useInteractiveGuideline:{get:function(){return t},set:function(a){t=a,a===!0&&c.interactive(!1)}}}),a.utils.inheritOptions(c,f),a.utils.initOptions(c),c},a.models.ohlcBarChart=function(){var b=a.models.historicalBarChart(a.models.ohlcBar());return b.useInteractiveGuideline(!0),b.interactiveLayer.tooltip.contentGenerator(function(a){var c=a.series[0].data,d=c.open<c.close?"2ca02c":"d62728";return'<h3 style="color: #'+d+'">'+a.value+"</h3><table><tr><td>open:</td><td>"+b.yAxis.tickFormat()(c.open)+"</td></tr><tr><td>close:</td><td>"+b.yAxis.tickFormat()(c.close)+"</td></tr><tr><td>high</td><td>"+b.yAxis.tickFormat()(c.high)+"</td></tr><tr><td>low:</td><td>"+b.yAxis.tickFormat()(c.low)+"</td></tr></table>"}),b},a.models.candlestickBarChart=function(){var b=a.models.historicalBarChart(a.models.candlestickBar());return b.useInteractiveGuideline(!0),b.interactiveLayer.tooltip.contentGenerator(function(a){var c=a.series[0].data,d=c.open<c.close?"2ca02c":"d62728";return'<h3 style="color: #'+d+'">'+a.value+"</h3><table><tr><td>open:</td><td>"+b.yAxis.tickFormat()(c.open)+"</td></tr><tr><td>close:</td><td>"+b.yAxis.tickFormat()(c.close)+"</td></tr><tr><td>high</td><td>"+b.yAxis.tickFormat()(c.high)+"</td></tr><tr><td>low:</td><td>"+b.yAxis.tickFormat()(c.low)+"</td></tr></table>"}),b},a.models.legend=function(){"use strict";function b(p){function q(a,b){return"furious"!=o?"#000":m?a.disengaged?"#000":"#fff":m?void 0:(a.color||(a.color=g(a,b)),a.disabled?a.color:"#fff")}function r(a,b){return m&&"furious"==o&&a.disengaged?"#eee":a.color||g(a,b)}function s(a){return m&&"furious"==o?1:a.disabled?0:1}return p.each(function(b){var g=d-c.left-c.right,p=d3.select(this);a.utils.initSVG(p);var t=p.selectAll("g.nv-legend").data([b]),u=t.enter().append("g").attr("class","nvd3 nv-legend").append("g"),v=t.select("g");t.attr("transform","translate("+c.left+","+c.top+")");var w,x,y=v.selectAll(".nv-series").data(function(a){return"furious"!=o?a:a.filter(function(a){return m?!0:!a.disengaged})}),z=y.enter().append("g").attr("class","nv-series");switch(o){case"furious":x=23;break;case"classic":x=20}if("classic"==o)z.append("circle").style("stroke-width",2).attr("class","nv-legend-symbol").attr("r",5),w=y.select("circle");else if("furious"==o){z.append("rect").style("stroke-width",2).attr("class","nv-legend-symbol").attr("rx",3).attr("ry",3),w=y.select(".nv-legend-symbol"),z.append("g").attr("class","nv-check-box").property("innerHTML",'<path d="M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z" class="nv-box"></path><path d="M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511" class="nv-check"></path>').attr("transform","translate(-10,-8)scale(0.5)");var A=y.select(".nv-check-box");A.each(function(a,b){d3.select(this).selectAll("path").attr("stroke",q(a,b))})}z.append("text").attr("text-anchor","start").attr("class","nv-legend-text").attr("dy",".32em").attr("dx","8");var B=y.select("text.nv-legend-text");y.on("mouseover",function(a,b){n.legendMouseover(a,b)}).on("mouseout",function(a,b){n.legendMouseout(a,b)}).on("click",function(a,b){n.legendClick(a,b);var c=y.data();if(k){if("classic"==o)l?(c.forEach(function(a){a.disabled=!0}),a.disabled=!1):(a.disabled=!a.disabled,c.every(function(a){return a.disabled})&&c.forEach(function(a){a.disabled=!1}));else if("furious"==o)if(m)a.disengaged=!a.disengaged,a.userDisabled=void 0==a.userDisabled?!!a.disabled:a.userDisabled,a.disabled=a.disengaged||a.userDisabled;else if(!m){a.disabled=!a.disabled,a.userDisabled=a.disabled;var d=c.filter(function(a){return!a.disengaged});d.every(function(a){return a.userDisabled})&&c.forEach(function(a){a.disabled=a.userDisabled=!1})}n.stateChange({disabled:c.map(function(a){return!!a.disabled}),disengaged:c.map(function(a){return!!a.disengaged})})}}).on("dblclick",function(a,b){if(("furious"!=o||!m)&&(n.legendDblclick(a,b),k)){var c=y.data();c.forEach(function(a){a.disabled=!0,"furious"==o&&(a.userDisabled=a.disabled)}),a.disabled=!1,"furious"==o&&(a.userDisabled=a.disabled),n.stateChange({disabled:c.map(function(a){return!!a.disabled})})}}),y.classed("nv-disabled",function(a){return a.userDisabled}),y.exit().remove(),B.attr("fill",q).text(f);var C=0;if(h){var D=[];y.each(function(){var b,c=d3.select(this).select("text");try{if(b=c.node().getComputedTextLength(),0>=b)throw Error()}catch(d){b=a.utils.calcApproxTextWidth(c)}D.push(b+i)});var E=0,F=[];for(C=0;g>C&&E<D.length;)F[E]=D[E],C+=D[E++];for(0===E&&(E=1);C>g&&E>1;){F=[],E--;for(var G=0;G<D.length;G++)D[G]>(F[G%E]||0)&&(F[G%E]=D[G]);C=F.reduce(function(a,b){return a+b})}for(var H=[],I=0,J=0;E>I;I++)H[I]=J,J+=F[I];y.attr("transform",function(a,b){return"translate("+H[b%E]+","+(5+Math.floor(b/E)*x)+")"}),j?v.attr("transform","translate("+(d-c.right-C)+","+c.top+")"):v.attr("transform","translate(0,"+c.top+")"),e=c.top+c.bottom+Math.ceil(D.length/E)*x}else{var K,L=5,M=5,N=0;y.attr("transform",function(){var a=d3.select(this).select("text").node().getComputedTextLength()+i;return K=M,d<c.left+c.right+K+a&&(M=K=5,L+=x),M+=a,M>N&&(N=M),K+N>C&&(C=K+N),"translate("+K+","+L+")"}),v.attr("transform","translate("+(d-c.right-N)+","+c.top+")"),e=c.top+c.bottom+L+15}if("furious"==o){w.attr("width",function(a,b){return B[0][b].getComputedTextLength()+27}).attr("height",18).attr("y",-9).attr("x",-15),u.insert("rect",":first-child").attr("class","nv-legend-bg").attr("fill","#eee").attr("opacity",0);var O=v.select(".nv-legend-bg");O.transition().duration(300).attr("x",-x).attr("width",C+x-12).attr("height",e+10).attr("y",-c.top-10).attr("opacity",m?1:0)}w.style("fill",r).style("fill-opacity",s).style("stroke",r)}),b}var c={top:5,right:0,bottom:5,left:0},d=400,e=20,f=function(a){return a.key},g=a.utils.getColor(),h=!0,i=32,j=!0,k=!0,l=!1,m=!1,n=d3.dispatch("legendClick","legendDblclick","legendMouseover","legendMouseout","stateChange"),o="classic";return b.dispatch=n,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return d},set:function(a){d=a}},height:{get:function(){return e},set:function(a){e=a}},key:{get:function(){return f},set:function(a){f=a}},align:{get:function(){return h},set:function(a){h=a}},rightAlign:{get:function(){return j},set:function(a){j=a}},padding:{get:function(){return i},set:function(a){i=a}},updateState:{get:function(){return k},set:function(a){k=a}},radioButtonMode:{get:function(){return l},set:function(a){l=a}},expanded:{get:function(){return m},set:function(a){m=a}},vers:{get:function(){return o},set:function(a){o=a}},margin:{get:function(){return c},set:function(a){c.top=void 0!==a.top?a.top:c.top,c.right=void 0!==a.right?a.right:c.right,c.bottom=void 0!==a.bottom?a.bottom:c.bottom,c.left=void 0!==a.left?a.left:c.left}},color:{get:function(){return g},set:function(b){g=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.line=function(){"use strict";function b(r){return v.reset(),v.models(e),r.each(function(b){i=d3.select(this);var r=a.utils.availableWidth(g,i,f),s=a.utils.availableHeight(h,i,f);a.utils.initSVG(i),c=e.xScale(),d=e.yScale(),t=t||c,u=u||d;var w=i.selectAll("g.nv-wrap.nv-line").data([b]),x=w.enter().append("g").attr("class","nvd3 nv-wrap nv-line"),y=x.append("defs"),z=x.append("g"),A=w.select("g");z.append("g").attr("class","nv-groups"),z.append("g").attr("class","nv-scatterWrap"),w.attr("transform","translate("+f.left+","+f.top+")"),e.width(r).height(s);var B=w.select(".nv-scatterWrap");B.call(e),y.append("clipPath").attr("id","nv-edge-clip-"+e.id()).append("rect"),w.select("#nv-edge-clip-"+e.id()+" rect").attr("width",r).attr("height",s>0?s:0),A.attr("clip-path",p?"url(#nv-edge-clip-"+e.id()+")":""),B.attr("clip-path",p?"url(#nv-edge-clip-"+e.id()+")":"");var C=w.select(".nv-groups").selectAll(".nv-group").data(function(a){return a},function(a){return a.key});C.enter().append("g").style("stroke-opacity",1e-6).style("stroke-width",function(a){return a.strokeWidth||j}).style("fill-opacity",1e-6),C.exit().remove(),C.attr("class",function(a,b){return(a.classed||"")+" nv-group nv-series-"+b}).classed("hover",function(a){return a.hover}).style("fill",function(a,b){return k(a,b)}).style("stroke",function(a,b){return k(a,b)}),C.watchTransition(v,"line: groups").style("stroke-opacity",1).style("fill-opacity",function(a){return a.fillOpacity||.5});var D=C.selectAll("path.nv-area").data(function(a){return o(a)?[a]:[]});D.enter().append("path").attr("class","nv-area").attr("d",function(b){return d3.svg.area().interpolate(q).defined(n).x(function(b,c){return a.utils.NaNtoZero(t(l(b,c)))}).y0(function(b,c){return a.utils.NaNtoZero(u(m(b,c)))}).y1(function(){return u(d.domain()[0]<=0?d.domain()[1]>=0?0:d.domain()[1]:d.domain()[0])}).apply(this,[b.values])}),C.exit().selectAll("path.nv-area").remove(),D.watchTransition(v,"line: areaPaths").attr("d",function(b){return d3.svg.area().interpolate(q).defined(n).x(function(b,d){return a.utils.NaNtoZero(c(l(b,d)))}).y0(function(b,c){return a.utils.NaNtoZero(d(m(b,c)))}).y1(function(){return d(d.domain()[0]<=0?d.domain()[1]>=0?0:d.domain()[1]:d.domain()[0])}).apply(this,[b.values])});var E=C.selectAll("path.nv-line").data(function(a){return[a.values]});E.enter().append("path").attr("class","nv-line").attr("d",d3.svg.line().interpolate(q).defined(n).x(function(b,c){return a.utils.NaNtoZero(t(l(b,c)))}).y(function(b,c){return a.utils.NaNtoZero(u(m(b,c)))})),E.watchTransition(v,"line: linePaths").attr("d",d3.svg.line().interpolate(q).defined(n).x(function(b,d){return a.utils.NaNtoZero(c(l(b,d)))}).y(function(b,c){return a.utils.NaNtoZero(d(m(b,c)))})),t=c.copy(),u=d.copy()}),v.renderEnd("line immediate"),b}var c,d,e=a.models.scatter(),f={top:0,right:0,bottom:0,left:0},g=960,h=500,i=null,j=1.5,k=a.utils.defaultColor(),l=function(a){return a.x},m=function(a){return a.y},n=function(a,b){return!isNaN(m(a,b))&&null!==m(a,b)},o=function(a){return a.area},p=!1,q="linear",r=250,s=d3.dispatch("elementClick","elementMouseover","elementMouseout","renderEnd");e.pointSize(16).pointDomain([16,256]);var t,u,v=a.utils.renderWatch(s,r);return b.dispatch=s,b.scatter=e,e.dispatch.on("elementClick",function(){s.elementClick.apply(this,arguments)}),e.dispatch.on("elementMouseover",function(){s.elementMouseover.apply(this,arguments)}),e.dispatch.on("elementMouseout",function(){s.elementMouseout.apply(this,arguments)}),b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return g},set:function(a){g=a}},height:{get:function(){return h},set:function(a){h=a}},defined:{get:function(){return n},set:function(a){n=a}},interpolate:{get:function(){return q},set:function(a){q=a}},clipEdge:{get:function(){return p},set:function(a){p=a}},margin:{get:function(){return f},set:function(a){f.top=void 0!==a.top?a.top:f.top,f.right=void 0!==a.right?a.right:f.right,f.bottom=void 0!==a.bottom?a.bottom:f.bottom,f.left=void 0!==a.left?a.left:f.left}},duration:{get:function(){return r},set:function(a){r=a,v.reset(r),e.duration(r)}},isArea:{get:function(){return o},set:function(a){o=d3.functor(a)}},x:{get:function(){return l},set:function(a){l=a,e.x(a)}},y:{get:function(){return m},set:function(a){m=a,e.y(a)}},color:{get:function(){return k},set:function(b){k=a.utils.getColor(b),e.color(k)}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.lineChart=function(){"use strict";function b(j){return y.reset(),y.models(e),p&&y.models(f),q&&y.models(g),j.each(function(j){var v=d3.select(this),y=this;a.utils.initSVG(v);var B=a.utils.availableWidth(m,v,k),C=a.utils.availableHeight(n,v,k);if(b.update=function(){0===x?v.call(b):v.transition().duration(x).call(b)},b.container=this,t.setter(A(j),b.update).getter(z(j)).update(),t.disabled=j.map(function(a){return!!a.disabled}),!u){var D;u={};for(D in t)u[D]=t[D]instanceof Array?t[D].slice(0):t[D]
}if(!(j&&j.length&&j.filter(function(a){return a.values.length}).length))return a.utils.noData(b,v),b;v.selectAll(".nv-noData").remove(),c=e.xScale(),d=e.yScale();var E=v.selectAll("g.nv-wrap.nv-lineChart").data([j]),F=E.enter().append("g").attr("class","nvd3 nv-wrap nv-lineChart").append("g"),G=E.select("g");F.append("rect").style("opacity",0),F.append("g").attr("class","nv-x nv-axis"),F.append("g").attr("class","nv-y nv-axis"),F.append("g").attr("class","nv-linesWrap"),F.append("g").attr("class","nv-legendWrap"),F.append("g").attr("class","nv-interactive"),G.select("rect").attr("width",B).attr("height",C>0?C:0),o&&(h.width(B),G.select(".nv-legendWrap").datum(j).call(h),k.top!=h.height()&&(k.top=h.height(),C=a.utils.availableHeight(n,v,k)),E.select(".nv-legendWrap").attr("transform","translate(0,"+-k.top+")")),E.attr("transform","translate("+k.left+","+k.top+")"),r&&G.select(".nv-y.nv-axis").attr("transform","translate("+B+",0)"),s&&(i.width(B).height(C).margin({left:k.left,top:k.top}).svgContainer(v).xScale(c),E.select(".nv-interactive").call(i)),e.width(B).height(C).color(j.map(function(a,b){return a.color||l(a,b)}).filter(function(a,b){return!j[b].disabled}));var H=G.select(".nv-linesWrap").datum(j.filter(function(a){return!a.disabled}));H.call(e),p&&(f.scale(c)._ticks(a.utils.calcTicksX(B/100,j)).tickSize(-C,0),G.select(".nv-x.nv-axis").attr("transform","translate(0,"+d.range()[0]+")"),G.select(".nv-x.nv-axis").call(f)),q&&(g.scale(d)._ticks(a.utils.calcTicksY(C/36,j)).tickSize(-B,0),G.select(".nv-y.nv-axis").call(g)),h.dispatch.on("stateChange",function(a){for(var c in a)t[c]=a[c];w.stateChange(t),b.update()}),i.dispatch.on("elementMousemove",function(c){e.clearHighlights();var d,h,m,n=[];if(j.filter(function(a,b){return a.seriesIndex=b,!a.disabled}).forEach(function(f,g){h=a.interactiveBisect(f.values,c.pointXValue,b.x());var i=f.values[h],j=b.y()(i,h);null!=j&&e.highlightPoint(g,h,!0),void 0!==i&&(void 0===d&&(d=i),void 0===m&&(m=b.xScale()(b.x()(i,h))),n.push({key:f.key,value:j,color:l(f,f.seriesIndex)}))}),n.length>2){var o=b.yScale().invert(c.mouseY),p=Math.abs(b.yScale().domain()[0]-b.yScale().domain()[1]),q=.03*p,r=a.nearestValueIndex(n.map(function(a){return a.value}),o,q);null!==r&&(n[r].highlight=!0)}var s=f.tickFormat()(b.x()(d,h));i.tooltip.position({left:c.mouseX+k.left,top:c.mouseY+k.top}).chartContainer(y.parentNode).valueFormatter(function(a){return null==a?"N/A":g.tickFormat()(a)}).data({value:s,index:h,series:n})(),i.renderGuideLine(m)}),i.dispatch.on("elementClick",function(c){var d,f=[];j.filter(function(a,b){return a.seriesIndex=b,!a.disabled}).forEach(function(e){var g=a.interactiveBisect(e.values,c.pointXValue,b.x()),h=e.values[g];if("undefined"!=typeof h){"undefined"==typeof d&&(d=b.xScale()(b.x()(h,g)));var i=b.yScale()(b.y()(h,g));f.push({point:h,pointIndex:g,pos:[d,i],seriesIndex:e.seriesIndex,series:e})}}),e.dispatch.elementClick(f)}),i.dispatch.on("elementMouseout",function(){e.clearHighlights()}),w.on("changeState",function(a){"undefined"!=typeof a.disabled&&j.length===a.disabled.length&&(j.forEach(function(b,c){b.disabled=a.disabled[c]}),t.disabled=a.disabled),b.update()})}),y.renderEnd("lineChart immediate"),b}var c,d,e=a.models.line(),f=a.models.axis(),g=a.models.axis(),h=a.models.legend(),i=a.interactiveGuideline(),j=a.models.tooltip(),k={top:30,right:20,bottom:50,left:60},l=a.utils.defaultColor(),m=null,n=null,o=!0,p=!0,q=!0,r=!1,s=!1,t=a.utils.state(),u=null,v=null,w=d3.dispatch("tooltipShow","tooltipHide","stateChange","changeState","renderEnd"),x=250;f.orient("bottom").tickPadding(7),g.orient(r?"right":"left"),j.valueFormatter(function(a,b){return g.tickFormat()(a,b)}).headerFormatter(function(a,b){return f.tickFormat()(a,b)});var y=a.utils.renderWatch(w,x),z=function(a){return function(){return{active:a.map(function(a){return!a.disabled})}}},A=function(a){return function(b){void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}};return e.dispatch.on("elementMouseover.tooltip",function(a){j.data(a).position(a.pos).hidden(!1)}),e.dispatch.on("elementMouseout.tooltip",function(){j.hidden(!0)}),b.dispatch=w,b.lines=e,b.legend=h,b.xAxis=f,b.yAxis=g,b.interactiveLayer=i,b.tooltip=j,b.dispatch=w,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return m},set:function(a){m=a}},height:{get:function(){return n},set:function(a){n=a}},showLegend:{get:function(){return o},set:function(a){o=a}},showXAxis:{get:function(){return p},set:function(a){p=a}},showYAxis:{get:function(){return q},set:function(a){q=a}},defaultState:{get:function(){return u},set:function(a){u=a}},noData:{get:function(){return v},set:function(a){v=a}},tooltips:{get:function(){return j.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),j.enabled(!!b)}},tooltipContent:{get:function(){return j.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),j.contentGenerator(b)}},margin:{get:function(){return k},set:function(a){k.top=void 0!==a.top?a.top:k.top,k.right=void 0!==a.right?a.right:k.right,k.bottom=void 0!==a.bottom?a.bottom:k.bottom,k.left=void 0!==a.left?a.left:k.left}},duration:{get:function(){return x},set:function(a){x=a,y.reset(x),e.duration(x),f.duration(x),g.duration(x)}},color:{get:function(){return l},set:function(b){l=a.utils.getColor(b),h.color(l),e.color(l)}},rightAlignYAxis:{get:function(){return r},set:function(a){r=a,g.orient(r?"right":"left")}},useInteractiveGuideline:{get:function(){return s},set:function(a){s=a,s&&(e.interactive(!1),e.useVoronoi(!1))}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.linePlusBarChart=function(){"use strict";function b(v){return v.each(function(v){function J(a){var b=+("e"==a),c=b?1:-1,d=X/3;return"M"+.5*c+","+d+"A6,6 0 0 "+b+" "+6.5*c+","+(d+6)+"V"+(2*d-6)+"A6,6 0 0 "+b+" "+.5*c+","+2*d+"ZM"+2.5*c+","+(d+8)+"V"+(2*d-8)+"M"+4.5*c+","+(d+8)+"V"+(2*d-8)}function S(){u.empty()||u.extent(I),kb.data([u.empty()?e.domain():I]).each(function(a){var b=e(a[0])-e.range()[0],c=e.range()[1]-e(a[1]);d3.select(this).select(".left").attr("width",0>b?0:b),d3.select(this).select(".right").attr("x",e(a[1])).attr("width",0>c?0:c)})}function T(){I=u.empty()?null:u.extent(),c=u.empty()?e.domain():u.extent(),K.brush({extent:c,brush:u}),S(),l.width(V).height(W).color(v.map(function(a,b){return a.color||C(a,b)}).filter(function(a,b){return!v[b].disabled&&v[b].bar})),j.width(V).height(W).color(v.map(function(a,b){return a.color||C(a,b)}).filter(function(a,b){return!v[b].disabled&&!v[b].bar}));var b=db.select(".nv-focus .nv-barsWrap").datum(Z.length?Z.map(function(a){return{key:a.key,values:a.values.filter(function(a,b){return l.x()(a,b)>=c[0]&&l.x()(a,b)<=c[1]})}}):[{values:[]}]),h=db.select(".nv-focus .nv-linesWrap").datum($[0].disabled?[{values:[]}]:$.map(function(a){return{area:a.area,fillOpacity:a.fillOpacity,key:a.key,values:a.values.filter(function(a,b){return j.x()(a,b)>=c[0]&&j.x()(a,b)<=c[1]})}}));d=Z.length?l.xScale():j.xScale(),n.scale(d)._ticks(a.utils.calcTicksX(V/100,v)).tickSize(-W,0),n.domain([Math.ceil(c[0]),Math.floor(c[1])]),db.select(".nv-x.nv-axis").transition().duration(L).call(n),b.transition().duration(L).call(l),h.transition().duration(L).call(j),db.select(".nv-focus .nv-x.nv-axis").attr("transform","translate(0,"+f.range()[0]+")"),p.scale(f)._ticks(a.utils.calcTicksY(W/36,v)).tickSize(-V,0),q.scale(g)._ticks(a.utils.calcTicksY(W/36,v)).tickSize(Z.length?0:-V,0),db.select(".nv-focus .nv-y1.nv-axis").style("opacity",Z.length?1:0),db.select(".nv-focus .nv-y2.nv-axis").style("opacity",$.length&&!$[0].disabled?1:0).attr("transform","translate("+d.range()[1]+",0)"),db.select(".nv-focus .nv-y1.nv-axis").transition().duration(L).call(p),db.select(".nv-focus .nv-y2.nv-axis").transition().duration(L).call(q)}var U=d3.select(this);a.utils.initSVG(U);var V=a.utils.availableWidth(y,U,w),W=a.utils.availableHeight(z,U,w)-(E?H:0),X=H-x.top-x.bottom;if(b.update=function(){U.transition().duration(L).call(b)},b.container=this,M.setter(R(v),b.update).getter(Q(v)).update(),M.disabled=v.map(function(a){return!!a.disabled}),!N){var Y;N={};for(Y in M)N[Y]=M[Y]instanceof Array?M[Y].slice(0):M[Y]}if(!(v&&v.length&&v.filter(function(a){return a.values.length}).length))return a.utils.noData(b,U),b;U.selectAll(".nv-noData").remove();var Z=v.filter(function(a){return!a.disabled&&a.bar}),$=v.filter(function(a){return!a.bar});d=l.xScale(),e=o.scale(),f=l.yScale(),g=j.yScale(),h=m.yScale(),i=k.yScale();var _=v.filter(function(a){return!a.disabled&&a.bar}).map(function(a){return a.values.map(function(a,b){return{x:A(a,b),y:B(a,b)}})}),ab=v.filter(function(a){return!a.disabled&&!a.bar}).map(function(a){return a.values.map(function(a,b){return{x:A(a,b),y:B(a,b)}})});d.range([0,V]),e.domain(d3.extent(d3.merge(_.concat(ab)),function(a){return a.x})).range([0,V]);var bb=U.selectAll("g.nv-wrap.nv-linePlusBar").data([v]),cb=bb.enter().append("g").attr("class","nvd3 nv-wrap nv-linePlusBar").append("g"),db=bb.select("g");cb.append("g").attr("class","nv-legendWrap");var eb=cb.append("g").attr("class","nv-focus");eb.append("g").attr("class","nv-x nv-axis"),eb.append("g").attr("class","nv-y1 nv-axis"),eb.append("g").attr("class","nv-y2 nv-axis"),eb.append("g").attr("class","nv-barsWrap"),eb.append("g").attr("class","nv-linesWrap");var fb=cb.append("g").attr("class","nv-context");if(fb.append("g").attr("class","nv-x nv-axis"),fb.append("g").attr("class","nv-y1 nv-axis"),fb.append("g").attr("class","nv-y2 nv-axis"),fb.append("g").attr("class","nv-barsWrap"),fb.append("g").attr("class","nv-linesWrap"),fb.append("g").attr("class","nv-brushBackground"),fb.append("g").attr("class","nv-x nv-brush"),D){var gb=t.align()?V/2:V,hb=t.align()?gb:0;t.width(gb),db.select(".nv-legendWrap").datum(v.map(function(a){return a.originalKey=void 0===a.originalKey?a.key:a.originalKey,a.key=a.originalKey+(a.bar?O:P),a})).call(t),w.top!=t.height()&&(w.top=t.height(),W=a.utils.availableHeight(z,U,w)-H),db.select(".nv-legendWrap").attr("transform","translate("+hb+","+-w.top+")")}bb.attr("transform","translate("+w.left+","+w.top+")"),db.select(".nv-context").style("display",E?"initial":"none"),m.width(V).height(X).color(v.map(function(a,b){return a.color||C(a,b)}).filter(function(a,b){return!v[b].disabled&&v[b].bar})),k.width(V).height(X).color(v.map(function(a,b){return a.color||C(a,b)}).filter(function(a,b){return!v[b].disabled&&!v[b].bar}));var ib=db.select(".nv-context .nv-barsWrap").datum(Z.length?Z:[{values:[]}]),jb=db.select(".nv-context .nv-linesWrap").datum($[0].disabled?[{values:[]}]:$);db.select(".nv-context").attr("transform","translate(0,"+(W+w.bottom+x.top)+")"),ib.transition().call(m),jb.transition().call(k),G&&(o._ticks(a.utils.calcTicksX(V/100,v)).tickSize(-X,0),db.select(".nv-context .nv-x.nv-axis").attr("transform","translate(0,"+h.range()[0]+")"),db.select(".nv-context .nv-x.nv-axis").transition().call(o)),F&&(r.scale(h)._ticks(X/36).tickSize(-V,0),s.scale(i)._ticks(X/36).tickSize(Z.length?0:-V,0),db.select(".nv-context .nv-y3.nv-axis").style("opacity",Z.length?1:0).attr("transform","translate(0,"+e.range()[0]+")"),db.select(".nv-context .nv-y2.nv-axis").style("opacity",$.length?1:0).attr("transform","translate("+e.range()[1]+",0)"),db.select(".nv-context .nv-y1.nv-axis").transition().call(r),db.select(".nv-context .nv-y2.nv-axis").transition().call(s)),u.x(e).on("brush",T),I&&u.extent(I);var kb=db.select(".nv-brushBackground").selectAll("g").data([I||u.extent()]),lb=kb.enter().append("g");lb.append("rect").attr("class","left").attr("x",0).attr("y",0).attr("height",X),lb.append("rect").attr("class","right").attr("x",0).attr("y",0).attr("height",X);var mb=db.select(".nv-x.nv-brush").call(u);mb.selectAll("rect").attr("height",X),mb.selectAll(".resize").append("path").attr("d",J),t.dispatch.on("stateChange",function(a){for(var c in a)M[c]=a[c];K.stateChange(M),b.update()}),K.on("changeState",function(a){"undefined"!=typeof a.disabled&&(v.forEach(function(b,c){b.disabled=a.disabled[c]}),M.disabled=a.disabled),b.update()}),T()}),b}var c,d,e,f,g,h,i,j=a.models.line(),k=a.models.line(),l=a.models.historicalBar(),m=a.models.historicalBar(),n=a.models.axis(),o=a.models.axis(),p=a.models.axis(),q=a.models.axis(),r=a.models.axis(),s=a.models.axis(),t=a.models.legend(),u=d3.svg.brush(),v=a.models.tooltip(),w={top:30,right:30,bottom:30,left:60},x={top:0,right:30,bottom:20,left:60},y=null,z=null,A=function(a){return a.x},B=function(a){return a.y},C=a.utils.defaultColor(),D=!0,E=!0,F=!1,G=!0,H=50,I=null,J=null,K=d3.dispatch("brush","stateChange","changeState"),L=0,M=a.utils.state(),N=null,O=" (left axis)",P=" (right axis)";j.clipEdge(!0),k.interactive(!1),n.orient("bottom").tickPadding(5),p.orient("left"),q.orient("right"),o.orient("bottom").tickPadding(5),r.orient("left"),s.orient("right"),v.headerEnabled(!0).headerFormatter(function(a,b){return n.tickFormat()(a,b)});var Q=function(a){return function(){return{active:a.map(function(a){return!a.disabled})}}},R=function(a){return function(b){void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}};return j.dispatch.on("elementMouseover.tooltip",function(a){v.duration(100).valueFormatter(function(a,b){return q.tickFormat()(a,b)}).data(a).position(a.pos).hidden(!1)}),j.dispatch.on("elementMouseout.tooltip",function(){v.hidden(!0)}),l.dispatch.on("elementMouseover.tooltip",function(a){a.value=b.x()(a.data),a.series={value:b.y()(a.data),color:a.color},v.duration(0).valueFormatter(function(a,b){return p.tickFormat()(a,b)}).data(a).hidden(!1)}),l.dispatch.on("elementMouseout.tooltip",function(){v.hidden(!0)}),l.dispatch.on("elementMousemove.tooltip",function(){v.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.dispatch=K,b.legend=t,b.lines=j,b.lines2=k,b.bars=l,b.bars2=m,b.xAxis=n,b.x2Axis=o,b.y1Axis=p,b.y2Axis=q,b.y3Axis=r,b.y4Axis=s,b.tooltip=v,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return y},set:function(a){y=a}},height:{get:function(){return z},set:function(a){z=a}},showLegend:{get:function(){return D},set:function(a){D=a}},brushExtent:{get:function(){return I},set:function(a){I=a}},noData:{get:function(){return J},set:function(a){J=a}},focusEnable:{get:function(){return E},set:function(a){E=a}},focusHeight:{get:function(){return H},set:function(a){H=a}},focusShowAxisX:{get:function(){return G},set:function(a){G=a}},focusShowAxisY:{get:function(){return F},set:function(a){F=a}},legendLeftAxisHint:{get:function(){return O},set:function(a){O=a}},legendRightAxisHint:{get:function(){return P},set:function(a){P=a}},tooltips:{get:function(){return v.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),v.enabled(!!b)}},tooltipContent:{get:function(){return v.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),v.contentGenerator(b)}},margin:{get:function(){return w},set:function(a){w.top=void 0!==a.top?a.top:w.top,w.right=void 0!==a.right?a.right:w.right,w.bottom=void 0!==a.bottom?a.bottom:w.bottom,w.left=void 0!==a.left?a.left:w.left}},duration:{get:function(){return L},set:function(a){L=a}},color:{get:function(){return C},set:function(b){C=a.utils.getColor(b),t.color(C)}},x:{get:function(){return A},set:function(a){A=a,j.x(a),k.x(a),l.x(a),m.x(a)}},y:{get:function(){return B},set:function(a){B=a,j.y(a),k.y(a),l.y(a),m.y(a)}}}),a.utils.inheritOptions(b,j),a.utils.initOptions(b),b},a.models.lineWithFocusChart=function(){"use strict";function b(o){return o.each(function(o){function z(a){var b=+("e"==a),c=b?1:-1,d=M/3;return"M"+.5*c+","+d+"A6,6 0 0 "+b+" "+6.5*c+","+(d+6)+"V"+(2*d-6)+"A6,6 0 0 "+b+" "+.5*c+","+2*d+"ZM"+2.5*c+","+(d+8)+"V"+(2*d-8)+"M"+4.5*c+","+(d+8)+"V"+(2*d-8)}function G(){n.empty()||n.extent(y),U.data([n.empty()?e.domain():y]).each(function(a){var b=e(a[0])-c.range()[0],d=K-e(a[1]);d3.select(this).select(".left").attr("width",0>b?0:b),d3.select(this).select(".right").attr("x",e(a[1])).attr("width",0>d?0:d)})}function H(){y=n.empty()?null:n.extent();var a=n.empty()?e.domain():n.extent();if(!(Math.abs(a[0]-a[1])<=1)){A.brush({extent:a,brush:n}),G();var b=Q.select(".nv-focus .nv-linesWrap").datum(o.filter(function(a){return!a.disabled}).map(function(b){return{key:b.key,area:b.area,values:b.values.filter(function(b,c){return g.x()(b,c)>=a[0]&&g.x()(b,c)<=a[1]})}}));b.transition().duration(B).call(g),Q.select(".nv-focus .nv-x.nv-axis").transition().duration(B).call(i),Q.select(".nv-focus .nv-y.nv-axis").transition().duration(B).call(j)}}var I=d3.select(this),J=this;a.utils.initSVG(I);var K=a.utils.availableWidth(t,I,q),L=a.utils.availableHeight(u,I,q)-v,M=v-r.top-r.bottom;if(b.update=function(){I.transition().duration(B).call(b)},b.container=this,C.setter(F(o),b.update).getter(E(o)).update(),C.disabled=o.map(function(a){return!!a.disabled}),!D){var N;D={};for(N in C)D[N]=C[N]instanceof Array?C[N].slice(0):C[N]}if(!(o&&o.length&&o.filter(function(a){return a.values.length}).length))return a.utils.noData(b,I),b;I.selectAll(".nv-noData").remove(),c=g.xScale(),d=g.yScale(),e=h.xScale(),f=h.yScale();var O=I.selectAll("g.nv-wrap.nv-lineWithFocusChart").data([o]),P=O.enter().append("g").attr("class","nvd3 nv-wrap nv-lineWithFocusChart").append("g"),Q=O.select("g");P.append("g").attr("class","nv-legendWrap");var R=P.append("g").attr("class","nv-focus");R.append("g").attr("class","nv-x nv-axis"),R.append("g").attr("class","nv-y nv-axis"),R.append("g").attr("class","nv-linesWrap"),R.append("g").attr("class","nv-interactive");var S=P.append("g").attr("class","nv-context");S.append("g").attr("class","nv-x nv-axis"),S.append("g").attr("class","nv-y nv-axis"),S.append("g").attr("class","nv-linesWrap"),S.append("g").attr("class","nv-brushBackground"),S.append("g").attr("class","nv-x nv-brush"),x&&(m.width(K),Q.select(".nv-legendWrap").datum(o).call(m),q.top!=m.height()&&(q.top=m.height(),L=a.utils.availableHeight(u,I,q)-v),Q.select(".nv-legendWrap").attr("transform","translate(0,"+-q.top+")")),O.attr("transform","translate("+q.left+","+q.top+")"),w&&(p.width(K).height(L).margin({left:q.left,top:q.top}).svgContainer(I).xScale(c),O.select(".nv-interactive").call(p)),g.width(K).height(L).color(o.map(function(a,b){return a.color||s(a,b)}).filter(function(a,b){return!o[b].disabled})),h.defined(g.defined()).width(K).height(M).color(o.map(function(a,b){return a.color||s(a,b)}).filter(function(a,b){return!o[b].disabled})),Q.select(".nv-context").attr("transform","translate(0,"+(L+q.bottom+r.top)+")");var T=Q.select(".nv-context .nv-linesWrap").datum(o.filter(function(a){return!a.disabled}));d3.transition(T).call(h),i.scale(c)._ticks(a.utils.calcTicksX(K/100,o)).tickSize(-L,0),j.scale(d)._ticks(a.utils.calcTicksY(L/36,o)).tickSize(-K,0),Q.select(".nv-focus .nv-x.nv-axis").attr("transform","translate(0,"+L+")"),n.x(e).on("brush",function(){H()}),y&&n.extent(y);var U=Q.select(".nv-brushBackground").selectAll("g").data([y||n.extent()]),V=U.enter().append("g");V.append("rect").attr("class","left").attr("x",0).attr("y",0).attr("height",M),V.append("rect").attr("class","right").attr("x",0).attr("y",0).attr("height",M);var W=Q.select(".nv-x.nv-brush").call(n);W.selectAll("rect").attr("height",M),W.selectAll(".resize").append("path").attr("d",z),H(),k.scale(e)._ticks(a.utils.calcTicksX(K/100,o)).tickSize(-M,0),Q.select(".nv-context .nv-x.nv-axis").attr("transform","translate(0,"+f.range()[0]+")"),d3.transition(Q.select(".nv-context .nv-x.nv-axis")).call(k),l.scale(f)._ticks(a.utils.calcTicksY(M/36,o)).tickSize(-K,0),d3.transition(Q.select(".nv-context .nv-y.nv-axis")).call(l),Q.select(".nv-context .nv-x.nv-axis").attr("transform","translate(0,"+f.range()[0]+")"),m.dispatch.on("stateChange",function(a){for(var c in a)C[c]=a[c];A.stateChange(C),b.update()}),p.dispatch.on("elementMousemove",function(c){g.clearHighlights();var d,f,h,k=[];if(o.filter(function(a,b){return a.seriesIndex=b,!a.disabled}).forEach(function(i,j){var l=n.empty()?e.domain():n.extent(),m=i.values.filter(function(a,b){return g.x()(a,b)>=l[0]&&g.x()(a,b)<=l[1]});f=a.interactiveBisect(m,c.pointXValue,g.x());var o=m[f],p=b.y()(o,f);null!=p&&g.highlightPoint(j,f,!0),void 0!==o&&(void 0===d&&(d=o),void 0===h&&(h=b.xScale()(b.x()(o,f))),k.push({key:i.key,value:b.y()(o,f),color:s(i,i.seriesIndex)}))}),k.length>2){var l=b.yScale().invert(c.mouseY),m=Math.abs(b.yScale().domain()[0]-b.yScale().domain()[1]),r=.03*m,t=a.nearestValueIndex(k.map(function(a){return a.value}),l,r);null!==t&&(k[t].highlight=!0)}var u=i.tickFormat()(b.x()(d,f));p.tooltip.position({left:c.mouseX+q.left,top:c.mouseY+q.top}).chartContainer(J.parentNode).valueFormatter(function(a){return null==a?"N/A":j.tickFormat()(a)}).data({value:u,index:f,series:k})(),p.renderGuideLine(h)}),p.dispatch.on("elementMouseout",function(){g.clearHighlights()}),A.on("changeState",function(a){"undefined"!=typeof a.disabled&&o.forEach(function(b,c){b.disabled=a.disabled[c]}),b.update()})}),b}var c,d,e,f,g=a.models.line(),h=a.models.line(),i=a.models.axis(),j=a.models.axis(),k=a.models.axis(),l=a.models.axis(),m=a.models.legend(),n=d3.svg.brush(),o=a.models.tooltip(),p=a.interactiveGuideline(),q={top:30,right:30,bottom:30,left:60},r={top:0,right:30,bottom:20,left:60},s=a.utils.defaultColor(),t=null,u=null,v=50,w=!1,x=!0,y=null,z=null,A=d3.dispatch("brush","stateChange","changeState"),B=250,C=a.utils.state(),D=null;g.clipEdge(!0).duration(0),h.interactive(!1),i.orient("bottom").tickPadding(5),j.orient("left"),k.orient("bottom").tickPadding(5),l.orient("left"),o.valueFormatter(function(a,b){return j.tickFormat()(a,b)}).headerFormatter(function(a,b){return i.tickFormat()(a,b)});var E=function(a){return function(){return{active:a.map(function(a){return!a.disabled})}}},F=function(a){return function(b){void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}};return g.dispatch.on("elementMouseover.tooltip",function(a){o.data(a).position(a.pos).hidden(!1)}),g.dispatch.on("elementMouseout.tooltip",function(){o.hidden(!0)}),b.dispatch=A,b.legend=m,b.lines=g,b.lines2=h,b.xAxis=i,b.yAxis=j,b.x2Axis=k,b.y2Axis=l,b.interactiveLayer=p,b.tooltip=o,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return t},set:function(a){t=a}},height:{get:function(){return u},set:function(a){u=a}},focusHeight:{get:function(){return v},set:function(a){v=a}},showLegend:{get:function(){return x},set:function(a){x=a}},brushExtent:{get:function(){return y},set:function(a){y=a}},defaultState:{get:function(){return D},set:function(a){D=a}},noData:{get:function(){return z},set:function(a){z=a}},tooltips:{get:function(){return o.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),o.enabled(!!b)}},tooltipContent:{get:function(){return o.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),o.contentGenerator(b)}},margin:{get:function(){return q},set:function(a){q.top=void 0!==a.top?a.top:q.top,q.right=void 0!==a.right?a.right:q.right,q.bottom=void 0!==a.bottom?a.bottom:q.bottom,q.left=void 0!==a.left?a.left:q.left}},color:{get:function(){return s},set:function(b){s=a.utils.getColor(b),m.color(s)}},interpolate:{get:function(){return g.interpolate()},set:function(a){g.interpolate(a),h.interpolate(a)}},xTickFormat:{get:function(){return i.tickFormat()},set:function(a){i.tickFormat(a),k.tickFormat(a)}},yTickFormat:{get:function(){return j.tickFormat()},set:function(a){j.tickFormat(a),l.tickFormat(a)}},duration:{get:function(){return B},set:function(a){B=a,j.duration(B),l.duration(B),i.duration(B),k.duration(B)}},x:{get:function(){return g.x()},set:function(a){g.x(a),h.x(a)}},y:{get:function(){return g.y()},set:function(a){g.y(a),h.y(a)}},useInteractiveGuideline:{get:function(){return w},set:function(a){w=a,w&&(g.interactive(!1),g.useVoronoi(!1))}}}),a.utils.inheritOptions(b,g),a.utils.initOptions(b),b},a.models.multiBar=function(){"use strict";function b(E){return C.reset(),E.each(function(b){var E=k-j.left-j.right,F=l-j.top-j.bottom;p=d3.select(this),a.utils.initSVG(p);var G=0;if(x&&b.length&&(x=[{values:b[0].values.map(function(a){return{x:a.x,y:0,series:a.series,size:.01}})}]),u){var H=d3.layout.stack().offset(v).values(function(a){return a.values}).y(r)(!b.length&&x?x:b);H.forEach(function(a,c){a.nonStackable?(b[c].nonStackableSeries=G++,H[c]=b[c]):c>0&&H[c-1].nonStackable&&H[c].values.map(function(a,b){a.y0-=H[c-1].values[b].y,a.y1=a.y0+a.y})}),b=H}b.forEach(function(a,b){a.values.forEach(function(c){c.series=b,c.key=a.key})}),u&&b[0].values.map(function(a,c){var d=0,e=0;b.map(function(a,f){if(!b[f].nonStackable){var g=a.values[c];g.size=Math.abs(g.y),g.y<0?(g.y1=e,e-=g.size):(g.y1=g.size+d,d+=g.size)}})});var I=d&&e?[]:b.map(function(a,b){return a.values.map(function(a,c){return{x:q(a,c),y:r(a,c),y0:a.y0,y1:a.y1,idx:b}})});m.domain(d||d3.merge(I).map(function(a){return a.x})).rangeBands(f||[0,E],A),n.domain(e||d3.extent(d3.merge(I).map(function(a){var c=a.y;return u&&!b[a.idx].nonStackable&&(c=a.y>0?a.y1:a.y1+a.y),c}).concat(s))).range(g||[F,0]),m.domain()[0]===m.domain()[1]&&m.domain(m.domain()[0]?[m.domain()[0]-.01*m.domain()[0],m.domain()[1]+.01*m.domain()[1]]:[-1,1]),n.domain()[0]===n.domain()[1]&&n.domain(n.domain()[0]?[n.domain()[0]+.01*n.domain()[0],n.domain()[1]-.01*n.domain()[1]]:[-1,1]),h=h||m,i=i||n;var J=p.selectAll("g.nv-wrap.nv-multibar").data([b]),K=J.enter().append("g").attr("class","nvd3 nv-wrap nv-multibar"),L=K.append("defs"),M=K.append("g"),N=J.select("g");M.append("g").attr("class","nv-groups"),J.attr("transform","translate("+j.left+","+j.top+")"),L.append("clipPath").attr("id","nv-edge-clip-"+o).append("rect"),J.select("#nv-edge-clip-"+o+" rect").attr("width",E).attr("height",F),N.attr("clip-path",t?"url(#nv-edge-clip-"+o+")":"");var O=J.select(".nv-groups").selectAll(".nv-group").data(function(a){return a},function(a,b){return b});O.enter().append("g").style("stroke-opacity",1e-6).style("fill-opacity",1e-6);var P=C.transition(O.exit().selectAll("rect.nv-bar"),"multibarExit",Math.min(100,z)).attr("y",function(a){var c=i(0)||0;return u&&b[a.series]&&!b[a.series].nonStackable&&(c=i(a.y0)),c}).attr("height",0).remove();P.delay&&P.delay(function(a,b){var c=b*(z/(D+1))-b;return c}),O.attr("class",function(a,b){return"nv-group nv-series-"+b}).classed("hover",function(a){return a.hover}).style("fill",function(a,b){return w(a,b)}).style("stroke",function(a,b){return w(a,b)}),O.style("stroke-opacity",1).style("fill-opacity",.75);var Q=O.selectAll("rect.nv-bar").data(function(a){return x&&!b.length?x.values:a.values});Q.exit().remove();Q.enter().append("rect").attr("class",function(a,b){return r(a,b)<0?"nv-bar negative":"nv-bar positive"}).attr("x",function(a,c,d){return u&&!b[d].nonStackable?0:d*m.rangeBand()/b.length}).attr("y",function(a,c,d){return i(u&&!b[d].nonStackable?a.y0:0)||0}).attr("height",0).attr("width",function(a,c,d){return m.rangeBand()/(u&&!b[d].nonStackable?1:b.length)}).attr("transform",function(a,b){return"translate("+m(q(a,b))+",0)"});Q.style("fill",function(a,b,c){return w(a,c,b)}).style("stroke",function(a,b,c){return w(a,c,b)}).on("mouseover",function(a,b){d3.select(this).classed("hover",!0),B.elementMouseover({data:a,index:b,color:d3.select(this).style("fill")})}).on("mouseout",function(a,b){d3.select(this).classed("hover",!1),B.elementMouseout({data:a,index:b,color:d3.select(this).style("fill")})}).on("mousemove",function(a,b){B.elementMousemove({data:a,index:b,color:d3.select(this).style("fill")})}).on("click",function(a,b){B.elementClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation()}).on("dblclick",function(a,b){B.elementDblClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation()}),Q.attr("class",function(a,b){return r(a,b)<0?"nv-bar negative":"nv-bar positive"}).attr("transform",function(a,b){return"translate("+m(q(a,b))+",0)"}),y&&(c||(c=b.map(function(){return!0})),Q.style("fill",function(a,b,d){return d3.rgb(y(a,b)).darker(c.map(function(a,b){return b}).filter(function(a,b){return!c[b]})[d]).toString()}).style("stroke",function(a,b,d){return d3.rgb(y(a,b)).darker(c.map(function(a,b){return b}).filter(function(a,b){return!c[b]})[d]).toString()}));var R=Q.watchTransition(C,"multibar",Math.min(250,z)).delay(function(a,c){return c*z/b[0].values.length});u?R.attr("y",function(a,c,d){var e=0;return e=b[d].nonStackable?r(a,c)<0?n(0):n(0)-n(r(a,c))<-1?n(0)-1:n(r(a,c))||0:n(a.y1)}).attr("height",function(a,c,d){return b[d].nonStackable?Math.max(Math.abs(n(r(a,c))-n(0)),1)||0:Math.max(Math.abs(n(a.y+a.y0)-n(a.y0)),1)}).attr("x",function(a,c,d){var e=0;return b[d].nonStackable&&(e=a.series*m.rangeBand()/b.length,b.length!==G&&(e=b[d].nonStackableSeries*m.rangeBand()/(2*G))),e}).attr("width",function(a,c,d){if(b[d].nonStackable){var e=m.rangeBand()/G;return b.length!==G&&(e=m.rangeBand()/(2*G)),e}return m.rangeBand()}):R.attr("x",function(a){return a.series*m.rangeBand()/b.length}).attr("width",m.rangeBand()/b.length).attr("y",function(a,b){return r(a,b)<0?n(0):n(0)-n(r(a,b))<1?n(0)-1:n(r(a,b))||0}).attr("height",function(a,b){return Math.max(Math.abs(n(r(a,b))-n(0)),1)||0}),h=m.copy(),i=n.copy(),b[0]&&b[0].values&&(D=b[0].values.length)}),C.renderEnd("multibar immediate"),b}var c,d,e,f,g,h,i,j={top:0,right:0,bottom:0,left:0},k=960,l=500,m=d3.scale.ordinal(),n=d3.scale.linear(),o=Math.floor(1e4*Math.random()),p=null,q=function(a){return a.x},r=function(a){return a.y},s=[0],t=!0,u=!1,v="zero",w=a.utils.defaultColor(),x=!1,y=null,z=500,A=.1,B=d3.dispatch("chartClick","elementClick","elementDblClick","elementMouseover","elementMouseout","elementMousemove","renderEnd"),C=a.utils.renderWatch(B,z),D=0;return b.dispatch=B,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return k},set:function(a){k=a}},height:{get:function(){return l},set:function(a){l=a}},x:{get:function(){return q},set:function(a){q=a}},y:{get:function(){return r},set:function(a){r=a}},xScale:{get:function(){return m},set:function(a){m=a}},yScale:{get:function(){return n},set:function(a){n=a}},xDomain:{get:function(){return d},set:function(a){d=a}},yDomain:{get:function(){return e},set:function(a){e=a}},xRange:{get:function(){return f},set:function(a){f=a}},yRange:{get:function(){return g},set:function(a){g=a}},forceY:{get:function(){return s},set:function(a){s=a}},stacked:{get:function(){return u},set:function(a){u=a}},stackOffset:{get:function(){return v},set:function(a){v=a}},clipEdge:{get:function(){return t},set:function(a){t=a}},disabled:{get:function(){return c},set:function(a){c=a}},id:{get:function(){return o},set:function(a){o=a}},hideable:{get:function(){return x},set:function(a){x=a}},groupSpacing:{get:function(){return A},set:function(a){A=a}},margin:{get:function(){return j},set:function(a){j.top=void 0!==a.top?a.top:j.top,j.right=void 0!==a.right?a.right:j.right,j.bottom=void 0!==a.bottom?a.bottom:j.bottom,j.left=void 0!==a.left?a.left:j.left}},duration:{get:function(){return z},set:function(a){z=a,C.reset(z)}},color:{get:function(){return w},set:function(b){w=a.utils.getColor(b)}},barColor:{get:function(){return y},set:function(b){y=b?a.utils.getColor(b):null}}}),a.utils.initOptions(b),b},a.models.multiBarChart=function(){"use strict";function b(j){return D.reset(),D.models(e),r&&D.models(f),s&&D.models(g),j.each(function(j){var z=d3.select(this);a.utils.initSVG(z);var D=a.utils.availableWidth(l,z,k),H=a.utils.availableHeight(m,z,k);if(b.update=function(){0===C?z.call(b):z.transition().duration(C).call(b)},b.container=this,x.setter(G(j),b.update).getter(F(j)).update(),x.disabled=j.map(function(a){return!!a.disabled}),!y){var I;y={};for(I in x)y[I]=x[I]instanceof Array?x[I].slice(0):x[I]}if(!(j&&j.length&&j.filter(function(a){return a.values.length}).length))return a.utils.noData(b,z),b;z.selectAll(".nv-noData").remove(),c=e.xScale(),d=e.yScale();
var J=z.selectAll("g.nv-wrap.nv-multiBarWithLegend").data([j]),K=J.enter().append("g").attr("class","nvd3 nv-wrap nv-multiBarWithLegend").append("g"),L=J.select("g");if(K.append("g").attr("class","nv-x nv-axis"),K.append("g").attr("class","nv-y nv-axis"),K.append("g").attr("class","nv-barsWrap"),K.append("g").attr("class","nv-legendWrap"),K.append("g").attr("class","nv-controlsWrap"),q&&(h.width(D-B()),L.select(".nv-legendWrap").datum(j).call(h),k.top!=h.height()&&(k.top=h.height(),H=a.utils.availableHeight(m,z,k)),L.select(".nv-legendWrap").attr("transform","translate("+B()+","+-k.top+")")),o){var M=[{key:p.grouped||"Grouped",disabled:e.stacked()},{key:p.stacked||"Stacked",disabled:!e.stacked()}];i.width(B()).color(["#444","#444","#444"]),L.select(".nv-controlsWrap").datum(M).attr("transform","translate(0,"+-k.top+")").call(i)}J.attr("transform","translate("+k.left+","+k.top+")"),t&&L.select(".nv-y.nv-axis").attr("transform","translate("+D+",0)"),e.disabled(j.map(function(a){return a.disabled})).width(D).height(H).color(j.map(function(a,b){return a.color||n(a,b)}).filter(function(a,b){return!j[b].disabled}));var N=L.select(".nv-barsWrap").datum(j.filter(function(a){return!a.disabled}));if(N.call(e),r){f.scale(c)._ticks(a.utils.calcTicksX(D/100,j)).tickSize(-H,0),L.select(".nv-x.nv-axis").attr("transform","translate(0,"+d.range()[0]+")"),L.select(".nv-x.nv-axis").call(f);var O=L.select(".nv-x.nv-axis > g").selectAll("g");if(O.selectAll("line, text").style("opacity",1),v){var P=function(a,b){return"translate("+a+","+b+")"},Q=5,R=17;O.selectAll("text").attr("transform",function(a,b,c){return P(0,c%2==0?Q:R)});var S=d3.selectAll(".nv-x.nv-axis .nv-wrap g g text")[0].length;L.selectAll(".nv-x.nv-axis .nv-axisMaxMin text").attr("transform",function(a,b){return P(0,0===b||S%2!==0?R:Q)})}u&&O.filter(function(a,b){return b%Math.ceil(j[0].values.length/(D/100))!==0}).selectAll("text, line").style("opacity",0),w&&O.selectAll(".tick text").attr("transform","rotate("+w+" 0,0)").style("text-anchor",w>0?"start":"end"),L.select(".nv-x.nv-axis").selectAll("g.nv-axisMaxMin text").style("opacity",1)}s&&(g.scale(d)._ticks(a.utils.calcTicksY(H/36,j)).tickSize(-D,0),L.select(".nv-y.nv-axis").call(g)),h.dispatch.on("stateChange",function(a){for(var c in a)x[c]=a[c];A.stateChange(x),b.update()}),i.dispatch.on("legendClick",function(a){if(a.disabled){switch(M=M.map(function(a){return a.disabled=!0,a}),a.disabled=!1,a.key){case"Grouped":case p.grouped:e.stacked(!1);break;case"Stacked":case p.stacked:e.stacked(!0)}x.stacked=e.stacked(),A.stateChange(x),b.update()}}),A.on("changeState",function(a){"undefined"!=typeof a.disabled&&(j.forEach(function(b,c){b.disabled=a.disabled[c]}),x.disabled=a.disabled),"undefined"!=typeof a.stacked&&(e.stacked(a.stacked),x.stacked=a.stacked,E=a.stacked),b.update()})}),D.renderEnd("multibarchart immediate"),b}var c,d,e=a.models.multiBar(),f=a.models.axis(),g=a.models.axis(),h=a.models.legend(),i=a.models.legend(),j=a.models.tooltip(),k={top:30,right:20,bottom:50,left:60},l=null,m=null,n=a.utils.defaultColor(),o=!0,p={},q=!0,r=!0,s=!0,t=!1,u=!0,v=!1,w=0,x=a.utils.state(),y=null,z=null,A=d3.dispatch("stateChange","changeState","renderEnd"),B=function(){return o?180:0},C=250;x.stacked=!1,e.stacked(!1),f.orient("bottom").tickPadding(7).showMaxMin(!1).tickFormat(function(a){return a}),g.orient(t?"right":"left").tickFormat(d3.format(",.1f")),j.duration(0).valueFormatter(function(a,b){return g.tickFormat()(a,b)}).headerFormatter(function(a,b){return f.tickFormat()(a,b)}),i.updateState(!1);var D=a.utils.renderWatch(A),E=!1,F=function(a){return function(){return{active:a.map(function(a){return!a.disabled}),stacked:E}}},G=function(a){return function(b){void 0!==b.stacked&&(E=b.stacked),void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}};return e.dispatch.on("elementMouseover.tooltip",function(a){a.value=b.x()(a.data),a.series={key:a.data.key,value:b.y()(a.data),color:a.color},j.data(a).hidden(!1)}),e.dispatch.on("elementMouseout.tooltip",function(){j.hidden(!0)}),e.dispatch.on("elementMousemove.tooltip",function(){j.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.dispatch=A,b.multibar=e,b.legend=h,b.controls=i,b.xAxis=f,b.yAxis=g,b.state=x,b.tooltip=j,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return l},set:function(a){l=a}},height:{get:function(){return m},set:function(a){m=a}},showLegend:{get:function(){return q},set:function(a){q=a}},showControls:{get:function(){return o},set:function(a){o=a}},controlLabels:{get:function(){return p},set:function(a){p=a}},showXAxis:{get:function(){return r},set:function(a){r=a}},showYAxis:{get:function(){return s},set:function(a){s=a}},defaultState:{get:function(){return y},set:function(a){y=a}},noData:{get:function(){return z},set:function(a){z=a}},reduceXTicks:{get:function(){return u},set:function(a){u=a}},rotateLabels:{get:function(){return w},set:function(a){w=a}},staggerLabels:{get:function(){return v},set:function(a){v=a}},tooltips:{get:function(){return j.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),j.enabled(!!b)}},tooltipContent:{get:function(){return j.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),j.contentGenerator(b)}},margin:{get:function(){return k},set:function(a){k.top=void 0!==a.top?a.top:k.top,k.right=void 0!==a.right?a.right:k.right,k.bottom=void 0!==a.bottom?a.bottom:k.bottom,k.left=void 0!==a.left?a.left:k.left}},duration:{get:function(){return C},set:function(a){C=a,e.duration(C),f.duration(C),g.duration(C),D.reset(C)}},color:{get:function(){return n},set:function(b){n=a.utils.getColor(b),h.color(n)}},rightAlignYAxis:{get:function(){return t},set:function(a){t=a,g.orient(t?"right":"left")}},barColor:{get:function(){return e.barColor},set:function(a){e.barColor(a),h.color(function(a,b){return d3.rgb("#ccc").darker(1.5*b).toString()})}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.multiBarHorizontal=function(){"use strict";function b(m){return E.reset(),m.each(function(b){var m=k-j.left-j.right,C=l-j.top-j.bottom;n=d3.select(this),a.utils.initSVG(n),w&&(b=d3.layout.stack().offset("zero").values(function(a){return a.values}).y(r)(b)),b.forEach(function(a,b){a.values.forEach(function(c){c.series=b,c.key=a.key})}),w&&b[0].values.map(function(a,c){var d=0,e=0;b.map(function(a){var b=a.values[c];b.size=Math.abs(b.y),b.y<0?(b.y1=e-b.size,e-=b.size):(b.y1=d,d+=b.size)})});var F=d&&e?[]:b.map(function(a){return a.values.map(function(a,b){return{x:q(a,b),y:r(a,b),y0:a.y0,y1:a.y1}})});o.domain(d||d3.merge(F).map(function(a){return a.x})).rangeBands(f||[0,C],A),p.domain(e||d3.extent(d3.merge(F).map(function(a){return w?a.y>0?a.y1+a.y:a.y1:a.y}).concat(t))),p.range(x&&!w?g||[p.domain()[0]<0?z:0,m-(p.domain()[1]>0?z:0)]:g||[0,m]),h=h||o,i=i||d3.scale.linear().domain(p.domain()).range([p(0),p(0)]);{var G=d3.select(this).selectAll("g.nv-wrap.nv-multibarHorizontal").data([b]),H=G.enter().append("g").attr("class","nvd3 nv-wrap nv-multibarHorizontal"),I=(H.append("defs"),H.append("g"));G.select("g")}I.append("g").attr("class","nv-groups"),G.attr("transform","translate("+j.left+","+j.top+")");var J=G.select(".nv-groups").selectAll(".nv-group").data(function(a){return a},function(a,b){return b});J.enter().append("g").style("stroke-opacity",1e-6).style("fill-opacity",1e-6),J.exit().watchTransition(E,"multibarhorizontal: exit groups").style("stroke-opacity",1e-6).style("fill-opacity",1e-6).remove(),J.attr("class",function(a,b){return"nv-group nv-series-"+b}).classed("hover",function(a){return a.hover}).style("fill",function(a,b){return u(a,b)}).style("stroke",function(a,b){return u(a,b)}),J.watchTransition(E,"multibarhorizontal: groups").style("stroke-opacity",1).style("fill-opacity",.75);var K=J.selectAll("g.nv-bar").data(function(a){return a.values});K.exit().remove();var L=K.enter().append("g").attr("transform",function(a,c,d){return"translate("+i(w?a.y0:0)+","+(w?0:d*o.rangeBand()/b.length+o(q(a,c)))+")"});L.append("rect").attr("width",0).attr("height",o.rangeBand()/(w?1:b.length)),K.on("mouseover",function(a,b){d3.select(this).classed("hover",!0),D.elementMouseover({data:a,index:b,color:d3.select(this).style("fill")})}).on("mouseout",function(a,b){d3.select(this).classed("hover",!1),D.elementMouseout({data:a,index:b,color:d3.select(this).style("fill")})}).on("mouseout",function(a,b){D.elementMouseout({data:a,index:b,color:d3.select(this).style("fill")})}).on("mousemove",function(a,b){D.elementMousemove({data:a,index:b,color:d3.select(this).style("fill")})}).on("click",function(a,b){D.elementClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation()}).on("dblclick",function(a,b){D.elementDblClick({data:a,index:b,color:d3.select(this).style("fill")}),d3.event.stopPropagation()}),s(b[0],0)&&(L.append("polyline"),K.select("polyline").attr("fill","none").attr("points",function(a,c){var d=s(a,c),e=.8*o.rangeBand()/(2*(w?1:b.length));d=d.length?d:[-Math.abs(d),Math.abs(d)],d=d.map(function(a){return p(a)-p(0)});var f=[[d[0],-e],[d[0],e],[d[0],0],[d[1],0],[d[1],-e],[d[1],e]];return f.map(function(a){return a.join(",")}).join(" ")}).attr("transform",function(a,c){var d=o.rangeBand()/(2*(w?1:b.length));return"translate("+(r(a,c)<0?0:p(r(a,c))-p(0))+", "+d+")"})),L.append("text"),x&&!w?(K.select("text").attr("text-anchor",function(a,b){return r(a,b)<0?"end":"start"}).attr("y",o.rangeBand()/(2*b.length)).attr("dy",".32em").text(function(a,b){var c=B(r(a,b)),d=s(a,b);return void 0===d?c:d.length?c+"+"+B(Math.abs(d[1]))+"-"+B(Math.abs(d[0])):c+""+B(Math.abs(d))}),K.watchTransition(E,"multibarhorizontal: bars").select("text").attr("x",function(a,b){return r(a,b)<0?-4:p(r(a,b))-p(0)+4})):K.selectAll("text").text(""),y&&!w?(L.append("text").classed("nv-bar-label",!0),K.select("text.nv-bar-label").attr("text-anchor",function(a,b){return r(a,b)<0?"start":"end"}).attr("y",o.rangeBand()/(2*b.length)).attr("dy",".32em").text(function(a,b){return q(a,b)}),K.watchTransition(E,"multibarhorizontal: bars").select("text.nv-bar-label").attr("x",function(a,b){return r(a,b)<0?p(0)-p(r(a,b))+4:-4})):K.selectAll("text.nv-bar-label").text(""),K.attr("class",function(a,b){return r(a,b)<0?"nv-bar negative":"nv-bar positive"}),v&&(c||(c=b.map(function(){return!0})),K.style("fill",function(a,b,d){return d3.rgb(v(a,b)).darker(c.map(function(a,b){return b}).filter(function(a,b){return!c[b]})[d]).toString()}).style("stroke",function(a,b,d){return d3.rgb(v(a,b)).darker(c.map(function(a,b){return b}).filter(function(a,b){return!c[b]})[d]).toString()})),w?K.watchTransition(E,"multibarhorizontal: bars").attr("transform",function(a,b){return"translate("+p(a.y1)+","+o(q(a,b))+")"}).select("rect").attr("width",function(a,b){return Math.abs(p(r(a,b)+a.y0)-p(a.y0))}).attr("height",o.rangeBand()):K.watchTransition(E,"multibarhorizontal: bars").attr("transform",function(a,c){return"translate("+p(r(a,c)<0?r(a,c):0)+","+(a.series*o.rangeBand()/b.length+o(q(a,c)))+")"}).select("rect").attr("height",o.rangeBand()/b.length).attr("width",function(a,b){return Math.max(Math.abs(p(r(a,b))-p(0)),1)}),h=o.copy(),i=p.copy()}),E.renderEnd("multibarHorizontal immediate"),b}var c,d,e,f,g,h,i,j={top:0,right:0,bottom:0,left:0},k=960,l=500,m=Math.floor(1e4*Math.random()),n=null,o=d3.scale.ordinal(),p=d3.scale.linear(),q=function(a){return a.x},r=function(a){return a.y},s=function(a){return a.yErr},t=[0],u=a.utils.defaultColor(),v=null,w=!1,x=!1,y=!1,z=60,A=.1,B=d3.format(",.2f"),C=250,D=d3.dispatch("chartClick","elementClick","elementDblClick","elementMouseover","elementMouseout","elementMousemove","renderEnd"),E=a.utils.renderWatch(D,C);return b.dispatch=D,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return k},set:function(a){k=a}},height:{get:function(){return l},set:function(a){l=a}},x:{get:function(){return q},set:function(a){q=a}},y:{get:function(){return r},set:function(a){r=a}},yErr:{get:function(){return s},set:function(a){s=a}},xScale:{get:function(){return o},set:function(a){o=a}},yScale:{get:function(){return p},set:function(a){p=a}},xDomain:{get:function(){return d},set:function(a){d=a}},yDomain:{get:function(){return e},set:function(a){e=a}},xRange:{get:function(){return f},set:function(a){f=a}},yRange:{get:function(){return g},set:function(a){g=a}},forceY:{get:function(){return t},set:function(a){t=a}},stacked:{get:function(){return w},set:function(a){w=a}},showValues:{get:function(){return x},set:function(a){x=a}},disabled:{get:function(){return c},set:function(a){c=a}},id:{get:function(){return m},set:function(a){m=a}},valueFormat:{get:function(){return B},set:function(a){B=a}},valuePadding:{get:function(){return z},set:function(a){z=a}},groupSpacing:{get:function(){return A},set:function(a){A=a}},margin:{get:function(){return j},set:function(a){j.top=void 0!==a.top?a.top:j.top,j.right=void 0!==a.right?a.right:j.right,j.bottom=void 0!==a.bottom?a.bottom:j.bottom,j.left=void 0!==a.left?a.left:j.left}},duration:{get:function(){return C},set:function(a){C=a,E.reset(C)}},color:{get:function(){return u},set:function(b){u=a.utils.getColor(b)}},barColor:{get:function(){return v},set:function(b){v=b?a.utils.getColor(b):null}}}),a.utils.initOptions(b),b},a.models.multiBarHorizontalChart=function(){"use strict";function b(j){return C.reset(),C.models(e),r&&C.models(f),s&&C.models(g),j.each(function(j){var w=d3.select(this);a.utils.initSVG(w);var C=a.utils.availableWidth(l,w,k),D=a.utils.availableHeight(m,w,k);if(b.update=function(){w.transition().duration(z).call(b)},b.container=this,t=e.stacked(),u.setter(B(j),b.update).getter(A(j)).update(),u.disabled=j.map(function(a){return!!a.disabled}),!v){var E;v={};for(E in u)v[E]=u[E]instanceof Array?u[E].slice(0):u[E]}if(!(j&&j.length&&j.filter(function(a){return a.values.length}).length))return a.utils.noData(b,w),b;w.selectAll(".nv-noData").remove(),c=e.xScale(),d=e.yScale();var F=w.selectAll("g.nv-wrap.nv-multiBarHorizontalChart").data([j]),G=F.enter().append("g").attr("class","nvd3 nv-wrap nv-multiBarHorizontalChart").append("g"),H=F.select("g");if(G.append("g").attr("class","nv-x nv-axis"),G.append("g").attr("class","nv-y nv-axis").append("g").attr("class","nv-zeroLine").append("line"),G.append("g").attr("class","nv-barsWrap"),G.append("g").attr("class","nv-legendWrap"),G.append("g").attr("class","nv-controlsWrap"),q&&(h.width(C-y()),H.select(".nv-legendWrap").datum(j).call(h),k.top!=h.height()&&(k.top=h.height(),D=a.utils.availableHeight(m,w,k)),H.select(".nv-legendWrap").attr("transform","translate("+y()+","+-k.top+")")),o){var I=[{key:p.grouped||"Grouped",disabled:e.stacked()},{key:p.stacked||"Stacked",disabled:!e.stacked()}];i.width(y()).color(["#444","#444","#444"]),H.select(".nv-controlsWrap").datum(I).attr("transform","translate(0,"+-k.top+")").call(i)}F.attr("transform","translate("+k.left+","+k.top+")"),e.disabled(j.map(function(a){return a.disabled})).width(C).height(D).color(j.map(function(a,b){return a.color||n(a,b)}).filter(function(a,b){return!j[b].disabled}));var J=H.select(".nv-barsWrap").datum(j.filter(function(a){return!a.disabled}));if(J.transition().call(e),r){f.scale(c)._ticks(a.utils.calcTicksY(D/24,j)).tickSize(-C,0),H.select(".nv-x.nv-axis").call(f);var K=H.select(".nv-x.nv-axis").selectAll("g");K.selectAll("line, text")}s&&(g.scale(d)._ticks(a.utils.calcTicksX(C/100,j)).tickSize(-D,0),H.select(".nv-y.nv-axis").attr("transform","translate(0,"+D+")"),H.select(".nv-y.nv-axis").call(g)),H.select(".nv-zeroLine line").attr("x1",d(0)).attr("x2",d(0)).attr("y1",0).attr("y2",-D),h.dispatch.on("stateChange",function(a){for(var c in a)u[c]=a[c];x.stateChange(u),b.update()}),i.dispatch.on("legendClick",function(a){if(a.disabled){switch(I=I.map(function(a){return a.disabled=!0,a}),a.disabled=!1,a.key){case"Grouped":e.stacked(!1);break;case"Stacked":e.stacked(!0)}u.stacked=e.stacked(),x.stateChange(u),t=e.stacked(),b.update()}}),x.on("changeState",function(a){"undefined"!=typeof a.disabled&&(j.forEach(function(b,c){b.disabled=a.disabled[c]}),u.disabled=a.disabled),"undefined"!=typeof a.stacked&&(e.stacked(a.stacked),u.stacked=a.stacked,t=a.stacked),b.update()})}),C.renderEnd("multibar horizontal chart immediate"),b}var c,d,e=a.models.multiBarHorizontal(),f=a.models.axis(),g=a.models.axis(),h=a.models.legend().height(30),i=a.models.legend().height(30),j=a.models.tooltip(),k={top:30,right:20,bottom:50,left:60},l=null,m=null,n=a.utils.defaultColor(),o=!0,p={},q=!0,r=!0,s=!0,t=!1,u=a.utils.state(),v=null,w=null,x=d3.dispatch("stateChange","changeState","renderEnd"),y=function(){return o?180:0},z=250;u.stacked=!1,e.stacked(t),f.orient("left").tickPadding(5).showMaxMin(!1).tickFormat(function(a){return a}),g.orient("bottom").tickFormat(d3.format(",.1f")),j.duration(0).valueFormatter(function(a,b){return g.tickFormat()(a,b)}).headerFormatter(function(a,b){return f.tickFormat()(a,b)}),i.updateState(!1);var A=function(a){return function(){return{active:a.map(function(a){return!a.disabled}),stacked:t}}},B=function(a){return function(b){void 0!==b.stacked&&(t=b.stacked),void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}},C=a.utils.renderWatch(x,z);return e.dispatch.on("elementMouseover.tooltip",function(a){a.value=b.x()(a.data),a.series={key:a.data.key,value:b.y()(a.data),color:a.color},j.data(a).hidden(!1)}),e.dispatch.on("elementMouseout.tooltip",function(){j.hidden(!0)}),e.dispatch.on("elementMousemove.tooltip",function(){j.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.dispatch=x,b.multibar=e,b.legend=h,b.controls=i,b.xAxis=f,b.yAxis=g,b.state=u,b.tooltip=j,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return l},set:function(a){l=a}},height:{get:function(){return m},set:function(a){m=a}},showLegend:{get:function(){return q},set:function(a){q=a}},showControls:{get:function(){return o},set:function(a){o=a}},controlLabels:{get:function(){return p},set:function(a){p=a}},showXAxis:{get:function(){return r},set:function(a){r=a}},showYAxis:{get:function(){return s},set:function(a){s=a}},defaultState:{get:function(){return v},set:function(a){v=a}},noData:{get:function(){return w},set:function(a){w=a}},tooltips:{get:function(){return j.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),j.enabled(!!b)}},tooltipContent:{get:function(){return j.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),j.contentGenerator(b)}},margin:{get:function(){return k},set:function(a){k.top=void 0!==a.top?a.top:k.top,k.right=void 0!==a.right?a.right:k.right,k.bottom=void 0!==a.bottom?a.bottom:k.bottom,k.left=void 0!==a.left?a.left:k.left}},duration:{get:function(){return z},set:function(a){z=a,C.reset(z),e.duration(z),f.duration(z),g.duration(z)}},color:{get:function(){return n},set:function(b){n=a.utils.getColor(b),h.color(n)}},barColor:{get:function(){return e.barColor},set:function(a){e.barColor(a),h.color(function(a,b){return d3.rgb("#ccc").darker(1.5*b).toString()})}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.multiChart=function(){"use strict";function b(j){return j.each(function(j){function k(a){var b=2===j[a.seriesIndex].yAxis?z:y;a.value=a.point.x,a.series={value:a.point.y,color:a.point.color},B.duration(100).valueFormatter(function(a,c){return b.tickFormat()(a,c)}).data(a).position(a.pos).hidden(!1)}function l(a){var b=2===j[a.seriesIndex].yAxis?z:y;a.point.x=v.x()(a.point),a.point.y=v.y()(a.point),B.duration(100).valueFormatter(function(a,c){return b.tickFormat()(a,c)}).data(a).position(a.pos).hidden(!1)}function n(a){var b=2===j[a.data.series].yAxis?z:y;a.value=t.x()(a.data),a.series={value:t.y()(a.data),color:a.color},B.duration(0).valueFormatter(function(a,c){return b.tickFormat()(a,c)}).data(a).hidden(!1)}var C=d3.select(this);a.utils.initSVG(C),b.update=function(){C.transition().call(b)},b.container=this;var D=a.utils.availableWidth(g,C,e),E=a.utils.availableHeight(h,C,e),F=j.filter(function(a){return"line"==a.type&&1==a.yAxis}),G=j.filter(function(a){return"line"==a.type&&2==a.yAxis}),H=j.filter(function(a){return"bar"==a.type&&1==a.yAxis}),I=j.filter(function(a){return"bar"==a.type&&2==a.yAxis}),J=j.filter(function(a){return"area"==a.type&&1==a.yAxis}),K=j.filter(function(a){return"area"==a.type&&2==a.yAxis});if(!(j&&j.length&&j.filter(function(a){return a.values.length}).length))return a.utils.noData(b,C),b;C.selectAll(".nv-noData").remove();var L=j.filter(function(a){return!a.disabled&&1==a.yAxis}).map(function(a){return a.values.map(function(a){return{x:a.x,y:a.y}})}),M=j.filter(function(a){return!a.disabled&&2==a.yAxis}).map(function(a){return a.values.map(function(a){return{x:a.x,y:a.y}})});o.domain(d3.extent(d3.merge(L.concat(M)),function(a){return a.x})).range([0,D]);var N=C.selectAll("g.wrap.multiChart").data([j]),O=N.enter().append("g").attr("class","wrap nvd3 multiChart").append("g");O.append("g").attr("class","nv-x nv-axis"),O.append("g").attr("class","nv-y1 nv-axis"),O.append("g").attr("class","nv-y2 nv-axis"),O.append("g").attr("class","lines1Wrap"),O.append("g").attr("class","lines2Wrap"),O.append("g").attr("class","bars1Wrap"),O.append("g").attr("class","bars2Wrap"),O.append("g").attr("class","stack1Wrap"),O.append("g").attr("class","stack2Wrap"),O.append("g").attr("class","legendWrap");var P=N.select("g"),Q=j.map(function(a,b){return j[b].color||f(a,b)});if(i){var R=A.align()?D/2:D,S=A.align()?R:0;A.width(R),A.color(Q),P.select(".legendWrap").datum(j.map(function(a){return a.originalKey=void 0===a.originalKey?a.key:a.originalKey,a.key=a.originalKey+(1==a.yAxis?"":" (right axis)"),a})).call(A),e.top!=A.height()&&(e.top=A.height(),E=a.utils.availableHeight(h,C,e)),P.select(".legendWrap").attr("transform","translate("+S+","+-e.top+")")}r.width(D).height(E).interpolate(m).color(Q.filter(function(a,b){return!j[b].disabled&&1==j[b].yAxis&&"line"==j[b].type})),s.width(D).height(E).interpolate(m).color(Q.filter(function(a,b){return!j[b].disabled&&2==j[b].yAxis&&"line"==j[b].type})),t.width(D).height(E).color(Q.filter(function(a,b){return!j[b].disabled&&1==j[b].yAxis&&"bar"==j[b].type})),u.width(D).height(E).color(Q.filter(function(a,b){return!j[b].disabled&&2==j[b].yAxis&&"bar"==j[b].type})),v.width(D).height(E).color(Q.filter(function(a,b){return!j[b].disabled&&1==j[b].yAxis&&"area"==j[b].type})),w.width(D).height(E).color(Q.filter(function(a,b){return!j[b].disabled&&2==j[b].yAxis&&"area"==j[b].type})),P.attr("transform","translate("+e.left+","+e.top+")");var T=P.select(".lines1Wrap").datum(F.filter(function(a){return!a.disabled})),U=P.select(".bars1Wrap").datum(H.filter(function(a){return!a.disabled})),V=P.select(".stack1Wrap").datum(J.filter(function(a){return!a.disabled})),W=P.select(".lines2Wrap").datum(G.filter(function(a){return!a.disabled})),X=P.select(".bars2Wrap").datum(I.filter(function(a){return!a.disabled})),Y=P.select(".stack2Wrap").datum(K.filter(function(a){return!a.disabled})),Z=J.length?J.map(function(a){return a.values}).reduce(function(a,b){return a.map(function(a,c){return{x:a.x,y:a.y+b[c].y}})}).concat([{x:0,y:0}]):[],$=K.length?K.map(function(a){return a.values}).reduce(function(a,b){return a.map(function(a,c){return{x:a.x,y:a.y+b[c].y}})}).concat([{x:0,y:0}]):[];p.domain(c||d3.extent(d3.merge(L).concat(Z),function(a){return a.y})).range([0,E]),q.domain(d||d3.extent(d3.merge(M).concat($),function(a){return a.y})).range([0,E]),r.yDomain(p.domain()),t.yDomain(p.domain()),v.yDomain(p.domain()),s.yDomain(q.domain()),u.yDomain(q.domain()),w.yDomain(q.domain()),J.length&&d3.transition(V).call(v),K.length&&d3.transition(Y).call(w),H.length&&d3.transition(U).call(t),I.length&&d3.transition(X).call(u),F.length&&d3.transition(T).call(r),G.length&&d3.transition(W).call(s),x._ticks(a.utils.calcTicksX(D/100,j)).tickSize(-E,0),P.select(".nv-x.nv-axis").attr("transform","translate(0,"+E+")"),d3.transition(P.select(".nv-x.nv-axis")).call(x),y._ticks(a.utils.calcTicksY(E/36,j)).tickSize(-D,0),d3.transition(P.select(".nv-y1.nv-axis")).call(y),z._ticks(a.utils.calcTicksY(E/36,j)).tickSize(-D,0),d3.transition(P.select(".nv-y2.nv-axis")).call(z),P.select(".nv-y1.nv-axis").classed("nv-disabled",L.length?!1:!0).attr("transform","translate("+o.range()[0]+",0)"),P.select(".nv-y2.nv-axis").classed("nv-disabled",M.length?!1:!0).attr("transform","translate("+o.range()[1]+",0)"),A.dispatch.on("stateChange",function(){b.update()}),r.dispatch.on("elementMouseover.tooltip",k),s.dispatch.on("elementMouseover.tooltip",k),r.dispatch.on("elementMouseout.tooltip",function(){B.hidden(!0)}),s.dispatch.on("elementMouseout.tooltip",function(){B.hidden(!0)}),v.dispatch.on("elementMouseover.tooltip",l),w.dispatch.on("elementMouseover.tooltip",l),v.dispatch.on("elementMouseout.tooltip",function(){B.hidden(!0)}),w.dispatch.on("elementMouseout.tooltip",function(){B.hidden(!0)}),t.dispatch.on("elementMouseover.tooltip",n),u.dispatch.on("elementMouseover.tooltip",n),t.dispatch.on("elementMouseout.tooltip",function(){B.hidden(!0)}),u.dispatch.on("elementMouseout.tooltip",function(){B.hidden(!0)}),t.dispatch.on("elementMousemove.tooltip",function(){B.position({top:d3.event.pageY,left:d3.event.pageX})()}),u.dispatch.on("elementMousemove.tooltip",function(){B.position({top:d3.event.pageY,left:d3.event.pageX})()})}),b}var c,d,e={top:30,right:20,bottom:50,left:60},f=a.utils.defaultColor(),g=null,h=null,i=!0,j=null,k=function(a){return a.x},l=function(a){return a.y},m="monotone",n=!0,o=d3.scale.linear(),p=d3.scale.linear(),q=d3.scale.linear(),r=a.models.line().yScale(p),s=a.models.line().yScale(q),t=a.models.multiBar().stacked(!1).yScale(p),u=a.models.multiBar().stacked(!1).yScale(q),v=a.models.stackedArea().yScale(p),w=a.models.stackedArea().yScale(q),x=a.models.axis().scale(o).orient("bottom").tickPadding(5),y=a.models.axis().scale(p).orient("left"),z=a.models.axis().scale(q).orient("right"),A=a.models.legend().height(30),B=a.models.tooltip(),C=d3.dispatch();return b.dispatch=C,b.lines1=r,b.lines2=s,b.bars1=t,b.bars2=u,b.stack1=v,b.stack2=w,b.xAxis=x,b.yAxis1=y,b.yAxis2=z,b.tooltip=B,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return g},set:function(a){g=a}},height:{get:function(){return h},set:function(a){h=a}},showLegend:{get:function(){return i},set:function(a){i=a}},yDomain1:{get:function(){return c},set:function(a){c=a}},yDomain2:{get:function(){return d},set:function(a){d=a}},noData:{get:function(){return j},set:function(a){j=a}},interpolate:{get:function(){return m},set:function(a){m=a}},tooltips:{get:function(){return B.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),B.enabled(!!b)}},tooltipContent:{get:function(){return B.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),B.contentGenerator(b)}},margin:{get:function(){return e},set:function(a){e.top=void 0!==a.top?a.top:e.top,e.right=void 0!==a.right?a.right:e.right,e.bottom=void 0!==a.bottom?a.bottom:e.bottom,e.left=void 0!==a.left?a.left:e.left}},color:{get:function(){return f},set:function(b){f=a.utils.getColor(b)}},x:{get:function(){return k},set:function(a){k=a,r.x(a),s.x(a),t.x(a),u.x(a),v.x(a),w.x(a)}},y:{get:function(){return l},set:function(a){l=a,r.y(a),s.y(a),v.y(a),w.y(a),t.y(a),u.y(a)}},useVoronoi:{get:function(){return n},set:function(a){n=a,r.useVoronoi(a),s.useVoronoi(a),v.useVoronoi(a),w.useVoronoi(a)}}}),a.utils.initOptions(b),b},a.models.ohlcBar=function(){"use strict";function b(y){return y.each(function(b){k=d3.select(this);var y=a.utils.availableWidth(h,k,g),A=a.utils.availableHeight(i,k,g);a.utils.initSVG(k);var B=y/b[0].values.length*.9;l.domain(c||d3.extent(b[0].values.map(n).concat(t))),l.range(v?e||[.5*y/b[0].values.length,y*(b[0].values.length-.5)/b[0].values.length]:e||[5+B/2,y-B/2-5]),m.domain(d||[d3.min(b[0].values.map(s).concat(u)),d3.max(b[0].values.map(r).concat(u))]).range(f||[A,0]),l.domain()[0]===l.domain()[1]&&l.domain(l.domain()[0]?[l.domain()[0]-.01*l.domain()[0],l.domain()[1]+.01*l.domain()[1]]:[-1,1]),m.domain()[0]===m.domain()[1]&&m.domain(m.domain()[0]?[m.domain()[0]+.01*m.domain()[0],m.domain()[1]-.01*m.domain()[1]]:[-1,1]);var C=d3.select(this).selectAll("g.nv-wrap.nv-ohlcBar").data([b[0].values]),D=C.enter().append("g").attr("class","nvd3 nv-wrap nv-ohlcBar"),E=D.append("defs"),F=D.append("g"),G=C.select("g");F.append("g").attr("class","nv-ticks"),C.attr("transform","translate("+g.left+","+g.top+")"),k.on("click",function(a,b){z.chartClick({data:a,index:b,pos:d3.event,id:j})}),E.append("clipPath").attr("id","nv-chart-clip-path-"+j).append("rect"),C.select("#nv-chart-clip-path-"+j+" rect").attr("width",y).attr("height",A),G.attr("clip-path",w?"url(#nv-chart-clip-path-"+j+")":"");var H=C.select(".nv-ticks").selectAll(".nv-tick").data(function(a){return a});H.exit().remove(),H.enter().append("path").attr("class",function(a,b,c){return(p(a,b)>q(a,b)?"nv-tick negative":"nv-tick positive")+" nv-tick-"+c+"-"+b}).attr("d",function(a,b){return"m0,0l0,"+(m(p(a,b))-m(r(a,b)))+"l"+-B/2+",0l"+B/2+",0l0,"+(m(s(a,b))-m(p(a,b)))+"l0,"+(m(q(a,b))-m(s(a,b)))+"l"+B/2+",0l"+-B/2+",0z"}).attr("transform",function(a,b){return"translate("+l(n(a,b))+","+m(r(a,b))+")"}).attr("fill",function(){return x[0]}).attr("stroke",function(){return x[0]}).attr("x",0).attr("y",function(a,b){return m(Math.max(0,o(a,b)))}).attr("height",function(a,b){return Math.abs(m(o(a,b))-m(0))}),H.attr("class",function(a,b,c){return(p(a,b)>q(a,b)?"nv-tick negative":"nv-tick positive")+" nv-tick-"+c+"-"+b}),d3.transition(H).attr("transform",function(a,b){return"translate("+l(n(a,b))+","+m(r(a,b))+")"}).attr("d",function(a,c){var d=y/b[0].values.length*.9;return"m0,0l0,"+(m(p(a,c))-m(r(a,c)))+"l"+-d/2+",0l"+d/2+",0l0,"+(m(s(a,c))-m(p(a,c)))+"l0,"+(m(q(a,c))-m(s(a,c)))+"l"+d/2+",0l"+-d/2+",0z"})}),b}var c,d,e,f,g={top:0,right:0,bottom:0,left:0},h=null,i=null,j=Math.floor(1e4*Math.random()),k=null,l=d3.scale.linear(),m=d3.scale.linear(),n=function(a){return a.x},o=function(a){return a.y},p=function(a){return a.open},q=function(a){return a.close},r=function(a){return a.high},s=function(a){return a.low},t=[],u=[],v=!1,w=!0,x=a.utils.defaultColor(),y=!1,z=d3.dispatch("tooltipShow","tooltipHide","stateChange","changeState","renderEnd","chartClick","elementClick","elementDblClick","elementMouseover","elementMouseout","elementMousemove");return b.highlightPoint=function(a,c){b.clearHighlights(),k.select(".nv-ohlcBar .nv-tick-0-"+a).classed("hover",c)},b.clearHighlights=function(){k.select(".nv-ohlcBar .nv-tick.hover").classed("hover",!1)},b.dispatch=z,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return h},set:function(a){h=a}},height:{get:function(){return i},set:function(a){i=a}},xScale:{get:function(){return l},set:function(a){l=a}},yScale:{get:function(){return m},set:function(a){m=a}},xDomain:{get:function(){return c},set:function(a){c=a}},yDomain:{get:function(){return d},set:function(a){d=a}},xRange:{get:function(){return e},set:function(a){e=a}},yRange:{get:function(){return f},set:function(a){f=a}},forceX:{get:function(){return t},set:function(a){t=a}},forceY:{get:function(){return u},set:function(a){u=a}},padData:{get:function(){return v},set:function(a){v=a}},clipEdge:{get:function(){return w},set:function(a){w=a}},id:{get:function(){return j},set:function(a){j=a}},interactive:{get:function(){return y},set:function(a){y=a}},x:{get:function(){return n},set:function(a){n=a}},y:{get:function(){return o},set:function(a){o=a}},open:{get:function(){return p()},set:function(a){p=a}},close:{get:function(){return q()},set:function(a){q=a}},high:{get:function(){return r},set:function(a){r=a}},low:{get:function(){return s},set:function(a){s=a}},margin:{get:function(){return g},set:function(a){g.top=void 0!=a.top?a.top:g.top,g.right=void 0!=a.right?a.right:g.right,g.bottom=void 0!=a.bottom?a.bottom:g.bottom,g.left=void 0!=a.left?a.left:g.left
}},color:{get:function(){return x},set:function(b){x=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.parallelCoordinates=function(){"use strict";function b(p){return p.each(function(b){function p(a){return F(h.map(function(b){if(isNaN(a[b])||isNaN(parseFloat(a[b]))){var c=g[b].domain(),d=g[b].range(),e=c[0]-(c[1]-c[0])/9;if(J.indexOf(b)<0){var h=d3.scale.linear().domain([e,c[1]]).range([x-12,d[1]]);g[b].brush.y(h),J.push(b)}return[f(b),g[b](e)]}return J.length>0?(D.style("display","inline"),E.style("display","inline")):(D.style("display","none"),E.style("display","none")),[f(b),g[b](a[b])]}))}function q(){var a=h.filter(function(a){return!g[a].brush.empty()}),b=a.map(function(a){return g[a].brush.extent()});k=[],a.forEach(function(a,c){k[c]={dimension:a,extent:b[c]}}),l=[],M.style("display",function(c){var d=a.every(function(a,d){return isNaN(c[a])&&b[d][0]==g[a].brush.y().domain()[0]?!0:b[d][0]<=c[a]&&c[a]<=b[d][1]});return d&&l.push(c),d?null:"none"}),o.brush({filters:k,active:l})}function r(a){m[a]=this.parentNode.__origin__=f(a),L.attr("visibility","hidden")}function s(a){m[a]=Math.min(w,Math.max(0,this.parentNode.__origin__+=d3.event.x)),M.attr("d",p),h.sort(function(a,b){return u(a)-u(b)}),f.domain(h),N.attr("transform",function(a){return"translate("+u(a)+")"})}function t(a){delete this.parentNode.__origin__,delete m[a],d3.select(this.parentNode).attr("transform","translate("+f(a)+")"),M.attr("d",p),L.attr("d",p).attr("visibility",null)}function u(a){var b=m[a];return null==b?f(a):b}var v=d3.select(this),w=a.utils.availableWidth(d,v,c),x=a.utils.availableHeight(e,v,c);a.utils.initSVG(v),l=b,f.rangePoints([0,w],1).domain(h);var y={};h.forEach(function(a){var c=d3.extent(b,function(b){return+b[a]});return y[a]=!1,void 0===c[0]&&(y[a]=!0,c[0]=0,c[1]=0),c[0]===c[1]&&(c[0]=c[0]-1,c[1]=c[1]+1),g[a]=d3.scale.linear().domain(c).range([.9*(x-12),0]),g[a].brush=d3.svg.brush().y(g[a]).on("brush",q),"name"!=a});var z=v.selectAll("g.nv-wrap.nv-parallelCoordinates").data([b]),A=z.enter().append("g").attr("class","nvd3 nv-wrap nv-parallelCoordinates"),B=A.append("g"),C=z.select("g");B.append("g").attr("class","nv-parallelCoordinates background"),B.append("g").attr("class","nv-parallelCoordinates foreground"),B.append("g").attr("class","nv-parallelCoordinates missingValuesline"),z.attr("transform","translate("+c.left+","+c.top+")");var D,E,F=d3.svg.line().interpolate("cardinal").tension(n),G=d3.svg.axis().orient("left"),H=d3.behavior.drag().on("dragstart",r).on("drag",s).on("dragend",t),I=f.range()[1]-f.range()[0],J=[],K=[0+I/2,x-12,w-I/2,x-12];D=z.select(".missingValuesline").selectAll("line").data([K]),D.enter().append("line"),D.exit().remove(),D.attr("x1",function(a){return a[0]}).attr("y1",function(a){return a[1]}).attr("x2",function(a){return a[2]}).attr("y2",function(a){return a[3]}),E=z.select(".missingValuesline").selectAll("text").data(["undefined values"]),E.append("text").data(["undefined values"]),E.enter().append("text"),E.exit().remove(),E.attr("y",x).attr("x",w-92-I/2).text(function(a){return a});var L=z.select(".background").selectAll("path").data(b);L.enter().append("path"),L.exit().remove(),L.attr("d",p);var M=z.select(".foreground").selectAll("path").data(b);M.enter().append("path"),M.exit().remove(),M.attr("d",p).attr("stroke",j),M.on("mouseover",function(a,b){d3.select(this).classed("hover",!0),o.elementMouseover({label:a.name,data:a.data,index:b,pos:[d3.mouse(this.parentNode)[0],d3.mouse(this.parentNode)[1]]})}),M.on("mouseout",function(a,b){d3.select(this).classed("hover",!1),o.elementMouseout({label:a.name,data:a.data,index:b})});var N=C.selectAll(".dimension").data(h),O=N.enter().append("g").attr("class","nv-parallelCoordinates dimension");O.append("g").attr("class","nv-parallelCoordinates nv-axis"),O.append("g").attr("class","nv-parallelCoordinates-brush"),O.append("text").attr("class","nv-parallelCoordinates nv-label"),N.attr("transform",function(a){return"translate("+f(a)+",0)"}),N.exit().remove(),N.select(".nv-label").style("cursor","move").attr("dy","-1em").attr("text-anchor","middle").text(String).on("mouseover",function(a){o.elementMouseover({dim:a,pos:[d3.mouse(this.parentNode.parentNode)[0],d3.mouse(this.parentNode.parentNode)[1]]})}).on("mouseout",function(a){o.elementMouseout({dim:a})}).call(H),N.select(".nv-axis").each(function(a,b){d3.select(this).call(G.scale(g[a]).tickFormat(d3.format(i[b])))}),N.select(".nv-parallelCoordinates-brush").each(function(a){d3.select(this).call(g[a].brush)}).selectAll("rect").attr("x",-8).attr("width",16)}),b}var c={top:30,right:0,bottom:10,left:0},d=null,e=null,f=d3.scale.ordinal(),g={},h=[],i=[],j=a.utils.defaultColor(),k=[],l=[],m=[],n=1,o=d3.dispatch("brush","elementMouseover","elementMouseout");return b.dispatch=o,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return d},set:function(a){d=a}},height:{get:function(){return e},set:function(a){e=a}},dimensionNames:{get:function(){return h},set:function(a){h=a}},dimensionFormats:{get:function(){return i},set:function(a){i=a}},lineTension:{get:function(){return n},set:function(a){n=a}},dimensions:{get:function(){return h},set:function(b){a.deprecated("dimensions","use dimensionNames instead"),h=b}},margin:{get:function(){return c},set:function(a){c.top=void 0!==a.top?a.top:c.top,c.right=void 0!==a.right?a.right:c.right,c.bottom=void 0!==a.bottom?a.bottom:c.bottom,c.left=void 0!==a.left?a.left:c.left}},color:{get:function(){return j},set:function(b){j=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.pie=function(){"use strict";function b(E){return D.reset(),E.each(function(b){function E(a,b){a.endAngle=isNaN(a.endAngle)?0:a.endAngle,a.startAngle=isNaN(a.startAngle)?0:a.startAngle,p||(a.innerRadius=0);var c=d3.interpolate(this._current,a);return this._current=c(0),function(a){return B[b](c(a))}}var F=d-c.left-c.right,G=e-c.top-c.bottom,H=Math.min(F,G)/2,I=[],J=[];if(i=d3.select(this),0===z.length)for(var K=H-H/5,L=y*H,M=0;M<b[0].length;M++)I.push(K),J.push(L);else I=z.map(function(a){return(a.outer-a.outer/5)*H}),J=z.map(function(a){return(a.inner-a.inner/5)*H}),y=d3.min(z.map(function(a){return a.inner-a.inner/5}));a.utils.initSVG(i);var N=i.selectAll(".nv-wrap.nv-pie").data(b),O=N.enter().append("g").attr("class","nvd3 nv-wrap nv-pie nv-chart-"+h),P=O.append("g"),Q=N.select("g"),R=P.append("g").attr("class","nv-pie");P.append("g").attr("class","nv-pieLabels"),N.attr("transform","translate("+c.left+","+c.top+")"),Q.select(".nv-pie").attr("transform","translate("+F/2+","+G/2+")"),Q.select(".nv-pieLabels").attr("transform","translate("+F/2+","+G/2+")"),i.on("click",function(a,b){A.chartClick({data:a,index:b,pos:d3.event,id:h})}),B=[],C=[];for(var M=0;M<b[0].length;M++){var S=d3.svg.arc().outerRadius(I[M]),T=d3.svg.arc().outerRadius(I[M]+5);u!==!1&&(S.startAngle(u),T.startAngle(u)),w!==!1&&(S.endAngle(w),T.endAngle(w)),p&&(S.innerRadius(J[M]),T.innerRadius(J[M])),S.cornerRadius&&x&&(S.cornerRadius(x),T.cornerRadius(x)),B.push(S),C.push(T)}var U=d3.layout.pie().sort(null).value(function(a){return a.disabled?0:g(a)});U.padAngle&&v&&U.padAngle(v),p&&q&&(R.append("text").attr("class","nv-pie-title"),N.select(".nv-pie-title").style("text-anchor","middle").text(function(){return q}).style("font-size",Math.min(F,G)*y*2/(q.length+2)+"px").attr("dy","0.35em").attr("transform",function(){return"translate(0, "+s+")"}));var V=N.select(".nv-pie").selectAll(".nv-slice").data(U),W=N.select(".nv-pieLabels").selectAll(".nv-label").data(U);V.exit().remove(),W.exit().remove();var X=V.enter().append("g");X.attr("class","nv-slice"),X.on("mouseover",function(a,b){d3.select(this).classed("hover",!0),r&&d3.select(this).select("path").transition().duration(70).attr("d",C[b]),A.elementMouseover({data:a.data,index:b,color:d3.select(this).style("fill")})}),X.on("mouseout",function(a,b){d3.select(this).classed("hover",!1),r&&d3.select(this).select("path").transition().duration(50).attr("d",B[b]),A.elementMouseout({data:a.data,index:b})}),X.on("mousemove",function(a,b){A.elementMousemove({data:a.data,index:b})}),X.on("click",function(a,b){A.elementClick({data:a.data,index:b,color:d3.select(this).style("fill")})}),X.on("dblclick",function(a,b){A.elementDblClick({data:a.data,index:b,color:d3.select(this).style("fill")})}),V.attr("fill",function(a,b){return j(a.data,b)}),V.attr("stroke",function(a,b){return j(a.data,b)});X.append("path").each(function(a){this._current=a});if(V.select("path").transition().attr("d",function(a,b){return B[b](a)}).attrTween("d",E),l){for(var Y=[],M=0;M<b[0].length;M++)Y.push(B[M]),m?p&&(Y[M]=d3.svg.arc().outerRadius(B[M].outerRadius()),u!==!1&&Y[M].startAngle(u),w!==!1&&Y[M].endAngle(w)):p||Y[M].innerRadius(0);W.enter().append("g").classed("nv-label",!0).each(function(a){var b=d3.select(this);b.attr("transform",function(a,b){if(t){a.outerRadius=I[b]+10,a.innerRadius=I[b]+15;var c=(a.startAngle+a.endAngle)/2*(180/Math.PI);return(a.startAngle+a.endAngle)/2<Math.PI?c-=90:c+=90,"translate("+Y[b].centroid(a)+") rotate("+c+")"}return a.outerRadius=H+10,a.innerRadius=H+15,"translate("+Y[b].centroid(a)+")"}),b.append("rect").style("stroke","#fff").style("fill","#fff").attr("rx",3).attr("ry",3),b.append("text").style("text-anchor",t?(a.startAngle+a.endAngle)/2<Math.PI?"start":"end":"middle").style("fill","#000")});var Z={},$=14,_=140,ab=function(a){return Math.floor(a[0]/_)*_+","+Math.floor(a[1]/$)*$};W.watchTransition(D,"pie labels").attr("transform",function(a,b){if(t){a.outerRadius=I[b]+10,a.innerRadius=I[b]+15;var c=(a.startAngle+a.endAngle)/2*(180/Math.PI);return(a.startAngle+a.endAngle)/2<Math.PI?c-=90:c+=90,"translate("+Y[b].centroid(a)+") rotate("+c+")"}a.outerRadius=H+10,a.innerRadius=H+15;var d=Y[b].centroid(a);if(a.value){var e=ab(d);Z[e]&&(d[1]-=$),Z[ab(d)]=!0}return"translate("+d+")"}),W.select(".nv-label text").style("text-anchor",function(a){return t?(a.startAngle+a.endAngle)/2<Math.PI?"start":"end":"middle"}).text(function(a,b){var c=(a.endAngle-a.startAngle)/(2*Math.PI),d="";if(!a.value||o>c)return"";if("function"==typeof n)d=n(a,b,{key:f(a.data),value:g(a.data),percent:k(c)});else switch(n){case"key":d=f(a.data);break;case"value":d=k(g(a.data));break;case"percent":d=d3.format("%")(c)}return d})}}),D.renderEnd("pie immediate"),b}var c={top:0,right:0,bottom:0,left:0},d=500,e=500,f=function(a){return a.x},g=function(a){return a.y},h=Math.floor(1e4*Math.random()),i=null,j=a.utils.defaultColor(),k=d3.format(",.2f"),l=!0,m=!1,n="key",o=.02,p=!1,q=!1,r=!0,s=0,t=!1,u=!1,v=!1,w=!1,x=0,y=.5,z=[],A=d3.dispatch("chartClick","elementClick","elementDblClick","elementMouseover","elementMouseout","elementMousemove","renderEnd"),B=[],C=[],D=a.utils.renderWatch(A);return b.dispatch=A,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{arcsRadius:{get:function(){return z},set:function(a){z=a}},width:{get:function(){return d},set:function(a){d=a}},height:{get:function(){return e},set:function(a){e=a}},showLabels:{get:function(){return l},set:function(a){l=a}},title:{get:function(){return q},set:function(a){q=a}},titleOffset:{get:function(){return s},set:function(a){s=a}},labelThreshold:{get:function(){return o},set:function(a){o=a}},valueFormat:{get:function(){return k},set:function(a){k=a}},x:{get:function(){return f},set:function(a){f=a}},id:{get:function(){return h},set:function(a){h=a}},endAngle:{get:function(){return w},set:function(a){w=a}},startAngle:{get:function(){return u},set:function(a){u=a}},padAngle:{get:function(){return v},set:function(a){v=a}},cornerRadius:{get:function(){return x},set:function(a){x=a}},donutRatio:{get:function(){return y},set:function(a){y=a}},labelsOutside:{get:function(){return m},set:function(a){m=a}},labelSunbeamLayout:{get:function(){return t},set:function(a){t=a}},donut:{get:function(){return p},set:function(a){p=a}},growOnHover:{get:function(){return r},set:function(a){r=a}},pieLabelsOutside:{get:function(){return m},set:function(b){m=b,a.deprecated("pieLabelsOutside","use labelsOutside instead")}},donutLabelsOutside:{get:function(){return m},set:function(b){m=b,a.deprecated("donutLabelsOutside","use labelsOutside instead")}},labelFormat:{get:function(){return k},set:function(b){k=b,a.deprecated("labelFormat","use valueFormat instead")}},margin:{get:function(){return c},set:function(a){c.top="undefined"!=typeof a.top?a.top:c.top,c.right="undefined"!=typeof a.right?a.right:c.right,c.bottom="undefined"!=typeof a.bottom?a.bottom:c.bottom,c.left="undefined"!=typeof a.left?a.left:c.left}},y:{get:function(){return g},set:function(a){g=d3.functor(a)}},color:{get:function(){return j},set:function(b){j=a.utils.getColor(b)}},labelType:{get:function(){return n},set:function(a){n=a||"key"}}}),a.utils.initOptions(b),b},a.models.pieChart=function(){"use strict";function b(e){return q.reset(),q.models(c),e.each(function(e){var k=d3.select(this);a.utils.initSVG(k);var n=a.utils.availableWidth(g,k,f),o=a.utils.availableHeight(h,k,f);if(b.update=function(){k.transition().call(b)},b.container=this,l.setter(s(e),b.update).getter(r(e)).update(),l.disabled=e.map(function(a){return!!a.disabled}),!m){var q;m={};for(q in l)m[q]=l[q]instanceof Array?l[q].slice(0):l[q]}if(!e||!e.length)return a.utils.noData(b,k),b;k.selectAll(".nv-noData").remove();var t=k.selectAll("g.nv-wrap.nv-pieChart").data([e]),u=t.enter().append("g").attr("class","nvd3 nv-wrap nv-pieChart").append("g"),v=t.select("g");if(u.append("g").attr("class","nv-pieWrap"),u.append("g").attr("class","nv-legendWrap"),i)if("top"===j)d.width(n).key(c.x()),t.select(".nv-legendWrap").datum(e).call(d),f.top!=d.height()&&(f.top=d.height(),o=a.utils.availableHeight(h,k,f)),t.select(".nv-legendWrap").attr("transform","translate(0,"+-f.top+")");else if("right"===j){var w=a.models.legend().width();w>n/2&&(w=n/2),d.height(o).key(c.x()),d.width(w),n-=d.width(),t.select(".nv-legendWrap").datum(e).call(d).attr("transform","translate("+n+",0)")}t.attr("transform","translate("+f.left+","+f.top+")"),c.width(n).height(o);var x=v.select(".nv-pieWrap").datum([e]);d3.transition(x).call(c),d.dispatch.on("stateChange",function(a){for(var c in a)l[c]=a[c];p.stateChange(l),b.update()}),p.on("changeState",function(a){"undefined"!=typeof a.disabled&&(e.forEach(function(b,c){b.disabled=a.disabled[c]}),l.disabled=a.disabled),b.update()})}),q.renderEnd("pieChart immediate"),b}var c=a.models.pie(),d=a.models.legend(),e=a.models.tooltip(),f={top:30,right:20,bottom:20,left:20},g=null,h=null,i=!0,j="top",k=a.utils.defaultColor(),l=a.utils.state(),m=null,n=null,o=250,p=d3.dispatch("tooltipShow","tooltipHide","stateChange","changeState","renderEnd");e.headerEnabled(!1).duration(0).valueFormatter(function(a,b){return c.valueFormat()(a,b)});var q=a.utils.renderWatch(p),r=function(a){return function(){return{active:a.map(function(a){return!a.disabled})}}},s=function(a){return function(b){void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}};return c.dispatch.on("elementMouseover.tooltip",function(a){a.series={key:b.x()(a.data),value:b.y()(a.data),color:a.color},e.data(a).hidden(!1)}),c.dispatch.on("elementMouseout.tooltip",function(){e.hidden(!0)}),c.dispatch.on("elementMousemove.tooltip",function(){e.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.legend=d,b.dispatch=p,b.pie=c,b.tooltip=e,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{noData:{get:function(){return n},set:function(a){n=a}},showLegend:{get:function(){return i},set:function(a){i=a}},legendPosition:{get:function(){return j},set:function(a){j=a}},defaultState:{get:function(){return m},set:function(a){m=a}},tooltips:{get:function(){return e.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),e.enabled(!!b)}},tooltipContent:{get:function(){return e.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),e.contentGenerator(b)}},color:{get:function(){return k},set:function(a){k=a,d.color(k),c.color(k)}},duration:{get:function(){return o},set:function(a){o=a,q.reset(o)}},margin:{get:function(){return f},set:function(a){f.top=void 0!==a.top?a.top:f.top,f.right=void 0!==a.right?a.right:f.right,f.bottom=void 0!==a.bottom?a.bottom:f.bottom,f.left=void 0!==a.left?a.left:f.left}}}),a.utils.inheritOptions(b,c),a.utils.initOptions(b),b},a.models.scatter=function(){"use strict";function b(N){return P.reset(),N.each(function(b){function N(){if(O=!1,!w)return!1;if(M===!0){var a=d3.merge(b.map(function(a,b){return a.values.map(function(a,c){var d=p(a,c),e=q(a,c);return[m(d)+1e-4*Math.random(),n(e)+1e-4*Math.random(),b,c,a]}).filter(function(a,b){return x(a[4],b)})}));if(0==a.length)return!1;a.length<3&&(a.push([m.range()[0]-20,n.range()[0]-20,null,null]),a.push([m.range()[1]+20,n.range()[1]+20,null,null]),a.push([m.range()[0]-20,n.range()[0]+20,null,null]),a.push([m.range()[1]+20,n.range()[1]-20,null,null]));var c=d3.geom.polygon([[-10,-10],[-10,i+10],[h+10,i+10],[h+10,-10]]),d=d3.geom.voronoi(a).map(function(b,d){return{data:c.clip(b),series:a[d][2],point:a[d][3]}});U.select(".nv-point-paths").selectAll("path").remove();var e=U.select(".nv-point-paths").selectAll("path").data(d),f=e.enter().append("svg:path").attr("d",function(a){return a&&a.data&&0!==a.data.length?"M"+a.data.join(",")+"Z":"M 0 0"}).attr("id",function(a,b){return"nv-path-"+b}).attr("clip-path",function(a,b){return"url(#nv-clip-"+b+")"});C&&f.style("fill",d3.rgb(230,230,230)).style("fill-opacity",.4).style("stroke-opacity",1).style("stroke",d3.rgb(200,200,200)),B&&(U.select(".nv-point-clips").selectAll("clipPath").remove(),U.select(".nv-point-clips").selectAll("clipPath").data(a).enter().append("svg:clipPath").attr("id",function(a,b){return"nv-clip-"+b}).append("svg:circle").attr("cx",function(a){return a[0]}).attr("cy",function(a){return a[1]}).attr("r",D));var k=function(a,c){if(O)return 0;var d=b[a.series];if(void 0!==d){var e=d.values[a.point];e.color=j(d,a.series),e.x=p(e),e.y=q(e);var f=l.node().getBoundingClientRect(),h=window.pageYOffset||document.documentElement.scrollTop,i=window.pageXOffset||document.documentElement.scrollLeft,k={left:m(p(e,a.point))+f.left+i+g.left+10,top:n(q(e,a.point))+f.top+h+g.top+10};c({point:e,series:d,pos:k,seriesIndex:a.series,pointIndex:a.point})}};e.on("click",function(a){k(a,L.elementClick)}).on("dblclick",function(a){k(a,L.elementDblClick)}).on("mouseover",function(a){k(a,L.elementMouseover)}).on("mouseout",function(a){k(a,L.elementMouseout)})}else U.select(".nv-groups").selectAll(".nv-group").selectAll(".nv-point").on("click",function(a,c){if(O||!b[a.series])return 0;var d=b[a.series],e=d.values[c];L.elementClick({point:e,series:d,pos:[m(p(e,c))+g.left,n(q(e,c))+g.top],seriesIndex:a.series,pointIndex:c})}).on("dblclick",function(a,c){if(O||!b[a.series])return 0;var d=b[a.series],e=d.values[c];L.elementDblClick({point:e,series:d,pos:[m(p(e,c))+g.left,n(q(e,c))+g.top],seriesIndex:a.series,pointIndex:c})}).on("mouseover",function(a,c){if(O||!b[a.series])return 0;var d=b[a.series],e=d.values[c];L.elementMouseover({point:e,series:d,pos:[m(p(e,c))+g.left,n(q(e,c))+g.top],seriesIndex:a.series,pointIndex:c,color:j(a,c)})}).on("mouseout",function(a,c){if(O||!b[a.series])return 0;var d=b[a.series],e=d.values[c];L.elementMouseout({point:e,series:d,seriesIndex:a.series,pointIndex:c,color:j(a,c)})})}l=d3.select(this);var R=a.utils.availableWidth(h,l,g),S=a.utils.availableHeight(i,l,g);a.utils.initSVG(l),b.forEach(function(a,b){a.values.forEach(function(a){a.series=b})});var T=E&&F&&I?[]:d3.merge(b.map(function(a){return a.values.map(function(a,b){return{x:p(a,b),y:q(a,b),size:r(a,b)}})}));m.domain(E||d3.extent(T.map(function(a){return a.x}).concat(t))),m.range(y&&b[0]?G||[(R*z+R)/(2*b[0].values.length),R-R*(1+z)/(2*b[0].values.length)]:G||[0,R]),n.domain(F||d3.extent(T.map(function(a){return a.y}).concat(u))).range(H||[S,0]),o.domain(I||d3.extent(T.map(function(a){return a.size}).concat(v))).range(J||Q),K=m.domain()[0]===m.domain()[1]||n.domain()[0]===n.domain()[1],m.domain()[0]===m.domain()[1]&&m.domain(m.domain()[0]?[m.domain()[0]-.01*m.domain()[0],m.domain()[1]+.01*m.domain()[1]]:[-1,1]),n.domain()[0]===n.domain()[1]&&n.domain(n.domain()[0]?[n.domain()[0]-.01*n.domain()[0],n.domain()[1]+.01*n.domain()[1]]:[-1,1]),isNaN(m.domain()[0])&&m.domain([-1,1]),isNaN(n.domain()[0])&&n.domain([-1,1]),c=c||m,d=d||n,e=e||o;var U=l.selectAll("g.nv-wrap.nv-scatter").data([b]),V=U.enter().append("g").attr("class","nvd3 nv-wrap nv-scatter nv-chart-"+k),W=V.append("defs"),X=V.append("g"),Y=U.select("g");U.classed("nv-single-point",K),X.append("g").attr("class","nv-groups"),X.append("g").attr("class","nv-point-paths"),V.append("g").attr("class","nv-point-clips"),U.attr("transform","translate("+g.left+","+g.top+")"),W.append("clipPath").attr("id","nv-edge-clip-"+k).append("rect"),U.select("#nv-edge-clip-"+k+" rect").attr("width",R).attr("height",S>0?S:0),Y.attr("clip-path",A?"url(#nv-edge-clip-"+k+")":""),O=!0;var Z=U.select(".nv-groups").selectAll(".nv-group").data(function(a){return a},function(a){return a.key});Z.enter().append("g").style("stroke-opacity",1e-6).style("fill-opacity",1e-6),Z.exit().remove(),Z.attr("class",function(a,b){return"nv-group nv-series-"+b}).classed("hover",function(a){return a.hover}),Z.watchTransition(P,"scatter: groups").style("fill",function(a,b){return j(a,b)}).style("stroke",function(a,b){return j(a,b)}).style("stroke-opacity",1).style("fill-opacity",.5);var $=Z.selectAll("path.nv-point").data(function(a){return a.values.map(function(a,b){return[a,b]}).filter(function(a,b){return x(a[0],b)})});$.enter().append("path").style("fill",function(a){return a.color}).style("stroke",function(a){return a.color}).attr("transform",function(a){return"translate("+c(p(a[0],a[1]))+","+d(q(a[0],a[1]))+")"}).attr("d",a.utils.symbol().type(function(a){return s(a[0])}).size(function(a){return o(r(a[0],a[1]))})),$.exit().remove(),Z.exit().selectAll("path.nv-point").watchTransition(P,"scatter exit").attr("transform",function(a){return"translate("+m(p(a[0],a[1]))+","+n(q(a[0],a[1]))+")"}).remove(),$.each(function(a){d3.select(this).classed("nv-point",!0).classed("nv-point-"+a[1],!0).classed("nv-noninteractive",!w).classed("hover",!1)}),$.watchTransition(P,"scatter points").attr("transform",function(a){return"translate("+m(p(a[0],a[1]))+","+n(q(a[0],a[1]))+")"}).attr("d",a.utils.symbol().type(function(a){return s(a[0])}).size(function(a){return o(r(a[0],a[1]))})),clearTimeout(f),f=setTimeout(N,300),c=m.copy(),d=n.copy(),e=o.copy()}),P.renderEnd("scatter immediate"),b}var c,d,e,f,g={top:0,right:0,bottom:0,left:0},h=null,i=null,j=a.utils.defaultColor(),k=Math.floor(1e5*Math.random()),l=null,m=d3.scale.linear(),n=d3.scale.linear(),o=d3.scale.linear(),p=function(a){return a.x},q=function(a){return a.y},r=function(a){return a.size||1},s=function(a){return a.shape||"circle"},t=[],u=[],v=[],w=!0,x=function(a){return!a.notActive},y=!1,z=.1,A=!1,B=!0,C=!1,D=function(){return 25},E=null,F=null,G=null,H=null,I=null,J=null,K=!1,L=d3.dispatch("elementClick","elementDblClick","elementMouseover","elementMouseout","renderEnd"),M=!0,N=250,O=!1,P=a.utils.renderWatch(L,N),Q=[16,256];return b.dispatch=L,b.options=a.utils.optionsFunc.bind(b),b._calls=new function(){this.clearHighlights=function(){return a.dom.write(function(){l.selectAll(".nv-point.hover").classed("hover",!1)}),null},this.highlightPoint=function(b,c,d){a.dom.write(function(){l.select(" .nv-series-"+b+" .nv-point-"+c).classed("hover",d)})}},L.on("elementMouseover.point",function(a){w&&b._calls.highlightPoint(a.seriesIndex,a.pointIndex,!0)}),L.on("elementMouseout.point",function(a){w&&b._calls.highlightPoint(a.seriesIndex,a.pointIndex,!1)}),b._options=Object.create({},{width:{get:function(){return h},set:function(a){h=a}},height:{get:function(){return i},set:function(a){i=a}},xScale:{get:function(){return m},set:function(a){m=a}},yScale:{get:function(){return n},set:function(a){n=a}},pointScale:{get:function(){return o},set:function(a){o=a}},xDomain:{get:function(){return E},set:function(a){E=a}},yDomain:{get:function(){return F},set:function(a){F=a}},pointDomain:{get:function(){return I},set:function(a){I=a}},xRange:{get:function(){return G},set:function(a){G=a}},yRange:{get:function(){return H},set:function(a){H=a}},pointRange:{get:function(){return J},set:function(a){J=a}},forceX:{get:function(){return t},set:function(a){t=a}},forceY:{get:function(){return u},set:function(a){u=a}},forcePoint:{get:function(){return v},set:function(a){v=a}},interactive:{get:function(){return w},set:function(a){w=a}},pointActive:{get:function(){return x},set:function(a){x=a}},padDataOuter:{get:function(){return z},set:function(a){z=a}},padData:{get:function(){return y},set:function(a){y=a}},clipEdge:{get:function(){return A},set:function(a){A=a}},clipVoronoi:{get:function(){return B},set:function(a){B=a}},clipRadius:{get:function(){return D},set:function(a){D=a}},showVoronoi:{get:function(){return C},set:function(a){C=a}},id:{get:function(){return k},set:function(a){k=a}},x:{get:function(){return p},set:function(a){p=d3.functor(a)}},y:{get:function(){return q},set:function(a){q=d3.functor(a)}},pointSize:{get:function(){return r},set:function(a){r=d3.functor(a)}},pointShape:{get:function(){return s},set:function(a){s=d3.functor(a)}},margin:{get:function(){return g},set:function(a){g.top=void 0!==a.top?a.top:g.top,g.right=void 0!==a.right?a.right:g.right,g.bottom=void 0!==a.bottom?a.bottom:g.bottom,g.left=void 0!==a.left?a.left:g.left}},duration:{get:function(){return N},set:function(a){N=a,P.reset(N)}},color:{get:function(){return j},set:function(b){j=a.utils.getColor(b)}},useVoronoi:{get:function(){return M},set:function(a){M=a,M===!1&&(B=!1)}}}),a.utils.initOptions(b),b},a.models.scatterChart=function(){"use strict";function b(z){return D.reset(),D.models(c),t&&D.models(d),u&&D.models(e),q&&D.models(g),r&&D.models(h),z.each(function(z){m=d3.select(this),a.utils.initSVG(m);var G=a.utils.availableWidth(k,m,j),H=a.utils.availableHeight(l,m,j);if(b.update=function(){0===A?m.call(b):m.transition().duration(A).call(b)},b.container=this,w.setter(F(z),b.update).getter(E(z)).update(),w.disabled=z.map(function(a){return!!a.disabled}),!x){var I;x={};for(I in w)x[I]=w[I]instanceof Array?w[I].slice(0):w[I]}if(!(z&&z.length&&z.filter(function(a){return a.values.length}).length))return a.utils.noData(b,m),D.renderEnd("scatter immediate"),b;m.selectAll(".nv-noData").remove(),o=c.xScale(),p=c.yScale();var J=m.selectAll("g.nv-wrap.nv-scatterChart").data([z]),K=J.enter().append("g").attr("class","nvd3 nv-wrap nv-scatterChart nv-chart-"+c.id()),L=K.append("g"),M=J.select("g");if(L.append("rect").attr("class","nvd3 nv-background").style("pointer-events","none"),L.append("g").attr("class","nv-x nv-axis"),L.append("g").attr("class","nv-y nv-axis"),L.append("g").attr("class","nv-scatterWrap"),L.append("g").attr("class","nv-regressionLinesWrap"),L.append("g").attr("class","nv-distWrap"),L.append("g").attr("class","nv-legendWrap"),v&&M.select(".nv-y.nv-axis").attr("transform","translate("+G+",0)"),s){var N=G;f.width(N),J.select(".nv-legendWrap").datum(z).call(f),j.top!=f.height()&&(j.top=f.height(),H=a.utils.availableHeight(l,m,j)),J.select(".nv-legendWrap").attr("transform","translate(0,"+-j.top+")")}J.attr("transform","translate("+j.left+","+j.top+")"),c.width(G).height(H).color(z.map(function(a,b){return a.color=a.color||n(a,b),a.color}).filter(function(a,b){return!z[b].disabled})),J.select(".nv-scatterWrap").datum(z.filter(function(a){return!a.disabled})).call(c),J.select(".nv-regressionLinesWrap").attr("clip-path","url(#nv-edge-clip-"+c.id()+")");var O=J.select(".nv-regressionLinesWrap").selectAll(".nv-regLines").data(function(a){return a});O.enter().append("g").attr("class","nv-regLines");var P=O.selectAll(".nv-regLine").data(function(a){return[a]});P.enter().append("line").attr("class","nv-regLine").style("stroke-opacity",0),P.filter(function(a){return a.intercept&&a.slope}).watchTransition(D,"scatterPlusLineChart: regline").attr("x1",o.range()[0]).attr("x2",o.range()[1]).attr("y1",function(a){return p(o.domain()[0]*a.slope+a.intercept)}).attr("y2",function(a){return p(o.domain()[1]*a.slope+a.intercept)}).style("stroke",function(a,b,c){return n(a,c)}).style("stroke-opacity",function(a){return a.disabled||"undefined"==typeof a.slope||"undefined"==typeof a.intercept?0:1}),t&&(d.scale(o)._ticks(a.utils.calcTicksX(G/100,z)).tickSize(-H,0),M.select(".nv-x.nv-axis").attr("transform","translate(0,"+p.range()[0]+")").call(d)),u&&(e.scale(p)._ticks(a.utils.calcTicksY(H/36,z)).tickSize(-G,0),M.select(".nv-y.nv-axis").call(e)),q&&(g.getData(c.x()).scale(o).width(G).color(z.map(function(a,b){return a.color||n(a,b)}).filter(function(a,b){return!z[b].disabled})),L.select(".nv-distWrap").append("g").attr("class","nv-distributionX"),M.select(".nv-distributionX").attr("transform","translate(0,"+p.range()[0]+")").datum(z.filter(function(a){return!a.disabled})).call(g)),r&&(h.getData(c.y()).scale(p).width(H).color(z.map(function(a,b){return a.color||n(a,b)}).filter(function(a,b){return!z[b].disabled})),L.select(".nv-distWrap").append("g").attr("class","nv-distributionY"),M.select(".nv-distributionY").attr("transform","translate("+(v?G:-h.size())+",0)").datum(z.filter(function(a){return!a.disabled})).call(h)),f.dispatch.on("stateChange",function(a){for(var c in a)w[c]=a[c];y.stateChange(w),b.update()}),y.on("changeState",function(a){"undefined"!=typeof a.disabled&&(z.forEach(function(b,c){b.disabled=a.disabled[c]}),w.disabled=a.disabled),b.update()}),c.dispatch.on("elementMouseout.tooltip",function(a){i.hidden(!0),m.select(".nv-chart-"+c.id()+" .nv-series-"+a.seriesIndex+" .nv-distx-"+a.pointIndex).attr("y1",0),m.select(".nv-chart-"+c.id()+" .nv-series-"+a.seriesIndex+" .nv-disty-"+a.pointIndex).attr("x2",h.size())}),c.dispatch.on("elementMouseover.tooltip",function(a){m.select(".nv-series-"+a.seriesIndex+" .nv-distx-"+a.pointIndex).attr("y1",a.pos.top-H-j.top),m.select(".nv-series-"+a.seriesIndex+" .nv-disty-"+a.pointIndex).attr("x2",a.pos.left+g.size()-j.left),i.position(a.pos).data(a).hidden(!1)}),B=o.copy(),C=p.copy()}),D.renderEnd("scatter with line immediate"),b}var c=a.models.scatter(),d=a.models.axis(),e=a.models.axis(),f=a.models.legend(),g=a.models.distribution(),h=a.models.distribution(),i=a.models.tooltip(),j={top:30,right:20,bottom:50,left:75},k=null,l=null,m=null,n=a.utils.defaultColor(),o=c.xScale(),p=c.yScale(),q=!1,r=!1,s=!0,t=!0,u=!0,v=!1,w=a.utils.state(),x=null,y=d3.dispatch("stateChange","changeState","renderEnd"),z=null,A=250;c.xScale(o).yScale(p),d.orient("bottom").tickPadding(10),e.orient(v?"right":"left").tickPadding(10),g.axis("x"),h.axis("y"),i.headerFormatter(function(a,b){return d.tickFormat()(a,b)}).valueFormatter(function(a,b){return e.tickFormat()(a,b)});var B,C,D=a.utils.renderWatch(y,A),E=function(a){return function(){return{active:a.map(function(a){return!a.disabled})}}},F=function(a){return function(b){void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}};return b.dispatch=y,b.scatter=c,b.legend=f,b.xAxis=d,b.yAxis=e,b.distX=g,b.distY=h,b.tooltip=i,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return k},set:function(a){k=a}},height:{get:function(){return l},set:function(a){l=a}},container:{get:function(){return m},set:function(a){m=a}},showDistX:{get:function(){return q},set:function(a){q=a}},showDistY:{get:function(){return r},set:function(a){r=a}},showLegend:{get:function(){return s},set:function(a){s=a}},showXAxis:{get:function(){return t},set:function(a){t=a}},showYAxis:{get:function(){return u},set:function(a){u=a}},defaultState:{get:function(){return x},set:function(a){x=a}},noData:{get:function(){return z},set:function(a){z=a}},duration:{get:function(){return A},set:function(a){A=a}},tooltips:{get:function(){return i.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),i.enabled(!!b)
}},tooltipContent:{get:function(){return i.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),i.contentGenerator(b)}},tooltipXContent:{get:function(){return i.contentGenerator()},set:function(){a.deprecated("tooltipContent","This option is removed, put values into main tooltip.")}},tooltipYContent:{get:function(){return i.contentGenerator()},set:function(){a.deprecated("tooltipContent","This option is removed, put values into main tooltip.")}},margin:{get:function(){return j},set:function(a){j.top=void 0!==a.top?a.top:j.top,j.right=void 0!==a.right?a.right:j.right,j.bottom=void 0!==a.bottom?a.bottom:j.bottom,j.left=void 0!==a.left?a.left:j.left}},rightAlignYAxis:{get:function(){return v},set:function(a){v=a,e.orient(a?"right":"left")}},color:{get:function(){return n},set:function(b){n=a.utils.getColor(b),f.color(n),g.color(n),h.color(n)}}}),a.utils.inheritOptions(b,c),a.utils.initOptions(b),b},a.models.sparkline=function(){"use strict";function b(k){return k.each(function(b){var k=h-g.left-g.right,q=i-g.top-g.bottom;j=d3.select(this),a.utils.initSVG(j),l.domain(c||d3.extent(b,n)).range(e||[0,k]),m.domain(d||d3.extent(b,o)).range(f||[q,0]);{var r=j.selectAll("g.nv-wrap.nv-sparkline").data([b]),s=r.enter().append("g").attr("class","nvd3 nv-wrap nv-sparkline");s.append("g"),r.select("g")}r.attr("transform","translate("+g.left+","+g.top+")");var t=r.selectAll("path").data(function(a){return[a]});t.enter().append("path"),t.exit().remove(),t.style("stroke",function(a,b){return a.color||p(a,b)}).attr("d",d3.svg.line().x(function(a,b){return l(n(a,b))}).y(function(a,b){return m(o(a,b))}));var u=r.selectAll("circle.nv-point").data(function(a){function b(b){if(-1!=b){var c=a[b];return c.pointIndex=b,c}return null}var c=a.map(function(a,b){return o(a,b)}),d=b(c.lastIndexOf(m.domain()[1])),e=b(c.indexOf(m.domain()[0])),f=b(c.length-1);return[e,d,f].filter(function(a){return null!=a})});u.enter().append("circle"),u.exit().remove(),u.attr("cx",function(a){return l(n(a,a.pointIndex))}).attr("cy",function(a){return m(o(a,a.pointIndex))}).attr("r",2).attr("class",function(a){return n(a,a.pointIndex)==l.domain()[1]?"nv-point nv-currentValue":o(a,a.pointIndex)==m.domain()[0]?"nv-point nv-minValue":"nv-point nv-maxValue"})}),b}var c,d,e,f,g={top:2,right:0,bottom:2,left:0},h=400,i=32,j=null,k=!0,l=d3.scale.linear(),m=d3.scale.linear(),n=function(a){return a.x},o=function(a){return a.y},p=a.utils.getColor(["#000"]);return b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return h},set:function(a){h=a}},height:{get:function(){return i},set:function(a){i=a}},xDomain:{get:function(){return c},set:function(a){c=a}},yDomain:{get:function(){return d},set:function(a){d=a}},xRange:{get:function(){return e},set:function(a){e=a}},yRange:{get:function(){return f},set:function(a){f=a}},xScale:{get:function(){return l},set:function(a){l=a}},yScale:{get:function(){return m},set:function(a){m=a}},animate:{get:function(){return k},set:function(a){k=a}},x:{get:function(){return n},set:function(a){n=d3.functor(a)}},y:{get:function(){return o},set:function(a){o=d3.functor(a)}},margin:{get:function(){return g},set:function(a){g.top=void 0!==a.top?a.top:g.top,g.right=void 0!==a.right?a.right:g.right,g.bottom=void 0!==a.bottom?a.bottom:g.bottom,g.left=void 0!==a.left?a.left:g.left}},color:{get:function(){return p},set:function(b){p=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.sparklinePlus=function(){"use strict";function b(p){return p.each(function(p){function q(){if(!j){var a=z.selectAll(".nv-hoverValue").data(i),b=a.enter().append("g").attr("class","nv-hoverValue").style("stroke-opacity",0).style("fill-opacity",0);a.exit().transition().duration(250).style("stroke-opacity",0).style("fill-opacity",0).remove(),a.attr("transform",function(a){return"translate("+c(e.x()(p[a],a))+",0)"}).transition().duration(250).style("stroke-opacity",1).style("fill-opacity",1),i.length&&(b.append("line").attr("x1",0).attr("y1",-f.top).attr("x2",0).attr("y2",u),b.append("text").attr("class","nv-xValue").attr("x",-6).attr("y",-f.top).attr("text-anchor","end").attr("dy",".9em"),z.select(".nv-hoverValue .nv-xValue").text(k(e.x()(p[i[0]],i[0]))),b.append("text").attr("class","nv-yValue").attr("x",6).attr("y",-f.top).attr("text-anchor","start").attr("dy",".9em"),z.select(".nv-hoverValue .nv-yValue").text(l(e.y()(p[i[0]],i[0]))))}}function r(){function a(a,b){for(var c=Math.abs(e.x()(a[0],0)-b),d=0,f=0;f<a.length;f++)Math.abs(e.x()(a[f],f)-b)<c&&(c=Math.abs(e.x()(a[f],f)-b),d=f);return d}if(!j){var b=d3.mouse(this)[0]-f.left;i=[a(p,Math.round(c.invert(b)))],q()}}var s=d3.select(this);a.utils.initSVG(s);var t=a.utils.availableWidth(g,s,f),u=a.utils.availableHeight(h,s,f);if(b.update=function(){s.call(b)},b.container=this,!p||!p.length)return a.utils.noData(b,s),b;s.selectAll(".nv-noData").remove();var v=e.y()(p[p.length-1],p.length-1);c=e.xScale(),d=e.yScale();var w=s.selectAll("g.nv-wrap.nv-sparklineplus").data([p]),x=w.enter().append("g").attr("class","nvd3 nv-wrap nv-sparklineplus"),y=x.append("g"),z=w.select("g");y.append("g").attr("class","nv-sparklineWrap"),y.append("g").attr("class","nv-valueWrap"),y.append("g").attr("class","nv-hoverArea"),w.attr("transform","translate("+f.left+","+f.top+")");var A=z.select(".nv-sparklineWrap");if(e.width(t).height(u),A.call(e),m){var B=z.select(".nv-valueWrap"),C=B.selectAll(".nv-currentValue").data([v]);C.enter().append("text").attr("class","nv-currentValue").attr("dx",o?-8:8).attr("dy",".9em").style("text-anchor",o?"end":"start"),C.attr("x",t+(o?f.right:0)).attr("y",n?function(a){return d(a)}:0).style("fill",e.color()(p[p.length-1],p.length-1)).text(l(v))}y.select(".nv-hoverArea").append("rect").on("mousemove",r).on("click",function(){j=!j}).on("mouseout",function(){i=[],q()}),z.select(".nv-hoverArea rect").attr("transform",function(){return"translate("+-f.left+","+-f.top+")"}).attr("width",t+f.left+f.right).attr("height",u+f.top)}),b}var c,d,e=a.models.sparkline(),f={top:15,right:100,bottom:10,left:50},g=null,h=null,i=[],j=!1,k=d3.format(",r"),l=d3.format(",.2f"),m=!0,n=!0,o=!1,p=null;return b.sparkline=e,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return g},set:function(a){g=a}},height:{get:function(){return h},set:function(a){h=a}},xTickFormat:{get:function(){return k},set:function(a){k=a}},yTickFormat:{get:function(){return l},set:function(a){l=a}},showLastValue:{get:function(){return m},set:function(a){m=a}},alignValue:{get:function(){return n},set:function(a){n=a}},rightAlignValue:{get:function(){return o},set:function(a){o=a}},noData:{get:function(){return p},set:function(a){p=a}},margin:{get:function(){return f},set:function(a){f.top=void 0!==a.top?a.top:f.top,f.right=void 0!==a.right?a.right:f.right,f.bottom=void 0!==a.bottom?a.bottom:f.bottom,f.left=void 0!==a.left?a.left:f.left}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.stackedArea=function(){"use strict";function b(m){return u.reset(),u.models(r),m.each(function(m){var s=f-e.left-e.right,v=g-e.top-e.bottom;j=d3.select(this),a.utils.initSVG(j),c=r.xScale(),d=r.yScale();var w=m;m.forEach(function(a,b){a.seriesIndex=b,a.values=a.values.map(function(a,c){return a.index=c,a.seriesIndex=b,a})});var x=m.filter(function(a){return!a.disabled});m=d3.layout.stack().order(o).offset(n).values(function(a){return a.values}).x(k).y(l).out(function(a,b,c){a.display={y:c,y0:b}})(x);var y=j.selectAll("g.nv-wrap.nv-stackedarea").data([m]),z=y.enter().append("g").attr("class","nvd3 nv-wrap nv-stackedarea"),A=z.append("defs"),B=z.append("g"),C=y.select("g");B.append("g").attr("class","nv-areaWrap"),B.append("g").attr("class","nv-scatterWrap"),y.attr("transform","translate("+e.left+","+e.top+")"),0==r.forceY().length&&r.forceY().push(0),r.width(s).height(v).x(k).y(function(a){return a.display.y+a.display.y0}).forceY([0]).color(m.map(function(a){return a.color||h(a,a.seriesIndex)}));var D=C.select(".nv-scatterWrap").datum(m);D.call(r),A.append("clipPath").attr("id","nv-edge-clip-"+i).append("rect"),y.select("#nv-edge-clip-"+i+" rect").attr("width",s).attr("height",v),C.attr("clip-path",q?"url(#nv-edge-clip-"+i+")":"");var E=d3.svg.area().x(function(a,b){return c(k(a,b))}).y0(function(a){return d(a.display.y0)}).y1(function(a){return d(a.display.y+a.display.y0)}).interpolate(p),F=d3.svg.area().x(function(a,b){return c(k(a,b))}).y0(function(a){return d(a.display.y0)}).y1(function(a){return d(a.display.y0)}),G=C.select(".nv-areaWrap").selectAll("path.nv-area").data(function(a){return a});G.enter().append("path").attr("class",function(a,b){return"nv-area nv-area-"+b}).attr("d",function(a){return F(a.values,a.seriesIndex)}).on("mouseover",function(a){d3.select(this).classed("hover",!0),t.areaMouseover({point:a,series:a.key,pos:[d3.event.pageX,d3.event.pageY],seriesIndex:a.seriesIndex})}).on("mouseout",function(a){d3.select(this).classed("hover",!1),t.areaMouseout({point:a,series:a.key,pos:[d3.event.pageX,d3.event.pageY],seriesIndex:a.seriesIndex})}).on("click",function(a){d3.select(this).classed("hover",!1),t.areaClick({point:a,series:a.key,pos:[d3.event.pageX,d3.event.pageY],seriesIndex:a.seriesIndex})}),G.exit().remove(),G.style("fill",function(a){return a.color||h(a,a.seriesIndex)}).style("stroke",function(a){return a.color||h(a,a.seriesIndex)}),G.watchTransition(u,"stackedArea path").attr("d",function(a,b){return E(a.values,b)}),r.dispatch.on("elementMouseover.area",function(a){C.select(".nv-chart-"+i+" .nv-area-"+a.seriesIndex).classed("hover",!0)}),r.dispatch.on("elementMouseout.area",function(a){C.select(".nv-chart-"+i+" .nv-area-"+a.seriesIndex).classed("hover",!1)}),b.d3_stackedOffset_stackPercent=function(a){var b,c,d,e=a.length,f=a[0].length,g=[];for(c=0;f>c;++c){for(b=0,d=0;b<w.length;b++)d+=l(w[b].values[c]);if(d)for(b=0;e>b;b++)a[b][c][1]/=d;else for(b=0;e>b;b++)a[b][c][1]=0}for(c=0;f>c;++c)g[c]=0;return g}}),u.renderEnd("stackedArea immediate"),b}var c,d,e={top:0,right:0,bottom:0,left:0},f=960,g=500,h=a.utils.defaultColor(),i=Math.floor(1e5*Math.random()),j=null,k=function(a){return a.x},l=function(a){return a.y},m="stack",n="zero",o="default",p="linear",q=!1,r=a.models.scatter(),s=250,t=d3.dispatch("areaClick","areaMouseover","areaMouseout","renderEnd","elementClick","elementMouseover","elementMouseout");r.pointSize(2.2).pointDomain([2.2,2.2]);var u=a.utils.renderWatch(t,s);return b.dispatch=t,b.scatter=r,r.dispatch.on("elementClick",function(){t.elementClick.apply(this,arguments)}),r.dispatch.on("elementMouseover",function(){t.elementMouseover.apply(this,arguments)}),r.dispatch.on("elementMouseout",function(){t.elementMouseout.apply(this,arguments)}),b.interpolate=function(a){return arguments.length?(p=a,b):p},b.duration=function(a){return arguments.length?(s=a,u.reset(s),r.duration(s),b):s},b.dispatch=t,b.scatter=r,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return f},set:function(a){f=a}},height:{get:function(){return g},set:function(a){g=a}},clipEdge:{get:function(){return q},set:function(a){q=a}},offset:{get:function(){return n},set:function(a){n=a}},order:{get:function(){return o},set:function(a){o=a}},interpolate:{get:function(){return p},set:function(a){p=a}},x:{get:function(){return k},set:function(a){k=d3.functor(a)}},y:{get:function(){return l},set:function(a){l=d3.functor(a)}},margin:{get:function(){return e},set:function(a){e.top=void 0!==a.top?a.top:e.top,e.right=void 0!==a.right?a.right:e.right,e.bottom=void 0!==a.bottom?a.bottom:e.bottom,e.left=void 0!==a.left?a.left:e.left}},color:{get:function(){return h},set:function(b){h=a.utils.getColor(b)}},style:{get:function(){return m},set:function(a){switch(m=a){case"stack":b.offset("zero"),b.order("default");break;case"stream":b.offset("wiggle"),b.order("inside-out");break;case"stream-center":b.offset("silhouette"),b.order("inside-out");break;case"expand":b.offset("expand"),b.order("default");break;case"stack_percent":b.offset(b.d3_stackedOffset_stackPercent),b.order("default")}}},duration:{get:function(){return s},set:function(a){s=a,u.reset(s),r.duration(s)}}}),a.utils.inheritOptions(b,r),a.utils.initOptions(b),b},a.models.stackedAreaChart=function(){"use strict";function b(k){return F.reset(),F.models(e),r&&F.models(f),s&&F.models(g),k.each(function(k){var x=d3.select(this),F=this;a.utils.initSVG(x);var K=a.utils.availableWidth(m,x,l),L=a.utils.availableHeight(n,x,l);if(b.update=function(){x.transition().duration(C).call(b)},b.container=this,v.setter(I(k),b.update).getter(H(k)).update(),v.disabled=k.map(function(a){return!!a.disabled}),!w){var M;w={};for(M in v)w[M]=v[M]instanceof Array?v[M].slice(0):v[M]}if(!(k&&k.length&&k.filter(function(a){return a.values.length}).length))return a.utils.noData(b,x),b;x.selectAll(".nv-noData").remove(),c=e.xScale(),d=e.yScale();var N=x.selectAll("g.nv-wrap.nv-stackedAreaChart").data([k]),O=N.enter().append("g").attr("class","nvd3 nv-wrap nv-stackedAreaChart").append("g"),P=N.select("g");if(O.append("rect").style("opacity",0),O.append("g").attr("class","nv-x nv-axis"),O.append("g").attr("class","nv-y nv-axis"),O.append("g").attr("class","nv-stackedWrap"),O.append("g").attr("class","nv-legendWrap"),O.append("g").attr("class","nv-controlsWrap"),O.append("g").attr("class","nv-interactive"),P.select("rect").attr("width",K).attr("height",L),q){var Q=p?K-z:K;h.width(Q),P.select(".nv-legendWrap").datum(k).call(h),l.top!=h.height()&&(l.top=h.height(),L=a.utils.availableHeight(n,x,l)),P.select(".nv-legendWrap").attr("transform","translate("+(K-Q)+","+-l.top+")")}if(p){var R=[{key:B.stacked||"Stacked",metaKey:"Stacked",disabled:"stack"!=e.style(),style:"stack"},{key:B.stream||"Stream",metaKey:"Stream",disabled:"stream"!=e.style(),style:"stream"},{key:B.expanded||"Expanded",metaKey:"Expanded",disabled:"expand"!=e.style(),style:"expand"},{key:B.stack_percent||"Stack %",metaKey:"Stack_Percent",disabled:"stack_percent"!=e.style(),style:"stack_percent"}];z=A.length/3*260,R=R.filter(function(a){return-1!==A.indexOf(a.metaKey)}),i.width(z).color(["#444","#444","#444"]),P.select(".nv-controlsWrap").datum(R).call(i),l.top!=Math.max(i.height(),h.height())&&(l.top=Math.max(i.height(),h.height()),L=a.utils.availableHeight(n,x,l)),P.select(".nv-controlsWrap").attr("transform","translate(0,"+-l.top+")")}N.attr("transform","translate("+l.left+","+l.top+")"),t&&P.select(".nv-y.nv-axis").attr("transform","translate("+K+",0)"),u&&(j.width(K).height(L).margin({left:l.left,top:l.top}).svgContainer(x).xScale(c),N.select(".nv-interactive").call(j)),e.width(K).height(L);var S=P.select(".nv-stackedWrap").datum(k);if(S.transition().call(e),r&&(f.scale(c)._ticks(a.utils.calcTicksX(K/100,k)).tickSize(-L,0),P.select(".nv-x.nv-axis").attr("transform","translate(0,"+L+")"),P.select(".nv-x.nv-axis").transition().duration(0).call(f)),s){var T;if(T="wiggle"===e.offset()?0:a.utils.calcTicksY(L/36,k),g.scale(d)._ticks(T).tickSize(-K,0),"expand"===e.style()||"stack_percent"===e.style()){var U=g.tickFormat();D&&U===J||(D=U),g.tickFormat(J)}else D&&(g.tickFormat(D),D=null);P.select(".nv-y.nv-axis").transition().duration(0).call(g)}e.dispatch.on("areaClick.toggle",function(a){k.forEach(1===k.filter(function(a){return!a.disabled}).length?function(a){a.disabled=!1}:function(b,c){b.disabled=c!=a.seriesIndex}),v.disabled=k.map(function(a){return!!a.disabled}),y.stateChange(v),b.update()}),h.dispatch.on("stateChange",function(a){for(var c in a)v[c]=a[c];y.stateChange(v),b.update()}),i.dispatch.on("legendClick",function(a){a.disabled&&(R=R.map(function(a){return a.disabled=!0,a}),a.disabled=!1,e.style(a.style),v.style=e.style(),y.stateChange(v),b.update())}),j.dispatch.on("elementMousemove",function(c){e.clearHighlights();var d,g,h,i=[];if(k.filter(function(a,b){return a.seriesIndex=b,!a.disabled}).forEach(function(f,j){g=a.interactiveBisect(f.values,c.pointXValue,b.x());var k=f.values[g],l=b.y()(k,g);if(null!=l&&e.highlightPoint(j,g,!0),"undefined"!=typeof k){"undefined"==typeof d&&(d=k),"undefined"==typeof h&&(h=b.xScale()(b.x()(k,g)));var m="expand"==e.style()?k.display.y:b.y()(k,g);i.push({key:f.key,value:m,color:o(f,f.seriesIndex),stackedValue:k.display})}}),i.reverse(),i.length>2){var m=b.yScale().invert(c.mouseY),n=null;i.forEach(function(a,b){m=Math.abs(m);var c=Math.abs(a.stackedValue.y0),d=Math.abs(a.stackedValue.y);return m>=c&&d+c>=m?void(n=b):void 0}),null!=n&&(i[n].highlight=!0)}var p=f.tickFormat()(b.x()(d,g)),q=j.tooltip.valueFormatter();"expand"===e.style()||"stack_percent"===e.style()?(E||(E=q),q=d3.format(".1%")):E&&(q=E,E=null),j.tooltip.position({left:h+l.left,top:c.mouseY+l.top}).chartContainer(F.parentNode).valueFormatter(q).data({value:p,series:i})(),j.renderGuideLine(h)}),j.dispatch.on("elementMouseout",function(){e.clearHighlights()}),y.on("changeState",function(a){"undefined"!=typeof a.disabled&&k.length===a.disabled.length&&(k.forEach(function(b,c){b.disabled=a.disabled[c]}),v.disabled=a.disabled),"undefined"!=typeof a.style&&(e.style(a.style),G=a.style),b.update()})}),F.renderEnd("stacked Area chart immediate"),b}var c,d,e=a.models.stackedArea(),f=a.models.axis(),g=a.models.axis(),h=a.models.legend(),i=a.models.legend(),j=a.interactiveGuideline(),k=a.models.tooltip(),l={top:30,right:25,bottom:50,left:60},m=null,n=null,o=a.utils.defaultColor(),p=!0,q=!0,r=!0,s=!0,t=!1,u=!1,v=a.utils.state(),w=null,x=null,y=d3.dispatch("stateChange","changeState","renderEnd"),z=250,A=["Stacked","Stream","Expanded"],B={},C=250;v.style=e.style(),f.orient("bottom").tickPadding(7),g.orient(t?"right":"left"),k.headerFormatter(function(a,b){return f.tickFormat()(a,b)}).valueFormatter(function(a,b){return g.tickFormat()(a,b)}),j.tooltip.headerFormatter(function(a,b){return f.tickFormat()(a,b)}).valueFormatter(function(a,b){return g.tickFormat()(a,b)});var D=null,E=null;i.updateState(!1);var F=a.utils.renderWatch(y),G=e.style(),H=function(a){return function(){return{active:a.map(function(a){return!a.disabled}),style:e.style()}}},I=function(a){return function(b){void 0!==b.style&&(G=b.style),void 0!==b.active&&a.forEach(function(a,c){a.disabled=!b.active[c]})}},J=d3.format("%");return e.dispatch.on("elementMouseover.tooltip",function(a){a.point.x=e.x()(a.point),a.point.y=e.y()(a.point),k.data(a).position(a.pos).hidden(!1)}),e.dispatch.on("elementMouseout.tooltip",function(){k.hidden(!0)}),b.dispatch=y,b.stacked=e,b.legend=h,b.controls=i,b.xAxis=f,b.yAxis=g,b.interactiveLayer=j,b.tooltip=k,b.dispatch=y,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return m},set:function(a){m=a}},height:{get:function(){return n},set:function(a){n=a}},showLegend:{get:function(){return q},set:function(a){q=a}},showXAxis:{get:function(){return r},set:function(a){r=a}},showYAxis:{get:function(){return s},set:function(a){s=a}},defaultState:{get:function(){return w},set:function(a){w=a}},noData:{get:function(){return x},set:function(a){x=a}},showControls:{get:function(){return p},set:function(a){p=a}},controlLabels:{get:function(){return B},set:function(a){B=a}},controlOptions:{get:function(){return A},set:function(a){A=a}},tooltips:{get:function(){return k.enabled()},set:function(b){a.deprecated("tooltips","use chart.tooltip.enabled() instead"),k.enabled(!!b)}},tooltipContent:{get:function(){return k.contentGenerator()},set:function(b){a.deprecated("tooltipContent","use chart.tooltip.contentGenerator() instead"),k.contentGenerator(b)}},margin:{get:function(){return l},set:function(a){l.top=void 0!==a.top?a.top:l.top,l.right=void 0!==a.right?a.right:l.right,l.bottom=void 0!==a.bottom?a.bottom:l.bottom,l.left=void 0!==a.left?a.left:l.left}},duration:{get:function(){return C},set:function(a){C=a,F.reset(C),e.duration(C),f.duration(C),g.duration(C)}},color:{get:function(){return o},set:function(b){o=a.utils.getColor(b),h.color(o),e.color(o)}},rightAlignYAxis:{get:function(){return t},set:function(a){t=a,g.orient(t?"right":"left")}},useInteractiveGuideline:{get:function(){return u},set:function(a){u=!!a,b.interactive(!a),b.useVoronoi(!a),e.scatter.interactive(!a)}}}),a.utils.inheritOptions(b,e),a.utils.initOptions(b),b},a.models.sunburst=function(){"use strict";function b(u){return t.reset(),u.each(function(b){function t(a){a.x0=a.x,a.dx0=a.dx}function u(a){var b=d3.interpolate(p.domain(),[a.x,a.x+a.dx]),c=d3.interpolate(q.domain(),[a.y,1]),d=d3.interpolate(q.range(),[a.y?20:0,y]);return function(a,e){return e?function(){return s(a)}:function(e){return p.domain(b(e)),q.domain(c(e)).range(d(e)),s(a)}}}l=d3.select(this);var v,w=a.utils.availableWidth(g,l,f),x=a.utils.availableHeight(h,l,f),y=Math.min(w,x)/2;a.utils.initSVG(l);var z=l.selectAll(".nv-wrap.nv-sunburst").data(b),A=z.enter().append("g").attr("class","nvd3 nv-wrap nv-sunburst nv-chart-"+k),B=A.selectAll("nv-sunburst");z.attr("transform","translate("+w/2+","+x/2+")"),l.on("click",function(a,b){o.chartClick({data:a,index:b,pos:d3.event,id:k})}),q.range([0,y]),c=c||b,e=b[0],r.value(j[i]||j.count),v=B.data(r.nodes).enter().append("path").attr("d",s).style("fill",function(a){return m((a.children?a:a.parent).name)}).style("stroke","#FFF").on("click",function(a){d!==c&&c!==a&&(d=c),c=a,v.transition().duration(n).attrTween("d",u(a))}).each(t).on("dblclick",function(a){d.parent==a&&v.transition().duration(n).attrTween("d",u(e))}).each(t).on("mouseover",function(a){d3.select(this).classed("hover",!0).style("opacity",.8),o.elementMouseover({data:a,color:d3.select(this).style("fill")})}).on("mouseout",function(a){d3.select(this).classed("hover",!1).style("opacity",1),o.elementMouseout({data:a})}).on("mousemove",function(a){o.elementMousemove({data:a})})}),t.renderEnd("sunburst immediate"),b}var c,d,e,f={top:0,right:0,bottom:0,left:0},g=null,h=null,i="count",j={count:function(){return 1},size:function(a){return a.size}},k=Math.floor(1e4*Math.random()),l=null,m=a.utils.defaultColor(),n=500,o=d3.dispatch("chartClick","elementClick","elementDblClick","elementMousemove","elementMouseover","elementMouseout","renderEnd"),p=d3.scale.linear().range([0,2*Math.PI]),q=d3.scale.sqrt(),r=d3.layout.partition().sort(null).value(function(){return 1}),s=d3.svg.arc().startAngle(function(a){return Math.max(0,Math.min(2*Math.PI,p(a.x)))}).endAngle(function(a){return Math.max(0,Math.min(2*Math.PI,p(a.x+a.dx)))}).innerRadius(function(a){return Math.max(0,q(a.y))}).outerRadius(function(a){return Math.max(0,q(a.y+a.dy))}),t=a.utils.renderWatch(o);return b.dispatch=o,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{width:{get:function(){return g},set:function(a){g=a}},height:{get:function(){return h},set:function(a){h=a}},mode:{get:function(){return i},set:function(a){i=a}},id:{get:function(){return k},set:function(a){k=a}},duration:{get:function(){return n},set:function(a){n=a}},margin:{get:function(){return f},set:function(a){f.top=void 0!=a.top?a.top:f.top,f.right=void 0!=a.right?a.right:f.right,f.bottom=void 0!=a.bottom?a.bottom:f.bottom,f.left=void 0!=a.left?a.left:f.left}},color:{get:function(){return m},set:function(b){m=a.utils.getColor(b)}}}),a.utils.initOptions(b),b},a.models.sunburstChart=function(){"use strict";function b(d){return m.reset(),m.models(c),d.each(function(d){var h=d3.select(this);a.utils.initSVG(h);var i=a.utils.availableWidth(f,h,e),j=a.utils.availableHeight(g,h,e);if(b.update=function(){0===k?h.call(b):h.transition().duration(k).call(b)},b.container=this,!d||!d.length)return a.utils.noData(b,h),b;h.selectAll(".nv-noData").remove();var l=h.selectAll("g.nv-wrap.nv-sunburstChart").data(d),m=l.enter().append("g").attr("class","nvd3 nv-wrap nv-sunburstChart").append("g"),n=l.select("g");m.append("g").attr("class","nv-sunburstWrap"),l.attr("transform","translate("+e.left+","+e.top+")"),c.width(i).height(j);var o=n.select(".nv-sunburstWrap").datum(d);d3.transition(o).call(c)}),m.renderEnd("sunburstChart immediate"),b}var c=a.models.sunburst(),d=a.models.tooltip(),e={top:30,right:20,bottom:20,left:20},f=null,g=null,h=a.utils.defaultColor(),i=(Math.round(1e5*Math.random()),null),j=null,k=250,l=d3.dispatch("tooltipShow","tooltipHide","stateChange","changeState","renderEnd"),m=a.utils.renderWatch(l);return d.headerEnabled(!1).duration(0).valueFormatter(function(a){return a}),c.dispatch.on("elementMouseover.tooltip",function(a){a.series={key:a.data.name,value:a.data.size,color:a.color},d.data(a).hidden(!1)}),c.dispatch.on("elementMouseout.tooltip",function(){d.hidden(!0)}),c.dispatch.on("elementMousemove.tooltip",function(){d.position({top:d3.event.pageY,left:d3.event.pageX})()}),b.dispatch=l,b.sunburst=c,b.tooltip=d,b.options=a.utils.optionsFunc.bind(b),b._options=Object.create({},{noData:{get:function(){return j},set:function(a){j=a}},defaultState:{get:function(){return i},set:function(a){i=a}},color:{get:function(){return h},set:function(a){h=a,c.color(h)}},duration:{get:function(){return k},set:function(a){k=a,m.reset(k),c.duration(k)}},margin:{get:function(){return e},set:function(a){e.top=void 0!==a.top?a.top:e.top,e.right=void 0!==a.right?a.right:e.right,e.bottom=void 0!==a.bottom?a.bottom:e.bottom,e.left=void 0!==a.left?a.left:e.left}}}),a.utils.inheritOptions(b,c),a.utils.initOptions(b),b},a.version="1.8.1"}();/*
 Copyright (C) Federico Zivolo 2019
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */(function(e,t){'object'==typeof exports&&'undefined'!=typeof module?module.exports=t():'function'==typeof define&&define.amd?define(t):e.Popper=t()})(this,function(){'use strict';function e(e){return e&&'[object Function]'==={}.toString.call(e)}function t(e,t){if(1!==e.nodeType)return[];var o=e.ownerDocument.defaultView,n=o.getComputedStyle(e,null);return t?n[t]:n}function o(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function n(e){if(!e)return document.body;switch(e.nodeName){case'HTML':case'BODY':return e.ownerDocument.body;case'#document':return e.body;}var i=t(e),r=i.overflow,p=i.overflowX,s=i.overflowY;return /(auto|scroll|overlay)/.test(r+s+p)?e:n(o(e))}function r(e){return 11===e?pe:10===e?se:pe||se}function p(e){if(!e)return document.documentElement;for(var o=r(10)?document.body:null,n=e.offsetParent||null;n===o&&e.nextElementSibling;)n=(e=e.nextElementSibling).offsetParent;var i=n&&n.nodeName;return i&&'BODY'!==i&&'HTML'!==i?-1!==['TH','TD','TABLE'].indexOf(n.nodeName)&&'static'===t(n,'position')?p(n):n:e?e.ownerDocument.documentElement:document.documentElement}function s(e){var t=e.nodeName;return'BODY'!==t&&('HTML'===t||p(e.firstElementChild)===e)}function d(e){return null===e.parentNode?e:d(e.parentNode)}function a(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return document.documentElement;var o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,n=o?e:t,i=o?t:e,r=document.createRange();r.setStart(n,0),r.setEnd(i,0);var l=r.commonAncestorContainer;if(e!==l&&t!==l||n.contains(i))return s(l)?l:p(l);var f=d(e);return f.host?a(f.host,t):a(e,d(t).host)}function l(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:'top',o='top'===t?'scrollTop':'scrollLeft',n=e.nodeName;if('BODY'===n||'HTML'===n){var i=e.ownerDocument.documentElement,r=e.ownerDocument.scrollingElement||i;return r[o]}return e[o]}function f(e,t){var o=2<arguments.length&&void 0!==arguments[2]&&arguments[2],n=l(t,'top'),i=l(t,'left'),r=o?-1:1;return e.top+=n*r,e.bottom+=n*r,e.left+=i*r,e.right+=i*r,e}function m(e,t){var o='x'===t?'Left':'Top',n='Left'==o?'Right':'Bottom';return parseFloat(e['border'+o+'Width'],10)+parseFloat(e['border'+n+'Width'],10)}function h(e,t,o,n){return ee(t['offset'+e],t['scroll'+e],o['client'+e],o['offset'+e],o['scroll'+e],r(10)?parseInt(o['offset'+e])+parseInt(n['margin'+('Height'===e?'Top':'Left')])+parseInt(n['margin'+('Height'===e?'Bottom':'Right')]):0)}function c(e){var t=e.body,o=e.documentElement,n=r(10)&&getComputedStyle(o);return{height:h('Height',t,o,n),width:h('Width',t,o,n)}}function g(e){return fe({},e,{right:e.left+e.width,bottom:e.top+e.height})}function u(e){var o={};try{if(r(10)){o=e.getBoundingClientRect();var n=l(e,'top'),i=l(e,'left');o.top+=n,o.left+=i,o.bottom+=n,o.right+=i}else o=e.getBoundingClientRect()}catch(t){}var p={left:o.left,top:o.top,width:o.right-o.left,height:o.bottom-o.top},s='HTML'===e.nodeName?c(e.ownerDocument):{},d=s.width||e.clientWidth||p.right-p.left,a=s.height||e.clientHeight||p.bottom-p.top,f=e.offsetWidth-d,h=e.offsetHeight-a;if(f||h){var u=t(e);f-=m(u,'x'),h-=m(u,'y'),p.width-=f,p.height-=h}return g(p)}function b(e,o){var i=2<arguments.length&&void 0!==arguments[2]&&arguments[2],p=r(10),s='HTML'===o.nodeName,d=u(e),a=u(o),l=n(e),m=t(o),h=parseFloat(m.borderTopWidth,10),c=parseFloat(m.borderLeftWidth,10);i&&s&&(a.top=ee(a.top,0),a.left=ee(a.left,0));var b=g({top:d.top-a.top-h,left:d.left-a.left-c,width:d.width,height:d.height});if(b.marginTop=0,b.marginLeft=0,!p&&s){var w=parseFloat(m.marginTop,10),y=parseFloat(m.marginLeft,10);b.top-=h-w,b.bottom-=h-w,b.left-=c-y,b.right-=c-y,b.marginTop=w,b.marginLeft=y}return(p&&!i?o.contains(l):o===l&&'BODY'!==l.nodeName)&&(b=f(b,o)),b}function w(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=e.ownerDocument.documentElement,n=b(e,o),i=ee(o.clientWidth,window.innerWidth||0),r=ee(o.clientHeight,window.innerHeight||0),p=t?0:l(o),s=t?0:l(o,'left'),d={top:p-n.top+n.marginTop,left:s-n.left+n.marginLeft,width:i,height:r};return g(d)}function y(e){var n=e.nodeName;if('BODY'===n||'HTML'===n)return!1;if('fixed'===t(e,'position'))return!0;var i=o(e);return!!i&&y(i)}function E(e){if(!e||!e.parentElement||r())return document.documentElement;for(var o=e.parentElement;o&&'none'===t(o,'transform');)o=o.parentElement;return o||document.documentElement}function v(e,t,i,r){var p=4<arguments.length&&void 0!==arguments[4]&&arguments[4],s={top:0,left:0},d=p?E(e):a(e,t);if('viewport'===r)s=w(d,p);else{var l;'scrollParent'===r?(l=n(o(t)),'BODY'===l.nodeName&&(l=e.ownerDocument.documentElement)):'window'===r?l=e.ownerDocument.documentElement:l=r;var f=b(l,d,p);if('HTML'===l.nodeName&&!y(d)){var m=c(e.ownerDocument),h=m.height,g=m.width;s.top+=f.top-f.marginTop,s.bottom=h+f.top,s.left+=f.left-f.marginLeft,s.right=g+f.left}else s=f}i=i||0;var u='number'==typeof i;return s.left+=u?i:i.left||0,s.top+=u?i:i.top||0,s.right-=u?i:i.right||0,s.bottom-=u?i:i.bottom||0,s}function x(e){var t=e.width,o=e.height;return t*o}function O(e,t,o,n,i){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===e.indexOf('auto'))return e;var p=v(o,n,r,i),s={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},d=Object.keys(s).map(function(e){return fe({key:e},s[e],{area:x(s[e])})}).sort(function(e,t){return t.area-e.area}),a=d.filter(function(e){var t=e.width,n=e.height;return t>=o.clientWidth&&n>=o.clientHeight}),l=0<a.length?a[0].key:d[0].key,f=e.split('-')[1];return l+(f?'-'+f:'')}function L(e,t,o){var n=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null,i=n?E(t):a(t,o);return b(o,i,n)}function S(e){var t=e.ownerDocument.defaultView,o=t.getComputedStyle(e),n=parseFloat(o.marginTop||0)+parseFloat(o.marginBottom||0),i=parseFloat(o.marginLeft||0)+parseFloat(o.marginRight||0),r={width:e.offsetWidth+i,height:e.offsetHeight+n};return r}function T(e){var t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,function(e){return t[e]})}function C(e,t,o){o=o.split('-')[0];var n=S(e),i={width:n.width,height:n.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',s=r?'left':'top',d=r?'height':'width',a=r?'width':'height';return i[p]=t[p]+t[d]/2-n[d]/2,i[s]=o===s?t[s]-n[a]:t[T(s)],i}function D(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function N(e,t,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var n=D(e,function(e){return e[t]===o});return e.indexOf(n)}function P(t,o,n){var i=void 0===n?t:t.slice(0,N(t,'name',n));return i.forEach(function(t){t['function']&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var n=t['function']||t.fn;t.enabled&&e(n)&&(o.offsets.popper=g(o.offsets.popper),o.offsets.reference=g(o.offsets.reference),o=n(o,t))}),o}function k(){if(!this.state.isDestroyed){var e={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=L(this.state,this.popper,this.reference,this.options.positionFixed),e.placement=O(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.positionFixed=this.options.positionFixed,e.offsets.popper=C(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position=this.options.positionFixed?'fixed':'absolute',e=P(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}}function W(e,t){return e.some(function(e){var o=e.name,n=e.enabled;return n&&o===t})}function B(e){for(var t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<t.length;n++){var i=t[n],r=i?''+i+o:e;if('undefined'!=typeof document.body.style[r])return r}return null}function H(){return this.state.isDestroyed=!0,W(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.position='',this.popper.style.top='',this.popper.style.left='',this.popper.style.right='',this.popper.style.bottom='',this.popper.style.willChange='',this.popper.style[B('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function A(e){var t=e.ownerDocument;return t?t.defaultView:window}function M(e,t,o,i){var r='BODY'===e.nodeName,p=r?e.ownerDocument.defaultView:e;p.addEventListener(t,o,{passive:!0}),r||M(n(p.parentNode),t,o,i),i.push(p)}function F(e,t,o,i){o.updateBound=i,A(e).addEventListener('resize',o.updateBound,{passive:!0});var r=n(e);return M(r,'scroll',o.updateBound,o.scrollParents),o.scrollElement=r,o.eventsEnabled=!0,o}function I(){this.state.eventsEnabled||(this.state=F(this.reference,this.options,this.state,this.scheduleUpdate))}function R(e,t){return A(e).removeEventListener('resize',t.updateBound),t.scrollParents.forEach(function(e){e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function U(){this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=R(this.reference,this.state))}function Y(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function V(e,t){Object.keys(t).forEach(function(o){var n='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&Y(t[o])&&(n='px'),e.style[o]=t[o]+n})}function j(e,t){Object.keys(t).forEach(function(o){var n=t[o];!1===n?e.removeAttribute(o):e.setAttribute(o,t[o])})}function q(e,t){var o=e.offsets,n=o.popper,i=o.reference,r=$,p=function(e){return e},s=r(i.width),d=r(n.width),a=-1!==['left','right'].indexOf(e.placement),l=-1!==e.placement.indexOf('-'),f=t?a||l||s%2==d%2?r:Z:p,m=t?r:p;return{left:f(1==s%2&&1==d%2&&!l&&t?n.left-1:n.left),top:m(n.top),bottom:m(n.bottom),right:f(n.right)}}function K(e,t,o){var n=D(e,function(e){var o=e.name;return o===t}),i=!!n&&e.some(function(e){return e.name===o&&e.enabled&&e.order<n.order});if(!i){var r='`'+t+'`';console.warn('`'+o+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return i}function z(e){return'end'===e?'start':'start'===e?'end':e}function G(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=ce.indexOf(e),n=ce.slice(o+1).concat(ce.slice(0,o));return t?n.reverse():n}function _(e,t,o,n){var i=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+i[1],p=i[2];if(!r)return e;if(0===p.indexOf('%')){var s;switch(p){case'%p':s=o;break;case'%':case'%r':default:s=n;}var d=g(s);return d[t]/100*r}if('vh'===p||'vw'===p){var a;return a='vh'===p?ee(document.documentElement.clientHeight,window.innerHeight||0):ee(document.documentElement.clientWidth,window.innerWidth||0),a/100*r}return r}function X(e,t,o,n){var i=[0,0],r=-1!==['right','left'].indexOf(n),p=e.split(/(\+|\-)/).map(function(e){return e.trim()}),s=p.indexOf(D(p,function(e){return-1!==e.search(/,|\s/)}));p[s]&&-1===p[s].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var d=/\s*,\s*|\s+/,a=-1===s?[p]:[p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a.map(function(e,n){var i=(1===n?!r:r)?'height':'width',p=!1;return e.reduce(function(e,t){return''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t)},[]).map(function(e){return _(e,i,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,n){Y(o)&&(i[t]+=o*('-'===e[n-1]?-1:1))})}),i}function J(e,t){var o,n=t.offset,i=e.placement,r=e.offsets,p=r.popper,s=r.reference,d=i.split('-')[0];return o=Y(+n)?[+n,0]:X(n,p,s,d),'left'===d?(p.top+=o[0],p.left-=o[1]):'right'===d?(p.top+=o[0],p.left+=o[1]):'top'===d?(p.left+=o[0],p.top-=o[1]):'bottom'===d&&(p.left+=o[0],p.top+=o[1]),e.popper=p,e}for(var Q=Math.min,Z=Math.floor,$=Math.round,ee=Math.max,te='undefined'!=typeof window&&'undefined'!=typeof document,oe=['Edge','Trident','Firefox'],ne=0,ie=0;ie<oe.length;ie+=1)if(te&&0<=navigator.userAgent.indexOf(oe[ie])){ne=1;break}var i=te&&window.Promise,re=i?function(e){var t=!1;return function(){t||(t=!0,window.Promise.resolve().then(function(){t=!1,e()}))}}:function(e){var t=!1;return function(){t||(t=!0,setTimeout(function(){t=!1,e()},ne))}},pe=te&&!!(window.MSInputMethodContext&&document.documentMode),se=te&&/MSIE 10/.test(navigator.userAgent),de=function(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')},ae=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable=o.enumerable||!1,o.configurable=!0,'value'in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}return function(t,o,n){return o&&e(t.prototype,o),n&&e(t,n),t}}(),le=function(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e},fe=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var n in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},me=te&&/Firefox/i.test(navigator.userAgent),he=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],ce=he.slice(3),ge={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'},ue=function(){function t(o,n){var i=this,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};de(this,t),this.scheduleUpdate=function(){return requestAnimationFrame(i.update)},this.update=re(this.update.bind(this)),this.options=fe({},t.Defaults,r),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=o&&o.jquery?o[0]:o,this.popper=n&&n.jquery?n[0]:n,this.options.modifiers={},Object.keys(fe({},t.Defaults.modifiers,r.modifiers)).forEach(function(e){i.options.modifiers[e]=fe({},t.Defaults.modifiers[e]||{},r.modifiers?r.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(e){return fe({name:e},i.options.modifiers[e])}).sort(function(e,t){return e.order-t.order}),this.modifiers.forEach(function(t){t.enabled&&e(t.onLoad)&&t.onLoad(i.reference,i.popper,i.options,t,i.state)}),this.update();var p=this.options.eventsEnabled;p&&this.enableEventListeners(),this.state.eventsEnabled=p}return ae(t,[{key:'update',value:function(){return k.call(this)}},{key:'destroy',value:function(){return H.call(this)}},{key:'enableEventListeners',value:function(){return I.call(this)}},{key:'disableEventListeners',value:function(){return U.call(this)}}]),t}();return ue.Utils=('undefined'==typeof window?global:window).PopperUtils,ue.placements=he,ue.Defaults={placement:'bottom',positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(e){var t=e.placement,o=t.split('-')[0],n=t.split('-')[1];if(n){var i=e.offsets,r=i.reference,p=i.popper,s=-1!==['bottom','top'].indexOf(o),d=s?'left':'top',a=s?'width':'height',l={start:le({},d,r[d]),end:le({},d,r[d]+r[a]-p[a])};e.offsets.popper=fe({},p,l[n])}return e}},offset:{order:200,enabled:!0,fn:J,offset:0},preventOverflow:{order:300,enabled:!0,fn:function(e,t){var o=t.boundariesElement||p(e.instance.popper);e.instance.reference===o&&(o=p(o));var n=B('transform'),i=e.instance.popper.style,r=i.top,s=i.left,d=i[n];i.top='',i.left='',i[n]='';var a=v(e.instance.popper,e.instance.reference,t.padding,o,e.positionFixed);i.top=r,i.left=s,i[n]=d,t.boundaries=a;var l=t.priority,f=e.offsets.popper,m={primary:function(e){var o=f[e];return f[e]<a[e]&&!t.escapeWithReference&&(o=ee(f[e],a[e])),le({},e,o)},secondary:function(e){var o='right'===e?'left':'top',n=f[o];return f[e]>a[e]&&!t.escapeWithReference&&(n=Q(f[o],a[e]-('right'===e?f.width:f.height))),le({},o,n)}};return l.forEach(function(e){var t=-1===['left','top'].indexOf(e)?'secondary':'primary';f=fe({},f,m[t](e))}),e.offsets.popper=f,e},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(e){var t=e.offsets,o=t.popper,n=t.reference,i=e.placement.split('-')[0],r=Z,p=-1!==['top','bottom'].indexOf(i),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(n[d])&&(e.offsets.popper[d]=r(n[d])-o[a]),o[d]>r(n[s])&&(e.offsets.popper[d]=r(n[s])),e}},arrow:{order:500,enabled:!0,fn:function(e,o){var n;if(!K(e.instance.modifiers,'arrow','keepTogether'))return e;var i=o.element;if('string'==typeof i){if(i=e.instance.popper.querySelector(i),!i)return e;}else if(!e.instance.popper.contains(i))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var r=e.placement.split('-')[0],p=e.offsets,s=p.popper,d=p.reference,a=-1!==['left','right'].indexOf(r),l=a?'height':'width',f=a?'Top':'Left',m=f.toLowerCase(),h=a?'left':'top',c=a?'bottom':'right',u=S(i)[l];d[c]-u<s[m]&&(e.offsets.popper[m]-=s[m]-(d[c]-u)),d[m]+u>s[c]&&(e.offsets.popper[m]+=d[m]+u-s[c]),e.offsets.popper=g(e.offsets.popper);var b=d[m]+d[l]/2-u/2,w=t(e.instance.popper),y=parseFloat(w['margin'+f],10),E=parseFloat(w['border'+f+'Width'],10),v=b-e.offsets.popper[m]-y-E;return v=ee(Q(s[l]-u,v),0),e.arrowElement=i,e.offsets.arrow=(n={},le(n,m,$(v)),le(n,h,''),n),e},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(e,t){if(W(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=v(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement,e.positionFixed),n=e.placement.split('-')[0],i=T(n),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case ge.FLIP:p=[n,i];break;case ge.CLOCKWISE:p=G(n);break;case ge.COUNTERCLOCKWISE:p=G(n,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(n!==s||p.length===d+1)return e;n=e.placement.split('-')[0],i=T(n);var a=e.offsets.popper,l=e.offsets.reference,f=Z,m='left'===n&&f(a.right)>f(l.left)||'right'===n&&f(a.left)<f(l.right)||'top'===n&&f(a.bottom)>f(l.top)||'bottom'===n&&f(a.top)<f(l.bottom),h=f(a.left)<f(o.left),c=f(a.right)>f(o.right),g=f(a.top)<f(o.top),u=f(a.bottom)>f(o.bottom),b='left'===n&&h||'right'===n&&c||'top'===n&&g||'bottom'===n&&u,w=-1!==['top','bottom'].indexOf(n),y=!!t.flipVariations&&(w&&'start'===r&&h||w&&'end'===r&&c||!w&&'start'===r&&g||!w&&'end'===r&&u),E=!!t.flipVariationsByContent&&(w&&'start'===r&&c||w&&'end'===r&&h||!w&&'start'===r&&u||!w&&'end'===r&&g),v=y||E;(m||b||v)&&(e.flipped=!0,(m||b)&&(n=p[d+1]),v&&(r=z(r)),e.placement=n+(r?'-'+r:''),e.offsets.popper=fe({},e.offsets.popper,C(e.instance.popper,e.offsets.reference,e.placement)),e=P(e.instance.modifiers,e,'flip'))}),e},behavior:'flip',padding:5,boundariesElement:'viewport',flipVariations:!1,flipVariationsByContent:!1},inner:{order:700,enabled:!1,fn:function(e){var t=e.placement,o=t.split('-')[0],n=e.offsets,i=n.popper,r=n.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return i[p?'left':'top']=r[o]-(s?i[p?'width':'height']:0),e.placement=T(t),e.offsets.popper=g(i),e}},hide:{order:800,enabled:!0,fn:function(e){if(!K(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=D(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}},computeStyle:{order:850,enabled:!0,fn:function(e,t){var o=t.x,n=t.y,i=e.offsets.popper,r=D(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==r&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var s,d,a=void 0===r?t.gpuAcceleration:r,l=p(e.instance.popper),f=u(l),m={position:i.position},h=q(e,2>window.devicePixelRatio||!me),c='bottom'===o?'top':'bottom',g='right'===n?'left':'right',b=B('transform');if(d='bottom'==c?'HTML'===l.nodeName?-l.clientHeight+h.bottom:-f.height+h.bottom:h.top,s='right'==g?'HTML'===l.nodeName?-l.clientWidth+h.right:-f.width+h.right:h.left,a&&b)m[b]='translate3d('+s+'px, '+d+'px, 0)',m[c]=0,m[g]=0,m.willChange='transform';else{var w='bottom'==c?-1:1,y='right'==g?-1:1;m[c]=d*w,m[g]=s*y,m.willChange=c+', '+g}var E={"x-placement":e.placement};return e.attributes=fe({},E,e.attributes),e.styles=fe({},m,e.styles),e.arrowStyles=fe({},e.offsets.arrow,e.arrowStyles),e},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(e){return V(e.instance.popper,e.styles),j(e.instance.popper,e.attributes),e.arrowElement&&Object.keys(e.arrowStyles).length&&V(e.arrowElement,e.arrowStyles),e},onLoad:function(e,t,o,n,i){var r=L(i,t,e,o.positionFixed),p=O(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),V(t,{position:o.positionFixed?'fixed':'absolute'}),o},gpuAcceleration:void 0}}},ue});
//# sourceMappingURL=popper.min.js.map
    <tr class="{{class}} d-flex"><td {{popover}} class="col-1 text-right"><a id="{{lineNumber}}" href="#{{lineNumber}}">{{lineNumber}}</a></td><td class="col-11 codeLine">{{lineContent}}</td></tr>
<table id="code" class="table table-borderless table-condensed">
<tbody>
{{lines}}
</tbody>
</table>
      <tr>
       <td class="{{methods_level}}" colspan="4">{{name}}</td>
       <td class="{{methods_level}} big">{{methods_bar}}</td>
       <td class="{{methods_level}} small"><div align="right">{{methods_tested_percent}}</div></td>
       <td class="{{methods_level}} small"><div align="right">{{methods_number}}</div></td>
       <td class="{{methods_level}} small">{{crap}}</td>
       <td class="{{lines_level}} big">{{lines_bar}}</td>
       <td class="{{lines_level}} small"><div align="right">{{lines_executed_percent}}</div></td>
       <td class="{{lines_level}} small"><div align="right">{{lines_number}}</div></td>
      </tr>

      <tr>
       <td class="{{methods_level}}" colspan="4">{{name}}</td>
       <td class="{{methods_level}} big">{{methods_bar}}</td>
       <td class="{{methods_level}} small"><div align="right">{{methods_tested_percent}}</div></td>
       <td class="{{methods_level}} small"><div align="right">{{methods_number}}</div></td>
       <td class="{{methods_level}} small">{{crap}}</td>
       <td class="{{paths_level}} big">{{paths_bar}}</td>
       <td class="{{paths_level}} small"><div align="right">{{paths_executed_percent}}</div></td>
       <td class="{{paths_level}} small"><div align="right">{{paths_number}}</div></td>
       <td class="{{branches_level}} big">{{branches_bar}}</td>
       <td class="{{branches_level}} small"><div align="right">{{branches_executed_percent}}</div></td>
       <td class="{{branches_level}} small"><div align="right">{{branches_number}}</div></td>
       <td class="{{lines_level}} big">{{lines_bar}}</td>
       <td class="{{lines_level}} small"><div align="right">{{lines_executed_percent}}</div></td>
       <td class="{{lines_level}} small"><div align="right">{{lines_number}}</div></td>
      </tr>

<hr/>
<h4>Paths</h4>
<p>
    Below are the source code lines that represent each code path as identified by Xdebug. Please note a path is not
    necessarily coterminous with a line, a line may contain multiple paths and therefore show up more than once.
    Please also be aware that some paths may include implicit rather than explicit branches, e.g. an <code>if</code> statement
    <i>always</i> has an <code>else</code> as part of its logical flow even if you didn't write one.
</p>
{{paths}}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report;

use function dirname;
use function file_put_contents;
use function serialize;
use function sprintf;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Directory;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
final class PHP
{
    public function process(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, ?string $target = null) : string
    {
        $buffer = \sprintf("<?php\nreturn \\unserialize(<<<'END_OF_COVERAGE_SERIALIZATION'%s%s%sEND_OF_COVERAGE_SERIALIZATION%s);", \PHP_EOL, \serialize($coverage), \PHP_EOL, \PHP_EOL);
        if ($target !== null) {
            \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create(\dirname($target));
            if (@\file_put_contents($target, $buffer) === \false) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException($target);
            }
        }
        return $buffer;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report;

use const PHP_EOL;
use function array_map;
use function date;
use function ksort;
use function max;
use function sprintf;
use function str_pad;
use function strlen;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\File;
use PHPUnit\SebastianBergmann\CodeCoverage\Percentage;
final class Text
{
    /**
     * @var string
     */
    private const COLOR_GREEN = "\33[30;42m";
    /**
     * @var string
     */
    private const COLOR_YELLOW = "\33[30;43m";
    /**
     * @var string
     */
    private const COLOR_RED = "\33[37;41m";
    /**
     * @var string
     */
    private const COLOR_HEADER = "\33[1;37;40m";
    /**
     * @var string
     */
    private const COLOR_RESET = "\33[0m";
    /**
     * @var string
     */
    private const COLOR_EOL = "\33[2K";
    private int $lowUpperBound;
    private int $highLowerBound;
    private bool $showUncoveredFiles;
    private bool $showOnlySummary;
    public function __construct(int $lowUpperBound = 50, int $highLowerBound = 90, bool $showUncoveredFiles = \false, bool $showOnlySummary = \false)
    {
        $this->lowUpperBound = $lowUpperBound;
        $this->highLowerBound = $highLowerBound;
        $this->showUncoveredFiles = $showUncoveredFiles;
        $this->showOnlySummary = $showOnlySummary;
    }
    public function process(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, bool $showColors = \false) : string
    {
        $hasBranchCoverage = !empty($coverage->getData(\true)->functionCoverage());
        $output = \PHP_EOL . \PHP_EOL;
        $report = $coverage->getReport();
        $colors = ['header' => '', 'classes' => '', 'methods' => '', 'lines' => '', 'branches' => '', 'paths' => '', 'reset' => '', 'eol' => ''];
        if ($showColors) {
            $colors['classes'] = $this->coverageColor($report->numberOfTestedClassesAndTraits(), $report->numberOfClassesAndTraits());
            $colors['methods'] = $this->coverageColor($report->numberOfTestedMethods(), $report->numberOfMethods());
            $colors['lines'] = $this->coverageColor($report->numberOfExecutedLines(), $report->numberOfExecutableLines());
            $colors['branches'] = $this->coverageColor($report->numberOfExecutedBranches(), $report->numberOfExecutableBranches());
            $colors['paths'] = $this->coverageColor($report->numberOfExecutedPaths(), $report->numberOfExecutablePaths());
            $colors['reset'] = self::COLOR_RESET;
            $colors['header'] = self::COLOR_HEADER;
            $colors['eol'] = self::COLOR_EOL;
        }
        $classes = \sprintf('  Classes: %6s (%d/%d)', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($report->numberOfTestedClassesAndTraits(), $report->numberOfClassesAndTraits())->asString(), $report->numberOfTestedClassesAndTraits(), $report->numberOfClassesAndTraits());
        $methods = \sprintf('  Methods: %6s (%d/%d)', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($report->numberOfTestedMethods(), $report->numberOfMethods())->asString(), $report->numberOfTestedMethods(), $report->numberOfMethods());
        $paths = '';
        $branches = '';
        if ($hasBranchCoverage) {
            $paths = \sprintf('  Paths:   %6s (%d/%d)', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($report->numberOfExecutedPaths(), $report->numberOfExecutablePaths())->asString(), $report->numberOfExecutedPaths(), $report->numberOfExecutablePaths());
            $branches = \sprintf('  Branches:   %6s (%d/%d)', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($report->numberOfExecutedBranches(), $report->numberOfExecutableBranches())->asString(), $report->numberOfExecutedBranches(), $report->numberOfExecutableBranches());
        }
        $lines = \sprintf('  Lines:   %6s (%d/%d)', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($report->numberOfExecutedLines(), $report->numberOfExecutableLines())->asString(), $report->numberOfExecutedLines(), $report->numberOfExecutableLines());
        $padding = \max(\array_map('strlen', [$classes, $methods, $lines]));
        if ($this->showOnlySummary) {
            $title = 'Code Coverage Report Summary:';
            $padding = \max($padding, \strlen($title));
            $output .= $this->format($colors['header'], $padding, $title);
        } else {
            $date = \date('  Y-m-d H:i:s');
            $title = 'Code Coverage Report:';
            $output .= $this->format($colors['header'], $padding, $title);
            $output .= $this->format($colors['header'], $padding, $date);
            $output .= $this->format($colors['header'], $padding, '');
            $output .= $this->format($colors['header'], $padding, ' Summary:');
        }
        $output .= $this->format($colors['classes'], $padding, $classes);
        $output .= $this->format($colors['methods'], $padding, $methods);
        if ($hasBranchCoverage) {
            $output .= $this->format($colors['paths'], $padding, $paths);
            $output .= $this->format($colors['branches'], $padding, $branches);
        }
        $output .= $this->format($colors['lines'], $padding, $lines);
        if ($this->showOnlySummary) {
            return $output . \PHP_EOL;
        }
        $classCoverage = [];
        foreach ($report as $item) {
            if (!$item instanceof \PHPUnit\SebastianBergmann\CodeCoverage\Node\File) {
                continue;
            }
            $classes = $item->classesAndTraits();
            foreach ($classes as $className => $class) {
                $classExecutableLines = 0;
                $classExecutedLines = 0;
                $classExecutableBranches = 0;
                $classExecutedBranches = 0;
                $classExecutablePaths = 0;
                $classExecutedPaths = 0;
                $coveredMethods = 0;
                $classMethods = 0;
                foreach ($class['methods'] as $method) {
                    if ($method['executableLines'] == 0) {
                        continue;
                    }
                    $classMethods++;
                    $classExecutableLines += $method['executableLines'];
                    $classExecutedLines += $method['executedLines'];
                    $classExecutableBranches += $method['executableBranches'];
                    $classExecutedBranches += $method['executedBranches'];
                    $classExecutablePaths += $method['executablePaths'];
                    $classExecutedPaths += $method['executedPaths'];
                    if ($method['coverage'] == 100) {
                        $coveredMethods++;
                    }
                }
                $classCoverage[$className] = ['namespace' => $class['namespace'], 'className' => $className, 'methodsCovered' => $coveredMethods, 'methodCount' => $classMethods, 'statementsCovered' => $classExecutedLines, 'statementCount' => $classExecutableLines, 'branchesCovered' => $classExecutedBranches, 'branchesCount' => $classExecutableBranches, 'pathsCovered' => $classExecutedPaths, 'pathsCount' => $classExecutablePaths];
            }
        }
        \ksort($classCoverage);
        $methodColor = '';
        $pathsColor = '';
        $branchesColor = '';
        $linesColor = '';
        $resetColor = '';
        foreach ($classCoverage as $fullQualifiedPath => $classInfo) {
            if ($this->showUncoveredFiles || $classInfo['statementsCovered'] != 0) {
                if ($showColors) {
                    $methodColor = $this->coverageColor($classInfo['methodsCovered'], $classInfo['methodCount']);
                    $pathsColor = $this->coverageColor($classInfo['pathsCovered'], $classInfo['pathsCount']);
                    $branchesColor = $this->coverageColor($classInfo['branchesCovered'], $classInfo['branchesCount']);
                    $linesColor = $this->coverageColor($classInfo['statementsCovered'], $classInfo['statementCount']);
                    $resetColor = $colors['reset'];
                }
                $output .= \PHP_EOL . $fullQualifiedPath . \PHP_EOL . '  ' . $methodColor . 'Methods: ' . $this->printCoverageCounts($classInfo['methodsCovered'], $classInfo['methodCount'], 2) . $resetColor . ' ';
                if ($hasBranchCoverage) {
                    $output .= '  ' . $pathsColor . 'Paths: ' . $this->printCoverageCounts($classInfo['pathsCovered'], $classInfo['pathsCount'], 3) . $resetColor . ' ' . '  ' . $branchesColor . 'Branches: ' . $this->printCoverageCounts($classInfo['branchesCovered'], $classInfo['branchesCount'], 3) . $resetColor . ' ';
                }
                $output .= '  ' . $linesColor . 'Lines: ' . $this->printCoverageCounts($classInfo['statementsCovered'], $classInfo['statementCount'], 3) . $resetColor;
            }
        }
        return $output . \PHP_EOL;
    }
    private function coverageColor(int $numberOfCoveredElements, int $totalNumberOfElements) : string
    {
        $coverage = \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($numberOfCoveredElements, $totalNumberOfElements);
        if ($coverage->asFloat() >= $this->highLowerBound) {
            return self::COLOR_GREEN;
        }
        if ($coverage->asFloat() > $this->lowUpperBound) {
            return self::COLOR_YELLOW;
        }
        return self::COLOR_RED;
    }
    private function printCoverageCounts(int $numberOfCoveredElements, int $totalNumberOfElements, int $precision) : string
    {
        $format = '%' . $precision . 's';
        return \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($numberOfCoveredElements, $totalNumberOfElements)->asFixedWidthString() . ' (' . \sprintf($format, $numberOfCoveredElements) . '/' . \sprintf($format, $totalNumberOfElements) . ')';
    }
    /**
     * @param false|string $string
     */
    private function format(string $color, int $padding, $string) : string
    {
        $reset = $color ? self::COLOR_RESET : '';
        return $color . \str_pad((string) $string, $padding) . $reset . \PHP_EOL;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use function constant;
use function phpversion;
use DateTimeImmutable;
use DOMElement;
use PHPUnit\SebastianBergmann\Environment\Runtime;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class BuildInformation
{
    private \DOMElement $contextNode;
    public function __construct(\DOMElement $contextNode)
    {
        $this->contextNode = $contextNode;
    }
    public function setRuntimeInformation(\PHPUnit\SebastianBergmann\Environment\Runtime $runtime) : void
    {
        $runtimeNode = $this->nodeByName('runtime');
        $runtimeNode->setAttribute('name', $runtime->getName());
        $runtimeNode->setAttribute('version', $runtime->getVersion());
        $runtimeNode->setAttribute('url', $runtime->getVendorUrl());
        $driverNode = $this->nodeByName('driver');
        if ($runtime->hasPHPDBGCodeCoverage()) {
            $driverNode->setAttribute('name', 'phpdbg');
            $driverNode->setAttribute('version', \constant('PHPDBG_VERSION'));
        }
        if ($runtime->hasXdebug()) {
            $driverNode->setAttribute('name', 'xdebug');
            $driverNode->setAttribute('version', \phpversion('xdebug'));
        }
        if ($runtime->hasPCOV()) {
            $driverNode->setAttribute('name', 'pcov');
            $driverNode->setAttribute('version', \phpversion('pcov'));
        }
    }
    public function setBuildTime(\DateTimeImmutable $date) : void
    {
        $this->contextNode->setAttribute('time', $date->format('D M j G:i:s T Y'));
    }
    public function setGeneratorVersions(string $phpUnitVersion, string $coverageVersion) : void
    {
        $this->contextNode->setAttribute('phpunit', $phpUnitVersion);
        $this->contextNode->setAttribute('coverage', $coverageVersion);
    }
    private function nodeByName(string $name) : \DOMElement
    {
        $node = $this->contextNode->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', $name)->item(0);
        if (!$node) {
            $node = $this->contextNode->appendChild($this->contextNode->ownerDocument->createElementNS('https://schema.phpunit.de/coverage/1.0', $name));
        }
        return $node;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMElement;
use PHPUnit\SebastianBergmann\CodeCoverage\ReportAlreadyFinalizedException;
use XMLWriter;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Coverage
{
    private \XMLWriter $writer;
    private \DOMElement $contextNode;
    private bool $finalized = \false;
    public function __construct(\DOMElement $context, string $line)
    {
        $this->contextNode = $context;
        $this->writer = new \XMLWriter();
        $this->writer->openMemory();
        $this->writer->startElementNS(null, $context->nodeName, 'https://schema.phpunit.de/coverage/1.0');
        $this->writer->writeAttribute('nr', $line);
    }
    /**
     * @throws ReportAlreadyFinalizedException
     */
    public function addTest(string $test) : void
    {
        if ($this->finalized) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\ReportAlreadyFinalizedException();
        }
        $this->writer->startElement('covered');
        $this->writer->writeAttribute('by', $test);
        $this->writer->endElement();
    }
    public function finalize() : void
    {
        $this->writer->endElement();
        $fragment = $this->contextNode->ownerDocument->createDocumentFragment();
        $fragment->appendXML($this->writer->outputMemory());
        $this->contextNode->parentNode->replaceChild($fragment, $this->contextNode);
        $this->finalized = \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Directory extends \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Node
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use const DIRECTORY_SEPARATOR;
use const PHP_EOL;
use function count;
use function dirname;
use function file_get_contents;
use function file_put_contents;
use function is_array;
use function is_dir;
use function is_file;
use function is_writable;
use function libxml_clear_errors;
use function libxml_get_errors;
use function libxml_use_internal_errors;
use function sprintf;
use function strlen;
use function substr;
use DateTimeImmutable;
use DOMDocument;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Directory as DirectoryUtil;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\PathExistsButIsNotDirectoryException;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory as DirectoryNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Node\File as FileNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Version;
use PHPUnit\SebastianBergmann\CodeCoverage\XmlException;
use PHPUnit\SebastianBergmann\Environment\Runtime;
final class Facade
{
    private string $target;
    private \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Project $project;
    private string $phpUnitVersion;
    public function __construct(string $version)
    {
        $this->phpUnitVersion = $version;
    }
    /**
     * @throws XmlException
     */
    public function process(\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $coverage, string $target) : void
    {
        if (\substr($target, -1, 1) !== \DIRECTORY_SEPARATOR) {
            $target .= \DIRECTORY_SEPARATOR;
        }
        $this->target = $target;
        $this->initTargetDirectory($target);
        $report = $coverage->getReport();
        $this->project = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Project($coverage->getReport()->name());
        $this->setBuildInformation();
        $this->processTests($coverage->getTests());
        $this->processDirectory($report, $this->project);
        $this->saveDocument($this->project->asDom(), 'index');
    }
    private function setBuildInformation() : void
    {
        $buildNode = $this->project->buildInformation();
        $buildNode->setRuntimeInformation(new \PHPUnit\SebastianBergmann\Environment\Runtime());
        $buildNode->setBuildTime(new \DateTimeImmutable());
        $buildNode->setGeneratorVersions($this->phpUnitVersion, \PHPUnit\SebastianBergmann\CodeCoverage\Version::id());
    }
    /**
     * @throws PathExistsButIsNotDirectoryException
     * @throws WriteOperationFailedException
     */
    private function initTargetDirectory(string $directory) : void
    {
        if (\is_file($directory)) {
            if (!\is_dir($directory)) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\PathExistsButIsNotDirectoryException($directory);
            }
            if (!\is_writable($directory)) {
                throw new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\WriteOperationFailedException($directory);
            }
        }
        \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create($directory);
    }
    /**
     * @throws XmlException
     */
    private function processDirectory(\PHPUnit\SebastianBergmann\CodeCoverage\Node\Directory $directory, \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Node $context) : void
    {
        $directoryName = $directory->name();
        if ($this->project->projectSourceDirectory() === $directoryName) {
            $directoryName = '/';
        }
        $directoryObject = $context->addDirectory($directoryName);
        $this->setTotals($directory, $directoryObject->totals());
        foreach ($directory->directories() as $node) {
            $this->processDirectory($node, $directoryObject);
        }
        foreach ($directory->files() as $node) {
            $this->processFile($node, $directoryObject);
        }
    }
    /**
     * @throws XmlException
     */
    private function processFile(\PHPUnit\SebastianBergmann\CodeCoverage\Node\File $file, \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Directory $context) : void
    {
        $fileObject = $context->addFile($file->name(), $file->id() . '.xml');
        $this->setTotals($file, $fileObject->totals());
        $path = \substr($file->pathAsString(), \strlen($this->project->projectSourceDirectory()));
        $fileReport = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Report($path);
        $this->setTotals($file, $fileReport->totals());
        foreach ($file->classesAndTraits() as $unit) {
            $this->processUnit($unit, $fileReport);
        }
        foreach ($file->functions() as $function) {
            $this->processFunction($function, $fileReport);
        }
        foreach ($file->lineCoverageData() as $line => $tests) {
            if (!\is_array($tests) || \count($tests) === 0) {
                continue;
            }
            $coverage = $fileReport->lineCoverage((string) $line);
            foreach ($tests as $test) {
                $coverage->addTest($test);
            }
            $coverage->finalize();
        }
        $fileReport->source()->setSourceCode(\file_get_contents($file->pathAsString()));
        $this->saveDocument($fileReport->asDom(), $file->id());
    }
    private function processUnit(array $unit, \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Report $report) : void
    {
        if (isset($unit['className'])) {
            $unitObject = $report->classObject($unit['className']);
        } else {
            $unitObject = $report->traitObject($unit['traitName']);
        }
        $unitObject->setLines($unit['startLine'], $unit['executableLines'], $unit['executedLines']);
        $unitObject->setCrap((float) $unit['crap']);
        $unitObject->setNamespace($unit['namespace']);
        foreach ($unit['methods'] as $method) {
            $methodObject = $unitObject->addMethod($method['methodName']);
            $methodObject->setSignature($method['signature']);
            $methodObject->setLines((string) $method['startLine'], (string) $method['endLine']);
            $methodObject->setCrap($method['crap']);
            $methodObject->setTotals((string) $method['executableLines'], (string) $method['executedLines'], (string) $method['coverage']);
        }
    }
    private function processFunction(array $function, \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Report $report) : void
    {
        $functionObject = $report->functionObject($function['functionName']);
        $functionObject->setSignature($function['signature']);
        $functionObject->setLines((string) $function['startLine']);
        $functionObject->setCrap($function['crap']);
        $functionObject->setTotals((string) $function['executableLines'], (string) $function['executedLines'], (string) $function['coverage']);
    }
    private function processTests(array $tests) : void
    {
        $testsObject = $this->project->tests();
        foreach ($tests as $test => $result) {
            $testsObject->addTest($test, $result);
        }
    }
    private function setTotals(\PHPUnit\SebastianBergmann\CodeCoverage\Node\AbstractNode $node, \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Totals $totals) : void
    {
        $loc = $node->linesOfCode();
        $totals->setNumLines($loc->linesOfCode(), $loc->commentLinesOfCode(), $loc->nonCommentLinesOfCode(), $node->numberOfExecutableLines(), $node->numberOfExecutedLines());
        $totals->setNumClasses($node->numberOfClasses(), $node->numberOfTestedClasses());
        $totals->setNumTraits($node->numberOfTraits(), $node->numberOfTestedTraits());
        $totals->setNumMethods($node->numberOfMethods(), $node->numberOfTestedMethods());
        $totals->setNumFunctions($node->numberOfFunctions(), $node->numberOfTestedFunctions());
    }
    private function targetDirectory() : string
    {
        return $this->target;
    }
    /**
     * @throws XmlException
     */
    private function saveDocument(\DOMDocument $document, string $name) : void
    {
        $filename = \sprintf('%s/%s.xml', $this->targetDirectory(), $name);
        $document->formatOutput = \true;
        $document->preserveWhiteSpace = \false;
        $this->initTargetDirectory(\dirname($filename));
        \file_put_contents($filename, $this->documentAsString($document));
    }
    /**
     * @throws XmlException
     *
     * @see https://bugs.php.net/bug.php?id=79191
     */
    private function documentAsString(\DOMDocument $document) : string
    {
        $xmlErrorHandling = \libxml_use_internal_errors(\true);
        $xml = $document->saveXML();
        if ($xml === \false) {
            $message = 'Unable to generate the XML';
            foreach (\libxml_get_errors() as $error) {
                $message .= \PHP_EOL . $error->message;
            }
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\XmlException($message);
        }
        \libxml_clear_errors();
        \libxml_use_internal_errors($xmlErrorHandling);
        return $xml;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
class File
{
    private \DOMDocument $dom;
    private \DOMElement $contextNode;
    public function __construct(\DOMElement $context)
    {
        $this->dom = $context->ownerDocument;
        $this->contextNode = $context;
    }
    public function totals() : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Totals
    {
        $totalsContainer = $this->contextNode->firstChild;
        if (!$totalsContainer) {
            $totalsContainer = $this->contextNode->appendChild($this->dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'totals'));
        }
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Totals($totalsContainer);
    }
    public function lineCoverage(string $line) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Coverage
    {
        $coverage = $this->contextNode->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', 'coverage')->item(0);
        if (!$coverage) {
            $coverage = $this->contextNode->appendChild($this->dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'coverage'));
        }
        $lineNode = $coverage->appendChild($this->dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'line'));
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Coverage($lineNode, $line);
    }
    protected function contextNode() : \DOMElement
    {
        return $this->contextNode;
    }
    protected function dom() : \DOMDocument
    {
        return $this->dom;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Method
{
    private \DOMElement $contextNode;
    public function __construct(\DOMElement $context, string $name)
    {
        $this->contextNode = $context;
        $this->setName($name);
    }
    public function setSignature(string $signature) : void
    {
        $this->contextNode->setAttribute('signature', $signature);
    }
    public function setLines(string $start, ?string $end = null) : void
    {
        $this->contextNode->setAttribute('start', $start);
        if ($end !== null) {
            $this->contextNode->setAttribute('end', $end);
        }
    }
    public function setTotals(string $executable, string $executed, string $coverage) : void
    {
        $this->contextNode->setAttribute('executable', $executable);
        $this->contextNode->setAttribute('executed', $executed);
        $this->contextNode->setAttribute('coverage', $coverage);
    }
    public function setCrap(string $crap) : void
    {
        $this->contextNode->setAttribute('crap', $crap);
    }
    private function setName(string $name) : void
    {
        $this->contextNode->setAttribute('name', $name);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
abstract class Node
{
    private \DOMDocument $dom;
    private \DOMElement $contextNode;
    public function __construct(\DOMElement $context)
    {
        $this->setContextNode($context);
    }
    public function dom() : \DOMDocument
    {
        return $this->dom;
    }
    public function totals() : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Totals
    {
        $totalsContainer = $this->contextNode()->firstChild;
        if (!$totalsContainer) {
            $totalsContainer = $this->contextNode()->appendChild($this->dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'totals'));
        }
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Totals($totalsContainer);
    }
    public function addDirectory(string $name) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Directory
    {
        $dirNode = $this->dom()->createElementNS('https://schema.phpunit.de/coverage/1.0', 'directory');
        $dirNode->setAttribute('name', $name);
        $this->contextNode()->appendChild($dirNode);
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Directory($dirNode);
    }
    public function addFile(string $name, string $href) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\File
    {
        $fileNode = $this->dom()->createElementNS('https://schema.phpunit.de/coverage/1.0', 'file');
        $fileNode->setAttribute('name', $name);
        $fileNode->setAttribute('href', $href);
        $this->contextNode()->appendChild($fileNode);
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\File($fileNode);
    }
    protected function setContextNode(\DOMElement $context) : void
    {
        $this->dom = $context->ownerDocument;
        $this->contextNode = $context;
    }
    protected function contextNode() : \DOMElement
    {
        return $this->contextNode;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Project extends \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Node
{
    public function __construct(string $directory)
    {
        $this->init();
        $this->setProjectSourceDirectory($directory);
    }
    public function projectSourceDirectory() : string
    {
        return $this->contextNode()->getAttribute('source');
    }
    public function buildInformation() : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\BuildInformation
    {
        $buildNode = $this->dom()->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', 'build')->item(0);
        if (!$buildNode) {
            $buildNode = $this->dom()->documentElement->appendChild($this->dom()->createElementNS('https://schema.phpunit.de/coverage/1.0', 'build'));
        }
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\BuildInformation($buildNode);
    }
    public function tests() : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Tests
    {
        $testsNode = $this->contextNode()->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', 'tests')->item(0);
        if (!$testsNode) {
            $testsNode = $this->contextNode()->appendChild($this->dom()->createElementNS('https://schema.phpunit.de/coverage/1.0', 'tests'));
        }
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Tests($testsNode);
    }
    public function asDom() : \DOMDocument
    {
        return $this->dom();
    }
    private function init() : void
    {
        $dom = new \DOMDocument();
        $dom->loadXML('<?xml version="1.0" ?><phpunit xmlns="https://schema.phpunit.de/coverage/1.0"><build/><project/></phpunit>');
        $this->setContextNode($dom->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', 'project')->item(0));
    }
    private function setProjectSourceDirectory(string $name) : void
    {
        $this->contextNode()->setAttribute('source', $name);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use function basename;
use function dirname;
use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Report extends \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\File
{
    public function __construct(string $name)
    {
        $dom = new \DOMDocument();
        $dom->loadXML('<?xml version="1.0" ?><phpunit xmlns="https://schema.phpunit.de/coverage/1.0"><file /></phpunit>');
        $contextNode = $dom->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', 'file')->item(0);
        parent::__construct($contextNode);
        $this->setName($name);
    }
    public function asDom() : \DOMDocument
    {
        return $this->dom();
    }
    public function functionObject($name) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Method
    {
        $node = $this->contextNode()->appendChild($this->dom()->createElementNS('https://schema.phpunit.de/coverage/1.0', 'function'));
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Method($node, $name);
    }
    public function classObject($name) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Unit
    {
        return $this->unitObject('class', $name);
    }
    public function traitObject($name) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Unit
    {
        return $this->unitObject('trait', $name);
    }
    public function source() : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Source
    {
        $source = $this->contextNode()->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', 'source')->item(0);
        if (!$source) {
            $source = $this->contextNode()->appendChild($this->dom()->createElementNS('https://schema.phpunit.de/coverage/1.0', 'source'));
        }
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Source($source);
    }
    private function setName(string $name) : void
    {
        $this->contextNode()->setAttribute('name', \basename($name));
        $this->contextNode()->setAttribute('path', \dirname($name));
    }
    private function unitObject(string $tagName, $name) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Unit
    {
        $node = $this->contextNode()->appendChild($this->dom()->createElementNS('https://schema.phpunit.de/coverage/1.0', $tagName));
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Unit($node, $name);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMElement;
use PHPUnit\TheSeer\Tokenizer\NamespaceUri;
use PHPUnit\TheSeer\Tokenizer\Tokenizer;
use PHPUnit\TheSeer\Tokenizer\XMLSerializer;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Source
{
    private \DOMElement $context;
    public function __construct(\DOMElement $context)
    {
        $this->context = $context;
    }
    public function setSourceCode(string $source) : void
    {
        $context = $this->context;
        $tokens = (new \PHPUnit\TheSeer\Tokenizer\Tokenizer())->parse($source);
        $srcDom = (new \PHPUnit\TheSeer\Tokenizer\XMLSerializer(new \PHPUnit\TheSeer\Tokenizer\NamespaceUri($context->namespaceURI)))->toDom($tokens);
        $context->parentNode->replaceChild($context->ownerDocument->importNode($srcDom->documentElement, \true), $context);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Tests
{
    private \DOMElement $contextNode;
    public function __construct(\DOMElement $context)
    {
        $this->contextNode = $context;
    }
    public function addTest(string $test, array $result) : void
    {
        $node = $this->contextNode->appendChild($this->contextNode->ownerDocument->createElementNS('https://schema.phpunit.de/coverage/1.0', 'test'));
        $node->setAttribute('name', $test);
        $node->setAttribute('size', $result['size']);
        $node->setAttribute('status', $result['status']);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use function sprintf;
use DOMElement;
use DOMNode;
use PHPUnit\SebastianBergmann\CodeCoverage\Percentage;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Totals
{
    private \DOMNode $container;
    private \DOMElement $linesNode;
    private \DOMElement $methodsNode;
    private \DOMElement $functionsNode;
    private \DOMElement $classesNode;
    private \DOMElement $traitsNode;
    public function __construct(\DOMElement $container)
    {
        $this->container = $container;
        $dom = $container->ownerDocument;
        $this->linesNode = $dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'lines');
        $this->methodsNode = $dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'methods');
        $this->functionsNode = $dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'functions');
        $this->classesNode = $dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'classes');
        $this->traitsNode = $dom->createElementNS('https://schema.phpunit.de/coverage/1.0', 'traits');
        $container->appendChild($this->linesNode);
        $container->appendChild($this->methodsNode);
        $container->appendChild($this->functionsNode);
        $container->appendChild($this->classesNode);
        $container->appendChild($this->traitsNode);
    }
    public function container() : \DOMNode
    {
        return $this->container;
    }
    public function setNumLines(int $loc, int $cloc, int $ncloc, int $executable, int $executed) : void
    {
        $this->linesNode->setAttribute('total', (string) $loc);
        $this->linesNode->setAttribute('comments', (string) $cloc);
        $this->linesNode->setAttribute('code', (string) $ncloc);
        $this->linesNode->setAttribute('executable', (string) $executable);
        $this->linesNode->setAttribute('executed', (string) $executed);
        $this->linesNode->setAttribute('percent', $executable === 0 ? '0' : \sprintf('%01.2F', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($executed, $executable)->asFloat()));
    }
    public function setNumClasses(int $count, int $tested) : void
    {
        $this->classesNode->setAttribute('count', (string) $count);
        $this->classesNode->setAttribute('tested', (string) $tested);
        $this->classesNode->setAttribute('percent', $count === 0 ? '0' : \sprintf('%01.2F', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($tested, $count)->asFloat()));
    }
    public function setNumTraits(int $count, int $tested) : void
    {
        $this->traitsNode->setAttribute('count', (string) $count);
        $this->traitsNode->setAttribute('tested', (string) $tested);
        $this->traitsNode->setAttribute('percent', $count === 0 ? '0' : \sprintf('%01.2F', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($tested, $count)->asFloat()));
    }
    public function setNumMethods(int $count, int $tested) : void
    {
        $this->methodsNode->setAttribute('count', (string) $count);
        $this->methodsNode->setAttribute('tested', (string) $tested);
        $this->methodsNode->setAttribute('percent', $count === 0 ? '0' : \sprintf('%01.2F', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($tested, $count)->asFloat()));
    }
    public function setNumFunctions(int $count, int $tested) : void
    {
        $this->functionsNode->setAttribute('count', (string) $count);
        $this->functionsNode->setAttribute('tested', (string) $tested);
        $this->functionsNode->setAttribute('percent', $count === 0 ? '0' : \sprintf('%01.2F', \PHPUnit\SebastianBergmann\CodeCoverage\Percentage::fromFractionAndTotal($tested, $count)->asFloat()));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class Unit
{
    private \DOMElement $contextNode;
    public function __construct(\DOMElement $context, string $name)
    {
        $this->contextNode = $context;
        $this->setName($name);
    }
    public function setLines(int $start, int $executable, int $executed) : void
    {
        $this->contextNode->setAttribute('start', (string) $start);
        $this->contextNode->setAttribute('executable', (string) $executable);
        $this->contextNode->setAttribute('executed', (string) $executed);
    }
    public function setCrap(float $crap) : void
    {
        $this->contextNode->setAttribute('crap', (string) $crap);
    }
    public function setNamespace(string $namespace) : void
    {
        $node = $this->contextNode->getElementsByTagNameNS('https://schema.phpunit.de/coverage/1.0', 'namespace')->item(0);
        if (!$node) {
            $node = $this->contextNode->appendChild($this->contextNode->ownerDocument->createElementNS('https://schema.phpunit.de/coverage/1.0', 'namespace'));
        }
        $node->setAttribute('name', $namespace);
    }
    public function addMethod(string $name) : \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Method
    {
        $node = $this->contextNode->appendChild($this->contextNode->ownerDocument->createElementNS('https://schema.phpunit.de/coverage/1.0', 'method'));
        return new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Method($node, $name);
    }
    private function setName(string $name) : void
    {
        $this->contextNode->setAttribute('name', $name);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use const DIRECTORY_SEPARATOR;
use function file_get_contents;
use function file_put_contents;
use function filemtime;
use function hash;
use function is_file;
use function serialize;
use function unserialize;
use PHPUnit\SebastianBergmann\CodeCoverage\Directory;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
abstract class Cache
{
    private string $directory;
    public function __construct(string $directory)
    {
        \PHPUnit\SebastianBergmann\CodeCoverage\Directory::create($directory);
        $this->directory = $directory;
    }
    protected function has(string $filename, string $key) : bool
    {
        $cacheFile = $this->cacheFile($filename, $key);
        if (!\is_file($cacheFile)) {
            return \false;
        }
        if (\filemtime($cacheFile) < \filemtime($filename)) {
            return \false;
        }
        return \true;
    }
    /**
     * @psalm-param list<class-string> $allowedClasses
     *
     * @return mixed
     */
    protected function read(string $filename, string $key, array $allowedClasses = [])
    {
        $options = ['allowed_classes' => \false];
        if (!empty($allowedClasses)) {
            $options = ['allowed_classes' => $allowedClasses];
        }
        return \unserialize(\file_get_contents($this->cacheFile($filename, $key)), $options);
    }
    /**
     * @param mixed $data
     */
    protected function write(string $filename, string $key, $data) : void
    {
        \file_put_contents($this->cacheFile($filename, $key), \serialize($data));
    }
    private function cacheFile(string $filename, string $key) : string
    {
        return $this->directory . \DIRECTORY_SEPARATOR . \hash('sha256', $filename . $key);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
final class CacheWarmer
{
    public function warmCache(string $cacheDirectory, bool $useAnnotationsForIgnoringCode, bool $ignoreDeprecatedCode, \PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter) : void
    {
        $coveredFileAnalyser = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CachingCoveredFileAnalyser($cacheDirectory, new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingCoveredFileAnalyser($useAnnotationsForIgnoringCode, $ignoreDeprecatedCode));
        $uncoveredFileAnalyser = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CachingUncoveredFileAnalyser($cacheDirectory, new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\ParsingUncoveredFileAnalyser());
        foreach ($filter->files() as $file) {
            $coveredFileAnalyser->process($file);
            /* @noinspection UnusedFunctionResultInspection */
            $uncoveredFileAnalyser->executableLinesIn($file);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class CachingCoveredFileAnalyser extends \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\Cache implements \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser
{
    private \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser $coveredFileAnalyser;
    private array $cache = [];
    public function __construct(string $directory, \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser $coveredFileAnalyser)
    {
        parent::__construct($directory);
        $this->coveredFileAnalyser = $coveredFileAnalyser;
    }
    public function classesIn(string $filename) : array
    {
        if (!isset($this->cache[$filename])) {
            $this->process($filename);
        }
        return $this->cache[$filename]['classesIn'];
    }
    public function traitsIn(string $filename) : array
    {
        if (!isset($this->cache[$filename])) {
            $this->process($filename);
        }
        return $this->cache[$filename]['traitsIn'];
    }
    public function functionsIn(string $filename) : array
    {
        if (!isset($this->cache[$filename])) {
            $this->process($filename);
        }
        return $this->cache[$filename]['functionsIn'];
    }
    public function linesOfCodeFor(string $filename) : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        if (!isset($this->cache[$filename])) {
            $this->process($filename);
        }
        return $this->cache[$filename]['linesOfCodeFor'];
    }
    public function ignoredLinesFor(string $filename) : array
    {
        if (!isset($this->cache[$filename])) {
            $this->process($filename);
        }
        return $this->cache[$filename]['ignoredLinesFor'];
    }
    public function process(string $filename) : void
    {
        if ($this->has($filename, __CLASS__)) {
            $this->cache[$filename] = $this->read($filename, __CLASS__, [\PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode::class]);
            return;
        }
        $this->cache[$filename] = ['classesIn' => $this->coveredFileAnalyser->classesIn($filename), 'traitsIn' => $this->coveredFileAnalyser->traitsIn($filename), 'functionsIn' => $this->coveredFileAnalyser->functionsIn($filename), 'linesOfCodeFor' => $this->coveredFileAnalyser->linesOfCodeFor($filename), 'ignoredLinesFor' => $this->coveredFileAnalyser->ignoredLinesFor($filename)];
        $this->write($filename, __CLASS__, $this->cache[$filename]);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class CachingUncoveredFileAnalyser extends \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\Cache implements \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser
{
    private \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser $uncoveredFileAnalyser;
    public function __construct(string $directory, \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser $uncoveredFileAnalyser)
    {
        parent::__construct($directory);
        $this->uncoveredFileAnalyser = $uncoveredFileAnalyser;
    }
    public function executableLinesIn(string $filename) : array
    {
        if ($this->has($filename, __METHOD__)) {
            return $this->read($filename, __METHOD__);
        }
        $data = $this->uncoveredFileAnalyser->executableLinesIn($filename);
        $this->write($filename, __METHOD__, $data);
        return $data;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use function implode;
use function rtrim;
use function trim;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Identifier;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\NullableType;
use PHPUnit\PhpParser\Node\Stmt\Class_;
use PHPUnit\PhpParser\Node\Stmt\ClassMethod;
use PHPUnit\PhpParser\Node\Stmt\Function_;
use PHPUnit\PhpParser\Node\Stmt\Interface_;
use PHPUnit\PhpParser\Node\Stmt\Trait_;
use PHPUnit\PhpParser\Node\UnionType;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\NodeVisitorAbstract;
use PHPUnit\SebastianBergmann\Complexity\CyclomaticComplexityCalculatingVisitor;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class CodeUnitFindingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    private array $classes = [];
    private array $traits = [];
    private array $functions = [];
    public function enterNode(\PHPUnit\PhpParser\Node $node) : void
    {
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Class_) {
            if ($node->isAnonymous()) {
                return;
            }
            $this->processClass($node);
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Trait_) {
            $this->processTrait($node);
        }
        if (!$node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod && !$node instanceof \PHPUnit\PhpParser\Node\Stmt\Function_) {
            return;
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod) {
            $parentNode = $node->getAttribute('parent');
            if ($parentNode instanceof \PHPUnit\PhpParser\Node\Stmt\Class_ && $parentNode->isAnonymous()) {
                return;
            }
            $this->processMethod($node);
            return;
        }
        $this->processFunction($node);
    }
    public function classes() : array
    {
        return $this->classes;
    }
    public function traits() : array
    {
        return $this->traits;
    }
    public function functions() : array
    {
        return $this->functions;
    }
    /**
     * @psalm-param ClassMethod|Function_ $node
     */
    private function cyclomaticComplexity(\PHPUnit\PhpParser\Node $node) : int
    {
        \assert($node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Function_);
        $nodes = $node->getStmts();
        if ($nodes === null) {
            return 0;
        }
        $traverser = new \PHPUnit\PhpParser\NodeTraverser();
        $cyclomaticComplexityCalculatingVisitor = new \PHPUnit\SebastianBergmann\Complexity\CyclomaticComplexityCalculatingVisitor();
        $traverser->addVisitor($cyclomaticComplexityCalculatingVisitor);
        /* @noinspection UnusedFunctionResultInspection */
        $traverser->traverse($nodes);
        return $cyclomaticComplexityCalculatingVisitor->cyclomaticComplexity();
    }
    /**
     * @psalm-param ClassMethod|Function_ $node
     */
    private function signature(\PHPUnit\PhpParser\Node $node) : string
    {
        \assert($node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Function_);
        $signature = ($node->returnsByRef() ? '&' : '') . $node->name->toString() . '(';
        $parameters = [];
        foreach ($node->getParams() as $parameter) {
            \assert(isset($parameter->var->name));
            $parameterAsString = '';
            if ($parameter->type !== null) {
                $parameterAsString = $this->type($parameter->type) . ' ';
            }
            $parameterAsString .= '$' . $parameter->var->name;
            /* @todo Handle default values */
            $parameters[] = $parameterAsString;
        }
        $signature .= \implode(', ', $parameters) . ')';
        $returnType = $node->getReturnType();
        if ($returnType !== null) {
            $signature .= ': ' . $this->type($returnType);
        }
        return $signature;
    }
    /**
     * @psalm-param Identifier|Name|NullableType|UnionType $type
     */
    private function type(\PHPUnit\PhpParser\Node $type) : string
    {
        \assert($type instanceof \PHPUnit\PhpParser\Node\Identifier || $type instanceof \PHPUnit\PhpParser\Node\Name || $type instanceof \PHPUnit\PhpParser\Node\NullableType || $type instanceof \PHPUnit\PhpParser\Node\UnionType);
        if ($type instanceof \PHPUnit\PhpParser\Node\NullableType) {
            return '?' . $type->type;
        }
        if ($type instanceof \PHPUnit\PhpParser\Node\UnionType) {
            $types = [];
            foreach ($type->types as $_type) {
                $types[] = $_type->toString();
            }
            return \implode('|', $types);
        }
        return $type->toString();
    }
    private function visibility(\PHPUnit\PhpParser\Node\Stmt\ClassMethod $node) : string
    {
        if ($node->isPrivate()) {
            return 'private';
        }
        if ($node->isProtected()) {
            return 'protected';
        }
        return 'public';
    }
    private function processClass(\PHPUnit\PhpParser\Node\Stmt\Class_ $node) : void
    {
        $name = $node->name->toString();
        $namespacedName = $node->namespacedName->toString();
        $this->classes[$namespacedName] = ['name' => $name, 'namespacedName' => $namespacedName, 'namespace' => $this->namespace($namespacedName, $name), 'startLine' => $node->getStartLine(), 'endLine' => $node->getEndLine(), 'methods' => []];
    }
    private function processTrait(\PHPUnit\PhpParser\Node\Stmt\Trait_ $node) : void
    {
        $name = $node->name->toString();
        $namespacedName = $node->namespacedName->toString();
        $this->traits[$namespacedName] = ['name' => $name, 'namespacedName' => $namespacedName, 'namespace' => $this->namespace($namespacedName, $name), 'startLine' => $node->getStartLine(), 'endLine' => $node->getEndLine(), 'methods' => []];
    }
    private function processMethod(\PHPUnit\PhpParser\Node\Stmt\ClassMethod $node) : void
    {
        $parentNode = $node->getAttribute('parent');
        if ($parentNode instanceof \PHPUnit\PhpParser\Node\Stmt\Interface_) {
            return;
        }
        \assert($parentNode instanceof \PHPUnit\PhpParser\Node\Stmt\Class_ || $parentNode instanceof \PHPUnit\PhpParser\Node\Stmt\Trait_);
        \assert(isset($parentNode->name));
        \assert(isset($parentNode->namespacedName));
        \assert($parentNode->namespacedName instanceof \PHPUnit\PhpParser\Node\Name);
        $parentName = $parentNode->name->toString();
        $parentNamespacedName = $parentNode->namespacedName->toString();
        if ($parentNode instanceof \PHPUnit\PhpParser\Node\Stmt\Class_) {
            $storage =& $this->classes;
        } else {
            $storage =& $this->traits;
        }
        if (!isset($storage[$parentNamespacedName])) {
            $storage[$parentNamespacedName] = ['name' => $parentName, 'namespacedName' => $parentNamespacedName, 'namespace' => $this->namespace($parentNamespacedName, $parentName), 'startLine' => $parentNode->getStartLine(), 'endLine' => $parentNode->getEndLine(), 'methods' => []];
        }
        $storage[$parentNamespacedName]['methods'][$node->name->toString()] = ['methodName' => $node->name->toString(), 'signature' => $this->signature($node), 'visibility' => $this->visibility($node), 'startLine' => $node->getStartLine(), 'endLine' => $node->getEndLine(), 'ccn' => $this->cyclomaticComplexity($node)];
    }
    private function processFunction(\PHPUnit\PhpParser\Node\Stmt\Function_ $node) : void
    {
        \assert(isset($node->name));
        \assert(isset($node->namespacedName));
        \assert($node->namespacedName instanceof \PHPUnit\PhpParser\Node\Name);
        $name = $node->name->toString();
        $namespacedName = $node->namespacedName->toString();
        $this->functions[$namespacedName] = ['name' => $name, 'namespacedName' => $namespacedName, 'namespace' => $this->namespace($namespacedName, $name), 'signature' => $this->signature($node), 'startLine' => $node->getStartLine(), 'endLine' => $node->getEndLine(), 'ccn' => $this->cyclomaticComplexity($node)];
    }
    private function namespace(string $namespacedName, string $name) : string
    {
        return \trim(\rtrim($namespacedName, $name), '\\');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
interface CoveredFileAnalyser
{
    public function classesIn(string $filename) : array;
    public function traitsIn(string $filename) : array;
    public function functionsIn(string $filename) : array;
    public function linesOfCodeFor(string $filename) : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
    public function ignoredLinesFor(string $filename) : array;
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use function array_unique;
use function sort;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt\Break_;
use PHPUnit\PhpParser\Node\Stmt\Case_;
use PHPUnit\PhpParser\Node\Stmt\Catch_;
use PHPUnit\PhpParser\Node\Stmt\Continue_;
use PHPUnit\PhpParser\Node\Stmt\Do_;
use PHPUnit\PhpParser\Node\Stmt\Echo_;
use PHPUnit\PhpParser\Node\Stmt\Else_;
use PHPUnit\PhpParser\Node\Stmt\ElseIf_;
use PHPUnit\PhpParser\Node\Stmt\Expression;
use PHPUnit\PhpParser\Node\Stmt\Finally_;
use PHPUnit\PhpParser\Node\Stmt\For_;
use PHPUnit\PhpParser\Node\Stmt\Foreach_;
use PHPUnit\PhpParser\Node\Stmt\Goto_;
use PHPUnit\PhpParser\Node\Stmt\If_;
use PHPUnit\PhpParser\Node\Stmt\Return_;
use PHPUnit\PhpParser\Node\Stmt\Switch_;
use PHPUnit\PhpParser\Node\Stmt\Throw_;
use PHPUnit\PhpParser\Node\Stmt\TryCatch;
use PHPUnit\PhpParser\Node\Stmt\Unset_;
use PHPUnit\PhpParser\Node\Stmt\While_;
use PHPUnit\PhpParser\NodeVisitorAbstract;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class ExecutableLinesFindingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /**
     * @psalm-var list<int>
     */
    private array $executableLines = [];
    public function enterNode(\PHPUnit\PhpParser\Node $node) : void
    {
        if (!$this->isExecutable($node)) {
            return;
        }
        $this->executableLines[] = $node->getStartLine();
    }
    /**
     * @psalm-return list<int>
     */
    public function executableLines() : array
    {
        $executableLines = \array_unique($this->executableLines);
        \sort($executableLines);
        return $executableLines;
    }
    private function isExecutable(\PHPUnit\PhpParser\Node $node) : bool
    {
        return $node instanceof \PHPUnit\PhpParser\Node\Stmt\Break_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Case_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Catch_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Continue_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Do_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Echo_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\ElseIf_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Else_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Expression || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Finally_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Foreach_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\For_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Goto_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\If_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Return_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Switch_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Throw_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\TryCatch || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Unset_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\While_;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use function array_merge;
use function range;
use function strpos;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Stmt\Class_;
use PHPUnit\PhpParser\Node\Stmt\ClassMethod;
use PHPUnit\PhpParser\Node\Stmt\Function_;
use PHPUnit\PhpParser\Node\Stmt\Interface_;
use PHPUnit\PhpParser\Node\Stmt\Trait_;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\NodeVisitorAbstract;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class IgnoredLinesFindingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /**
     * @psalm-var list<int>
     */
    private array $ignoredLines = [];
    private bool $useAnnotationsForIgnoringCode;
    private bool $ignoreDeprecated;
    public function __construct(bool $useAnnotationsForIgnoringCode, bool $ignoreDeprecated)
    {
        $this->useAnnotationsForIgnoringCode = $useAnnotationsForIgnoringCode;
        $this->ignoreDeprecated = $ignoreDeprecated;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node) : ?int
    {
        if (!$node instanceof \PHPUnit\PhpParser\Node\Stmt\Class_ && !$node instanceof \PHPUnit\PhpParser\Node\Stmt\Trait_ && !$node instanceof \PHPUnit\PhpParser\Node\Stmt\Interface_ && !$node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod && !$node instanceof \PHPUnit\PhpParser\Node\Stmt\Function_) {
            return null;
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Class_ && $node->isAnonymous()) {
            return null;
        }
        // Workaround for https://bugs.xdebug.org/view.php?id=1798
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Class_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Trait_ || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Interface_) {
            $this->ignoredLines[] = $node->getStartLine();
        }
        if (!$this->useAnnotationsForIgnoringCode) {
            return null;
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\Interface_) {
            return null;
        }
        $docComment = $node->getDocComment();
        if ($docComment === null) {
            return null;
        }
        if (\strpos($docComment->getText(), '@codeCoverageIgnore') !== \false) {
            $this->ignoredLines = \array_merge($this->ignoredLines, \range($node->getStartLine(), $node->getEndLine()));
        }
        if ($this->ignoreDeprecated && \strpos($docComment->getText(), '@deprecated') !== \false) {
            $this->ignoredLines = \array_merge($this->ignoredLines, \range($node->getStartLine(), $node->getEndLine()));
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod || $node instanceof \PHPUnit\PhpParser\Node\Stmt\Function_) {
            return \PHPUnit\PhpParser\NodeTraverser::DONT_TRAVERSE_CHILDREN;
        }
        return null;
    }
    /**
     * @psalm-return list<int>
     */
    public function ignoredLines() : array
    {
        return $this->ignoredLines;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use function array_unique;
use function assert;
use function file_get_contents;
use function is_array;
use function sprintf;
use function substr_count;
use function token_get_all;
use function trim;
use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Lexer;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\NodeVisitor\NameResolver;
use PHPUnit\PhpParser\NodeVisitor\ParentConnectingVisitor;
use PHPUnit\PhpParser\ParserFactory;
use PHPUnit\SebastianBergmann\CodeCoverage\ParserException;
use PHPUnit\SebastianBergmann\LinesOfCode\LineCountingVisitor;
use PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class ParsingCoveredFileAnalyser implements \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CoveredFileAnalyser
{
    private array $classes = [];
    private array $traits = [];
    private array $functions = [];
    /**
     * @var array<string,LinesOfCode>
     */
    private array $linesOfCode = [];
    private array $ignoredLines = [];
    private bool $useAnnotationsForIgnoringCode;
    private bool $ignoreDeprecatedCode;
    public function __construct(bool $useAnnotationsForIgnoringCode, bool $ignoreDeprecatedCode)
    {
        $this->useAnnotationsForIgnoringCode = $useAnnotationsForIgnoringCode;
        $this->ignoreDeprecatedCode = $ignoreDeprecatedCode;
    }
    public function classesIn(string $filename) : array
    {
        $this->analyse($filename);
        return $this->classes[$filename];
    }
    public function traitsIn(string $filename) : array
    {
        $this->analyse($filename);
        return $this->traits[$filename];
    }
    public function functionsIn(string $filename) : array
    {
        $this->analyse($filename);
        return $this->functions[$filename];
    }
    public function linesOfCodeFor(string $filename) : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        $this->analyse($filename);
        return $this->linesOfCode[$filename];
    }
    public function ignoredLinesFor(string $filename) : array
    {
        $this->analyse($filename);
        return $this->ignoredLines[$filename];
    }
    /**
     * @throws ParserException
     */
    private function analyse(string $filename) : void
    {
        if (isset($this->classes[$filename])) {
            return;
        }
        $source = \file_get_contents($filename);
        $linesOfCode = \substr_count($source, "\n");
        if ($linesOfCode === 0 && !empty($source)) {
            $linesOfCode = 1;
        }
        $parser = (new \PHPUnit\PhpParser\ParserFactory())->create(\PHPUnit\PhpParser\ParserFactory::PREFER_PHP7, new \PHPUnit\PhpParser\Lexer());
        try {
            $nodes = $parser->parse($source);
            \assert($nodes !== null);
            $traverser = new \PHPUnit\PhpParser\NodeTraverser();
            $codeUnitFindingVisitor = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CodeUnitFindingVisitor();
            $lineCountingVisitor = new \PHPUnit\SebastianBergmann\LinesOfCode\LineCountingVisitor($linesOfCode);
            $ignoredLinesFindingVisitor = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\IgnoredLinesFindingVisitor($this->useAnnotationsForIgnoringCode, $this->ignoreDeprecatedCode);
            $traverser->addVisitor(new \PHPUnit\PhpParser\NodeVisitor\NameResolver());
            $traverser->addVisitor(new \PHPUnit\PhpParser\NodeVisitor\ParentConnectingVisitor());
            $traverser->addVisitor($codeUnitFindingVisitor);
            $traverser->addVisitor($lineCountingVisitor);
            $traverser->addVisitor($ignoredLinesFindingVisitor);
            /* @noinspection UnusedFunctionResultInspection */
            $traverser->traverse($nodes);
            // @codeCoverageIgnoreStart
        } catch (\PHPUnit\PhpParser\Error $error) {
            throw new \PHPUnit\SebastianBergmann\CodeCoverage\ParserException(\sprintf('Cannot parse %s: %s', $filename, $error->getMessage()), (int) $error->getCode(), $error);
        }
        // @codeCoverageIgnoreEnd
        $this->classes[$filename] = $codeUnitFindingVisitor->classes();
        $this->traits[$filename] = $codeUnitFindingVisitor->traits();
        $this->functions[$filename] = $codeUnitFindingVisitor->functions();
        $this->linesOfCode[$filename] = $lineCountingVisitor->result();
        $this->ignoredLines[$filename] = [];
        $this->findLinesIgnoredByLineBasedAnnotations($filename, $source, $this->useAnnotationsForIgnoringCode);
        $this->ignoredLines[$filename] = \array_unique(\array_merge($this->ignoredLines[$filename], $ignoredLinesFindingVisitor->ignoredLines()));
        \sort($this->ignoredLines[$filename]);
    }
    private function findLinesIgnoredByLineBasedAnnotations(string $filename, string $source, bool $useAnnotationsForIgnoringCode) : void
    {
        $ignore = \false;
        $stop = \false;
        foreach (\token_get_all($source) as $token) {
            if (!\is_array($token)) {
                continue;
            }
            switch ($token[0]) {
                case \T_COMMENT:
                case \T_DOC_COMMENT:
                    if (!$useAnnotationsForIgnoringCode) {
                        break;
                    }
                    $comment = \trim($token[1]);
                    if ($comment === '// @codeCoverageIgnore' || $comment === '//@codeCoverageIgnore') {
                        $ignore = \true;
                        $stop = \true;
                    } elseif ($comment === '// @codeCoverageIgnoreStart' || $comment === '//@codeCoverageIgnoreStart') {
                        $ignore = \true;
                    } elseif ($comment === '// @codeCoverageIgnoreEnd' || $comment === '//@codeCoverageIgnoreEnd') {
                        $stop = \true;
                    }
                    break;
            }
            if ($ignore) {
                $this->ignoredLines[$filename][] = $token[2];
                if ($stop) {
                    $ignore = \false;
                    $stop = \false;
                }
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Lexer;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\ParserFactory;
/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
final class ParsingUncoveredFileAnalyser implements \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\UncoveredFileAnalyser
{
    public function executableLinesIn(string $filename) : array
    {
        $parser = (new \PHPUnit\PhpParser\ParserFactory())->create(\PHPUnit\PhpParser\ParserFactory::PREFER_PHP7, new \PHPUnit\PhpParser\Lexer());
        try {
            $nodes = $parser->parse(\file_get_contents($filename));
            \assert($nodes !== null);
            $traverser = new \PHPUnit\PhpParser\NodeTraverser();
            $visitor = new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\ExecutableLinesFindingVisitor();
            $traverser->addVisitor($visitor);
            /* @noinspection UnusedFunctionResultInspection */
            $traverser->traverse($nodes);
            return $visitor->executableLines();
            // @codeCoverageIgnoreStart
        } catch (\PHPUnit\PhpParser\Error $error) {
        }
        // @codeCoverageIgnoreEnd
        return [];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis;

/**
 * @internal This class is not covered by the backward compatibility promise for phpunit/php-code-coverage
 */
interface UncoveredFileAnalyser
{
    public function executableLinesIn(string $filename) : array;
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-code-coverage.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeCoverage;

use function dirname;
use PHPUnit\SebastianBergmann\Version as VersionId;
final class Version
{
    private static string $version = '';
    public static function id() : string
    {
        if (self::$version === '') {
            self::$version = (new \PHPUnit\SebastianBergmann\Version('10.0', \dirname(__DIR__)))->getVersion();
        }
        return self::$version;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-file-iterator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\FileIterator;

use const DIRECTORY_SEPARATOR;
use function array_unique;
use function count;
use function dirname;
use function explode;
use function is_file;
use function is_string;
use function realpath;
use function sort;
class Facade
{
    /**
     * @param array|string $paths
     * @param array|string $suffixes
     * @param array|string $prefixes
     */
    public function getFilesAsArray($paths, $suffixes = '', $prefixes = '', array $exclude = [], bool $commonPath = \false) : array
    {
        if (\is_string($paths)) {
            $paths = [$paths];
        }
        $iterator = (new \PHPUnit\SebastianBergmann\FileIterator\Factory())->getFileIterator($paths, $suffixes, $prefixes, $exclude);
        $files = [];
        foreach ($iterator as $file) {
            $file = $file->getRealPath();
            if ($file) {
                $files[] = $file;
            }
        }
        foreach ($paths as $path) {
            if (\is_file($path)) {
                $files[] = \realpath($path);
            }
        }
        $files = \array_unique($files);
        \sort($files);
        if ($commonPath) {
            return ['commonPath' => $this->getCommonPath($files), 'files' => $files];
        }
        return $files;
    }
    protected function getCommonPath(array $files) : string
    {
        $count = \count($files);
        if ($count === 0) {
            return '';
        }
        if ($count === 1) {
            return \dirname($files[0]) . \DIRECTORY_SEPARATOR;
        }
        $_files = [];
        foreach ($files as $file) {
            $_files[] = $_fileParts = \explode(\DIRECTORY_SEPARATOR, $file);
            if (empty($_fileParts[0])) {
                $_fileParts[0] = \DIRECTORY_SEPARATOR;
            }
        }
        $common = '';
        $done = \false;
        $j = 0;
        $count--;
        while (!$done) {
            for ($i = 0; $i < $count; $i++) {
                if ($_files[$i][$j] != $_files[$i + 1][$j]) {
                    $done = \true;
                    break;
                }
            }
            if (!$done) {
                $common .= $_files[0][$j];
                if ($j > 0) {
                    $common .= \DIRECTORY_SEPARATOR;
                }
            }
            $j++;
        }
        return \DIRECTORY_SEPARATOR . $common;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-file-iterator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\FileIterator;

use const GLOB_ONLYDIR;
use function array_filter;
use function array_map;
use function array_merge;
use function glob;
use function is_dir;
use function is_string;
use function realpath;
use AppendIterator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
class Factory
{
    /**
     * @param array|string $paths
     * @param array|string $suffixes
     * @param array|string $prefixes
     */
    public function getFileIterator($paths, $suffixes = '', $prefixes = '', array $exclude = []) : \AppendIterator
    {
        if (\is_string($paths)) {
            $paths = [$paths];
        }
        $paths = $this->getPathsAfterResolvingWildcards($paths);
        $exclude = $this->getPathsAfterResolvingWildcards($exclude);
        if (\is_string($prefixes)) {
            if ($prefixes !== '') {
                $prefixes = [$prefixes];
            } else {
                $prefixes = [];
            }
        }
        if (\is_string($suffixes)) {
            if ($suffixes !== '') {
                $suffixes = [$suffixes];
            } else {
                $suffixes = [];
            }
        }
        $iterator = new \AppendIterator();
        foreach ($paths as $path) {
            if (\is_dir($path)) {
                $iterator->append(new \PHPUnit\SebastianBergmann\FileIterator\Iterator($path, new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::FOLLOW_SYMLINKS | \RecursiveDirectoryIterator::SKIP_DOTS)), $suffixes, $prefixes, $exclude));
            }
        }
        return $iterator;
    }
    protected function getPathsAfterResolvingWildcards(array $paths) : array
    {
        $_paths = [];
        foreach ($paths as $path) {
            if ($locals = \glob($path, \GLOB_ONLYDIR)) {
                $_paths = \array_merge($_paths, \array_map('\\realpath', $locals));
            } else {
                $_paths[] = \realpath($path);
            }
        }
        return \array_filter($_paths);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-file-iterator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\FileIterator;

use function array_filter;
use function array_map;
use function preg_match;
use function realpath;
use function str_replace;
use function strlen;
use function strpos;
use function substr;
use FilterIterator;
class Iterator extends \FilterIterator
{
    public const PREFIX = 0;
    public const SUFFIX = 1;
    /**
     * @var string
     */
    private $basePath;
    /**
     * @var array
     */
    private $suffixes = [];
    /**
     * @var array
     */
    private $prefixes = [];
    /**
     * @var array
     */
    private $exclude = [];
    public function __construct(string $basePath, \Iterator $iterator, array $suffixes = [], array $prefixes = [], array $exclude = [])
    {
        $this->basePath = \realpath($basePath);
        $this->prefixes = $prefixes;
        $this->suffixes = $suffixes;
        $this->exclude = \array_filter(\array_map('realpath', $exclude));
        parent::__construct($iterator);
    }
    public function accept() : bool
    {
        $current = $this->getInnerIterator()->current();
        $filename = $current->getFilename();
        $realPath = $current->getRealPath();
        if ($realPath === \false) {
            return \false;
        }
        return $this->acceptPath($realPath) && $this->acceptPrefix($filename) && $this->acceptSuffix($filename);
    }
    private function acceptPath(string $path) : bool
    {
        // Filter files in hidden directories by checking path that is relative to the base path.
        if (\preg_match('=/\\.[^/]*/=', \str_replace($this->basePath, '', $path))) {
            return \false;
        }
        foreach ($this->exclude as $exclude) {
            if (\strpos($path, $exclude) === 0) {
                return \false;
            }
        }
        return \true;
    }
    private function acceptPrefix(string $filename) : bool
    {
        return $this->acceptSubString($filename, $this->prefixes, self::PREFIX);
    }
    private function acceptSuffix(string $filename) : bool
    {
        return $this->acceptSubString($filename, $this->suffixes, self::SUFFIX);
    }
    private function acceptSubString(string $filename, array $subStrings, int $type) : bool
    {
        if (empty($subStrings)) {
            return \true;
        }
        $matched = \false;
        foreach ($subStrings as $string) {
            if ($type === self::PREFIX && \strpos($filename, $string) === 0 || $type === self::SUFFIX && \substr($filename, -1 * \strlen($string)) === $string) {
                $matched = \true;
                break;
            }
        }
        return $matched;
    }
}
php-file-iterator

Copyright (c) 2009-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-invoker.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Invoker;

use const SIGALRM;
use function call_user_func_array;
use function function_exists;
use function pcntl_alarm;
use function pcntl_async_signals;
use function pcntl_signal;
use function sprintf;
use Throwable;
final class Invoker
{
    /**
     * @var int
     */
    private $timeout;
    /**
     * @throws Throwable
     */
    public function invoke(callable $callable, array $arguments, int $timeout)
    {
        if (!$this->canInvokeWithTimeout()) {
            throw new \PHPUnit\SebastianBergmann\Invoker\ProcessControlExtensionNotLoadedException('The pcntl (process control) extension for PHP is required');
        }
        \pcntl_signal(\SIGALRM, function () : void {
            throw new \PHPUnit\SebastianBergmann\Invoker\TimeoutException(\sprintf('Execution aborted after %d second%s', $this->timeout, $this->timeout === 1 ? '' : 's'));
        }, \true);
        $this->timeout = $timeout;
        \pcntl_async_signals(\true);
        \pcntl_alarm($timeout);
        try {
            return \call_user_func_array($callable, $arguments);
        } finally {
            \pcntl_alarm(0);
        }
    }
    public function canInvokeWithTimeout() : bool
    {
        return \function_exists('pcntl_signal') && \function_exists('pcntl_async_signals') && \function_exists('pcntl_alarm');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-invoker.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Invoker;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-invoker.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Invoker;

use RuntimeException;
final class ProcessControlExtensionNotLoadedException extends \RuntimeException implements \PHPUnit\SebastianBergmann\Invoker\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-invoker.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Invoker;

use RuntimeException;
final class TimeoutException extends \RuntimeException implements \PHPUnit\SebastianBergmann\Invoker\Exception
{
}
phpunit/php-text-template

Copyright (c) 2009-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-text-template.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Template;

use function array_merge;
use function file_exists;
use function file_get_contents;
use function file_put_contents;
use function sprintf;
use function str_replace;
final class Template
{
    /**
     * @var string
     */
    private $template = '';
    /**
     * @var string
     */
    private $openDelimiter;
    /**
     * @var string
     */
    private $closeDelimiter;
    /**
     * @var array
     */
    private $values = [];
    /**
     * @throws InvalidArgumentException
     */
    public function __construct(string $file = '', string $openDelimiter = '{', string $closeDelimiter = '}')
    {
        $this->setFile($file);
        $this->openDelimiter = $openDelimiter;
        $this->closeDelimiter = $closeDelimiter;
    }
    /**
     * @throws InvalidArgumentException
     */
    public function setFile(string $file) : void
    {
        $distFile = $file . '.dist';
        if (\file_exists($file)) {
            $this->template = \file_get_contents($file);
        } elseif (\file_exists($distFile)) {
            $this->template = \file_get_contents($distFile);
        } else {
            throw new \PHPUnit\SebastianBergmann\Template\InvalidArgumentException(\sprintf('Failed to load template "%s"', $file));
        }
    }
    public function setVar(array $values, bool $merge = \true) : void
    {
        if (!$merge || empty($this->values)) {
            $this->values = $values;
        } else {
            $this->values = \array_merge($this->values, $values);
        }
    }
    public function render() : string
    {
        $keys = [];
        foreach ($this->values as $key => $value) {
            $keys[] = $this->openDelimiter . $key . $this->closeDelimiter;
        }
        return \str_replace($keys, $this->values, $this->template);
    }
    /**
     * @codeCoverageIgnore
     */
    public function renderTo(string $target) : void
    {
        if (!\file_put_contents($target, $this->render())) {
            throw new \PHPUnit\SebastianBergmann\Template\RuntimeException(\sprintf('Writing rendered result to "%s" failed', $target));
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-text-template.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Template;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-text-template.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Template;

final class InvalidArgumentException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\Template\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-text-template.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Template;

use InvalidArgumentException;
final class RuntimeException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\Template\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-timer.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Timer;

use function floor;
use function sprintf;
/**
 * @psalm-immutable
 */
final class Duration
{
    /**
     * @var float
     */
    private $nanoseconds;
    /**
     * @var int
     */
    private $hours;
    /**
     * @var int
     */
    private $minutes;
    /**
     * @var int
     */
    private $seconds;
    /**
     * @var int
     */
    private $milliseconds;
    public static function fromMicroseconds(float $microseconds) : self
    {
        return new self($microseconds * 1000);
    }
    public static function fromNanoseconds(float $nanoseconds) : self
    {
        return new self($nanoseconds);
    }
    private function __construct(float $nanoseconds)
    {
        $this->nanoseconds = $nanoseconds;
        $timeInMilliseconds = $nanoseconds / 1000000;
        $hours = \floor($timeInMilliseconds / 60 / 60 / 1000);
        $hoursInMilliseconds = $hours * 60 * 60 * 1000;
        $minutes = \floor($timeInMilliseconds / 60 / 1000) % 60;
        $minutesInMilliseconds = $minutes * 60 * 1000;
        $seconds = \floor(($timeInMilliseconds - $hoursInMilliseconds - $minutesInMilliseconds) / 1000);
        $secondsInMilliseconds = $seconds * 1000;
        $milliseconds = $timeInMilliseconds - $hoursInMilliseconds - $minutesInMilliseconds - $secondsInMilliseconds;
        $this->hours = (int) $hours;
        $this->minutes = $minutes;
        $this->seconds = (int) $seconds;
        $this->milliseconds = (int) $milliseconds;
    }
    public function asNanoseconds() : float
    {
        return $this->nanoseconds;
    }
    public function asMicroseconds() : float
    {
        return $this->nanoseconds / 1000;
    }
    public function asMilliseconds() : float
    {
        return $this->nanoseconds / 1000000;
    }
    public function asSeconds() : float
    {
        return $this->nanoseconds / 1000000000;
    }
    public function asString() : string
    {
        $result = '';
        if ($this->hours > 0) {
            $result = \sprintf('%02d', $this->hours) . ':';
        }
        $result .= \sprintf('%02d', $this->minutes) . ':';
        $result .= \sprintf('%02d', $this->seconds);
        if ($this->milliseconds > 0) {
            $result .= '.' . \sprintf('%03d', $this->milliseconds);
        }
        return $result;
    }
}
phpunit/php-timer

Copyright (c) 2010-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-timer.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Timer;

use function is_float;
use function memory_get_peak_usage;
use function microtime;
use function sprintf;
final class ResourceUsageFormatter
{
    /**
     * @psalm-var array<string,int>
     */
    private const SIZES = ['GB' => 1073741824, 'MB' => 1048576, 'KB' => 1024];
    public function resourceUsage(\PHPUnit\SebastianBergmann\Timer\Duration $duration) : string
    {
        return \sprintf('Time: %s, Memory: %s', $duration->asString(), $this->bytesToString(\memory_get_peak_usage(\true)));
    }
    /**
     * @throws TimeSinceStartOfRequestNotAvailableException
     */
    public function resourceUsageSinceStartOfRequest() : string
    {
        if (!isset($_SERVER['REQUEST_TIME_FLOAT'])) {
            throw new \PHPUnit\SebastianBergmann\Timer\TimeSinceStartOfRequestNotAvailableException('Cannot determine time at which the request started because $_SERVER[\'REQUEST_TIME_FLOAT\'] is not available');
        }
        if (!\is_float($_SERVER['REQUEST_TIME_FLOAT'])) {
            throw new \PHPUnit\SebastianBergmann\Timer\TimeSinceStartOfRequestNotAvailableException('Cannot determine time at which the request started because $_SERVER[\'REQUEST_TIME_FLOAT\'] is not of type float');
        }
        return $this->resourceUsage(\PHPUnit\SebastianBergmann\Timer\Duration::fromMicroseconds(1000000 * (\microtime(\true) - $_SERVER['REQUEST_TIME_FLOAT'])));
    }
    private function bytesToString(int $bytes) : string
    {
        foreach (self::SIZES as $unit => $value) {
            if ($bytes >= $value) {
                return \sprintf('%.2f %s', $bytes >= 1024 ? $bytes / $value : $bytes, $unit);
            }
        }
        // @codeCoverageIgnoreStart
        return $bytes . ' byte' . ($bytes !== 1 ? 's' : '');
        // @codeCoverageIgnoreEnd
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-timer.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Timer;

use function array_pop;
use function hrtime;
final class Timer
{
    /**
     * @psalm-var list<float>
     */
    private $startTimes = [];
    public function start() : void
    {
        $this->startTimes[] = (float) \hrtime(\true);
    }
    /**
     * @throws NoActiveTimerException
     */
    public function stop() : \PHPUnit\SebastianBergmann\Timer\Duration
    {
        if (empty($this->startTimes)) {
            throw new \PHPUnit\SebastianBergmann\Timer\NoActiveTimerException('Timer::start() has to be called before Timer::stop()');
        }
        return \PHPUnit\SebastianBergmann\Timer\Duration::fromNanoseconds((float) \hrtime(\true) - \array_pop($this->startTimes));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-timer.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Timer;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-timer.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Timer;

use LogicException;
final class NoActiveTimerException extends \LogicException implements \PHPUnit\SebastianBergmann\Timer\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of phpunit/php-timer.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Timer;

use RuntimeException;
final class TimeSinceStartOfRequestNotAvailableException extends \RuntimeException implements \PHPUnit\SebastianBergmann\Timer\Exception
{
}
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:annotation>
        <xs:documentation source="https://phpunit.de/documentation.html">
            This Schema file defines the rules by which the XML configuration file of PHPUnit 10.0 may be structured.
        </xs:documentation>
        <xs:appinfo source="https://phpunit.de/documentation.html"/>
    </xs:annotation>
    <xs:element name="phpunit" type="phpUnitType">
        <xs:annotation>
            <xs:documentation>Root Element</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="coverageType">
        <xs:all>
            <xs:element name="include" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:group ref="pathGroup"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="exclude" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:group ref="pathGroup"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="report" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:group ref="coverageReportGroup"/>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="cacheDirectory" type="xs:anyURI"/>
        <xs:attribute name="pathCoverage" type="xs:boolean" default="false"/>
        <xs:attribute name="includeUncoveredFiles" type="xs:boolean" default="true"/>
        <xs:attribute name="ignoreDeprecatedCodeUnits" type="xs:boolean" default="false"/>
        <xs:attribute name="disableCodeCoverageIgnore" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:complexType name="loggingType">
        <xs:group ref="loggingGroup"/>
    </xs:complexType>
    <xs:complexType name="groupsType">
        <xs:choice>
            <xs:sequence>
                <xs:element name="include" type="groupType"/>
                <xs:element name="exclude" type="groupType" minOccurs="0"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element name="exclude" type="groupType"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="groupType">
        <xs:sequence>
            <xs:element name="group" type="xs:string" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="extensionsType">
        <xs:sequence>
            <xs:element name="extension" type="objectType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="objectType">
        <xs:sequence>
            <xs:element name="arguments" minOccurs="0">
                <xs:complexType>
                    <xs:group ref="argumentsGroup"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="class" type="xs:string" use="required"/>
        <xs:attribute name="file" type="xs:anyURI"/>
    </xs:complexType>
    <xs:complexType name="arrayType">
        <xs:sequence>
            <xs:element name="element" type="argumentType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="argumentType">
        <xs:group ref="argumentChoice"/>
        <xs:attribute name="key" use="required"/>
    </xs:complexType>
    <xs:group name="argumentsGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="array" type="arrayType" />
                <xs:element name="integer" type="xs:integer" />
                <xs:element name="string" type="xs:string" />
                <xs:element name="double" type="xs:double" />
                <xs:element name="null" />
                <xs:element name="object" type="objectType" />
                <xs:element name="file" type="xs:anyURI" />
                <xs:element name="directory" type="xs:anyURI" />
                <xs:element name="boolean" type="xs:boolean" />
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:group name="argumentChoice">
        <xs:choice>
            <xs:element name="array" type="arrayType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="integer" type="xs:integer" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="string" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="double" type="xs:double" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="null" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="object" type="objectType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="file" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="directory" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="boolean" type="xs:boolean" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
    </xs:group>
    <xs:simpleType name="columnsType">
        <xs:union>
            <xs:simpleType>
                <xs:restriction base="xs:integer"/>
            </xs:simpleType>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="max"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    <xs:group name="pathGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="directory" type="directoryFilterType"/>
                <xs:element name="file" type="fileFilterType"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="directoryFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attribute type="xs:string" name="prefix" default=""/>
                <xs:attribute type="xs:string" name="suffix" default="Test.php"/>
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:simpleType name="executionOrderType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default"/>
            <xs:enumeration value="defects"/>
            <xs:enumeration value="depends"/>
            <xs:enumeration value="depends,defects"/>
            <xs:enumeration value="depends,duration"/>
            <xs:enumeration value="depends,random"/>
            <xs:enumeration value="depends,reverse"/>
            <xs:enumeration value="depends,size"/>
            <xs:enumeration value="duration"/>
            <xs:enumeration value="no-depends"/>
            <xs:enumeration value="no-depends,defects"/>
            <xs:enumeration value="no-depends,duration"/>
            <xs:enumeration value="no-depends,random"/>
            <xs:enumeration value="no-depends,reverse"/>
            <xs:enumeration value="no-depends,size"/>
            <xs:enumeration value="random"/>
            <xs:enumeration value="reverse"/>
            <xs:enumeration value="size"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="fileFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="phpVersionGroup">
        <xs:attribute name="phpVersion" type="xs:string" default="5.3.0"/>
        <xs:attribute name="phpVersionOperator" type="xs:string" default="&gt;="/>
    </xs:attributeGroup>
    <xs:complexType name="phpType">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="includePath" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="ini" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="const" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="var" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="env" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="post" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="get" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="cookie" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="server" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="files" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="request" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="namedValueType">
        <xs:attribute name="name" use="required" type="xs:string"/>
        <xs:attribute name="value" use="required" type="xs:anySimpleType"/>
        <xs:attribute name="verbatim" use="optional" type="xs:boolean"/>
        <xs:attribute name="force" use="optional" type="xs:boolean"/>
    </xs:complexType>
    <xs:complexType name="phpUnitType">
        <xs:annotation>
            <xs:documentation>The main type specifying the document structure</xs:documentation>
        </xs:annotation>
        <xs:group ref="configGroup"/>
        <xs:attributeGroup ref="configAttributeGroup"/>
    </xs:complexType>
    <xs:attributeGroup name="configAttributeGroup">
        <xs:attribute name="backupGlobals" type="xs:boolean" default="false"/>
        <xs:attribute name="backupStaticProperties" type="xs:boolean" default="false"/>
        <xs:attribute name="bootstrap" type="xs:anyURI"/>
        <xs:attribute name="cacheDirectory" type="xs:anyURI"/>
        <xs:attribute name="cacheResult" type="xs:boolean" default="true"/>
        <xs:attribute name="cacheResultFile" type="xs:anyURI"/>
        <xs:attribute name="colors" type="xs:boolean" default="false"/>
        <xs:attribute name="columns" type="columnsType" default="80"/>
        <xs:attribute name="convertDeprecationsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertErrorsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertNoticesToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertWarningsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="forceCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="printerClass" type="xs:string" default="PHPUnit\TextUI\DefaultResultPrinter"/>
        <xs:attribute name="printerFile" type="xs:anyURI"/>
        <xs:attribute name="processIsolation" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnDefect" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnError" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnFailure" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnIncomplete" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnSkipped" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnEmptyTestSuite" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnIncomplete" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnSkipped" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutChangesToGlobalState" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutOutputDuringTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutResourceUsageDuringSmallTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutTestsThatDoNotTestAnything" type="xs:boolean" default="true"/>
        <xs:attribute name="beStrictAboutTodoAnnotatedTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="defaultTimeLimit" type="xs:integer" default="0"/>
        <xs:attribute name="enforceTimeLimit" type="xs:boolean" default="false"/>
        <xs:attribute name="timeoutForSmallTests" type="xs:integer" default="1"/>
        <xs:attribute name="timeoutForMediumTests" type="xs:integer" default="10"/>
        <xs:attribute name="timeoutForLargeTests" type="xs:integer" default="60"/>
        <xs:attribute name="defaultTestSuite" type="xs:string" default=""/>
        <xs:attribute name="verbose" type="xs:boolean" default="false"/>
        <xs:attribute name="testdox" type="xs:boolean" default="false"/>
        <xs:attribute name="stderr" type="xs:boolean" default="false"/>
        <xs:attribute name="reverseDefectList" type="xs:boolean" default="false"/>
        <xs:attribute name="registerMockObjectsFromTestArgumentsRecursively" type="xs:boolean" default="false"/>
        <xs:attribute name="extensionsDirectory" type="xs:string"/>
        <xs:attribute name="executionOrder" type="executionOrderType" default="default"/>
        <xs:attribute name="resolveDependencies" type="xs:boolean" default="true"/>
        <xs:attribute name="noInteraction" type="xs:boolean" default="false"/>
    </xs:attributeGroup>
    <xs:group name="configGroup">
        <xs:all>
            <xs:element ref="testSuiteFacet" minOccurs="0"/>
            <xs:element name="groups" type="groupsType" minOccurs="0"/>
            <xs:element name="testdoxGroups" type="groupsType" minOccurs="0"/>
            <xs:element name="coverage" type="coverageType" minOccurs="0"/>
            <xs:element name="logging" type="loggingType" minOccurs="0"/>
            <xs:element name="extensions" type="extensionsType" minOccurs="0"/>
            <xs:element name="php" type="phpType" minOccurs="0"/>
        </xs:all>
    </xs:group>
    <xs:element name="testSuiteFacet" abstract="true"/>
    <xs:element name="testsuite" type="testSuiteType" substitutionGroup="testSuiteFacet"/>
    <xs:element name="testsuites" type="testSuitesType" substitutionGroup="testSuiteFacet"/>
    <xs:complexType name="testSuitesType">
        <xs:sequence>
            <xs:element name="testsuite" type="testSuiteType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="testSuiteType">
        <xs:sequence>
            <xs:group ref="pathGroup"/>
            <xs:element name="exclude" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required"/>
    </xs:complexType>
    <xs:group name="coverageReportGroup">
        <xs:all>
            <xs:element name="clover" type="logToFileType" minOccurs="0"/>
            <xs:element name="cobertura" type="logToFileType" minOccurs="0"/>
            <xs:element name="crap4j" type="coverageReportCrap4JType" minOccurs="0" />
            <xs:element name="html" type="coverageReportHtmlType" minOccurs="0" />
            <xs:element name="php" type="logToFileType" minOccurs="0" />
            <xs:element name="text" type="coverageReportTextType" minOccurs="0" />
            <xs:element name="xml" type="logToDirectoryType" minOccurs="0" />
        </xs:all>
    </xs:group>
    <xs:group name="loggingGroup">
        <xs:all>
            <xs:element name="junit" type="logToFileType" minOccurs="0" />
            <xs:element name="teamcity" type="logToFileType" minOccurs="0" />
            <xs:element name="testdoxHtml" type="logToFileType" minOccurs="0" />
            <xs:element name="testdoxText" type="logToFileType" minOccurs="0" />
            <xs:element name="testdoxXml" type="logToFileType" minOccurs="0" />
            <xs:element name="text" type="logToFileType" minOccurs="0"/>
        </xs:all>
    </xs:group>
    <xs:complexType name="logToFileType">
        <xs:attribute name="outputFile" type="xs:anyURI" use="required"/>
    </xs:complexType>
    <xs:complexType name="logToDirectoryType">
        <xs:attribute name="outputDirectory" type="xs:anyURI" use="required"/>
    </xs:complexType>
    <xs:complexType name="coverageReportCrap4JType">
        <xs:attribute name="outputFile" type="xs:anyURI" use="required"/>
        <xs:attribute name="threshold" type="xs:integer"/>
    </xs:complexType>
    <xs:complexType name="coverageReportHtmlType">
        <xs:attribute name="outputDirectory" type="xs:anyURI" use="required"/>
        <xs:attribute name="lowUpperBound" type="xs:integer" default="50"/>
        <xs:attribute name="highLowerBound" type="xs:integer" default="90"/>
    </xs:complexType>
    <xs:complexType name="coverageReportTextType">
        <xs:attribute name="outputFile" type="xs:anyURI" use="required"/>
        <xs:attribute name="showUncoveredFiles" type="xs:boolean" default="false"/>
        <xs:attribute name="showOnlySummary" type="xs:boolean" default="false"/>
    </xs:complexType>
</xs:schema>
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit;

use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const DEBUG_BACKTRACE_IGNORE_ARGS;
use const PHP_EOL;
use function array_shift;
use function array_unshift;
use function class_exists;
use function count;
use function debug_backtrace;
use function explode;
use function file_get_contents;
use function func_get_args;
use function implode;
use function interface_exists;
use function is_array;
use function is_bool;
use function is_int;
use function is_iterable;
use function is_object;
use function is_string;
use function preg_match;
use function preg_split;
use function strpos;
use ArrayAccess;
use Countable;
use Generator;
use PHPUnit\Framework\Constraint\ArrayHasKey;
use PHPUnit\Framework\Constraint\Callback;
use PHPUnit\Framework\Constraint\ClassHasAttribute;
use PHPUnit\Framework\Constraint\ClassHasStaticAttribute;
use PHPUnit\Framework\Constraint\Constraint;
use PHPUnit\Framework\Constraint\Count;
use PHPUnit\Framework\Constraint\DirectoryExists;
use PHPUnit\Framework\Constraint\FileExists;
use PHPUnit\Framework\Constraint\GreaterThan;
use PHPUnit\Framework\Constraint\IsAnything;
use PHPUnit\Framework\Constraint\IsEmpty;
use PHPUnit\Framework\Constraint\IsEqual;
use PHPUnit\Framework\Constraint\IsEqualCanonicalizing;
use PHPUnit\Framework\Constraint\IsEqualIgnoringCase;
use PHPUnit\Framework\Constraint\IsEqualWithDelta;
use PHPUnit\Framework\Constraint\IsFalse;
use PHPUnit\Framework\Constraint\IsFinite;
use PHPUnit\Framework\Constraint\IsIdentical;
use PHPUnit\Framework\Constraint\IsInfinite;
use PHPUnit\Framework\Constraint\IsInstanceOf;
use PHPUnit\Framework\Constraint\IsJson;
use PHPUnit\Framework\Constraint\IsNan;
use PHPUnit\Framework\Constraint\IsNull;
use PHPUnit\Framework\Constraint\IsReadable;
use PHPUnit\Framework\Constraint\IsTrue;
use PHPUnit\Framework\Constraint\IsType;
use PHPUnit\Framework\Constraint\IsWritable;
use PHPUnit\Framework\Constraint\JsonMatches;
use PHPUnit\Framework\Constraint\LessThan;
use PHPUnit\Framework\Constraint\LogicalAnd;
use PHPUnit\Framework\Constraint\LogicalNot;
use PHPUnit\Framework\Constraint\LogicalOr;
use PHPUnit\Framework\Constraint\LogicalXor;
use PHPUnit\Framework\Constraint\ObjectEquals;
use PHPUnit\Framework\Constraint\ObjectHasAttribute;
use PHPUnit\Framework\Constraint\RegularExpression;
use PHPUnit\Framework\Constraint\SameSize;
use PHPUnit\Framework\Constraint\StringContains;
use PHPUnit\Framework\Constraint\StringEndsWith;
use PHPUnit\Framework\Constraint\StringMatchesFormatDescription;
use PHPUnit\Framework\Constraint\StringStartsWith;
use PHPUnit\Framework\Constraint\TraversableContainsEqual;
use PHPUnit\Framework\Constraint\TraversableContainsIdentical;
use PHPUnit\Framework\Constraint\TraversableContainsOnly;
use PHPUnit\Util\Type;
use PHPUnit\Util\Warning as WarningUtil;
use PHPUnit\Util\Xml\Loader as XmlLoader;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
abstract class Assert
{
    private static int $count = 0;
    /**
     * Asserts that an array has a specified key.
     *
     * @param int|string        $key
     * @param array|ArrayAccess $array
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertArrayHasKey($key, $array, string $message = '') : void
    {
        if (!(\is_int($key) || \is_string($key))) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'integer or string');
        }
        if (!(\is_array($array) || $array instanceof \ArrayAccess)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'array or ArrayAccess');
        }
        $constraint = new \PHPUnit\Framework\Constraint\ArrayHasKey($key);
        static::assertThat($array, $constraint, $message);
    }
    /**
     * Asserts that an array does not have a specified key.
     *
     * @param int|string        $key
     * @param array|ArrayAccess $array
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertArrayNotHasKey($key, $array, string $message = '') : void
    {
        if (!(\is_int($key) || \is_string($key))) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'integer or string');
        }
        if (!(\is_array($array) || $array instanceof \ArrayAccess)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'array or ArrayAccess');
        }
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\ArrayHasKey($key));
        static::assertThat($array, $constraint, $message);
    }
    /**
     * Asserts that a haystack contains a needle.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertContains($needle, iterable $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\TraversableContainsIdentical($needle);
        static::assertThat($haystack, $constraint, $message);
    }
    public static function assertContainsEquals($needle, iterable $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\TraversableContainsEqual($needle);
        static::assertThat($haystack, $constraint, $message);
    }
    /**
     * Asserts that a haystack does not contain a needle.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertNotContains($needle, iterable $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\TraversableContainsIdentical($needle));
        static::assertThat($haystack, $constraint, $message);
    }
    public static function assertNotContainsEquals($needle, iterable $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\TraversableContainsEqual($needle));
        static::assertThat($haystack, $constraint, $message);
    }
    /**
     * Asserts that a haystack contains only values of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertContainsOnly(string $type, iterable $haystack, ?bool $isNativeType = null, string $message = '') : void
    {
        if ($isNativeType === null) {
            $isNativeType = \PHPUnit\Util\Type::isType($type);
        }
        static::assertThat($haystack, new \PHPUnit\Framework\Constraint\TraversableContainsOnly($type, $isNativeType), $message);
    }
    /**
     * Asserts that a haystack contains only instances of a given class name.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertContainsOnlyInstancesOf(string $className, iterable $haystack, string $message = '') : void
    {
        static::assertThat($haystack, new \PHPUnit\Framework\Constraint\TraversableContainsOnly($className, \false), $message);
    }
    /**
     * Asserts that a haystack does not contain only values of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertNotContainsOnly(string $type, iterable $haystack, ?bool $isNativeType = null, string $message = '') : void
    {
        if ($isNativeType === null) {
            $isNativeType = \PHPUnit\Util\Type::isType($type);
        }
        static::assertThat($haystack, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\TraversableContainsOnly($type, $isNativeType)), $message);
    }
    /**
     * Asserts the number of elements of an array, Countable or Traversable.
     *
     * @param Countable|iterable $haystack
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertCount(int $expectedCount, $haystack, string $message = '') : void
    {
        if (!$haystack instanceof \Countable && !\is_iterable($haystack)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'countable or iterable');
        }
        if ($haystack instanceof \Generator) {
            (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('Passing an argument of type Generator for the $haystack parameter is deprecated. Support for this will be removed in PHPUnit 11.');
        }
        static::assertThat($haystack, new \PHPUnit\Framework\Constraint\Count($expectedCount), $message);
    }
    /**
     * Asserts the number of elements of an array, Countable or Traversable.
     *
     * @param Countable|iterable $haystack
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertNotCount(int $expectedCount, $haystack, string $message = '') : void
    {
        if (!$haystack instanceof \Countable && !\is_iterable($haystack)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'countable or iterable');
        }
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\Count($expectedCount));
        static::assertThat($haystack, $constraint, $message);
    }
    /**
     * Asserts that two variables are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertEquals($expected, $actual, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\IsEqual($expected);
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * Asserts that two variables are equal (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertEqualsCanonicalizing($expected, $actual, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\IsEqualCanonicalizing($expected);
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * Asserts that two variables are equal (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertEqualsIgnoringCase($expected, $actual, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\IsEqualIgnoringCase($expected);
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * Asserts that two variables are equal (with delta).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertEqualsWithDelta($expected, $actual, float $delta, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\IsEqualWithDelta($expected, $delta);
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * Asserts that two variables are not equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertNotEquals($expected, $actual, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqual($expected));
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * Asserts that two variables are not equal (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertNotEqualsCanonicalizing($expected, $actual, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqualCanonicalizing($expected));
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * Asserts that two variables are not equal (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertNotEqualsIgnoringCase($expected, $actual, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqualIgnoringCase($expected));
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * Asserts that two variables are not equal (with delta).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertNotEqualsWithDelta($expected, $actual, float $delta, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqualWithDelta($expected, $delta));
        static::assertThat($actual, $constraint, $message);
    }
    /**
     * @throws ExpectationFailedException
     */
    public static function assertObjectEquals(object $expected, object $actual, string $method = 'equals', string $message = '') : void
    {
        static::assertThat($actual, static::objectEquals($expected, $method), $message);
    }
    /**
     * Asserts that a variable is empty.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert empty $actual
     */
    public static function assertEmpty($actual, string $message = '') : void
    {
        static::assertThat($actual, static::isEmpty(), $message);
    }
    /**
     * Asserts that a variable is not empty.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !empty $actual
     */
    public static function assertNotEmpty($actual, string $message = '') : void
    {
        static::assertThat($actual, static::logicalNot(static::isEmpty()), $message);
    }
    /**
     * Asserts that a value is greater than another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertGreaterThan($expected, $actual, string $message = '') : void
    {
        static::assertThat($actual, static::greaterThan($expected), $message);
    }
    /**
     * Asserts that a value is greater than or equal to another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertGreaterThanOrEqual($expected, $actual, string $message = '') : void
    {
        static::assertThat($actual, static::greaterThanOrEqual($expected), $message);
    }
    /**
     * Asserts that a value is smaller than another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertLessThan($expected, $actual, string $message = '') : void
    {
        static::assertThat($actual, static::lessThan($expected), $message);
    }
    /**
     * Asserts that a value is smaller than or equal to another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertLessThanOrEqual($expected, $actual, string $message = '') : void
    {
        static::assertThat($actual, static::lessThanOrEqual($expected), $message);
    }
    /**
     * Asserts that the contents of one file is equal to the contents of another
     * file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileEquals(string $expected, string $actual, string $message = '') : void
    {
        static::assertFileExists($expected, $message);
        static::assertFileExists($actual, $message);
        $constraint = new \PHPUnit\Framework\Constraint\IsEqual(\file_get_contents($expected));
        static::assertThat(\file_get_contents($actual), $constraint, $message);
    }
    /**
     * Asserts that the contents of one file is equal to the contents of another
     * file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileEqualsCanonicalizing(string $expected, string $actual, string $message = '') : void
    {
        static::assertFileExists($expected, $message);
        static::assertFileExists($actual, $message);
        $constraint = new \PHPUnit\Framework\Constraint\IsEqualCanonicalizing(\file_get_contents($expected));
        static::assertThat(\file_get_contents($actual), $constraint, $message);
    }
    /**
     * Asserts that the contents of one file is equal to the contents of another
     * file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileEqualsIgnoringCase(string $expected, string $actual, string $message = '') : void
    {
        static::assertFileExists($expected, $message);
        static::assertFileExists($actual, $message);
        $constraint = new \PHPUnit\Framework\Constraint\IsEqualIgnoringCase(\file_get_contents($expected));
        static::assertThat(\file_get_contents($actual), $constraint, $message);
    }
    /**
     * Asserts that the contents of one file is not equal to the contents of
     * another file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileNotEquals(string $expected, string $actual, string $message = '') : void
    {
        static::assertFileExists($expected, $message);
        static::assertFileExists($actual, $message);
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqual(\file_get_contents($expected)));
        static::assertThat(\file_get_contents($actual), $constraint, $message);
    }
    /**
     * Asserts that the contents of one file is not equal to the contents of another
     * file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileNotEqualsCanonicalizing(string $expected, string $actual, string $message = '') : void
    {
        static::assertFileExists($expected, $message);
        static::assertFileExists($actual, $message);
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqualCanonicalizing(\file_get_contents($expected)));
        static::assertThat(\file_get_contents($actual), $constraint, $message);
    }
    /**
     * Asserts that the contents of one file is not equal to the contents of another
     * file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileNotEqualsIgnoringCase(string $expected, string $actual, string $message = '') : void
    {
        static::assertFileExists($expected, $message);
        static::assertFileExists($actual, $message);
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqualIgnoringCase(\file_get_contents($expected)));
        static::assertThat(\file_get_contents($actual), $constraint, $message);
    }
    /**
     * Asserts that the contents of a string is equal
     * to the contents of a file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringEqualsFile(string $expectedFile, string $actualString, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $constraint = new \PHPUnit\Framework\Constraint\IsEqual(\file_get_contents($expectedFile));
        static::assertThat($actualString, $constraint, $message);
    }
    /**
     * Asserts that the contents of a string is equal
     * to the contents of a file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringEqualsFileCanonicalizing(string $expectedFile, string $actualString, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $constraint = new \PHPUnit\Framework\Constraint\IsEqualCanonicalizing(\file_get_contents($expectedFile));
        static::assertThat($actualString, $constraint, $message);
    }
    /**
     * Asserts that the contents of a string is equal
     * to the contents of a file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringEqualsFileIgnoringCase(string $expectedFile, string $actualString, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $constraint = new \PHPUnit\Framework\Constraint\IsEqualIgnoringCase(\file_get_contents($expectedFile));
        static::assertThat($actualString, $constraint, $message);
    }
    /**
     * Asserts that the contents of a string is not equal
     * to the contents of a file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringNotEqualsFile(string $expectedFile, string $actualString, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqual(\file_get_contents($expectedFile)));
        static::assertThat($actualString, $constraint, $message);
    }
    /**
     * Asserts that the contents of a string is not equal
     * to the contents of a file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringNotEqualsFileCanonicalizing(string $expectedFile, string $actualString, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqualCanonicalizing(\file_get_contents($expectedFile)));
        static::assertThat($actualString, $constraint, $message);
    }
    /**
     * Asserts that the contents of a string is not equal
     * to the contents of a file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringNotEqualsFileIgnoringCase(string $expectedFile, string $actualString, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsEqualIgnoringCase(\file_get_contents($expectedFile)));
        static::assertThat($actualString, $constraint, $message);
    }
    /**
     * Asserts that a file/dir is readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertIsReadable(string $filename, string $message = '') : void
    {
        static::assertThat($filename, new \PHPUnit\Framework\Constraint\IsReadable(), $message);
    }
    /**
     * Asserts that a file/dir exists and is not readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertIsNotReadable(string $filename, string $message = '') : void
    {
        static::assertThat($filename, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsReadable()), $message);
    }
    /**
     * Asserts that a file/dir exists and is writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertIsWritable(string $filename, string $message = '') : void
    {
        static::assertThat($filename, new \PHPUnit\Framework\Constraint\IsWritable(), $message);
    }
    /**
     * Asserts that a file/dir exists and is not writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertIsNotWritable(string $filename, string $message = '') : void
    {
        static::assertThat($filename, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsWritable()), $message);
    }
    /**
     * Asserts that a directory exists.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertDirectoryExists(string $directory, string $message = '') : void
    {
        static::assertThat($directory, new \PHPUnit\Framework\Constraint\DirectoryExists(), $message);
    }
    /**
     * Asserts that a directory does not exist.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertDirectoryDoesNotExist(string $directory, string $message = '') : void
    {
        static::assertThat($directory, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\DirectoryExists()), $message);
    }
    /**
     * Asserts that a directory exists and is readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertDirectoryIsReadable(string $directory, string $message = '') : void
    {
        self::assertDirectoryExists($directory, $message);
        self::assertIsReadable($directory, $message);
    }
    /**
     * Asserts that a directory exists and is not readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertDirectoryIsNotReadable(string $directory, string $message = '') : void
    {
        self::assertDirectoryExists($directory, $message);
        self::assertIsNotReadable($directory, $message);
    }
    /**
     * Asserts that a directory exists and is writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertDirectoryIsWritable(string $directory, string $message = '') : void
    {
        self::assertDirectoryExists($directory, $message);
        self::assertIsWritable($directory, $message);
    }
    /**
     * Asserts that a directory exists and is not writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertDirectoryIsNotWritable(string $directory, string $message = '') : void
    {
        self::assertDirectoryExists($directory, $message);
        self::assertIsNotWritable($directory, $message);
    }
    /**
     * Asserts that a file exists.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileExists(string $filename, string $message = '') : void
    {
        static::assertThat($filename, new \PHPUnit\Framework\Constraint\FileExists(), $message);
    }
    /**
     * Asserts that a file does not exist.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileDoesNotExist(string $filename, string $message = '') : void
    {
        static::assertThat($filename, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\FileExists()), $message);
    }
    /**
     * Asserts that a file exists and is readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileIsReadable(string $file, string $message = '') : void
    {
        self::assertFileExists($file, $message);
        self::assertIsReadable($file, $message);
    }
    /**
     * Asserts that a file exists and is not readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileIsNotReadable(string $file, string $message = '') : void
    {
        self::assertFileExists($file, $message);
        self::assertIsNotReadable($file, $message);
    }
    /**
     * Asserts that a file exists and is writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileIsWritable(string $file, string $message = '') : void
    {
        self::assertFileExists($file, $message);
        self::assertIsWritable($file, $message);
    }
    /**
     * Asserts that a file exists and is not writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFileIsNotWritable(string $file, string $message = '') : void
    {
        self::assertFileExists($file, $message);
        self::assertIsNotWritable($file, $message);
    }
    /**
     * Asserts that a condition is true.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert true $condition
     */
    public static function assertTrue($condition, string $message = '') : void
    {
        static::assertThat($condition, static::isTrue(), $message);
    }
    /**
     * Asserts that a condition is not true.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !true $condition
     */
    public static function assertNotTrue($condition, string $message = '') : void
    {
        static::assertThat($condition, static::logicalNot(static::isTrue()), $message);
    }
    /**
     * Asserts that a condition is false.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert false $condition
     */
    public static function assertFalse($condition, string $message = '') : void
    {
        static::assertThat($condition, static::isFalse(), $message);
    }
    /**
     * Asserts that a condition is not false.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !false $condition
     */
    public static function assertNotFalse($condition, string $message = '') : void
    {
        static::assertThat($condition, static::logicalNot(static::isFalse()), $message);
    }
    /**
     * Asserts that a variable is null.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert null $actual
     */
    public static function assertNull($actual, string $message = '') : void
    {
        static::assertThat($actual, static::isNull(), $message);
    }
    /**
     * Asserts that a variable is not null.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !null $actual
     */
    public static function assertNotNull($actual, string $message = '') : void
    {
        static::assertThat($actual, static::logicalNot(static::isNull()), $message);
    }
    /**
     * Asserts that a variable is finite.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertFinite($actual, string $message = '') : void
    {
        static::assertThat($actual, static::isFinite(), $message);
    }
    /**
     * Asserts that a variable is infinite.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertInfinite($actual, string $message = '') : void
    {
        static::assertThat($actual, static::isInfinite(), $message);
    }
    /**
     * Asserts that a variable is nan.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertNan($actual, string $message = '') : void
    {
        static::assertThat($actual, static::isNan(), $message);
    }
    /**
     * Asserts that a class has a specified attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function assertClassHasAttribute(string $attributeName, string $className, string $message = '') : void
    {
        if (!self::isValidClassAttributeName($attributeName)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'valid attribute name');
        }
        if (!\class_exists($className)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'class name');
        }
        (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('assertClassHasAttribute() is deprecated and will be removed in PHPUnit 11.');
        static::assertThat($className, new \PHPUnit\Framework\Constraint\ClassHasAttribute($attributeName), $message);
    }
    /**
     * Asserts that a class does not have a specified attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function assertClassNotHasAttribute(string $attributeName, string $className, string $message = '') : void
    {
        if (!self::isValidClassAttributeName($attributeName)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'valid attribute name');
        }
        if (!\class_exists($className)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'class name');
        }
        (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('assertClassHasAttribute() is deprecated and will be removed in PHPUnit 11.');
        static::assertThat($className, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\ClassHasAttribute($attributeName)), $message);
    }
    /**
     * Asserts that a class has a specified static attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function assertClassHasStaticAttribute(string $attributeName, string $className, string $message = '') : void
    {
        if (!self::isValidClassAttributeName($attributeName)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'valid attribute name');
        }
        if (!\class_exists($className)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'class name');
        }
        (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('assertClassHasAttribute() is deprecated and will be removed in PHPUnit 11.');
        static::assertThat($className, new \PHPUnit\Framework\Constraint\ClassHasStaticAttribute($attributeName), $message);
    }
    /**
     * Asserts that a class does not have a specified static attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function assertClassNotHasStaticAttribute(string $attributeName, string $className, string $message = '') : void
    {
        if (!self::isValidClassAttributeName($attributeName)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'valid attribute name');
        }
        if (!\class_exists($className)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'class name');
        }
        (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('assertClassHasAttribute() is deprecated and will be removed in PHPUnit 11.');
        static::assertThat($className, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\ClassHasStaticAttribute($attributeName)), $message);
    }
    /**
     * Asserts that an object has a specified attribute.
     *
     * @param object $object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function assertObjectHasAttribute(string $attributeName, $object, string $message = '') : void
    {
        if (!self::isValidObjectAttributeName($attributeName)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'valid attribute name');
        }
        if (!\is_object($object)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'object');
        }
        (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('assertClassHasAttribute() is deprecated and will be removed in PHPUnit 11.');
        static::assertThat($object, new \PHPUnit\Framework\Constraint\ObjectHasAttribute($attributeName), $message);
    }
    /**
     * Asserts that an object does not have a specified attribute.
     *
     * @param object $object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function assertObjectNotHasAttribute(string $attributeName, $object, string $message = '') : void
    {
        if (!self::isValidObjectAttributeName($attributeName)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'valid attribute name');
        }
        if (!\is_object($object)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'object');
        }
        (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('assertClassHasAttribute() is deprecated and will be removed in PHPUnit 11.');
        static::assertThat($object, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\ObjectHasAttribute($attributeName)), $message);
    }
    /**
     * Asserts that two variables have the same type and value.
     * Used on objects, it asserts that two variables reference
     * the same object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-template ExpectedType
     * @psalm-param ExpectedType $expected
     * @psalm-assert =ExpectedType $actual
     */
    public static function assertSame($expected, $actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsIdentical($expected), $message);
    }
    /**
     * Asserts that two variables do not have the same type and value.
     * Used on objects, it asserts that two variables do not reference
     * the same object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertNotSame($expected, $actual, string $message = '') : void
    {
        if (\is_bool($expected) && \is_bool($actual)) {
            static::assertNotEquals($expected, $actual, $message);
        }
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsIdentical($expected)), $message);
    }
    /**
     * Asserts that a variable is of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @psalm-template ExpectedType of object
     * @psalm-param class-string<ExpectedType> $expected
     * @psalm-assert =ExpectedType $actual
     */
    public static function assertInstanceOf(string $expected, $actual, string $message = '') : void
    {
        if (!\class_exists($expected) && !\interface_exists($expected)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'class or interface name');
        }
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsInstanceOf($expected), $message);
    }
    /**
     * Asserts that a variable is not of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @psalm-template ExpectedType of object
     * @psalm-param class-string<ExpectedType> $expected
     * @psalm-assert !ExpectedType $actual
     */
    public static function assertNotInstanceOf(string $expected, $actual, string $message = '') : void
    {
        if (!\class_exists($expected) && !\interface_exists($expected)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'class or interface name');
        }
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsInstanceOf($expected)), $message);
    }
    /**
     * Asserts that a variable is of type array.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert array $actual
     */
    public static function assertIsArray($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_ARRAY), $message);
    }
    /**
     * Asserts that a variable is of type bool.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert bool $actual
     */
    public static function assertIsBool($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_BOOL), $message);
    }
    /**
     * Asserts that a variable is of type float.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert float $actual
     */
    public static function assertIsFloat($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_FLOAT), $message);
    }
    /**
     * Asserts that a variable is of type int.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert int $actual
     */
    public static function assertIsInt($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_INT), $message);
    }
    /**
     * Asserts that a variable is of type numeric.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert numeric $actual
     */
    public static function assertIsNumeric($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_NUMERIC), $message);
    }
    /**
     * Asserts that a variable is of type object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert object $actual
     */
    public static function assertIsObject($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_OBJECT), $message);
    }
    /**
     * Asserts that a variable is of type resource.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert resource $actual
     */
    public static function assertIsResource($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_RESOURCE), $message);
    }
    /**
     * Asserts that a variable is of type resource and is closed.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert resource $actual
     */
    public static function assertIsClosedResource($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_CLOSED_RESOURCE), $message);
    }
    /**
     * Asserts that a variable is of type string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert string $actual
     */
    public static function assertIsString($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_STRING), $message);
    }
    /**
     * Asserts that a variable is of type scalar.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert scalar $actual
     */
    public static function assertIsScalar($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_SCALAR), $message);
    }
    /**
     * Asserts that a variable is of type callable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert callable $actual
     */
    public static function assertIsCallable($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_CALLABLE), $message);
    }
    /**
     * Asserts that a variable is of type iterable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert iterable $actual
     */
    public static function assertIsIterable($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_ITERABLE), $message);
    }
    /**
     * Asserts that a variable is not of type array.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !array $actual
     */
    public static function assertIsNotArray($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_ARRAY)), $message);
    }
    /**
     * Asserts that a variable is not of type bool.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !bool $actual
     */
    public static function assertIsNotBool($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_BOOL)), $message);
    }
    /**
     * Asserts that a variable is not of type float.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !float $actual
     */
    public static function assertIsNotFloat($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_FLOAT)), $message);
    }
    /**
     * Asserts that a variable is not of type int.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !int $actual
     */
    public static function assertIsNotInt($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_INT)), $message);
    }
    /**
     * Asserts that a variable is not of type numeric.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !numeric $actual
     */
    public static function assertIsNotNumeric($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_NUMERIC)), $message);
    }
    /**
     * Asserts that a variable is not of type object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !object $actual
     */
    public static function assertIsNotObject($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_OBJECT)), $message);
    }
    /**
     * Asserts that a variable is not of type resource.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !resource $actual
     */
    public static function assertIsNotResource($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_RESOURCE)), $message);
    }
    /**
     * Asserts that a variable is not of type resource.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !resource $actual
     */
    public static function assertIsNotClosedResource($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_CLOSED_RESOURCE)), $message);
    }
    /**
     * Asserts that a variable is not of type string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !string $actual
     */
    public static function assertIsNotString($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_STRING)), $message);
    }
    /**
     * Asserts that a variable is not of type scalar.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !scalar $actual
     */
    public static function assertIsNotScalar($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_SCALAR)), $message);
    }
    /**
     * Asserts that a variable is not of type callable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !callable $actual
     */
    public static function assertIsNotCallable($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_CALLABLE)), $message);
    }
    /**
     * Asserts that a variable is not of type iterable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !iterable $actual
     */
    public static function assertIsNotIterable($actual, string $message = '') : void
    {
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\IsType(\PHPUnit\Framework\Constraint\IsType::TYPE_ITERABLE)), $message);
    }
    /**
     * Asserts that a string matches a given regular expression.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertMatchesRegularExpression(string $pattern, string $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\RegularExpression($pattern), $message);
    }
    /**
     * Asserts that a string does not match a given regular expression.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertDoesNotMatchRegularExpression(string $pattern, string $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\RegularExpression($pattern)), $message);
    }
    /**
     * Assert that the size of two arrays (or `Countable` or `Traversable` objects)
     * is the same.
     *
     * @param Countable|iterable $expected
     * @param Countable|iterable $actual
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertSameSize($expected, $actual, string $message = '') : void
    {
        if (!$expected instanceof \Countable && !\is_iterable($expected)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'countable or iterable');
        }
        if (!$actual instanceof \Countable && !\is_iterable($actual)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'countable or iterable');
        }
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\SameSize($expected), $message);
    }
    /**
     * Assert that the size of two arrays (or `Countable` or `Traversable` objects)
     * is not the same.
     *
     * @param Countable|iterable $expected
     * @param Countable|iterable $actual
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertNotSameSize($expected, $actual, string $message = '') : void
    {
        if (!$expected instanceof \Countable && !\is_iterable($expected)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'countable or iterable');
        }
        if (!$actual instanceof \Countable && !\is_iterable($actual)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'countable or iterable');
        }
        static::assertThat($actual, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\SameSize($expected)), $message);
    }
    /**
     * Asserts that a string matches a given format string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringMatchesFormat(string $format, string $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\StringMatchesFormatDescription($format), $message);
    }
    /**
     * Asserts that a string does not match a given format string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringNotMatchesFormat(string $format, string $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\StringMatchesFormatDescription($format)), $message);
    }
    /**
     * Asserts that a string matches a given format file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringMatchesFormatFile(string $formatFile, string $string, string $message = '') : void
    {
        static::assertFileExists($formatFile, $message);
        static::assertThat($string, new \PHPUnit\Framework\Constraint\StringMatchesFormatDescription(\file_get_contents($formatFile)), $message);
    }
    /**
     * Asserts that a string does not match a given format string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringNotMatchesFormatFile(string $formatFile, string $string, string $message = '') : void
    {
        static::assertFileExists($formatFile, $message);
        static::assertThat($string, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\StringMatchesFormatDescription(\file_get_contents($formatFile))), $message);
    }
    /**
     * Asserts that a string starts with a given prefix.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringStartsWith(string $prefix, string $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\StringStartsWith($prefix), $message);
    }
    /**
     * Asserts that a string starts not with a given prefix.
     *
     * @param string $prefix
     * @param string $string
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringStartsNotWith($prefix, $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\StringStartsWith($prefix)), $message);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringContainsString(string $needle, string $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\StringContains($needle, \false);
        static::assertThat($haystack, $constraint, $message);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringContainsStringIgnoringCase(string $needle, string $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\StringContains($needle, \true);
        static::assertThat($haystack, $constraint, $message);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringNotContainsString(string $needle, string $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\StringContains($needle));
        static::assertThat($haystack, $constraint, $message);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringNotContainsStringIgnoringCase(string $needle, string $haystack, string $message = '') : void
    {
        $constraint = new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\StringContains($needle, \true));
        static::assertThat($haystack, $constraint, $message);
    }
    /**
     * Asserts that a string ends with a given suffix.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringEndsWith(string $suffix, string $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\StringEndsWith($suffix), $message);
    }
    /**
     * Asserts that a string ends not with a given suffix.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertStringEndsNotWith(string $suffix, string $string, string $message = '') : void
    {
        static::assertThat($string, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\StringEndsWith($suffix)), $message);
    }
    /**
     * Asserts that two XML files are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    public static function assertXmlFileEqualsXmlFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        $expected = (new \PHPUnit\Util\Xml\Loader())->loadFile($expectedFile);
        $actual = (new \PHPUnit\Util\Xml\Loader())->loadFile($actualFile);
        static::assertEquals($expected, $actual, $message);
    }
    /**
     * Asserts that two XML files are not equal.
     *
     * @throws \PHPUnit\Util\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertXmlFileNotEqualsXmlFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        $expected = (new \PHPUnit\Util\Xml\Loader())->loadFile($expectedFile);
        $actual = (new \PHPUnit\Util\Xml\Loader())->loadFile($actualFile);
        static::assertNotEquals($expected, $actual, $message);
    }
    /**
     * Asserts that two XML documents are equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertXmlStringEqualsXmlFile(string $expectedFile, string $actualXml, string $message = '') : void
    {
        $expected = (new \PHPUnit\Util\Xml\Loader())->loadFile($expectedFile);
        $actual = (new \PHPUnit\Util\Xml\Loader())->load($actualXml);
        static::assertEquals($expected, $actual, $message);
    }
    /**
     * Asserts that two XML documents are not equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertXmlStringNotEqualsXmlFile(string $expectedFile, string $actualXml, string $message = '') : void
    {
        $expected = (new \PHPUnit\Util\Xml\Loader())->loadFile($expectedFile);
        $actual = (new \PHPUnit\Util\Xml\Loader())->load($actualXml);
        static::assertNotEquals($expected, $actual, $message);
    }
    /**
     * Asserts that two XML documents are equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertXmlStringEqualsXmlString(string $expectedXml, string $actualXml, string $message = '') : void
    {
        $expected = (new \PHPUnit\Util\Xml\Loader())->load($expectedXml);
        $actual = (new \PHPUnit\Util\Xml\Loader())->load($actualXml);
        static::assertEquals($expected, $actual, $message);
    }
    /**
     * Asserts that two XML documents are not equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertXmlStringNotEqualsXmlString(string $expectedXml, string $actualXml, string $message = '') : void
    {
        $expected = (new \PHPUnit\Util\Xml\Loader())->load($expectedXml);
        $actual = (new \PHPUnit\Util\Xml\Loader())->load($actualXml);
        static::assertNotEquals($expected, $actual, $message);
    }
    /**
     * Evaluates a PHPUnit\Framework\Constraint matcher object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertThat($value, \PHPUnit\Framework\Constraint\Constraint $constraint, string $message = '') : void
    {
        self::$count += \count($constraint);
        $constraint->evaluate($value, $message);
    }
    /**
     * Asserts that a string is a valid JSON string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertJson(string $actualJson, string $message = '') : void
    {
        static::assertThat($actualJson, static::isJson(), $message);
    }
    /**
     * Asserts that two given JSON encoded objects or arrays are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertJsonStringEqualsJsonString(string $expectedJson, string $actualJson, string $message = '') : void
    {
        static::assertJson($expectedJson, $message);
        static::assertJson($actualJson, $message);
        static::assertThat($actualJson, new \PHPUnit\Framework\Constraint\JsonMatches($expectedJson), $message);
    }
    /**
     * Asserts that two given JSON encoded objects or arrays are not equal.
     *
     * @param string $expectedJson
     * @param string $actualJson
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertJsonStringNotEqualsJsonString($expectedJson, $actualJson, string $message = '') : void
    {
        static::assertJson($expectedJson, $message);
        static::assertJson($actualJson, $message);
        static::assertThat($actualJson, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\JsonMatches($expectedJson)), $message);
    }
    /**
     * Asserts that the generated JSON encoded object and the content of the given file are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertJsonStringEqualsJsonFile(string $expectedFile, string $actualJson, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $expectedJson = \file_get_contents($expectedFile);
        static::assertJson($expectedJson, $message);
        static::assertJson($actualJson, $message);
        static::assertThat($actualJson, new \PHPUnit\Framework\Constraint\JsonMatches($expectedJson), $message);
    }
    /**
     * Asserts that the generated JSON encoded object and the content of the given file are not equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertJsonStringNotEqualsJsonFile(string $expectedFile, string $actualJson, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        $expectedJson = \file_get_contents($expectedFile);
        static::assertJson($expectedJson, $message);
        static::assertJson($actualJson, $message);
        static::assertThat($actualJson, new \PHPUnit\Framework\Constraint\LogicalNot(new \PHPUnit\Framework\Constraint\JsonMatches($expectedJson)), $message);
    }
    /**
     * Asserts that two JSON files are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertJsonFileEqualsJsonFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        static::assertFileExists($actualFile, $message);
        $actualJson = \file_get_contents($actualFile);
        $expectedJson = \file_get_contents($expectedFile);
        static::assertJson($expectedJson, $message);
        static::assertJson($actualJson, $message);
        $constraintExpected = new \PHPUnit\Framework\Constraint\JsonMatches($expectedJson);
        $constraintActual = new \PHPUnit\Framework\Constraint\JsonMatches($actualJson);
        static::assertThat($expectedJson, $constraintActual, $message);
        static::assertThat($actualJson, $constraintExpected, $message);
    }
    /**
     * Asserts that two JSON files are not equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public static function assertJsonFileNotEqualsJsonFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        static::assertFileExists($expectedFile, $message);
        static::assertFileExists($actualFile, $message);
        $actualJson = \file_get_contents($actualFile);
        $expectedJson = \file_get_contents($expectedFile);
        static::assertJson($expectedJson, $message);
        static::assertJson($actualJson, $message);
        $constraintExpected = new \PHPUnit\Framework\Constraint\JsonMatches($expectedJson);
        $constraintActual = new \PHPUnit\Framework\Constraint\JsonMatches($actualJson);
        static::assertThat($expectedJson, new \PHPUnit\Framework\Constraint\LogicalNot($constraintActual), $message);
        static::assertThat($actualJson, new \PHPUnit\Framework\Constraint\LogicalNot($constraintExpected), $message);
    }
    /**
     * @throws Exception
     */
    public static function logicalAnd() : \PHPUnit\Framework\Constraint\LogicalAnd
    {
        $constraints = \func_get_args();
        $constraint = new \PHPUnit\Framework\Constraint\LogicalAnd();
        $constraint->setConstraints($constraints);
        return $constraint;
    }
    public static function logicalOr() : \PHPUnit\Framework\Constraint\LogicalOr
    {
        $constraints = \func_get_args();
        $constraint = new \PHPUnit\Framework\Constraint\LogicalOr();
        $constraint->setConstraints($constraints);
        return $constraint;
    }
    public static function logicalNot(\PHPUnit\Framework\Constraint\Constraint $constraint) : \PHPUnit\Framework\Constraint\LogicalNot
    {
        return new \PHPUnit\Framework\Constraint\LogicalNot($constraint);
    }
    public static function logicalXor() : \PHPUnit\Framework\Constraint\LogicalXor
    {
        $constraints = \func_get_args();
        $constraint = new \PHPUnit\Framework\Constraint\LogicalXor();
        $constraint->setConstraints($constraints);
        return $constraint;
    }
    public static function anything() : \PHPUnit\Framework\Constraint\IsAnything
    {
        return new \PHPUnit\Framework\Constraint\IsAnything();
    }
    public static function isTrue() : \PHPUnit\Framework\Constraint\IsTrue
    {
        return new \PHPUnit\Framework\Constraint\IsTrue();
    }
    /**
     * @psalm-template CallbackInput of mixed
     *
     * @psalm-param callable(CallbackInput $callback): bool $callback
     *
     * @psalm-return Callback<CallbackInput>
     */
    public static function callback(callable $callback) : \PHPUnit\Framework\Constraint\Callback
    {
        return new \PHPUnit\Framework\Constraint\Callback($callback);
    }
    public static function isFalse() : \PHPUnit\Framework\Constraint\IsFalse
    {
        return new \PHPUnit\Framework\Constraint\IsFalse();
    }
    public static function isJson() : \PHPUnit\Framework\Constraint\IsJson
    {
        return new \PHPUnit\Framework\Constraint\IsJson();
    }
    public static function isNull() : \PHPUnit\Framework\Constraint\IsNull
    {
        return new \PHPUnit\Framework\Constraint\IsNull();
    }
    public static function isFinite() : \PHPUnit\Framework\Constraint\IsFinite
    {
        return new \PHPUnit\Framework\Constraint\IsFinite();
    }
    public static function isInfinite() : \PHPUnit\Framework\Constraint\IsInfinite
    {
        return new \PHPUnit\Framework\Constraint\IsInfinite();
    }
    public static function isNan() : \PHPUnit\Framework\Constraint\IsNan
    {
        return new \PHPUnit\Framework\Constraint\IsNan();
    }
    public static function containsEqual($value) : \PHPUnit\Framework\Constraint\TraversableContainsEqual
    {
        return new \PHPUnit\Framework\Constraint\TraversableContainsEqual($value);
    }
    public static function containsIdentical($value) : \PHPUnit\Framework\Constraint\TraversableContainsIdentical
    {
        return new \PHPUnit\Framework\Constraint\TraversableContainsIdentical($value);
    }
    public static function containsOnly(string $type) : \PHPUnit\Framework\Constraint\TraversableContainsOnly
    {
        return new \PHPUnit\Framework\Constraint\TraversableContainsOnly($type);
    }
    public static function containsOnlyInstancesOf(string $className) : \PHPUnit\Framework\Constraint\TraversableContainsOnly
    {
        return new \PHPUnit\Framework\Constraint\TraversableContainsOnly($className, \false);
    }
    /**
     * @param int|string $key
     */
    public static function arrayHasKey($key) : \PHPUnit\Framework\Constraint\ArrayHasKey
    {
        return new \PHPUnit\Framework\Constraint\ArrayHasKey($key);
    }
    public static function equalTo($value) : \PHPUnit\Framework\Constraint\IsEqual
    {
        return new \PHPUnit\Framework\Constraint\IsEqual($value, 0.0, \false, \false);
    }
    public static function equalToCanonicalizing($value) : \PHPUnit\Framework\Constraint\IsEqualCanonicalizing
    {
        return new \PHPUnit\Framework\Constraint\IsEqualCanonicalizing($value);
    }
    public static function equalToIgnoringCase($value) : \PHPUnit\Framework\Constraint\IsEqualIgnoringCase
    {
        return new \PHPUnit\Framework\Constraint\IsEqualIgnoringCase($value);
    }
    public static function equalToWithDelta($value, float $delta) : \PHPUnit\Framework\Constraint\IsEqualWithDelta
    {
        return new \PHPUnit\Framework\Constraint\IsEqualWithDelta($value, $delta);
    }
    public static function isEmpty() : \PHPUnit\Framework\Constraint\IsEmpty
    {
        return new \PHPUnit\Framework\Constraint\IsEmpty();
    }
    public static function isWritable() : \PHPUnit\Framework\Constraint\IsWritable
    {
        return new \PHPUnit\Framework\Constraint\IsWritable();
    }
    public static function isReadable() : \PHPUnit\Framework\Constraint\IsReadable
    {
        return new \PHPUnit\Framework\Constraint\IsReadable();
    }
    public static function directoryExists() : \PHPUnit\Framework\Constraint\DirectoryExists
    {
        return new \PHPUnit\Framework\Constraint\DirectoryExists();
    }
    public static function fileExists() : \PHPUnit\Framework\Constraint\FileExists
    {
        return new \PHPUnit\Framework\Constraint\FileExists();
    }
    public static function greaterThan($value) : \PHPUnit\Framework\Constraint\GreaterThan
    {
        return new \PHPUnit\Framework\Constraint\GreaterThan($value);
    }
    public static function greaterThanOrEqual($value) : \PHPUnit\Framework\Constraint\LogicalOr
    {
        return static::logicalOr(new \PHPUnit\Framework\Constraint\IsEqual($value), new \PHPUnit\Framework\Constraint\GreaterThan($value));
    }
    /**
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function classHasAttribute(string $attributeName) : \PHPUnit\Framework\Constraint\ClassHasAttribute
    {
        return new \PHPUnit\Framework\Constraint\ClassHasAttribute($attributeName);
    }
    /**
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function classHasStaticAttribute(string $attributeName) : \PHPUnit\Framework\Constraint\ClassHasStaticAttribute
    {
        return new \PHPUnit\Framework\Constraint\ClassHasStaticAttribute($attributeName);
    }
    /**
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     */
    public static function objectHasAttribute($attributeName) : \PHPUnit\Framework\Constraint\ObjectHasAttribute
    {
        return new \PHPUnit\Framework\Constraint\ObjectHasAttribute($attributeName);
    }
    public static function identicalTo($value) : \PHPUnit\Framework\Constraint\IsIdentical
    {
        return new \PHPUnit\Framework\Constraint\IsIdentical($value);
    }
    public static function isInstanceOf(string $className) : \PHPUnit\Framework\Constraint\IsInstanceOf
    {
        return new \PHPUnit\Framework\Constraint\IsInstanceOf($className);
    }
    public static function isType(string $type) : \PHPUnit\Framework\Constraint\IsType
    {
        return new \PHPUnit\Framework\Constraint\IsType($type);
    }
    public static function lessThan($value) : \PHPUnit\Framework\Constraint\LessThan
    {
        return new \PHPUnit\Framework\Constraint\LessThan($value);
    }
    public static function lessThanOrEqual($value) : \PHPUnit\Framework\Constraint\LogicalOr
    {
        return static::logicalOr(new \PHPUnit\Framework\Constraint\IsEqual($value), new \PHPUnit\Framework\Constraint\LessThan($value));
    }
    public static function matchesRegularExpression(string $pattern) : \PHPUnit\Framework\Constraint\RegularExpression
    {
        return new \PHPUnit\Framework\Constraint\RegularExpression($pattern);
    }
    public static function matches(string $string) : \PHPUnit\Framework\Constraint\StringMatchesFormatDescription
    {
        return new \PHPUnit\Framework\Constraint\StringMatchesFormatDescription($string);
    }
    public static function stringStartsWith($prefix) : \PHPUnit\Framework\Constraint\StringStartsWith
    {
        return new \PHPUnit\Framework\Constraint\StringStartsWith($prefix);
    }
    public static function stringContains(string $string, bool $case = \true) : \PHPUnit\Framework\Constraint\StringContains
    {
        return new \PHPUnit\Framework\Constraint\StringContains($string, $case);
    }
    public static function stringEndsWith(string $suffix) : \PHPUnit\Framework\Constraint\StringEndsWith
    {
        return new \PHPUnit\Framework\Constraint\StringEndsWith($suffix);
    }
    public static function countOf(int $count) : \PHPUnit\Framework\Constraint\Count
    {
        return new \PHPUnit\Framework\Constraint\Count($count);
    }
    public static function objectEquals(object $object, string $method = 'equals') : \PHPUnit\Framework\Constraint\ObjectEquals
    {
        return new \PHPUnit\Framework\Constraint\ObjectEquals($object, $method);
    }
    /**
     * Fails a test with the given message.
     *
     * @throws AssertionFailedError
     *
     * @psalm-return never-return
     */
    public static function fail(string $message = '') : void
    {
        self::$count++;
        throw new \PHPUnit\Framework\AssertionFailedError($message);
    }
    /**
     * Mark the test as incomplete.
     *
     * @throws IncompleteTestError
     *
     * @psalm-return never-return
     */
    public static function markTestIncomplete(string $message = '') : void
    {
        throw new \PHPUnit\Framework\IncompleteTestError($message);
    }
    /**
     * Mark the test as skipped.
     *
     * @throws SkippedTestError
     * @throws SyntheticSkippedError
     *
     * @psalm-return never-return
     */
    public static function markTestSkipped(string $message = '') : void
    {
        if ($hint = self::detectLocationHint($message)) {
            $trace = \debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS);
            \array_unshift($trace, $hint);
            throw new \PHPUnit\Framework\SyntheticSkippedError($hint['message'], 0, $hint['file'], (int) $hint['line'], $trace);
        }
        throw new \PHPUnit\Framework\SkippedTestError($message);
    }
    /**
     * Return the current assertion count.
     */
    public static function getCount() : int
    {
        return self::$count;
    }
    /**
     * Reset the assertion counter.
     */
    public static function resetCount() : void
    {
        self::$count = 0;
    }
    private static function detectLocationHint(string $message) : ?array
    {
        $hint = null;
        $lines = \preg_split('/\\r\\n|\\r|\\n/', $message);
        while (\strpos($lines[0], '__OFFSET') !== \false) {
            $offset = \explode('=', \array_shift($lines));
            if ($offset[0] === '__OFFSET_FILE') {
                $hint['file'] = $offset[1];
            }
            if ($offset[0] === '__OFFSET_LINE') {
                $hint['line'] = $offset[1];
            }
        }
        if ($hint) {
            $hint['message'] = \implode(\PHP_EOL, $lines);
        }
        return $hint;
    }
    private static function isValidObjectAttributeName(string $attributeName) : bool
    {
        return (bool) \preg_match('/[^\\x00-\\x1f\\x7f-\\x9f]+/', $attributeName);
    }
    private static function isValidClassAttributeName(string $attributeName) : bool
    {
        return (bool) \preg_match('/[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*/', $attributeName);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function func_get_args;
use ArrayAccess;
use Countable;
use PHPUnit\Framework\Constraint\ArrayHasKey;
use PHPUnit\Framework\Constraint\Callback;
use PHPUnit\Framework\Constraint\ClassHasAttribute;
use PHPUnit\Framework\Constraint\ClassHasStaticAttribute;
use PHPUnit\Framework\Constraint\Constraint;
use PHPUnit\Framework\Constraint\Count;
use PHPUnit\Framework\Constraint\DirectoryExists;
use PHPUnit\Framework\Constraint\FileExists;
use PHPUnit\Framework\Constraint\GreaterThan;
use PHPUnit\Framework\Constraint\IsAnything;
use PHPUnit\Framework\Constraint\IsEmpty;
use PHPUnit\Framework\Constraint\IsEqual;
use PHPUnit\Framework\Constraint\IsEqualCanonicalizing;
use PHPUnit\Framework\Constraint\IsEqualIgnoringCase;
use PHPUnit\Framework\Constraint\IsEqualWithDelta;
use PHPUnit\Framework\Constraint\IsFalse;
use PHPUnit\Framework\Constraint\IsFinite;
use PHPUnit\Framework\Constraint\IsIdentical;
use PHPUnit\Framework\Constraint\IsInfinite;
use PHPUnit\Framework\Constraint\IsInstanceOf;
use PHPUnit\Framework\Constraint\IsJson;
use PHPUnit\Framework\Constraint\IsNan;
use PHPUnit\Framework\Constraint\IsNull;
use PHPUnit\Framework\Constraint\IsReadable;
use PHPUnit\Framework\Constraint\IsTrue;
use PHPUnit\Framework\Constraint\IsType;
use PHPUnit\Framework\Constraint\IsWritable;
use PHPUnit\Framework\Constraint\LessThan;
use PHPUnit\Framework\Constraint\LogicalAnd;
use PHPUnit\Framework\Constraint\LogicalNot;
use PHPUnit\Framework\Constraint\LogicalOr;
use PHPUnit\Framework\Constraint\LogicalXor;
use PHPUnit\Framework\Constraint\ObjectEquals;
use PHPUnit\Framework\Constraint\ObjectHasAttribute;
use PHPUnit\Framework\Constraint\RegularExpression;
use PHPUnit\Framework\Constraint\StringContains;
use PHPUnit\Framework\Constraint\StringEndsWith;
use PHPUnit\Framework\Constraint\StringMatchesFormatDescription;
use PHPUnit\Framework\Constraint\StringStartsWith;
use PHPUnit\Framework\Constraint\TraversableContainsEqual;
use PHPUnit\Framework\Constraint\TraversableContainsIdentical;
use PHPUnit\Framework\Constraint\TraversableContainsOnly;
use PHPUnit\Framework\MockObject\Rule\AnyInvokedCount as AnyInvokedCountMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount as InvokedAtLeastCountMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce as InvokedAtLeastOnceMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount as InvokedAtMostCountMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedCount as InvokedCountMatcher;
use PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls as ConsecutiveCallsStub;
use PHPUnit\Framework\MockObject\Stub\Exception as ExceptionStub;
use PHPUnit\Framework\MockObject\Stub\ReturnArgument as ReturnArgumentStub;
use PHPUnit\Framework\MockObject\Stub\ReturnCallback as ReturnCallbackStub;
use PHPUnit\Framework\MockObject\Stub\ReturnSelf as ReturnSelfStub;
use PHPUnit\Framework\MockObject\Stub\ReturnStub;
use PHPUnit\Framework\MockObject\Stub\ReturnValueMap as ReturnValueMapStub;
use Throwable;
if (!\function_exists('PHPUnit\\Framework\\assertArrayHasKey')) {
    /**
     * Asserts that an array has a specified key.
     *
     * @param int|string        $key
     * @param array|ArrayAccess $array
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertArrayHasKey
     */
    function assertArrayHasKey($key, $array, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertArrayHasKey(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertArrayNotHasKey')) {
    /**
     * Asserts that an array does not have a specified key.
     *
     * @param int|string        $key
     * @param array|ArrayAccess $array
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertArrayNotHasKey
     */
    function assertArrayNotHasKey($key, $array, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertArrayNotHasKey(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertContains')) {
    /**
     * Asserts that a haystack contains a needle.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertContains
     */
    function assertContains($needle, iterable $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertContains(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertContainsEquals')) {
    function assertContainsEquals($needle, iterable $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertContainsEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotContains')) {
    /**
     * Asserts that a haystack does not contain a needle.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotContains
     */
    function assertNotContains($needle, iterable $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotContains(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotContainsEquals')) {
    function assertNotContainsEquals($needle, iterable $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotContainsEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertContainsOnly')) {
    /**
     * Asserts that a haystack contains only values of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertContainsOnly
     */
    function assertContainsOnly(string $type, iterable $haystack, ?bool $isNativeType = null, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertContainsOnly(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertContainsOnlyInstancesOf')) {
    /**
     * Asserts that a haystack contains only instances of a given class name.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertContainsOnlyInstancesOf
     */
    function assertContainsOnlyInstancesOf(string $className, iterable $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertContainsOnlyInstancesOf(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotContainsOnly')) {
    /**
     * Asserts that a haystack does not contain only values of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotContainsOnly
     */
    function assertNotContainsOnly(string $type, iterable $haystack, ?bool $isNativeType = null, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotContainsOnly(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertCount')) {
    /**
     * Asserts the number of elements of an array, Countable or Traversable.
     *
     * @param Countable|iterable $haystack
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertCount
     */
    function assertCount(int $expectedCount, $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertCount(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotCount')) {
    /**
     * Asserts the number of elements of an array, Countable or Traversable.
     *
     * @param Countable|iterable $haystack
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotCount
     */
    function assertNotCount(int $expectedCount, $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotCount(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertEquals')) {
    /**
     * Asserts that two variables are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertEquals
     */
    function assertEquals($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertEqualsCanonicalizing')) {
    /**
     * Asserts that two variables are equal (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertEqualsCanonicalizing
     */
    function assertEqualsCanonicalizing($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertEqualsCanonicalizing(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertEqualsIgnoringCase')) {
    /**
     * Asserts that two variables are equal (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertEqualsIgnoringCase
     */
    function assertEqualsIgnoringCase($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertEqualsIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertEqualsWithDelta')) {
    /**
     * Asserts that two variables are equal (with delta).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertEqualsWithDelta
     */
    function assertEqualsWithDelta($expected, $actual, float $delta, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertEqualsWithDelta(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotEquals')) {
    /**
     * Asserts that two variables are not equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotEquals
     */
    function assertNotEquals($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotEqualsCanonicalizing')) {
    /**
     * Asserts that two variables are not equal (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotEqualsCanonicalizing
     */
    function assertNotEqualsCanonicalizing($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotEqualsCanonicalizing(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotEqualsIgnoringCase')) {
    /**
     * Asserts that two variables are not equal (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotEqualsIgnoringCase
     */
    function assertNotEqualsIgnoringCase($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotEqualsIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotEqualsWithDelta')) {
    /**
     * Asserts that two variables are not equal (with delta).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotEqualsWithDelta
     */
    function assertNotEqualsWithDelta($expected, $actual, float $delta, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotEqualsWithDelta(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertObjectEquals')) {
    /**
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertObjectEquals
     */
    function assertObjectEquals(object $expected, object $actual, string $method = 'equals', string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertObjectEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertEmpty')) {
    /**
     * Asserts that a variable is empty.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert empty $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertEmpty
     */
    function assertEmpty($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertEmpty(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotEmpty')) {
    /**
     * Asserts that a variable is not empty.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !empty $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotEmpty
     */
    function assertNotEmpty($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotEmpty(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertGreaterThan')) {
    /**
     * Asserts that a value is greater than another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertGreaterThan
     */
    function assertGreaterThan($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertGreaterThan(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertGreaterThanOrEqual')) {
    /**
     * Asserts that a value is greater than or equal to another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertGreaterThanOrEqual
     */
    function assertGreaterThanOrEqual($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertGreaterThanOrEqual(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertLessThan')) {
    /**
     * Asserts that a value is smaller than another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertLessThan
     */
    function assertLessThan($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertLessThan(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertLessThanOrEqual')) {
    /**
     * Asserts that a value is smaller than or equal to another value.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertLessThanOrEqual
     */
    function assertLessThanOrEqual($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertLessThanOrEqual(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileEquals')) {
    /**
     * Asserts that the contents of one file is equal to the contents of another
     * file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileEquals
     */
    function assertFileEquals(string $expected, string $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileEqualsCanonicalizing')) {
    /**
     * Asserts that the contents of one file is equal to the contents of another
     * file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileEqualsCanonicalizing
     */
    function assertFileEqualsCanonicalizing(string $expected, string $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileEqualsCanonicalizing(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileEqualsIgnoringCase')) {
    /**
     * Asserts that the contents of one file is equal to the contents of another
     * file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileEqualsIgnoringCase
     */
    function assertFileEqualsIgnoringCase(string $expected, string $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileEqualsIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileNotEquals')) {
    /**
     * Asserts that the contents of one file is not equal to the contents of
     * another file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileNotEquals
     */
    function assertFileNotEquals(string $expected, string $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileNotEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileNotEqualsCanonicalizing')) {
    /**
     * Asserts that the contents of one file is not equal to the contents of another
     * file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileNotEqualsCanonicalizing
     */
    function assertFileNotEqualsCanonicalizing(string $expected, string $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileNotEqualsCanonicalizing(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileNotEqualsIgnoringCase')) {
    /**
     * Asserts that the contents of one file is not equal to the contents of another
     * file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileNotEqualsIgnoringCase
     */
    function assertFileNotEqualsIgnoringCase(string $expected, string $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileNotEqualsIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringEqualsFile')) {
    /**
     * Asserts that the contents of a string is equal
     * to the contents of a file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringEqualsFile
     */
    function assertStringEqualsFile(string $expectedFile, string $actualString, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringEqualsFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringEqualsFileCanonicalizing')) {
    /**
     * Asserts that the contents of a string is equal
     * to the contents of a file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringEqualsFileCanonicalizing
     */
    function assertStringEqualsFileCanonicalizing(string $expectedFile, string $actualString, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringEqualsFileCanonicalizing(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringEqualsFileIgnoringCase')) {
    /**
     * Asserts that the contents of a string is equal
     * to the contents of a file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringEqualsFileIgnoringCase
     */
    function assertStringEqualsFileIgnoringCase(string $expectedFile, string $actualString, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringEqualsFileIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringNotEqualsFile')) {
    /**
     * Asserts that the contents of a string is not equal
     * to the contents of a file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringNotEqualsFile
     */
    function assertStringNotEqualsFile(string $expectedFile, string $actualString, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringNotEqualsFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringNotEqualsFileCanonicalizing')) {
    /**
     * Asserts that the contents of a string is not equal
     * to the contents of a file (canonicalizing).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringNotEqualsFileCanonicalizing
     */
    function assertStringNotEqualsFileCanonicalizing(string $expectedFile, string $actualString, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringNotEqualsFileCanonicalizing(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringNotEqualsFileIgnoringCase')) {
    /**
     * Asserts that the contents of a string is not equal
     * to the contents of a file (ignoring case).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringNotEqualsFileIgnoringCase
     */
    function assertStringNotEqualsFileIgnoringCase(string $expectedFile, string $actualString, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringNotEqualsFileIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsReadable')) {
    /**
     * Asserts that a file/dir is readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsReadable
     */
    function assertIsReadable(string $filename, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsReadable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotReadable')) {
    /**
     * Asserts that a file/dir exists and is not readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotReadable
     */
    function assertIsNotReadable(string $filename, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotReadable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsWritable')) {
    /**
     * Asserts that a file/dir exists and is writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsWritable
     */
    function assertIsWritable(string $filename, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsWritable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotWritable')) {
    /**
     * Asserts that a file/dir exists and is not writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotWritable
     */
    function assertIsNotWritable(string $filename, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotWritable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertDirectoryExists')) {
    /**
     * Asserts that a directory exists.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertDirectoryExists
     */
    function assertDirectoryExists(string $directory, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertDirectoryExists(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertDirectoryDoesNotExist')) {
    /**
     * Asserts that a directory does not exist.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertDirectoryDoesNotExist
     */
    function assertDirectoryDoesNotExist(string $directory, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertDirectoryDoesNotExist(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertDirectoryIsReadable')) {
    /**
     * Asserts that a directory exists and is readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertDirectoryIsReadable
     */
    function assertDirectoryIsReadable(string $directory, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertDirectoryIsReadable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertDirectoryIsNotReadable')) {
    /**
     * Asserts that a directory exists and is not readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertDirectoryIsNotReadable
     */
    function assertDirectoryIsNotReadable(string $directory, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertDirectoryIsNotReadable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertDirectoryIsWritable')) {
    /**
     * Asserts that a directory exists and is writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertDirectoryIsWritable
     */
    function assertDirectoryIsWritable(string $directory, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertDirectoryIsWritable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertDirectoryIsNotWritable')) {
    /**
     * Asserts that a directory exists and is not writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertDirectoryIsNotWritable
     */
    function assertDirectoryIsNotWritable(string $directory, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertDirectoryIsNotWritable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileExists')) {
    /**
     * Asserts that a file exists.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileExists
     */
    function assertFileExists(string $filename, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileExists(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileDoesNotExist')) {
    /**
     * Asserts that a file does not exist.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileDoesNotExist
     */
    function assertFileDoesNotExist(string $filename, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileDoesNotExist(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileIsReadable')) {
    /**
     * Asserts that a file exists and is readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileIsReadable
     */
    function assertFileIsReadable(string $file, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileIsReadable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileIsNotReadable')) {
    /**
     * Asserts that a file exists and is not readable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileIsNotReadable
     */
    function assertFileIsNotReadable(string $file, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileIsNotReadable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileIsWritable')) {
    /**
     * Asserts that a file exists and is writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileIsWritable
     */
    function assertFileIsWritable(string $file, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileIsWritable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFileIsNotWritable')) {
    /**
     * Asserts that a file exists and is not writable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFileIsNotWritable
     */
    function assertFileIsNotWritable(string $file, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFileIsNotWritable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertTrue')) {
    /**
     * Asserts that a condition is true.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert true $condition
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertTrue
     */
    function assertTrue($condition, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertTrue(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotTrue')) {
    /**
     * Asserts that a condition is not true.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !true $condition
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotTrue
     */
    function assertNotTrue($condition, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotTrue(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFalse')) {
    /**
     * Asserts that a condition is false.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert false $condition
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFalse
     */
    function assertFalse($condition, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFalse(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotFalse')) {
    /**
     * Asserts that a condition is not false.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !false $condition
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotFalse
     */
    function assertNotFalse($condition, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotFalse(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNull')) {
    /**
     * Asserts that a variable is null.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert null $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNull
     */
    function assertNull($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNull(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotNull')) {
    /**
     * Asserts that a variable is not null.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !null $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotNull
     */
    function assertNotNull($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotNull(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertFinite')) {
    /**
     * Asserts that a variable is finite.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertFinite
     */
    function assertFinite($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertFinite(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertInfinite')) {
    /**
     * Asserts that a variable is infinite.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertInfinite
     */
    function assertInfinite($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertInfinite(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNan')) {
    /**
     * Asserts that a variable is nan.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNan
     */
    function assertNan($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNan(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertClassHasAttribute')) {
    /**
     * Asserts that a class has a specified attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertClassHasAttribute
     */
    function assertClassHasAttribute(string $attributeName, string $className, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertClassHasAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertClassNotHasAttribute')) {
    /**
     * Asserts that a class does not have a specified attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertClassNotHasAttribute
     */
    function assertClassNotHasAttribute(string $attributeName, string $className, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertClassNotHasAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertClassHasStaticAttribute')) {
    /**
     * Asserts that a class has a specified static attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertClassHasStaticAttribute
     */
    function assertClassHasStaticAttribute(string $attributeName, string $className, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertClassHasStaticAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertClassNotHasStaticAttribute')) {
    /**
     * Asserts that a class does not have a specified static attribute.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertClassNotHasStaticAttribute
     */
    function assertClassNotHasStaticAttribute(string $attributeName, string $className, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertClassNotHasStaticAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertObjectHasAttribute')) {
    /**
     * Asserts that an object has a specified attribute.
     *
     * @param object $object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertObjectHasAttribute
     */
    function assertObjectHasAttribute(string $attributeName, $object, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertObjectHasAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertObjectNotHasAttribute')) {
    /**
     * Asserts that an object does not have a specified attribute.
     *
     * @param object $object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @codeCoverageIgnore
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertObjectNotHasAttribute
     */
    function assertObjectNotHasAttribute(string $attributeName, $object, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertObjectNotHasAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertSame')) {
    /**
     * Asserts that two variables have the same type and value.
     * Used on objects, it asserts that two variables reference
     * the same object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-template ExpectedType
     * @psalm-param ExpectedType $expected
     * @psalm-assert =ExpectedType $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertSame
     */
    function assertSame($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertSame(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotSame')) {
    /**
     * Asserts that two variables do not have the same type and value.
     * Used on objects, it asserts that two variables do not reference
     * the same object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotSame
     */
    function assertNotSame($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotSame(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertInstanceOf')) {
    /**
     * Asserts that a variable is of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @psalm-template ExpectedType of object
     * @psalm-param class-string<ExpectedType> $expected
     * @psalm-assert =ExpectedType $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertInstanceOf
     */
    function assertInstanceOf(string $expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertInstanceOf(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotInstanceOf')) {
    /**
     * Asserts that a variable is not of a given type.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @psalm-template ExpectedType of object
     * @psalm-param class-string<ExpectedType> $expected
     * @psalm-assert !ExpectedType $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotInstanceOf
     */
    function assertNotInstanceOf(string $expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotInstanceOf(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsArray')) {
    /**
     * Asserts that a variable is of type array.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert array $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsArray
     */
    function assertIsArray($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsArray(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsBool')) {
    /**
     * Asserts that a variable is of type bool.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert bool $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsBool
     */
    function assertIsBool($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsBool(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsFloat')) {
    /**
     * Asserts that a variable is of type float.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert float $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsFloat
     */
    function assertIsFloat($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsFloat(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsInt')) {
    /**
     * Asserts that a variable is of type int.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert int $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsInt
     */
    function assertIsInt($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsInt(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNumeric')) {
    /**
     * Asserts that a variable is of type numeric.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert numeric $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNumeric
     */
    function assertIsNumeric($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNumeric(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsObject')) {
    /**
     * Asserts that a variable is of type object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert object $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsObject
     */
    function assertIsObject($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsObject(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsResource')) {
    /**
     * Asserts that a variable is of type resource.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert resource $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsResource
     */
    function assertIsResource($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsResource(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsClosedResource')) {
    /**
     * Asserts that a variable is of type resource and is closed.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert resource $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsClosedResource
     */
    function assertIsClosedResource($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsClosedResource(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsString')) {
    /**
     * Asserts that a variable is of type string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert string $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsString
     */
    function assertIsString($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsScalar')) {
    /**
     * Asserts that a variable is of type scalar.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert scalar $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsScalar
     */
    function assertIsScalar($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsScalar(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsCallable')) {
    /**
     * Asserts that a variable is of type callable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert callable $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsCallable
     */
    function assertIsCallable($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsCallable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsIterable')) {
    /**
     * Asserts that a variable is of type iterable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert iterable $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsIterable
     */
    function assertIsIterable($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsIterable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotArray')) {
    /**
     * Asserts that a variable is not of type array.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !array $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotArray
     */
    function assertIsNotArray($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotArray(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotBool')) {
    /**
     * Asserts that a variable is not of type bool.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !bool $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotBool
     */
    function assertIsNotBool($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotBool(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotFloat')) {
    /**
     * Asserts that a variable is not of type float.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !float $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotFloat
     */
    function assertIsNotFloat($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotFloat(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotInt')) {
    /**
     * Asserts that a variable is not of type int.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !int $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotInt
     */
    function assertIsNotInt($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotInt(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotNumeric')) {
    /**
     * Asserts that a variable is not of type numeric.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !numeric $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotNumeric
     */
    function assertIsNotNumeric($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotNumeric(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotObject')) {
    /**
     * Asserts that a variable is not of type object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !object $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotObject
     */
    function assertIsNotObject($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotObject(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotResource')) {
    /**
     * Asserts that a variable is not of type resource.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !resource $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotResource
     */
    function assertIsNotResource($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotResource(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotClosedResource')) {
    /**
     * Asserts that a variable is not of type resource.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !resource $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotClosedResource
     */
    function assertIsNotClosedResource($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotClosedResource(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotString')) {
    /**
     * Asserts that a variable is not of type string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !string $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotString
     */
    function assertIsNotString($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotScalar')) {
    /**
     * Asserts that a variable is not of type scalar.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !scalar $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotScalar
     */
    function assertIsNotScalar($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotScalar(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotCallable')) {
    /**
     * Asserts that a variable is not of type callable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !callable $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotCallable
     */
    function assertIsNotCallable($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotCallable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertIsNotIterable')) {
    /**
     * Asserts that a variable is not of type iterable.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-assert !iterable $actual
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertIsNotIterable
     */
    function assertIsNotIterable($actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertIsNotIterable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertMatchesRegularExpression')) {
    /**
     * Asserts that a string matches a given regular expression.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertMatchesRegularExpression
     */
    function assertMatchesRegularExpression(string $pattern, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertMatchesRegularExpression(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertDoesNotMatchRegularExpression')) {
    /**
     * Asserts that a string does not match a given regular expression.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertDoesNotMatchRegularExpression
     */
    function assertDoesNotMatchRegularExpression(string $pattern, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertDoesNotMatchRegularExpression(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertSameSize')) {
    /**
     * Assert that the size of two arrays (or `Countable` or `Traversable` objects)
     * is the same.
     *
     * @param Countable|iterable $expected
     * @param Countable|iterable $actual
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertSameSize
     */
    function assertSameSize($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertSameSize(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertNotSameSize')) {
    /**
     * Assert that the size of two arrays (or `Countable` or `Traversable` objects)
     * is not the same.
     *
     * @param Countable|iterable $expected
     * @param Countable|iterable $actual
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertNotSameSize
     */
    function assertNotSameSize($expected, $actual, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertNotSameSize(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringMatchesFormat')) {
    /**
     * Asserts that a string matches a given format string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringMatchesFormat
     */
    function assertStringMatchesFormat(string $format, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringMatchesFormat(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringNotMatchesFormat')) {
    /**
     * Asserts that a string does not match a given format string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringNotMatchesFormat
     */
    function assertStringNotMatchesFormat(string $format, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringNotMatchesFormat(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringMatchesFormatFile')) {
    /**
     * Asserts that a string matches a given format file.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringMatchesFormatFile
     */
    function assertStringMatchesFormatFile(string $formatFile, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringMatchesFormatFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringNotMatchesFormatFile')) {
    /**
     * Asserts that a string does not match a given format string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringNotMatchesFormatFile
     */
    function assertStringNotMatchesFormatFile(string $formatFile, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringNotMatchesFormatFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringStartsWith')) {
    /**
     * Asserts that a string starts with a given prefix.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringStartsWith
     */
    function assertStringStartsWith(string $prefix, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringStartsWith(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringStartsNotWith')) {
    /**
     * Asserts that a string starts not with a given prefix.
     *
     * @param string $prefix
     * @param string $string
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringStartsNotWith
     */
    function assertStringStartsNotWith($prefix, $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringStartsNotWith(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringContainsString')) {
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringContainsString
     */
    function assertStringContainsString(string $needle, string $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringContainsString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringContainsStringIgnoringCase')) {
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringContainsStringIgnoringCase
     */
    function assertStringContainsStringIgnoringCase(string $needle, string $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringContainsStringIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringNotContainsString')) {
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringNotContainsString
     */
    function assertStringNotContainsString(string $needle, string $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringNotContainsString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringNotContainsStringIgnoringCase')) {
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringNotContainsStringIgnoringCase
     */
    function assertStringNotContainsStringIgnoringCase(string $needle, string $haystack, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringNotContainsStringIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringEndsWith')) {
    /**
     * Asserts that a string ends with a given suffix.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringEndsWith
     */
    function assertStringEndsWith(string $suffix, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringEndsWith(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertStringEndsNotWith')) {
    /**
     * Asserts that a string ends not with a given suffix.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertStringEndsNotWith
     */
    function assertStringEndsNotWith(string $suffix, string $string, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertStringEndsNotWith(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertXmlFileEqualsXmlFile')) {
    /**
     * Asserts that two XML files are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertXmlFileEqualsXmlFile
     */
    function assertXmlFileEqualsXmlFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertXmlFileEqualsXmlFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertXmlFileNotEqualsXmlFile')) {
    /**
     * Asserts that two XML files are not equal.
     *
     * @throws \PHPUnit\Util\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertXmlFileNotEqualsXmlFile
     */
    function assertXmlFileNotEqualsXmlFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertXmlFileNotEqualsXmlFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertXmlStringEqualsXmlFile')) {
    /**
     * Asserts that two XML documents are equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertXmlStringEqualsXmlFile
     */
    function assertXmlStringEqualsXmlFile(string $expectedFile, string $actualXml, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertXmlStringEqualsXmlFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertXmlStringNotEqualsXmlFile')) {
    /**
     * Asserts that two XML documents are not equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertXmlStringNotEqualsXmlFile
     */
    function assertXmlStringNotEqualsXmlFile(string $expectedFile, string $actualXml, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertXmlStringNotEqualsXmlFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertXmlStringEqualsXmlString')) {
    /**
     * Asserts that two XML documents are equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertXmlStringEqualsXmlString
     */
    function assertXmlStringEqualsXmlString(string $expectedXml, string $actualXml, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertXmlStringEqualsXmlString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertXmlStringNotEqualsXmlString')) {
    /**
     * Asserts that two XML documents are not equal.
     *
     * @throws \PHPUnit\Util\Xml\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertXmlStringNotEqualsXmlString
     */
    function assertXmlStringNotEqualsXmlString(string $expectedXml, string $actualXml, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertXmlStringNotEqualsXmlString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertThat')) {
    /**
     * Evaluates a PHPUnit\Framework\Constraint matcher object.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertThat
     */
    function assertThat($value, \PHPUnit\Framework\Constraint\Constraint $constraint, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertThat(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertJson')) {
    /**
     * Asserts that a string is a valid JSON string.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertJson
     */
    function assertJson(string $actualJson, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertJson(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertJsonStringEqualsJsonString')) {
    /**
     * Asserts that two given JSON encoded objects or arrays are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertJsonStringEqualsJsonString
     */
    function assertJsonStringEqualsJsonString(string $expectedJson, string $actualJson, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertJsonStringEqualsJsonString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertJsonStringNotEqualsJsonString')) {
    /**
     * Asserts that two given JSON encoded objects or arrays are not equal.
     *
     * @param string $expectedJson
     * @param string $actualJson
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertJsonStringNotEqualsJsonString
     */
    function assertJsonStringNotEqualsJsonString($expectedJson, $actualJson, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertJsonStringNotEqualsJsonString(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertJsonStringEqualsJsonFile')) {
    /**
     * Asserts that the generated JSON encoded object and the content of the given file are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertJsonStringEqualsJsonFile
     */
    function assertJsonStringEqualsJsonFile(string $expectedFile, string $actualJson, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertJsonStringEqualsJsonFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertJsonStringNotEqualsJsonFile')) {
    /**
     * Asserts that the generated JSON encoded object and the content of the given file are not equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertJsonStringNotEqualsJsonFile
     */
    function assertJsonStringNotEqualsJsonFile(string $expectedFile, string $actualJson, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertJsonStringNotEqualsJsonFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertJsonFileEqualsJsonFile')) {
    /**
     * Asserts that two JSON files are equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertJsonFileEqualsJsonFile
     */
    function assertJsonFileEqualsJsonFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertJsonFileEqualsJsonFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\assertJsonFileNotEqualsJsonFile')) {
    /**
     * Asserts that two JSON files are not equal.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
     *
     * @see Assert::assertJsonFileNotEqualsJsonFile
     */
    function assertJsonFileNotEqualsJsonFile(string $expectedFile, string $actualFile, string $message = '') : void
    {
        \PHPUnit\Framework\Assert::assertJsonFileNotEqualsJsonFile(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\logicalAnd')) {
    function logicalAnd() : \PHPUnit\Framework\Constraint\LogicalAnd
    {
        return \PHPUnit\Framework\Assert::logicalAnd(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\logicalOr')) {
    function logicalOr() : \PHPUnit\Framework\Constraint\LogicalOr
    {
        return \PHPUnit\Framework\Assert::logicalOr(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\logicalNot')) {
    function logicalNot(\PHPUnit\Framework\Constraint\Constraint $constraint) : \PHPUnit\Framework\Constraint\LogicalNot
    {
        return \PHPUnit\Framework\Assert::logicalNot(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\logicalXor')) {
    function logicalXor() : \PHPUnit\Framework\Constraint\LogicalXor
    {
        return \PHPUnit\Framework\Assert::logicalXor(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\anything')) {
    function anything() : \PHPUnit\Framework\Constraint\IsAnything
    {
        return \PHPUnit\Framework\Assert::anything(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isTrue')) {
    function isTrue() : \PHPUnit\Framework\Constraint\IsTrue
    {
        return \PHPUnit\Framework\Assert::isTrue(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\callback')) {
    function callback(callable $callback) : \PHPUnit\Framework\Constraint\Callback
    {
        return \PHPUnit\Framework\Assert::callback(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isFalse')) {
    function isFalse() : \PHPUnit\Framework\Constraint\IsFalse
    {
        return \PHPUnit\Framework\Assert::isFalse(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isJson')) {
    function isJson() : \PHPUnit\Framework\Constraint\IsJson
    {
        return \PHPUnit\Framework\Assert::isJson(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isNull')) {
    function isNull() : \PHPUnit\Framework\Constraint\IsNull
    {
        return \PHPUnit\Framework\Assert::isNull(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isFinite')) {
    function isFinite() : \PHPUnit\Framework\Constraint\IsFinite
    {
        return \PHPUnit\Framework\Assert::isFinite(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isInfinite')) {
    function isInfinite() : \PHPUnit\Framework\Constraint\IsInfinite
    {
        return \PHPUnit\Framework\Assert::isInfinite(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isNan')) {
    function isNan() : \PHPUnit\Framework\Constraint\IsNan
    {
        return \PHPUnit\Framework\Assert::isNan(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\containsEqual')) {
    function containsEqual($value) : \PHPUnit\Framework\Constraint\TraversableContainsEqual
    {
        return \PHPUnit\Framework\Assert::containsEqual(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\containsIdentical')) {
    function containsIdentical($value) : \PHPUnit\Framework\Constraint\TraversableContainsIdentical
    {
        return \PHPUnit\Framework\Assert::containsIdentical(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\containsOnly')) {
    function containsOnly(string $type) : \PHPUnit\Framework\Constraint\TraversableContainsOnly
    {
        return \PHPUnit\Framework\Assert::containsOnly(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\containsOnlyInstancesOf')) {
    function containsOnlyInstancesOf(string $className) : \PHPUnit\Framework\Constraint\TraversableContainsOnly
    {
        return \PHPUnit\Framework\Assert::containsOnlyInstancesOf(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\arrayHasKey')) {
    function arrayHasKey($key) : \PHPUnit\Framework\Constraint\ArrayHasKey
    {
        return \PHPUnit\Framework\Assert::arrayHasKey(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\equalTo')) {
    function equalTo($value) : \PHPUnit\Framework\Constraint\IsEqual
    {
        return \PHPUnit\Framework\Assert::equalTo(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\equalToCanonicalizing')) {
    function equalToCanonicalizing($value) : \PHPUnit\Framework\Constraint\IsEqualCanonicalizing
    {
        return \PHPUnit\Framework\Assert::equalToCanonicalizing(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\equalToIgnoringCase')) {
    function equalToIgnoringCase($value) : \PHPUnit\Framework\Constraint\IsEqualIgnoringCase
    {
        return \PHPUnit\Framework\Assert::equalToIgnoringCase(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\equalToWithDelta')) {
    function equalToWithDelta($value, float $delta) : \PHPUnit\Framework\Constraint\IsEqualWithDelta
    {
        return \PHPUnit\Framework\Assert::equalToWithDelta(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isEmpty')) {
    function isEmpty() : \PHPUnit\Framework\Constraint\IsEmpty
    {
        return \PHPUnit\Framework\Assert::isEmpty(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isWritable')) {
    function isWritable() : \PHPUnit\Framework\Constraint\IsWritable
    {
        return \PHPUnit\Framework\Assert::isWritable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isReadable')) {
    function isReadable() : \PHPUnit\Framework\Constraint\IsReadable
    {
        return \PHPUnit\Framework\Assert::isReadable(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\directoryExists')) {
    function directoryExists() : \PHPUnit\Framework\Constraint\DirectoryExists
    {
        return \PHPUnit\Framework\Assert::directoryExists(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\fileExists')) {
    function fileExists() : \PHPUnit\Framework\Constraint\FileExists
    {
        return \PHPUnit\Framework\Assert::fileExists(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\greaterThan')) {
    function greaterThan($value) : \PHPUnit\Framework\Constraint\GreaterThan
    {
        return \PHPUnit\Framework\Assert::greaterThan(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\greaterThanOrEqual')) {
    function greaterThanOrEqual($value) : \PHPUnit\Framework\Constraint\LogicalOr
    {
        return \PHPUnit\Framework\Assert::greaterThanOrEqual(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\classHasAttribute')) {
    function classHasAttribute(string $attributeName) : \PHPUnit\Framework\Constraint\ClassHasAttribute
    {
        return \PHPUnit\Framework\Assert::classHasAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\classHasStaticAttribute')) {
    function classHasStaticAttribute(string $attributeName) : \PHPUnit\Framework\Constraint\ClassHasStaticAttribute
    {
        return \PHPUnit\Framework\Assert::classHasStaticAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\objectHasAttribute')) {
    function objectHasAttribute($attributeName) : \PHPUnit\Framework\Constraint\ObjectHasAttribute
    {
        return \PHPUnit\Framework\Assert::objectHasAttribute(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\identicalTo')) {
    function identicalTo($value) : \PHPUnit\Framework\Constraint\IsIdentical
    {
        return \PHPUnit\Framework\Assert::identicalTo(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isInstanceOf')) {
    function isInstanceOf(string $className) : \PHPUnit\Framework\Constraint\IsInstanceOf
    {
        return \PHPUnit\Framework\Assert::isInstanceOf(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\isType')) {
    function isType(string $type) : \PHPUnit\Framework\Constraint\IsType
    {
        return \PHPUnit\Framework\Assert::isType(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\lessThan')) {
    function lessThan($value) : \PHPUnit\Framework\Constraint\LessThan
    {
        return \PHPUnit\Framework\Assert::lessThan(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\lessThanOrEqual')) {
    function lessThanOrEqual($value) : \PHPUnit\Framework\Constraint\LogicalOr
    {
        return \PHPUnit\Framework\Assert::lessThanOrEqual(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\matchesRegularExpression')) {
    function matchesRegularExpression(string $pattern) : \PHPUnit\Framework\Constraint\RegularExpression
    {
        return \PHPUnit\Framework\Assert::matchesRegularExpression(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\matches')) {
    function matches(string $string) : \PHPUnit\Framework\Constraint\StringMatchesFormatDescription
    {
        return \PHPUnit\Framework\Assert::matches(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\stringStartsWith')) {
    function stringStartsWith($prefix) : \PHPUnit\Framework\Constraint\StringStartsWith
    {
        return \PHPUnit\Framework\Assert::stringStartsWith(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\stringContains')) {
    function stringContains(string $string, bool $case = \true) : \PHPUnit\Framework\Constraint\StringContains
    {
        return \PHPUnit\Framework\Assert::stringContains(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\stringEndsWith')) {
    function stringEndsWith(string $suffix) : \PHPUnit\Framework\Constraint\StringEndsWith
    {
        return \PHPUnit\Framework\Assert::stringEndsWith(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\countOf')) {
    function countOf(int $count) : \PHPUnit\Framework\Constraint\Count
    {
        return \PHPUnit\Framework\Assert::countOf(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\objectEquals')) {
    function objectEquals(object $object, string $method = 'equals') : \PHPUnit\Framework\Constraint\ObjectEquals
    {
        return \PHPUnit\Framework\Assert::objectEquals(...\func_get_args());
    }
}
if (!\function_exists('PHPUnit\\Framework\\any')) {
    /**
     * Returns a matcher that matches when the method is executed
     * zero or more times.
     */
    function any() : \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount();
    }
}
if (!\function_exists('PHPUnit\\Framework\\never')) {
    /**
     * Returns a matcher that matches when the method is never executed.
     */
    function never() : \PHPUnit\Framework\MockObject\Rule\InvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedCount(0);
    }
}
if (!\function_exists('PHPUnit\\Framework\\atLeast')) {
    /**
     * Returns a matcher that matches when the method is executed
     * at least N times.
     */
    function atLeast(int $requiredInvocations) : \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount($requiredInvocations);
    }
}
if (!\function_exists('PHPUnit\\Framework\\atLeastOnce')) {
    /**
     * Returns a matcher that matches when the method is executed at least once.
     */
    function atLeastOnce() : \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce();
    }
}
if (!\function_exists('PHPUnit\\Framework\\once')) {
    /**
     * Returns a matcher that matches when the method is executed exactly once.
     */
    function once() : \PHPUnit\Framework\MockObject\Rule\InvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedCount(1);
    }
}
if (!\function_exists('PHPUnit\\Framework\\exactly')) {
    /**
     * Returns a matcher that matches when the method is executed
     * exactly $count times.
     */
    function exactly(int $count) : \PHPUnit\Framework\MockObject\Rule\InvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedCount($count);
    }
}
if (!\function_exists('PHPUnit\\Framework\\atMost')) {
    /**
     * Returns a matcher that matches when the method is executed
     * at most N times.
     */
    function atMost(int $allowedInvocations) : \PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount($allowedInvocations);
    }
}
if (!\function_exists('PHPUnit\\Framework\\returnValue')) {
    function returnValue($value) : \PHPUnit\Framework\MockObject\Stub\ReturnStub
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnStub($value);
    }
}
if (!\function_exists('PHPUnit\\Framework\\returnValueMap')) {
    function returnValueMap(array $valueMap) : \PHPUnit\Framework\MockObject\Stub\ReturnValueMap
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnValueMap($valueMap);
    }
}
if (!\function_exists('PHPUnit\\Framework\\returnArgument')) {
    function returnArgument(int $argumentIndex) : \PHPUnit\Framework\MockObject\Stub\ReturnArgument
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnArgument($argumentIndex);
    }
}
if (!\function_exists('PHPUnit\\Framework\\returnCallback')) {
    function returnCallback($callback) : \PHPUnit\Framework\MockObject\Stub\ReturnCallback
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnCallback($callback);
    }
}
if (!\function_exists('PHPUnit\\Framework\\returnSelf')) {
    /**
     * Returns the current object.
     *
     * This method is useful when mocking a fluent interface.
     */
    function returnSelf() : \PHPUnit\Framework\MockObject\Stub\ReturnSelf
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnSelf();
    }
}
if (!\function_exists('PHPUnit\\Framework\\throwException')) {
    function throwException(\Throwable $exception) : \PHPUnit\Framework\MockObject\Stub\Exception
    {
        return new \PHPUnit\Framework\MockObject\Stub\Exception($exception);
    }
}
if (!\function_exists('PHPUnit\\Framework\\onConsecutiveCalls')) {
    function onConsecutiveCalls() : \PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls
    {
        $args = \func_get_args();
        return new \PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls($args);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class After
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class AfterClass
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class BackupGlobals
{
    private bool $enabled;
    public function __construct(bool $enabled)
    {
        $this->enabled = $enabled;
    }
    public function enabled() : bool
    {
        return $this->enabled;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class BackupStaticProperties
{
    private bool $enabled;
    public function __construct(bool $enabled)
    {
        $this->enabled = $enabled;
    }
    public function enabled() : bool
    {
        return $this->enabled;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class Before
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class BeforeClass
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class CodeCoverageIgnore
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::IS_REPEATABLE)]
final class CoversClass
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::IS_REPEATABLE)]
final class CoversFunction
{
    private string $functionName;
    public function __construct(string $functionName)
    {
        $this->functionName = $functionName;
    }
    public function functionName() : string
    {
        return $this->functionName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class CoversNothing
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class DataProvider
{
    private string $methodName;
    public function __construct(string $methodName)
    {
        $this->methodName = $methodName;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class DataProviderExternal
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class Depends
{
    private string $methodName;
    public function __construct(string $methodName)
    {
        $this->methodName = $methodName;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class DependsExternal
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class DependsExternalUsingDeepClone
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class DependsExternalUsingShallowClone
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class DependsUsingDeepClone
{
    private string $methodName;
    public function __construct(string $methodName)
    {
        $this->methodName = $methodName;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class DependsUsingShallowClone
{
    private string $methodName;
    public function __construct(string $methodName)
    {
        $this->methodName = $methodName;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class DoesNotPerformAssertions
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class Group
{
    private string $name;
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    public function name() : string
    {
        return $this->name;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS)]
final class Large
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS)]
final class Medium
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class PostCondition
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class PreCondition
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class PreserveGlobalState
{
    private bool $enabled;
    public function __construct(bool $enabled)
    {
        $this->enabled = $enabled;
    }
    public function enabled() : bool
    {
        return $this->enabled;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class RequiresFunction
{
    private string $functionName;
    public function __construct(string $functionName)
    {
        $this->functionName = $functionName;
    }
    public function functionName() : string
    {
        return $this->functionName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class RequiresMethod
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class RequiresOperatingSystem
{
    private string $regularExpression;
    public function __construct(string $regularExpression)
    {
        $this->regularExpression = $regularExpression;
    }
    public function regularExpression() : string
    {
        return $this->regularExpression;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class RequiresOperatingSystemFamily
{
    private string $operatingSystemFamily;
    public function __construct(string $operatingSystemFamily)
    {
        $this->operatingSystemFamily = $operatingSystemFamily;
    }
    public function operatingSystemFamily() : string
    {
        return $this->operatingSystemFamily;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class RequiresPhp
{
    private string $versionRequirement;
    public function __construct(string $versionRequirement)
    {
        $this->versionRequirement = $versionRequirement;
    }
    public function versionRequirement() : string
    {
        return $this->versionRequirement;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class RequiresPhpExtension
{
    private string $extension;
    private ?string $versionRequirement;
    public function __construct(string $extension, ?string $versionRequirement = null)
    {
        $this->extension = $extension;
        $this->versionRequirement = $versionRequirement;
    }
    public function extension() : string
    {
        return $this->extension;
    }
    public function hasVersionRequirement() : bool
    {
        return $this->versionRequirement !== null;
    }
    public function versionRequirement() : ?string
    {
        return $this->versionRequirement;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class RequiresPhpunit
{
    private string $versionRequirement;
    public function __construct(string $versionRequirement)
    {
        $this->versionRequirement = $versionRequirement;
    }
    public function versionRequirement() : string
    {
        return $this->versionRequirement;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class RequiresSetting
{
    private string $setting;
    private string $value;
    public function __construct(string $setting, string $value)
    {
        $this->setting = $setting;
        $this->value = $value;
    }
    public function setting() : string
    {
        return $this->setting;
    }
    public function value() : string
    {
        return $this->value;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS)]
final class RunClassInSeparateProcess
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class RunInSeparateProcess
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS)]
final class RunTestsInSeparateProcesses
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS)]
final class Small
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD)]
final class Test
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD)]
final class TestDox
{
    private string $text;
    public function __construct(string $text)
    {
        $this->text = $text;
    }
    public function text() : string
    {
        return $this->text;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class TestWith
{
    private array $data;
    public function __construct(array $data)
    {
        $this->data = $data;
    }
    public function data() : array
    {
        return $this->data;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class TestWithJson
{
    private string $json;
    public function __construct(string $json)
    {
        $this->json = $json;
    }
    public function json() : string
    {
        return $this->json;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::TARGET_METHOD | Attribute::IS_REPEATABLE)]
final class Ticket
{
    private string $text;
    public function __construct(string $text)
    {
        $this->text = $text;
    }
    public function text() : string
    {
        return $this->text;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::IS_REPEATABLE)]
final class UsesClass
{
    private string $className;
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    public function className() : string
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Attributes;

use Attribute;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
#[Attribute(Attribute::TARGET_CLASS | Attribute::IS_REPEATABLE)]
final class UsesFunction
{
    private string $functionName;
    public function __construct(string $functionName)
    {
        $this->functionName = $functionName;
    }
    public function functionName() : string
    {
        return $this->functionName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsFalse extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is false';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return $other === \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsTrue extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is true';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return $other === \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @psalm-template CallbackInput of mixed
 *
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class Callback extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var callable
     *
     * @psalm-var callable(CallbackInput $input): bool
     */
    private $callback;
    /** @psalm-param callable(CallbackInput $input): bool $callback */
    public function __construct(callable $callback)
    {
        $this->callback = $callback;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is accepted by specified callback';
    }
    /**
     * Evaluates the constraint for parameter $value. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     *
     * @psalm-param CallbackInput $other
     */
    protected function matches($other) : bool
    {
        return ($this->callback)($other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function count;
use function is_countable;
use function iterator_count;
use function sprintf;
use EmptyIterator;
use Generator;
use Iterator;
use IteratorAggregate;
use PHPUnit\Framework\Exception;
use Traversable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
class Count extends \PHPUnit\Framework\Constraint\Constraint
{
    private int $expectedCount;
    public function __construct(int $expected)
    {
        $this->expectedCount = $expected;
    }
    public function toString() : string
    {
        return \sprintf('count matches %d', $this->expectedCount);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @throws Exception
     */
    protected function matches($other) : bool
    {
        return $this->expectedCount === $this->getCountOf($other);
    }
    /**
     * @throws Exception
     */
    protected function getCountOf($other) : ?int
    {
        if (\is_countable($other)) {
            return \count($other);
        }
        if ($other instanceof \EmptyIterator) {
            return 0;
        }
        if ($other instanceof \Traversable) {
            while ($other instanceof \IteratorAggregate) {
                try {
                    $other = $other->getIterator();
                } catch (\Exception $e) {
                    throw new \PHPUnit\Framework\Exception($e->getMessage(), $e->getCode(), $e);
                }
            }
            $iterator = $other;
            if ($iterator instanceof \Generator) {
                return $this->getCountOfGenerator($iterator);
            }
            if (!$iterator instanceof \Iterator) {
                return \iterator_count($iterator);
            }
            $key = $iterator->key();
            $count = \iterator_count($iterator);
            // Manually rewind $iterator to previous key, since iterator_count
            // moves pointer.
            if ($key !== null) {
                $iterator->rewind();
                while ($iterator->valid() && $key !== $iterator->key()) {
                    $iterator->next();
                }
            }
            return $count;
        }
        return null;
    }
    /**
     * Returns the total number of iterations from a generator.
     * This will fully exhaust the generator.
     */
    protected function getCountOfGenerator(\Generator $generator) : int
    {
        for ($count = 0; $generator->valid(); $generator->next()) {
            $count++;
        }
        return $count;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('actual size %d matches expected size %d', (int) $this->getCountOf($other), $this->expectedCount);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class GreaterThan extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var float|int
     */
    private $value;
    /**
     * @param float|int $value
     */
    public function __construct($value)
    {
        $this->value = $value;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        return 'is greater than ' . $this->exporter()->export($this->value);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return $this->value < $other;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function count;
use function gettype;
use function sprintf;
use function strpos;
use Countable;
use EmptyIterator;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsEmpty extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is empty';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        if ($other instanceof \EmptyIterator) {
            return \true;
        }
        if ($other instanceof \Countable) {
            return \count($other) === 0;
        }
        return empty($other);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        $type = \gettype($other);
        return \sprintf('%s %s %s', \strpos($type, 'a') === 0 || \strpos($type, 'o') === 0 ? 'an' : 'a', $type, $this->toString());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class LessThan extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var float|int
     */
    private $value;
    /**
     * @param float|int $value
     */
    public function __construct($value)
    {
        $this->value = $value;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        return 'is less than ' . $this->exporter()->export($this->value);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return $this->value > $other;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class SameSize extends \PHPUnit\Framework\Constraint\Count
{
    /**
     * @psalm-param \Countable|iterable $expected
     */
    public function __construct($expected)
    {
        parent::__construct((int) $this->getCountOf($expected));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function sprintf;
use Countable;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\SelfDescribing;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
abstract class Constraint implements \Countable, \PHPUnit\Framework\SelfDescribing
{
    private ?\PHPUnit\SebastianBergmann\Exporter\Exporter $exporter = null;
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        $success = \false;
        if ($this->matches($other)) {
            $success = \true;
        }
        if ($returnResult) {
            return $success;
        }
        if (!$success) {
            $this->fail($other, $description);
        }
        return null;
    }
    /**
     * Counts the number of constraint elements.
     */
    public function count() : int
    {
        return 1;
    }
    protected function exporter() : \PHPUnit\SebastianBergmann\Exporter\Exporter
    {
        if ($this->exporter === null) {
            $this->exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
        }
        return $this->exporter;
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * This method can be overridden to implement the evaluation algorithm.
     *
     * @param mixed $other value or object to evaluate
     * @codeCoverageIgnore
     */
    protected function matches($other) : bool
    {
        return \false;
    }
    /**
     * Throws an exception for the given compared value and test description.
     *
     * @param mixed             $other             evaluated value or object
     * @param string            $description       Additional information about the test
     * @param ComparisonFailure $comparisonFailure
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-return never-return
     */
    protected function fail($other, $description, \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $comparisonFailure = null) : void
    {
        $failureDescription = \sprintf('Failed asserting that %s.', $this->failureDescription($other));
        $additionalFailureDescription = $this->additionalFailureDescription($other);
        if ($additionalFailureDescription) {
            $failureDescription .= "\n" . $additionalFailureDescription;
        }
        if (!empty($description)) {
            $failureDescription = $description . "\n" . $failureDescription;
        }
        throw new \PHPUnit\Framework\ExpectationFailedException($failureDescription, $comparisonFailure);
    }
    /**
     * Return additional failure description where needed.
     *
     * The function can be overridden to provide additional failure
     * information like a diff
     *
     * @param mixed $other evaluated value or object
     */
    protected function additionalFailureDescription($other) : string
    {
        return '';
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * To provide additional failure information additionalFailureDescription
     * can be used.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        return $this->exporter()->export($other) . ' ' . $this->toString();
    }
    /**
     * Returns a custom string representation of the constraint object when it
     * appears in context of an $operator expression.
     *
     * The purpose of this method is to provide meaningful descriptive string
     * in context of operators such as LogicalNot. Native PHPUnit constraints
     * are supported out of the box by LogicalNot, but externally developed
     * ones had no way to provide correct strings in this context.
     *
     * The method shall return empty string, when it does not handle
     * customization by itself.
     *
     * @param Operator $operator the $operator of the expression
     * @param mixed    $role     role of $this constraint in the $operator expression
     */
    protected function toStringInContext(\PHPUnit\Framework\Constraint\Operator $operator, $role) : string
    {
        return '';
    }
    /**
     * Returns the description of the failure when this constraint appears in
     * context of an $operator expression.
     *
     * The purpose of this method is to provide meaningful failue description
     * in context of operators such as LogicalNot. Native PHPUnit constraints
     * are supported out of the box by LogicalNot, but externally developed
     * ones had no way to provide correct messages in this context.
     *
     * The method shall return empty string, when it does not handle
     * customization by itself.
     *
     * @param Operator $operator the $operator of the expression
     * @param mixed    $role     role of $this constraint in the $operator expression
     * @param mixed    $other    evaluated value or object
     */
    protected function failureDescriptionInContext(\PHPUnit\Framework\Constraint\Operator $operator, $role, $other) : string
    {
        $string = $this->toStringInContext($operator, $role);
        if ($string === '') {
            return '';
        }
        return $this->exporter()->export($other) . ' ' . $string;
    }
    /**
     * Reduces the sub-expression starting at $this by skipping degenerate
     * sub-expression and returns first descendant constraint that starts
     * a non-reducible sub-expression.
     *
     * Returns $this for terminal constraints and for operators that start
     * non-reducible sub-expression, or the nearest descendant of $this that
     * starts a non-reducible sub-expression.
     *
     * A constraint expression may be modelled as a tree with non-terminal
     * nodes (operators) and terminal nodes. For example:
     *
     *      LogicalOr           (operator, non-terminal)
     *      + LogicalAnd        (operator, non-terminal)
     *      | + IsType('int')   (terminal)
     *      | + GreaterThan(10) (terminal)
     *      + LogicalNot        (operator, non-terminal)
     *        + IsType('array') (terminal)
     *
     * A degenerate sub-expression is a part of the tree, that effectively does
     * not contribute to the evaluation of the expression it appears in. An example
     * of degenerate sub-expression is a BinaryOperator constructed with single
     * operand or nested BinaryOperators, each with single operand. An
     * expression involving a degenerate sub-expression is equivalent to a
     * reduced expression with the degenerate sub-expression removed, for example
     *
     *      LogicalAnd          (operator)
     *      + LogicalOr         (degenerate operator)
     *      | + LogicalAnd      (degenerate operator)
     *      |   + IsType('int') (terminal)
     *      + GreaterThan(10)   (terminal)
     *
     * is equivalent to
     *
     *      LogicalAnd          (operator)
     *      + IsType('int')     (terminal)
     *      + GreaterThan(10)   (terminal)
     *
     * because the subexpression
     *
     *      + LogicalOr
     *        + LogicalAnd
     *          + -
     *
     * is degenerate. Calling reduce() on the LogicalOr object above, as well
     * as on LogicalAnd, shall return the IsType('int') instance.
     *
     * Other specific reductions can be implemented, for example cascade of
     * LogicalNot operators
     *
     *      + LogicalNot
     *        + LogicalNot
     *          +LogicalNot
     *           + IsTrue
     *
     * can be reduced to
     *
     *      LogicalNot
     *      + IsTrue
     */
    protected function reduce() : self
    {
        return $this;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_string;
use function sprintf;
use function strpos;
use function trim;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
use PHPUnit\SebastianBergmann\Comparator\Factory as ComparatorFactory;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsEqual extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var mixed
     */
    private $value;
    private float $delta;
    private bool $canonicalize;
    private bool $ignoreCase;
    public function __construct($value, float $delta = 0.0, bool $canonicalize = \false, bool $ignoreCase = \false)
    {
        $this->value = $value;
        $this->delta = $delta;
        $this->canonicalize = $canonicalize;
        $this->ignoreCase = $ignoreCase;
    }
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @throws ExpectationFailedException
     *
     * @return bool
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        // If $this->value and $other are identical, they are also equal.
        // This is the most common path and will allow us to skip
        // initialization of all the comparators.
        if ($this->value === $other) {
            return \true;
        }
        $comparatorFactory = \PHPUnit\SebastianBergmann\Comparator\Factory::getInstance();
        try {
            $comparator = $comparatorFactory->getComparatorFor($this->value, $other);
            $comparator->assertEquals($this->value, $other, $this->delta, $this->canonicalize, $this->ignoreCase);
        } catch (\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $f) {
            if ($returnResult) {
                return \false;
            }
            throw new \PHPUnit\Framework\ExpectationFailedException(\trim($description . "\n" . $f->getMessage()), $f);
        }
        return \true;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        $delta = '';
        if (\is_string($this->value)) {
            if (\strpos($this->value, "\n") !== \false) {
                return 'is equal to <text>';
            }
            return \sprintf("is equal to '%s'", $this->value);
        }
        if ($this->delta != 0) {
            $delta = \sprintf(' with delta <%F>', $this->delta);
        }
        return \sprintf('is equal to %s%s', $this->exporter()->export($this->value), $delta);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_string;
use function sprintf;
use function strpos;
use function trim;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
use PHPUnit\SebastianBergmann\Comparator\Factory as ComparatorFactory;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsEqualCanonicalizing extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var mixed
     */
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @throws ExpectationFailedException
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        // If $this->value and $other are identical, they are also equal.
        // This is the most common path and will allow us to skip
        // initialization of all the comparators.
        if ($this->value === $other) {
            return \true;
        }
        $comparatorFactory = \PHPUnit\SebastianBergmann\Comparator\Factory::getInstance();
        try {
            $comparator = $comparatorFactory->getComparatorFor($this->value, $other);
            $comparator->assertEquals($this->value, $other, 0.0, \true, \false);
        } catch (\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $f) {
            if ($returnResult) {
                return \false;
            }
            throw new \PHPUnit\Framework\ExpectationFailedException(\trim($description . "\n" . $f->getMessage()), $f);
        }
        return \true;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        if (\is_string($this->value)) {
            if (\strpos($this->value, "\n") !== \false) {
                return 'is equal to <text>';
            }
            return \sprintf("is equal to '%s'", $this->value);
        }
        return \sprintf('is equal to %s', $this->exporter()->export($this->value));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_string;
use function sprintf;
use function strpos;
use function trim;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
use PHPUnit\SebastianBergmann\Comparator\Factory as ComparatorFactory;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsEqualIgnoringCase extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var mixed
     */
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @throws ExpectationFailedException
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        // If $this->value and $other are identical, they are also equal.
        // This is the most common path and will allow us to skip
        // initialization of all the comparators.
        if ($this->value === $other) {
            return \true;
        }
        $comparatorFactory = \PHPUnit\SebastianBergmann\Comparator\Factory::getInstance();
        try {
            $comparator = $comparatorFactory->getComparatorFor($this->value, $other);
            $comparator->assertEquals($this->value, $other, 0.0, \false, \true);
        } catch (\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $f) {
            if ($returnResult) {
                return \false;
            }
            throw new \PHPUnit\Framework\ExpectationFailedException(\trim($description . "\n" . $f->getMessage()), $f);
        }
        return \true;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        if (\is_string($this->value)) {
            if (\strpos($this->value, "\n") !== \false) {
                return 'is equal to <text>';
            }
            return \sprintf("is equal to '%s'", $this->value);
        }
        return \sprintf('is equal to %s', $this->exporter()->export($this->value));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function sprintf;
use function trim;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
use PHPUnit\SebastianBergmann\Comparator\Factory as ComparatorFactory;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsEqualWithDelta extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var mixed
     */
    private $value;
    private float $delta;
    public function __construct($value, float $delta)
    {
        $this->value = $value;
        $this->delta = $delta;
    }
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @throws ExpectationFailedException
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        // If $this->value and $other are identical, they are also equal.
        // This is the most common path and will allow us to skip
        // initialization of all the comparators.
        if ($this->value === $other) {
            return \true;
        }
        $comparatorFactory = \PHPUnit\SebastianBergmann\Comparator\Factory::getInstance();
        try {
            $comparator = $comparatorFactory->getComparatorFor($this->value, $other);
            $comparator->assertEquals($this->value, $other, $this->delta);
        } catch (\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $f) {
            if ($returnResult) {
                return \false;
            }
            throw new \PHPUnit\Framework\ExpectationFailedException(\trim($description . "\n" . $f->getMessage()), $f);
        }
        return \true;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        return \sprintf('is equal to %s with delta <%F>>', $this->exporter()->export($this->value), $this->delta);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function get_class;
use function sprintf;
use PHPUnit\Util\Filter;
use Throwable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class Exception extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $className;
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return \sprintf('exception of type "%s"', $this->className);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return $other instanceof $this->className;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        if ($other !== null) {
            $message = '';
            if ($other instanceof \Throwable) {
                $message = '. Message was: "' . $other->getMessage() . '" at' . "\n" . \PHPUnit\Util\Filter::getFilteredStacktrace($other);
            }
            return \sprintf('exception of type "%s" matches expected exception "%s"%s', \get_class($other), $this->className, $message);
        }
        return \sprintf('exception of type "%s" is thrown', $this->className);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function sprintf;
use Throwable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class ExceptionCode extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var int|string
     */
    private $expectedCode;
    /**
     * @param int|string $expected
     */
    public function __construct($expected)
    {
        $this->expectedCode = $expected;
    }
    public function toString() : string
    {
        return 'exception code is ';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param Throwable $other
     */
    protected function matches($other) : bool
    {
        return (string) $other->getCode() === (string) $this->expectedCode;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('%s is equal to expected exception code %s', $this->exporter()->export($other->getCode()), $this->exporter()->export($this->expectedCode));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function sprintf;
use function strpos;
use Throwable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class ExceptionMessage extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $expectedMessage;
    public function __construct(string $expected)
    {
        $this->expectedMessage = $expected;
    }
    public function toString() : string
    {
        if ($this->expectedMessage === '') {
            return 'exception message is empty';
        }
        return 'exception message contains ';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param Throwable $other
     */
    protected function matches($other) : bool
    {
        if ($this->expectedMessage === '') {
            return $other->getMessage() === '';
        }
        return \strpos((string) $other->getMessage(), $this->expectedMessage) !== \false;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        if ($this->expectedMessage === '') {
            return \sprintf("exception message is empty but is '%s'", $other->getMessage());
        }
        return \sprintf("exception message '%s' contains '%s'", $other->getMessage(), $this->expectedMessage);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function sprintf;
use Exception;
use PHPUnit\Util\RegularExpression as RegularExpressionUtil;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class ExceptionMessageRegularExpression extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $expectedMessageRegExp;
    public function __construct(string $expected)
    {
        $this->expectedMessageRegExp = $expected;
    }
    public function toString() : string
    {
        return 'exception message matches ';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param \PHPUnit\Framework\Exception $other
     *
     * @throws \PHPUnit\Framework\Exception
     * @throws Exception
     */
    protected function matches($other) : bool
    {
        $match = \PHPUnit\Util\RegularExpression::safeMatch($this->expectedMessageRegExp, $other->getMessage());
        if ($match === \false) {
            throw new \PHPUnit\Framework\Exception("Invalid expected exception message regex given: '{$this->expectedMessageRegExp}'");
        }
        return $match === 1;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        return \sprintf("exception message '%s' matches '%s'", $other->getMessage(), $this->expectedMessageRegExp);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_dir;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class DirectoryExists extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'directory exists';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \is_dir($other);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('directory "%s" exists', $other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function file_exists;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class FileExists extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'file exists';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \file_exists($other);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('file "%s" exists', $other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_readable;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsReadable extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is readable';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \is_readable($other);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('"%s" is readable', $other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_writable;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsWritable extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is writable';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \is_writable($other);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('"%s" is writable', $other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use PHPUnit\Framework\ExpectationFailedException;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsAnything extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @throws ExpectationFailedException
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        return $returnResult ? \true : null;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is anything';
    }
    /**
     * Counts the number of constraint elements.
     */
    public function count() : int
    {
        return 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function abs;
use function get_class;
use function is_array;
use function is_float;
use function is_infinite;
use function is_nan;
use function is_object;
use function is_string;
use function sprintf;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsIdentical extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var float
     */
    private const EPSILON = 1.0E-10;
    /**
     * @var mixed
     */
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        if (\is_float($this->value) && \is_float($other) && !\is_infinite($this->value) && !\is_infinite($other) && !\is_nan($this->value) && !\is_nan($other)) {
            $success = \abs($this->value - $other) < self::EPSILON;
        } else {
            $success = $this->value === $other;
        }
        if ($returnResult) {
            return $success;
        }
        if (!$success) {
            $f = null;
            // if both values are strings, make sure a diff is generated
            if (\is_string($this->value) && \is_string($other)) {
                $f = new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($this->value, $other, \sprintf("'%s'", $this->value), \sprintf("'%s'", $other));
            }
            // if both values are array, make sure a diff is generated
            if (\is_array($this->value) && \is_array($other)) {
                $f = new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($this->value, $other, $this->exporter()->export($this->value), $this->exporter()->export($other));
            }
            $this->fail($other, $description, $f);
        }
        return null;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        if (\is_object($this->value)) {
            return 'is identical to an object of class "' . \get_class($this->value) . '"';
        }
        return 'is identical to ' . $this->exporter()->export($this->value);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        if (\is_object($this->value) && \is_object($other)) {
            return 'two variables reference the same object';
        }
        if (\is_string($this->value) && \is_string($other)) {
            return 'two strings are identical';
        }
        if (\is_array($this->value) && \is_array($other)) {
            return 'two arrays are identical';
        }
        return parent::failureDescription($other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function json_decode;
use function sprintf;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Util\Json;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class JsonMatches extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $value;
    public function __construct(string $value)
    {
        $this->value = $value;
    }
    /**
     * Returns a string representation of the object.
     */
    public function toString() : string
    {
        return \sprintf('matches JSON string "%s"', $this->value);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * This method can be overridden to implement the evaluation algorithm.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        [$error, $recodedOther] = \PHPUnit\Util\Json::canonicalize($other);
        if ($error) {
            return \false;
        }
        [$error, $recodedValue] = \PHPUnit\Util\Json::canonicalize($this->value);
        if ($error) {
            return \false;
        }
        return $recodedOther == $recodedValue;
    }
    /**
     * Throws an exception for the given compared value and test description.
     *
     * @param mixed             $other             evaluated value or object
     * @param string            $description       Additional information about the test
     * @param ComparisonFailure $comparisonFailure
     *
     * @throws \PHPUnit\Framework\Exception
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     *
     * @psalm-return never-return
     */
    protected function fail($other, $description, \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $comparisonFailure = null) : void
    {
        if ($comparisonFailure === null) {
            [$error, $recodedOther] = \PHPUnit\Util\Json::canonicalize($other);
            if ($error) {
                parent::fail($other, $description);
            }
            [$error, $recodedValue] = \PHPUnit\Util\Json::canonicalize($this->value);
            if ($error) {
                parent::fail($other, $description);
            }
            $comparisonFailure = new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure(\json_decode($this->value), \json_decode($other), \PHPUnit\Util\Json::prettify($recodedValue), \PHPUnit\Util\Json::prettify($recodedOther), \false, 'Failed asserting that two json values are equal.');
        }
        parent::fail($other, $description, $comparisonFailure);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use const JSON_ERROR_CTRL_CHAR;
use const JSON_ERROR_DEPTH;
use const JSON_ERROR_NONE;
use const JSON_ERROR_STATE_MISMATCH;
use const JSON_ERROR_SYNTAX;
use const JSON_ERROR_UTF8;
use function strtolower;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class JsonMatchesErrorMessageProvider
{
    /**
     * Translates JSON error to a human readable string.
     */
    public static function determineJsonError(string $error, string $prefix = '') : ?string
    {
        switch ($error) {
            case \JSON_ERROR_NONE:
                return null;
            case \JSON_ERROR_DEPTH:
                return $prefix . 'Maximum stack depth exceeded';
            case \JSON_ERROR_STATE_MISMATCH:
                return $prefix . 'Underflow or the modes mismatch';
            case \JSON_ERROR_CTRL_CHAR:
                return $prefix . 'Unexpected control character found';
            case \JSON_ERROR_SYNTAX:
                return $prefix . 'Syntax error, malformed JSON';
            case \JSON_ERROR_UTF8:
                return $prefix . 'Malformed UTF-8 characters, possibly incorrectly encoded';
            default:
                return $prefix . 'Unknown error';
        }
    }
    /**
     * Translates a given type to a human readable message prefix.
     */
    public static function translateTypeToPrefix(string $type) : string
    {
        switch (\strtolower($type)) {
            case 'expected':
                $prefix = 'Expected value JSON decode error - ';
                break;
            case 'actual':
                $prefix = 'Actual value JSON decode error - ';
                break;
            default:
                $prefix = '';
                break;
        }
        return $prefix;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_finite;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsFinite extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is finite';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \is_finite($other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_infinite;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsInfinite extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is infinite';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \is_infinite($other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_nan;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsNan extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is nan';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \is_nan($other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function get_class;
use function is_object;
use function sprintf;
use PHPUnit\Framework\Exception;
use ReflectionClass;
use ReflectionException;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @codeCoverageIgnore
 *
 * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
 */
class ClassHasAttribute extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $attributeName;
    public function __construct(string $attributeName)
    {
        $this->attributeName = $attributeName;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return \sprintf('has attribute "%s"', $this->attributeName);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        try {
            return (new \ReflectionClass($other))->hasProperty($this->attributeName);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('%sclass "%s" %s', \is_object($other) ? 'object of ' : '', \is_object($other) ? \get_class($other) : $other, $this->toString());
    }
    protected function attributeName() : string
    {
        return $this->attributeName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function sprintf;
use PHPUnit\Framework\Exception;
use ReflectionClass;
use ReflectionException;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @codeCoverageIgnore
 *
 * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
 */
final class ClassHasStaticAttribute extends \PHPUnit\Framework\Constraint\ClassHasAttribute
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return \sprintf('has static attribute "%s"', $this->attributeName());
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        try {
            $class = new \ReflectionClass($other);
            if ($class->hasProperty($this->attributeName())) {
                return $class->getProperty($this->attributeName())->isStatic();
            }
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function get_class;
use function is_object;
use PHPUnit\Framework\ActualValueIsNotAnObjectException;
use PHPUnit\Framework\ComparisonMethodDoesNotAcceptParameterTypeException;
use PHPUnit\Framework\ComparisonMethodDoesNotDeclareBoolReturnTypeException;
use PHPUnit\Framework\ComparisonMethodDoesNotDeclareExactlyOneParameterException;
use PHPUnit\Framework\ComparisonMethodDoesNotDeclareParameterTypeException;
use PHPUnit\Framework\ComparisonMethodDoesNotExistException;
use ReflectionNamedType;
use ReflectionObject;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class ObjectEquals extends \PHPUnit\Framework\Constraint\Constraint
{
    private object $expected;
    private string $method;
    public function __construct(object $object, string $method = 'equals')
    {
        $this->expected = $object;
        $this->method = $method;
    }
    public function toString() : string
    {
        return 'two objects are equal';
    }
    /**
     * @throws ActualValueIsNotAnObjectException
     * @throws ComparisonMethodDoesNotAcceptParameterTypeException
     * @throws ComparisonMethodDoesNotDeclareBoolReturnTypeException
     * @throws ComparisonMethodDoesNotDeclareExactlyOneParameterException
     * @throws ComparisonMethodDoesNotDeclareParameterTypeException
     * @throws ComparisonMethodDoesNotExistException
     */
    protected function matches($other) : bool
    {
        if (!\is_object($other)) {
            throw new \PHPUnit\Framework\ActualValueIsNotAnObjectException();
        }
        $object = new \ReflectionObject($other);
        if (!$object->hasMethod($this->method)) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotExistException(\get_class($other), $this->method);
        }
        /** @noinspection PhpUnhandledExceptionInspection */
        $method = $object->getMethod($this->method);
        if (!$method->hasReturnType()) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotDeclareBoolReturnTypeException(\get_class($other), $this->method);
        }
        $returnType = $method->getReturnType();
        if (!$returnType instanceof \ReflectionNamedType) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotDeclareBoolReturnTypeException(\get_class($other), $this->method);
        }
        if ($returnType->allowsNull()) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotDeclareBoolReturnTypeException(\get_class($other), $this->method);
        }
        if ($returnType->getName() !== 'bool') {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotDeclareBoolReturnTypeException(\get_class($other), $this->method);
        }
        if ($method->getNumberOfParameters() !== 1 || $method->getNumberOfRequiredParameters() !== 1) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotDeclareExactlyOneParameterException(\get_class($other), $this->method);
        }
        $parameter = $method->getParameters()[0];
        if (!$parameter->hasType()) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotDeclareParameterTypeException(\get_class($other), $this->method);
        }
        $type = $parameter->getType();
        if (!$type instanceof \ReflectionNamedType) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotDeclareParameterTypeException(\get_class($other), $this->method);
        }
        $typeName = $type->getName();
        if ($typeName === 'self') {
            $typeName = \get_class($other);
        }
        if (!$this->expected instanceof $typeName) {
            throw new \PHPUnit\Framework\ComparisonMethodDoesNotAcceptParameterTypeException(\get_class($other), $this->method, \get_class($this->expected));
        }
        return $other->{$this->method}($this->expected);
    }
    protected function failureDescription($other) : string
    {
        return $this->toString();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use ReflectionObject;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @codeCoverageIgnore
 *
 * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4601
 */
final class ObjectHasAttribute extends \PHPUnit\Framework\Constraint\ClassHasAttribute
{
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return (new \ReflectionObject($other))->hasProperty($this->attributeName());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function array_map;
use function array_values;
use function count;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
abstract class BinaryOperator extends \PHPUnit\Framework\Constraint\Operator
{
    /**
     * @var Constraint[]
     */
    private array $constraints = [];
    public static function fromConstraints(\PHPUnit\Framework\Constraint\Constraint ...$constraints) : self
    {
        $constraint = new static();
        $constraint->constraints = $constraints;
        return $constraint;
    }
    /**
     * @param mixed[] $constraints
     */
    public function setConstraints(array $constraints) : void
    {
        $this->constraints = \array_map(function ($constraint) : Constraint {
            return $this->checkConstraint($constraint);
        }, \array_values($constraints));
    }
    /**
     * Returns the number of operands (constraints).
     */
    public final function arity() : int
    {
        return \count($this->constraints);
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        $reduced = $this->reduce();
        if ($reduced !== $this) {
            return $reduced->toString();
        }
        $text = '';
        foreach ($this->constraints as $key => $constraint) {
            $constraint = $constraint->reduce();
            $text .= $this->constraintToString($constraint, $key);
        }
        return $text;
    }
    /**
     * Counts the number of constraint elements.
     */
    public function count() : int
    {
        $count = 0;
        foreach ($this->constraints as $constraint) {
            $count += \count($constraint);
        }
        return $count;
    }
    /**
     * Returns the nested constraints.
     */
    protected final function constraints() : array
    {
        return $this->constraints;
    }
    /**
     * Returns true if the $constraint needs to be wrapped with braces.
     */
    protected final function constraintNeedsParentheses(\PHPUnit\Framework\Constraint\Constraint $constraint) : bool
    {
        return $this->arity() > 1 && parent::constraintNeedsParentheses($constraint);
    }
    /**
     * Reduces the sub-expression starting at $this by skipping degenerate
     * sub-expression and returns first descendant constraint that starts
     * a non-reducible sub-expression.
     *
     * See Constraint::reduce() for more.
     */
    protected function reduce() : \PHPUnit\Framework\Constraint\Constraint
    {
        if ($this->arity() === 1 && $this->constraints[0] instanceof \PHPUnit\Framework\Constraint\Operator) {
            return $this->constraints[0]->reduce();
        }
        return parent::reduce();
    }
    /**
     * Returns string representation of given operand in context of this operator.
     *
     * @param Constraint $constraint operand constraint
     * @param int        $position   position of $constraint in this expression
     */
    private function constraintToString(\PHPUnit\Framework\Constraint\Constraint $constraint, int $position) : string
    {
        $prefix = '';
        if ($position > 0) {
            $prefix = ' ' . $this->operator() . ' ';
        }
        if ($this->constraintNeedsParentheses($constraint)) {
            return $prefix . '( ' . $constraint->toString() . ' )';
        }
        $string = $constraint->toStringInContext($this, $position);
        if ($string === '') {
            $string = $constraint->toString();
        }
        return $prefix . $string;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class LogicalAnd extends \PHPUnit\Framework\Constraint\BinaryOperator
{
    /**
     * Returns the name of this operator.
     */
    public function operator() : string
    {
        return 'and';
    }
    /**
     * Returns this operator's precedence.
     *
     * @see https://www.php.net/manual/en/language.operators.precedence.php
     */
    public function precedence() : int
    {
        return 22;
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        foreach ($this->constraints() as $constraint) {
            if (!$constraint->evaluate($other, '', \true)) {
                return \false;
            }
        }
        return [] !== $this->constraints();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function array_map;
use function count;
use function preg_match;
use function preg_quote;
use function preg_replace;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class LogicalNot extends \PHPUnit\Framework\Constraint\UnaryOperator
{
    public static function negate(string $string) : string
    {
        $positives = ['contains ', 'exists', 'has ', 'is ', 'are ', 'matches ', 'starts with ', 'ends with ', 'reference ', 'not not '];
        $negatives = ['does not contain ', 'does not exist', 'does not have ', 'is not ', 'are not ', 'does not match ', 'starts not with ', 'ends not with ', 'don\'t reference ', 'not '];
        \preg_match('/(\'[\\w\\W]*\')([\\w\\W]*)("[\\w\\W]*")/i', $string, $matches);
        $positives = \array_map(static function (string $s) {
            return '/\\b' . \preg_quote($s, '/') . '/';
        }, $positives);
        if (\count($matches) > 0) {
            $nonInput = $matches[2];
            $negatedString = \preg_replace('/' . \preg_quote($nonInput, '/') . '/', \preg_replace($positives, $negatives, $nonInput), $string);
        } else {
            $negatedString = \preg_replace($positives, $negatives, $string);
        }
        return $negatedString;
    }
    /**
     * Returns the name of this operator.
     */
    public function operator() : string
    {
        return 'not';
    }
    /**
     * Returns this operator's precedence.
     *
     * @see https://www.php.net/manual/en/language.operators.precedence.php
     */
    public function precedence() : int
    {
        return 5;
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return !$this->constraint()->evaluate($other, '', \true);
    }
    /**
     * Applies additional transformation to strings returned by toString() or
     * failureDescription().
     */
    protected function transformString(string $string) : string
    {
        return self::negate($string);
    }
    /**
     * Reduces the sub-expression starting at $this by skipping degenerate
     * sub-expression and returns first descendant constraint that starts
     * a non-reducible sub-expression.
     *
     * See Constraint::reduce() for more.
     */
    protected function reduce() : \PHPUnit\Framework\Constraint\Constraint
    {
        $constraint = $this->constraint();
        if ($constraint instanceof self) {
            return $constraint->constraint()->reduce();
        }
        return parent::reduce();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class LogicalOr extends \PHPUnit\Framework\Constraint\BinaryOperator
{
    /**
     * Returns the name of this operator.
     */
    public function operator() : string
    {
        return 'or';
    }
    /**
     * Returns this operator's precedence.
     *
     * @see https://www.php.net/manual/en/language.operators.precedence.php
     */
    public function precedence() : int
    {
        return 24;
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    public function matches($other) : bool
    {
        foreach ($this->constraints() as $constraint) {
            if ($constraint->evaluate($other, '', \true)) {
                return \true;
            }
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function array_reduce;
use function array_shift;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class LogicalXor extends \PHPUnit\Framework\Constraint\BinaryOperator
{
    /**
     * Returns the name of this operator.
     */
    public function operator() : string
    {
        return 'xor';
    }
    /**
     * Returns this operator's precedence.
     *
     * @see https://www.php.net/manual/en/language.operators.precedence.php.
     */
    public function precedence() : int
    {
        return 23;
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    public function matches($other) : bool
    {
        $constraints = $this->constraints();
        $initial = \array_shift($constraints);
        if ($initial === null) {
            return \false;
        }
        return \array_reduce($constraints, static function (bool $matches, \PHPUnit\Framework\Constraint\Constraint $constraint) use($other) : bool {
            return $matches xor $constraint->evaluate($other, '', \true);
        }, $initial->evaluate($other, '', \true));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
abstract class Operator extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns the name of this operator.
     */
    public abstract function operator() : string;
    /**
     * Returns this operator's precedence.
     *
     * @see https://www.php.net/manual/en/language.operators.precedence.php
     */
    public abstract function precedence() : int;
    /**
     * Returns the number of operands.
     */
    public abstract function arity() : int;
    /**
     * Validates $constraint argument.
     */
    protected function checkConstraint($constraint) : \PHPUnit\Framework\Constraint\Constraint
    {
        if (!$constraint instanceof \PHPUnit\Framework\Constraint\Constraint) {
            return new \PHPUnit\Framework\Constraint\IsEqual($constraint);
        }
        return $constraint;
    }
    /**
     * Returns true if the $constraint needs to be wrapped with braces.
     */
    protected function constraintNeedsParentheses(\PHPUnit\Framework\Constraint\Constraint $constraint) : bool
    {
        return $constraint instanceof self && $constraint->arity() > 1 && $this->precedence() <= $constraint->precedence();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function count;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
abstract class UnaryOperator extends \PHPUnit\Framework\Constraint\Operator
{
    private \PHPUnit\Framework\Constraint\Constraint $constraint;
    /**
     * @param Constraint|mixed $constraint
     */
    public function __construct($constraint)
    {
        $this->constraint = $this->checkConstraint($constraint);
    }
    /**
     * Returns the number of operands (constraints).
     */
    public function arity() : int
    {
        return 1;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        $reduced = $this->reduce();
        if ($reduced !== $this) {
            return $reduced->toString();
        }
        $constraint = $this->constraint->reduce();
        if ($this->constraintNeedsParentheses($constraint)) {
            return $this->operator() . '( ' . $constraint->toString() . ' )';
        }
        $string = $constraint->toStringInContext($this, 0);
        if ($string === '') {
            return $this->transformString($constraint->toString());
        }
        return $string;
    }
    /**
     * Counts the number of constraint elements.
     */
    public function count() : int
    {
        return \count($this->constraint);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        $reduced = $this->reduce();
        if ($reduced !== $this) {
            return $reduced->failureDescription($other);
        }
        $constraint = $this->constraint->reduce();
        if ($this->constraintNeedsParentheses($constraint)) {
            return $this->operator() . '( ' . $constraint->failureDescription($other) . ' )';
        }
        $string = $constraint->failureDescriptionInContext($this, 0, $other);
        if ($string === '') {
            return $this->transformString($constraint->failureDescription($other));
        }
        return $string;
    }
    /**
     * Transforms string returned by the memeber constraint's toString() or
     * failureDescription() such that it reflects constraint's participation in
     * this expression.
     *
     * The method may be overwritten in a subclass to apply default
     * transformation in case the operand constraint does not provide its own
     * custom strings via toStringInContext() or failureDescriptionInContext().
     *
     * @param string $string the string to be transformed
     */
    protected function transformString(string $string) : string
    {
        return $string;
    }
    /**
     * Provides access to $this->constraint for subclasses.
     */
    protected final function constraint() : \PHPUnit\Framework\Constraint\Constraint
    {
        return $this->constraint;
    }
    /**
     * Returns true if the $constraint needs to be wrapped with parentheses.
     */
    protected function constraintNeedsParentheses(\PHPUnit\Framework\Constraint\Constraint $constraint) : bool
    {
        $constraint = $constraint->reduce();
        return $constraint instanceof self || parent::constraintNeedsParentheses($constraint);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function json_decode;
use function json_last_error;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsJson extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is valid JSON';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        if ($other === '') {
            return \false;
        }
        \json_decode($other);
        if (\json_last_error()) {
            return \false;
        }
        return \true;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        if ($other === '') {
            return 'an empty string is valid JSON';
        }
        \json_decode($other);
        $error = (string) \PHPUnit\Framework\Constraint\JsonMatchesErrorMessageProvider::determineJsonError((string) \json_last_error());
        return \sprintf('%s is valid JSON (%s)', $this->exporter()->shortenedExport($other), $error);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function preg_match;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
class RegularExpression extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $pattern;
    public function __construct(string $pattern)
    {
        $this->pattern = $pattern;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return \sprintf('matches PCRE pattern "%s"', $this->pattern);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \preg_match($this->pattern, $other) > 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function mb_stripos;
use function mb_strtolower;
use function sprintf;
use function strpos;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class StringContains extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $string;
    private bool $ignoreCase;
    public function __construct(string $string, bool $ignoreCase = \false)
    {
        $this->string = $string;
        $this->ignoreCase = $ignoreCase;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        if ($this->ignoreCase) {
            $string = \mb_strtolower($this->string, 'UTF-8');
        } else {
            $string = $this->string;
        }
        return \sprintf('contains "%s"', $string);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        if ('' === $this->string) {
            return \true;
        }
        if ($this->ignoreCase) {
            /*
             * We must use the multi byte safe version so we can accurately compare non latin upper characters with
             * their lowercase equivalents.
             */
            return \mb_stripos($other, $this->string, 0, 'UTF-8') !== \false;
        }
        /*
         * Use the non multi byte safe functions to see if the string is contained in $other.
         *
         * This function is very fast and we don't care about the character position in the string.
         *
         * Additionally, we want this method to be binary safe so we can check if some binary data is in other binary
         * data.
         */
        return \strpos($other, $this->string) !== \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function strlen;
use function substr;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class StringEndsWith extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $suffix;
    public function __construct(string $suffix)
    {
        $this->suffix = $suffix;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'ends with "' . $this->suffix . '"';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \substr($other, 0 - \strlen($this->suffix)) === $this->suffix;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use const DIRECTORY_SEPARATOR;
use function explode;
use function implode;
use function preg_match;
use function preg_quote;
use function preg_replace;
use function strtr;
use PHPUnit\SebastianBergmann\Diff\Differ;
use PHPUnit\SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class StringMatchesFormatDescription extends \PHPUnit\Framework\Constraint\RegularExpression
{
    private string $string;
    public function __construct(string $string)
    {
        parent::__construct($this->createPatternFromFormat($this->convertNewlines($string)));
        $this->string = $string;
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return parent::matches($this->convertNewlines($other));
    }
    protected function failureDescription($other) : string
    {
        return 'string matches format description';
    }
    protected function additionalFailureDescription($other) : string
    {
        $from = \explode("\n", $this->string);
        $to = \explode("\n", $this->convertNewlines($other));
        foreach ($from as $index => $line) {
            if (isset($to[$index]) && $line !== $to[$index]) {
                $line = $this->createPatternFromFormat($line);
                if (\preg_match($line, $to[$index]) > 0) {
                    $from[$index] = $to[$index];
                }
            }
        }
        $this->string = \implode("\n", $from);
        $other = \implode("\n", $to);
        return (new \PHPUnit\SebastianBergmann\Diff\Differ(new \PHPUnit\SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder("--- Expected\n+++ Actual\n")))->diff($this->string, $other);
    }
    private function createPatternFromFormat(string $string) : string
    {
        $string = \strtr(\preg_quote($string, '/'), ['%%' => '%', '%e' => '\\' . \DIRECTORY_SEPARATOR, '%s' => '[^\\r\\n]+', '%S' => '[^\\r\\n]*', '%a' => '.+', '%A' => '.*', '%w' => '\\s*', '%i' => '[+-]?\\d+', '%d' => '\\d+', '%x' => '[0-9a-fA-F]+', '%f' => '[+-]?\\.?\\d+\\.?\\d*(?:[Ee][+-]?\\d+)?', '%c' => '.']);
        return '/^' . $string . '$/s';
    }
    private function convertNewlines(string $text) : string
    {
        return \preg_replace('/\\r\\n/', "\n", $text);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function strlen;
use function strpos;
use PHPUnit\Framework\InvalidArgumentException;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class StringStartsWith extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $prefix;
    public function __construct(string $prefix)
    {
        if (\strlen($prefix) === 0) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'non-empty string');
        }
        $this->prefix = $prefix;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'starts with "' . $this->prefix . '"';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return \strpos((string) $other, $this->prefix) === 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function array_key_exists;
use function is_array;
use ArrayAccess;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class ArrayHasKey extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var int|string
     */
    private $key;
    /**
     * @param int|string $key
     */
    public function __construct($key)
    {
        $this->key = $key;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        return 'has the key ' . $this->exporter()->export($this->key);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        if (\is_array($other)) {
            return \array_key_exists($this->key, $other);
        }
        if ($other instanceof \ArrayAccess) {
            return $other->offsetExists($this->key);
        }
        return \false;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        return 'an array ' . $this->toString();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function is_array;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
abstract class TraversableContains extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var mixed
     */
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }
    /**
     * Returns a string representation of the constraint.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        return 'contains ' . $this->exporter()->export($this->value);
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('%s %s', \is_array($other) ? 'an array' : 'a traversable', $this->toString());
    }
    protected function value()
    {
        return $this->value;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use SplObjectStorage;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class TraversableContainsEqual extends \PHPUnit\Framework\Constraint\TraversableContains
{
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        if ($other instanceof \SplObjectStorage) {
            return $other->contains($this->value());
        }
        foreach ($other as $element) {
            /* @noinspection TypeUnsafeComparisonInspection */
            if ($this->value() == $element) {
                return \true;
            }
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use SplObjectStorage;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class TraversableContainsIdentical extends \PHPUnit\Framework\Constraint\TraversableContains
{
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        if ($other instanceof \SplObjectStorage) {
            return $other->contains($this->value());
        }
        foreach ($other as $element) {
            if ($this->value() === $element) {
                return \true;
            }
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use PHPUnit\Framework\ExpectationFailedException;
use Traversable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class TraversableContainsOnly extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var Constraint
     */
    private $constraint;
    private string $type;
    /**
     * @throws \PHPUnit\Framework\Exception
     */
    public function __construct(string $type, bool $isNativeType = \true)
    {
        if ($isNativeType) {
            $this->constraint = new \PHPUnit\Framework\Constraint\IsType($type);
        } else {
            $this->constraint = new \PHPUnit\Framework\Constraint\IsInstanceOf($type);
        }
        $this->type = $type;
    }
    /**
     * Evaluates the constraint for parameter $other.
     *
     * If $returnResult is set to false (the default), an exception is thrown
     * in case of a failure. null is returned otherwise.
     *
     * If $returnResult is true, the result of the evaluation is returned as
     * a boolean value instead: true in case of success, false in case of a
     * failure.
     *
     * @param mixed|Traversable $other
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public function evaluate($other, string $description = '', bool $returnResult = \false) : ?bool
    {
        $success = \true;
        foreach ($other as $item) {
            if (!$this->constraint->evaluate($item, '', \true)) {
                $success = \false;
                break;
            }
        }
        if ($returnResult) {
            return $success;
        }
        if (!$success) {
            $this->fail($other, $description);
        }
        return null;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'contains only values of type "' . $this->type . '"';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function sprintf;
use ReflectionClass;
use ReflectionException;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsInstanceOf extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $className;
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return \sprintf('is instance of %s "%s"', $this->getType(), $this->className);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return $other instanceof $this->className;
    }
    /**
     * Returns the description of the failure.
     *
     * The beginning of failure messages is "Failed asserting that" in most
     * cases. This method should return the second part of that sentence.
     *
     * @param mixed $other evaluated value or object
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function failureDescription($other) : string
    {
        return \sprintf('%s is an instance of %s "%s"', $this->exporter()->shortenedExport($other), $this->getType(), $this->className);
    }
    private function getType() : string
    {
        try {
            $reflection = new \ReflectionClass($this->className);
            if ($reflection->isInterface()) {
                return 'interface';
            }
        } catch (\ReflectionException $e) {
        }
        return 'class';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsNull extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return 'is null';
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        return $other === null;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\Constraint;

use function gettype;
use function is_array;
use function is_bool;
use function is_callable;
use function is_float;
use function is_int;
use function is_iterable;
use function is_numeric;
use function is_object;
use function is_scalar;
use function is_string;
use function sprintf;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class IsType extends \PHPUnit\Framework\Constraint\Constraint
{
    /**
     * @var string
     */
    public const TYPE_ARRAY = 'array';
    /**
     * @var string
     */
    public const TYPE_BOOL = 'bool';
    /**
     * @var string
     */
    public const TYPE_FLOAT = 'float';
    /**
     * @var string
     */
    public const TYPE_INT = 'int';
    /**
     * @var string
     */
    public const TYPE_NULL = 'null';
    /**
     * @var string
     */
    public const TYPE_NUMERIC = 'numeric';
    /**
     * @var string
     */
    public const TYPE_OBJECT = 'object';
    /**
     * @var string
     */
    public const TYPE_RESOURCE = 'resource';
    /**
     * @var string
     */
    public const TYPE_CLOSED_RESOURCE = 'resource (closed)';
    /**
     * @var string
     */
    public const TYPE_STRING = 'string';
    /**
     * @var string
     */
    public const TYPE_SCALAR = 'scalar';
    /**
     * @var string
     */
    public const TYPE_CALLABLE = 'callable';
    /**
     * @var string
     */
    public const TYPE_ITERABLE = 'iterable';
    /**
     * @var array<string,bool>
     */
    private const KNOWN_TYPES = ['array' => \true, 'boolean' => \true, 'bool' => \true, 'double' => \true, 'float' => \true, 'integer' => \true, 'int' => \true, 'null' => \true, 'numeric' => \true, 'object' => \true, 'real' => \true, 'resource' => \true, 'resource (closed)' => \true, 'string' => \true, 'scalar' => \true, 'callable' => \true, 'iterable' => \true];
    private string $type;
    /**
     * @throws \PHPUnit\Framework\Exception
     */
    public function __construct(string $type)
    {
        if (!isset(self::KNOWN_TYPES[$type])) {
            throw new \PHPUnit\Framework\Exception(\sprintf('Type specified for PHPUnit\\Framework\\Constraint\\IsType <%s> ' . 'is not a valid type.', $type));
        }
        $this->type = $type;
    }
    /**
     * Returns a string representation of the constraint.
     */
    public function toString() : string
    {
        return \sprintf('is of type "%s"', $this->type);
    }
    /**
     * Evaluates the constraint for parameter $other. Returns true if the
     * constraint is met, false otherwise.
     *
     * @param mixed $other value or object to evaluate
     */
    protected function matches($other) : bool
    {
        switch ($this->type) {
            case 'numeric':
                return \is_numeric($other);
            case 'integer':
            case 'int':
                return \is_int($other);
            case 'double':
            case 'float':
            case 'real':
                return \is_float($other);
            case 'string':
                return \is_string($other);
            case 'boolean':
            case 'bool':
                return \is_bool($other);
            case 'null':
                return null === $other;
            case 'array':
                return \is_array($other);
            case 'object':
                return \is_object($other);
            case 'resource':
                $type = \gettype($other);
                return $type === 'resource' || $type === 'resource (closed)';
            case 'resource (closed)':
                return \gettype($other) === 'resource (closed)';
            case 'scalar':
                return \is_scalar($other);
            case 'callable':
                return \is_callable($other);
            case 'iterable':
                return \is_iterable($other);
            default:
                return \false;
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function explode;
use PHPUnit\Framework\TestSize\TestSize;
use PHPUnit\Metadata\GroupsFacade;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class DataProviderTestSuite extends \PHPUnit\Framework\TestSuite
{
    /**
     * @var list<ExecutionOrderDependency>
     */
    private array $dependencies = [];
    /**
     * @param list<ExecutionOrderDependency> $dependencies
     */
    public function setDependencies(array $dependencies) : void
    {
        $this->dependencies = $dependencies;
        foreach ($this->tests as $test) {
            if (!$test instanceof \PHPUnit\Framework\TestCase) {
                // @codeCoverageIgnoreStart
                continue;
                // @codeCoverageIgnoreStart
            }
            $test->setDependencies($dependencies);
        }
    }
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function provides() : array
    {
        if ($this->providedTests === null) {
            $this->providedTests = [new \PHPUnit\Framework\ExecutionOrderDependency($this->getName())];
        }
        return $this->providedTests;
    }
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function requires() : array
    {
        // A DataProviderTestSuite does not have to traverse its child tests
        // as these are inherited and cannot reference dataProvider rows directly
        return $this->dependencies;
    }
    /**
     * Returns the size of the each test created using the data provider(s).
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function size() : \PHPUnit\Framework\TestSize\TestSize
    {
        [$className, $methodName] = \explode('::', $this->getName());
        return (new \PHPUnit\Metadata\GroupsFacade())->size($className, $methodName);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ErrorTestCase extends \PHPUnit\Framework\TestCase
{
    /**
     * @var bool
     */
    protected $backupGlobals = \false;
    /**
     * @var bool
     */
    protected $backupStaticAttributes = \false;
    /**
     * @var bool
     */
    protected $runTestInSeparateProcess = \false;
    private string $message;
    public function __construct(string $message = '')
    {
        $this->message = $message;
        parent::__construct('Error');
    }
    public function getMessage() : string
    {
        return $this->message;
    }
    /**
     * Returns a string representation of the test case.
     */
    public function toString() : string
    {
        return 'Error';
    }
    /**
     * @throws Exception
     *
     * @psalm-return never-return
     */
    protected function runTest() : void
    {
        throw new \PHPUnit\Framework\Error($this->message);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ActualValueIsNotAnObjectException extends \PHPUnit\Framework\Exception
{
    public function __construct()
    {
        parent::__construct('Actual value is not an object', 0, null);
    }
    public function __toString() : string
    {
        return $this->getMessage() . \PHP_EOL;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class AssertionFailedError extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\SelfDescribing
{
    /**
     * Wrapper for getMessage() which is declared as final.
     */
    public function toString() : string
    {
        return $this->getMessage();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class CodeCoverageException extends \PHPUnit\Framework\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ComparisonMethodDoesNotAcceptParameterTypeException extends \PHPUnit\Framework\Exception
{
    public function __construct(string $className, string $methodName, string $type)
    {
        parent::__construct(\sprintf('%s is not an accepted argument type for comparison method %s::%s().', $type, $className, $methodName), 0, null);
    }
    public function __toString() : string
    {
        return $this->getMessage() . \PHP_EOL;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ComparisonMethodDoesNotDeclareBoolReturnTypeException extends \PHPUnit\Framework\Exception
{
    public function __construct(string $className, string $methodName)
    {
        parent::__construct(\sprintf('Comparison method %s::%s() does not declare bool return type.', $className, $methodName), 0, null);
    }
    public function __toString() : string
    {
        return $this->getMessage() . \PHP_EOL;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ComparisonMethodDoesNotDeclareExactlyOneParameterException extends \PHPUnit\Framework\Exception
{
    public function __construct(string $className, string $methodName)
    {
        parent::__construct(\sprintf('Comparison method %s::%s() does not declare exactly one parameter.', $className, $methodName), 0, null);
    }
    public function __toString() : string
    {
        return $this->getMessage() . \PHP_EOL;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ComparisonMethodDoesNotDeclareParameterTypeException extends \PHPUnit\Framework\Exception
{
    public function __construct(string $className, string $methodName)
    {
        parent::__construct(\sprintf('Parameter of comparison method %s::%s() does not have a declared type.', $className, $methodName), 0, null);
    }
    public function __toString() : string
    {
        return $this->getMessage() . \PHP_EOL;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ComparisonMethodDoesNotExistException extends \PHPUnit\Framework\Exception
{
    public function __construct(string $className, string $methodName)
    {
        parent::__construct(\sprintf('Comparison method %s::%s() does not exist.', $className, $methodName), 0, null);
    }
    public function __toString() : string
    {
        return $this->getMessage() . \PHP_EOL;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CoveredCodeNotExecutedException extends \PHPUnit\Framework\RiskyTestError
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Error extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\SelfDescribing
{
    /**
     * Wrapper for getMessage() which is declared as final.
     */
    public function toString() : string
    {
        return $this->getMessage();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function array_keys;
use function get_object_vars;
use PHPUnit\Util\Filter;
use RuntimeException;
use Throwable;
/**
 * Base class for all PHPUnit Framework exceptions.
 *
 * Ensures that exceptions thrown during a test run do not leave stray
 * references behind.
 *
 * Every Exception contains a stack trace. Each stack frame contains the 'args'
 * of the called function. The function arguments can contain references to
 * instantiated objects. The references prevent the objects from being
 * destructed (until test results are eventually printed), so memory cannot be
 * freed up.
 *
 * With enabled process isolation, test results are serialized in the child
 * process and unserialized in the parent process. The stack trace of Exceptions
 * may contain objects that cannot be serialized or unserialized (e.g., PDO
 * connections). Unserializing user-space objects from the child process into
 * the parent would break the intended encapsulation of process isolation.
 *
 * @see http://fabien.potencier.org/article/9/php-serialization-stack-traces-and-exceptions
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class Exception extends \RuntimeException implements \PHPUnit\Exception
{
    protected array $serializableTrace;
    public function __construct($message = '', $code = 0, \Throwable $previous = null)
    {
        parent::__construct($message, $code, $previous);
        $this->serializableTrace = $this->getTrace();
        foreach (\array_keys($this->serializableTrace) as $key) {
            unset($this->serializableTrace[$key]['args']);
        }
    }
    public function __toString() : string
    {
        $string = \PHPUnit\Framework\TestFailure::exceptionToString($this);
        if ($trace = \PHPUnit\Util\Filter::getFilteredStacktrace($this)) {
            $string .= "\n" . $trace;
        }
        return $string;
    }
    public function __sleep() : array
    {
        return \array_keys(\get_object_vars($this));
    }
    /**
     * Returns the serializable trace (without 'args').
     */
    public function getSerializableTrace() : array
    {
        return $this->serializableTrace;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use Exception;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
/**
 * Exception for expectations which failed their check.
 *
 * The exception contains the error message and optionally a
 * SebastianBergmann\Comparator\ComparisonFailure which is used to
 * generate diff output of the failed expectations.
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ExpectationFailedException extends \PHPUnit\Framework\AssertionFailedError
{
    protected ?\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $comparisonFailure = null;
    public function __construct(string $message, \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $comparisonFailure = null, \Exception $previous = null)
    {
        $this->comparisonFailure = $comparisonFailure;
        parent::__construct($message, 0, $previous);
    }
    public function getComparisonFailure() : ?\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure
    {
        return $this->comparisonFailure;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class IncompleteTestError extends \PHPUnit\Framework\AssertionFailedError implements \PHPUnit\Framework\IncompleteTest
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function debug_backtrace;
use function in_array;
use function lcfirst;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvalidArgumentException extends \PHPUnit\Framework\Exception
{
    public static function create(int $argument, string $type) : self
    {
        $stack = \debug_backtrace();
        return new self(\sprintf('Argument #%d of %s::%s() must be %s %s', $argument, $stack[1]['class'], $stack[1]['function'], \in_array(\lcfirst($type)[0], ['a', 'e', 'i', 'o', 'u'], \true) ? 'an' : 'a', $type));
    }
    private function __construct(string $message = '', int $code = 0, \Exception $previous = null)
    {
        parent::__construct($message, $code, $previous);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvalidCoversTargetException extends \PHPUnit\Framework\CodeCoverageException
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvalidDataProviderException extends \PHPUnit\Framework\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MissingCoversAnnotationException extends \PHPUnit\Framework\RiskyTestError
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class NoChildTestSuiteException extends \PHPUnit\Framework\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class OutputError extends \PHPUnit\Framework\AssertionFailedError
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class PHPTAssertionFailedError extends \PHPUnit\Framework\SyntheticError
{
    private string $diff;
    public function __construct(string $message, int $code, string $file, int $line, array $trace, string $diff)
    {
        parent::__construct($message, $code, $file, $line, $trace);
        $this->diff = $diff;
    }
    public function getDiff() : string
    {
        return $this->diff;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class RiskyTestError extends \PHPUnit\Framework\AssertionFailedError
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SkippedTestError extends \PHPUnit\Framework\AssertionFailedError implements \PHPUnit\Framework\SkippedTest
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SkippedTestSuiteError extends \PHPUnit\Framework\AssertionFailedError implements \PHPUnit\Framework\SkippedTest
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class SyntheticError extends \PHPUnit\Framework\AssertionFailedError
{
    /**
     * The synthetic file.
     */
    protected string $syntheticFile = '';
    /**
     * The synthetic line number.
     */
    protected int $syntheticLine = 0;
    /**
     * The synthetic trace.
     */
    protected array $syntheticTrace = [];
    public function __construct(string $message, int $code, string $file, int $line, array $trace)
    {
        parent::__construct($message, $code);
        $this->syntheticFile = $file;
        $this->syntheticLine = $line;
        $this->syntheticTrace = $trace;
    }
    public function getSyntheticFile() : string
    {
        return $this->syntheticFile;
    }
    public function getSyntheticLine() : int
    {
        return $this->syntheticLine;
    }
    public function getSyntheticTrace() : array
    {
        return $this->syntheticTrace;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SyntheticSkippedError extends \PHPUnit\Framework\SyntheticError implements \PHPUnit\Framework\SkippedTest
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class UnintentionallyCoveredCodeError extends \PHPUnit\Framework\RiskyTestError
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Warning extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\SelfDescribing
{
    /**
     * Wrapper for getMessage() which is declared as final.
     */
    public function toString() : string
    {
        return $this->getMessage();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function array_keys;
use function get_class;
use function spl_object_hash;
use PHPUnit\Util\Filter;
use Throwable;
/**
 * Wraps Exceptions thrown by code under test.
 *
 * Re-instantiates Exceptions thrown by user-space code to retain their original
 * class names, properties, and stack traces (but without arguments).
 *
 * Unlike PHPUnit\Framework\Exception, the complete stack of previous Exceptions
 * is processed.
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ExceptionWrapper extends \PHPUnit\Framework\Exception
{
    /**
     * @var string
     */
    protected $className;
    /**
     * @var null|ExceptionWrapper
     */
    protected $previous;
    public function __construct(\Throwable $t)
    {
        // PDOException::getCode() is a string.
        // @see https://php.net/manual/en/class.pdoexception.php#95812
        parent::__construct($t->getMessage(), (int) $t->getCode());
        $this->setOriginalException($t);
    }
    public function __toString() : string
    {
        $string = \PHPUnit\Framework\TestFailure::exceptionToString($this);
        if ($trace = \PHPUnit\Util\Filter::getFilteredStacktrace($this)) {
            $string .= "\n" . $trace;
        }
        if ($this->previous) {
            $string .= "\nCaused by\n" . $this->previous;
        }
        return $string;
    }
    public function getClassName() : string
    {
        return $this->className;
    }
    public function getPreviousWrapped() : ?self
    {
        return $this->previous;
    }
    public function setClassName(string $className) : void
    {
        $this->className = $className;
    }
    public function setOriginalException(\Throwable $t) : void
    {
        $this->originalException($t);
        $this->className = \get_class($t);
        $this->file = $t->getFile();
        $this->line = $t->getLine();
        $this->serializableTrace = $t->getTrace();
        foreach (\array_keys($this->serializableTrace) as $key) {
            unset($this->serializableTrace[$key]['args']);
        }
        if ($t->getPrevious()) {
            $this->previous = new self($t->getPrevious());
        }
    }
    public function getOriginalException() : ?\Throwable
    {
        return $this->originalException();
    }
    /**
     * Method to contain static originalException to exclude it from stacktrace to prevent the stacktrace contents,
     * which can be quite big, from being garbage-collected, thus blocking memory until shutdown.
     *
     * Approach works both for var_dump() and var_export() and print_r().
     */
    private function originalException(\Throwable $exceptionToStore = null) : ?\Throwable
    {
        static $originalExceptions;
        $instanceId = \spl_object_hash($this);
        if ($exceptionToStore) {
            $originalExceptions[$instanceId] = $exceptionToStore;
        }
        return $originalExceptions[$instanceId] ?? null;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function array_filter;
use function array_map;
use function array_values;
use function count;
use function explode;
use function in_array;
use function strpos;
use function trim;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ExecutionOrderDependency
{
    private string $className = '';
    private string $methodName = '';
    private bool $shallowClone;
    private bool $deepClone;
    public static function fromDependsAnnotation(string $className, string $annotation) : self
    {
        // Split clone option and target
        $parts = \explode(' ', \trim($annotation), 2);
        if (\count($parts) === 1) {
            $cloneOption = '';
            $target = $parts[0];
        } else {
            $cloneOption = $parts[0];
            $target = $parts[1];
        }
        // Prefix provided class for targets assumed to be in scope
        if ($target !== '' && \strpos($target, '::') === \false) {
            $target = $className . '::' . $target;
        }
        return new self($target, null, $cloneOption === 'clone', $cloneOption === 'shallowClone');
    }
    /**
     * @psalm-param list<ExecutionOrderDependency> $dependencies
     *
     * @psalm-return list<ExecutionOrderDependency>
     */
    public static function filterInvalid(array $dependencies) : array
    {
        return \array_values(\array_filter($dependencies, static function (self $d) {
            return $d->isValid();
        }));
    }
    /**
     * @psalm-param list<ExecutionOrderDependency> $existing
     * @psalm-param list<ExecutionOrderDependency> $additional
     *
     * @psalm-return list<ExecutionOrderDependency>
     */
    public static function mergeUnique(array $existing, array $additional) : array
    {
        $existingTargets = \array_map(static function ($dependency) {
            return $dependency->getTarget();
        }, $existing);
        foreach ($additional as $dependency) {
            if (\in_array($dependency->getTarget(), $existingTargets, \true)) {
                continue;
            }
            $existingTargets[] = $dependency->getTarget();
            $existing[] = $dependency;
        }
        return $existing;
    }
    /**
     * @psalm-param list<ExecutionOrderDependency> $left
     * @psalm-param list<ExecutionOrderDependency> $right
     *
     * @psalm-return list<ExecutionOrderDependency>
     */
    public static function diff(array $left, array $right) : array
    {
        if ($right === []) {
            return $left;
        }
        if ($left === []) {
            return [];
        }
        $diff = [];
        $rightTargets = \array_map(static function ($dependency) {
            return $dependency->getTarget();
        }, $right);
        foreach ($left as $dependency) {
            if (\in_array($dependency->getTarget(), $rightTargets, \true)) {
                continue;
            }
            $diff[] = $dependency;
        }
        return $diff;
    }
    public function __construct(string $classOrCallableName, ?string $methodName = null, bool $deepClone = \false, bool $shallowClone = \false)
    {
        if ($classOrCallableName === '') {
            return;
        }
        if (\strpos($classOrCallableName, '::') !== \false) {
            [$this->className, $this->methodName] = \explode('::', $classOrCallableName);
        } else {
            $this->className = $classOrCallableName;
            $this->methodName = !empty($methodName) ? $methodName : 'class';
        }
        $this->deepClone = $deepClone;
        $this->shallowClone = $shallowClone;
    }
    public function __toString() : string
    {
        return $this->getTarget();
    }
    public function isValid() : bool
    {
        // Invalid dependencies can be declared and are skipped by the runner
        return $this->className !== '' && $this->methodName !== '';
    }
    public function shallowClone() : bool
    {
        return $this->shallowClone;
    }
    public function deepClone() : bool
    {
        return $this->deepClone;
    }
    public function targetIsClass() : bool
    {
        return $this->methodName === 'class';
    }
    public function getTarget() : string
    {
        return $this->isValid() ? $this->className . '::' . $this->methodName : '';
    }
    public function getTargetClassName() : string
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface IncompleteTest extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class IncompleteTestCase extends \PHPUnit\Framework\TestCase
{
    /**
     * @var bool
     */
    protected $backupGlobals = \false;
    /**
     * @var bool
     */
    protected $backupStaticAttributes = \false;
    /**
     * @var bool
     */
    protected $runTestInSeparateProcess = \false;
    private string $message;
    public function __construct(string $className, string $methodName, string $message = '')
    {
        parent::__construct($className . '::' . $methodName);
        $this->message = $message;
    }
    public function getMessage() : string
    {
        return $this->message;
    }
    /**
     * Returns a string representation of the test case.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        return $this->getName();
    }
    /**
     * @throws Exception
     */
    protected function runTest() : void
    {
        $this->markTestIncomplete($this->message);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvalidParameterGroupException extends \PHPUnit\Framework\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use PHPUnit\Framework\MockObject\Builder\InvocationMocker as InvocationMockerBuilder;
use PHPUnit\Framework\MockObject\Rule\InvocationOrder;
/**
 * @internal This trait is not covered by the backward compatibility promise for PHPUnit
 */
trait Api
{
    /**
     * @var ConfigurableMethod[]
     */
    private static array $__phpunit_configurableMethods;
    private object $__phpunit_originalObject;
    private bool $__phpunit_returnValueGeneration = \true;
    private ?\PHPUnit\Framework\MockObject\InvocationHandler $__phpunit_invocationMocker = null;
    /** @noinspection MagicMethodsValidityInspection */
    public static function __phpunit_initConfigurableMethods(\PHPUnit\Framework\MockObject\ConfigurableMethod ...$configurableMethods) : void
    {
        if (isset(static::$__phpunit_configurableMethods)) {
            throw new \PHPUnit\Framework\MockObject\ConfigurableMethodsAlreadyInitializedException('Configurable methods is already initialized and can not be reinitialized');
        }
        static::$__phpunit_configurableMethods = $configurableMethods;
    }
    /** @noinspection MagicMethodsValidityInspection */
    public function __phpunit_setOriginalObject($originalObject) : void
    {
        $this->__phpunit_originalObject = $originalObject;
    }
    /** @noinspection MagicMethodsValidityInspection */
    public function __phpunit_setReturnValueGeneration(bool $returnValueGeneration) : void
    {
        $this->__phpunit_returnValueGeneration = $returnValueGeneration;
    }
    /** @noinspection MagicMethodsValidityInspection */
    public function __phpunit_getInvocationHandler() : \PHPUnit\Framework\MockObject\InvocationHandler
    {
        if ($this->__phpunit_invocationMocker === null) {
            $this->__phpunit_invocationMocker = new \PHPUnit\Framework\MockObject\InvocationHandler(static::$__phpunit_configurableMethods, $this->__phpunit_returnValueGeneration);
        }
        return $this->__phpunit_invocationMocker;
    }
    /** @noinspection MagicMethodsValidityInspection */
    public function __phpunit_hasMatchers() : bool
    {
        return $this->__phpunit_getInvocationHandler()->hasMatchers();
    }
    /** @noinspection MagicMethodsValidityInspection */
    public function __phpunit_verify(bool $unsetInvocationMocker = \true) : void
    {
        $this->__phpunit_getInvocationHandler()->verify();
        if ($unsetInvocationMocker) {
            $this->__phpunit_invocationMocker = null;
        }
    }
    public function expects(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $matcher) : \PHPUnit\Framework\MockObject\Builder\InvocationMocker
    {
        return $this->__phpunit_getInvocationHandler()->expects($matcher);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function call_user_func_array;
use function func_get_args;
use PHPUnit\Framework\MockObject\Rule\AnyInvokedCount;
/**
 * @internal This trait is not covered by the backward compatibility promise for PHPUnit
 */
trait Method
{
    public function method()
    {
        $expects = $this->expects(new \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount());
        return \call_user_func_array([$expects, 'method'], \func_get_args());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This trait is not covered by the backward compatibility promise for PHPUnit
 */
trait MockedCloneMethod
{
    public function __clone()
    {
        $this->__phpunit_invocationMocker = clone $this->__phpunit_getInvocationHandler();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This trait is not covered by the backward compatibility promise for PHPUnit
 */
trait UnmockedCloneMethod
{
    public function __clone()
    {
        $this->__phpunit_invocationMocker = clone $this->__phpunit_getInvocationHandler();
        parent::__clone();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Builder;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Identity
{
    /**
     * Sets the identification of the expectation to $id.
     *
     * @note The identifier is unique per mock object.
     *
     * @param string $id unique identification of expectation
     */
    public function id($id);
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Builder;

use function array_map;
use function array_merge;
use function count;
use function in_array;
use function is_string;
use function strtolower;
use PHPUnit\Framework\Constraint\Constraint;
use PHPUnit\Framework\MockObject\ConfigurableMethod;
use PHPUnit\Framework\MockObject\IncompatibleReturnValueException;
use PHPUnit\Framework\MockObject\InvocationHandler;
use PHPUnit\Framework\MockObject\Matcher;
use PHPUnit\Framework\MockObject\MatcherAlreadyRegisteredException;
use PHPUnit\Framework\MockObject\MethodCannotBeConfiguredException;
use PHPUnit\Framework\MockObject\MethodNameAlreadyConfiguredException;
use PHPUnit\Framework\MockObject\MethodNameNotConfiguredException;
use PHPUnit\Framework\MockObject\MethodParametersAlreadyConfiguredException;
use PHPUnit\Framework\MockObject\Rule;
use PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls;
use PHPUnit\Framework\MockObject\Stub\Exception;
use PHPUnit\Framework\MockObject\Stub\ReturnArgument;
use PHPUnit\Framework\MockObject\Stub\ReturnCallback;
use PHPUnit\Framework\MockObject\Stub\ReturnReference;
use PHPUnit\Framework\MockObject\Stub\ReturnSelf;
use PHPUnit\Framework\MockObject\Stub\ReturnStub;
use PHPUnit\Framework\MockObject\Stub\ReturnValueMap;
use PHPUnit\Framework\MockObject\Stub\Stub;
use PHPUnit\Util\Warning as WarningUtil;
use Throwable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class InvocationMocker implements \PHPUnit\Framework\MockObject\Builder\InvocationStubber, \PHPUnit\Framework\MockObject\Builder\MethodNameMatch
{
    private \PHPUnit\Framework\MockObject\InvocationHandler $invocationHandler;
    private \PHPUnit\Framework\MockObject\Matcher $matcher;
    /**
     * @var ConfigurableMethod[]
     */
    private array $configurableMethods;
    public function __construct(\PHPUnit\Framework\MockObject\InvocationHandler $handler, \PHPUnit\Framework\MockObject\Matcher $matcher, \PHPUnit\Framework\MockObject\ConfigurableMethod ...$configurableMethods)
    {
        $this->invocationHandler = $handler;
        $this->matcher = $matcher;
        $this->configurableMethods = $configurableMethods;
    }
    /**
     * @throws MatcherAlreadyRegisteredException
     *
     * @return $this
     */
    public function id($id) : self
    {
        $this->invocationHandler->registerMatcher($id, $this->matcher);
        return $this;
    }
    /**
     * @return $this
     */
    public function will(\PHPUnit\Framework\MockObject\Stub\Stub $stub) : \PHPUnit\Framework\MockObject\Builder\Identity
    {
        $this->matcher->setStub($stub);
        return $this;
    }
    /**
     * @param mixed   $value
     * @param mixed[] $nextValues
     *
     * @throws IncompatibleReturnValueException
     */
    public function willReturn($value, ...$nextValues) : self
    {
        if (\count($nextValues) === 0) {
            $this->ensureTypeOfReturnValues([$value]);
            $stub = $value instanceof \PHPUnit\Framework\MockObject\Stub\Stub ? $value : new \PHPUnit\Framework\MockObject\Stub\ReturnStub($value);
        } else {
            $values = \array_merge([$value], $nextValues);
            $this->ensureTypeOfReturnValues($values);
            $stub = new \PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls($values);
        }
        return $this->will($stub);
    }
    public function willReturnReference(&$reference) : self
    {
        $stub = new \PHPUnit\Framework\MockObject\Stub\ReturnReference($reference);
        return $this->will($stub);
    }
    public function willReturnMap(array $valueMap) : self
    {
        $stub = new \PHPUnit\Framework\MockObject\Stub\ReturnValueMap($valueMap);
        return $this->will($stub);
    }
    public function willReturnArgument($argumentIndex) : self
    {
        $stub = new \PHPUnit\Framework\MockObject\Stub\ReturnArgument($argumentIndex);
        return $this->will($stub);
    }
    public function willReturnCallback($callback) : self
    {
        $stub = new \PHPUnit\Framework\MockObject\Stub\ReturnCallback($callback);
        return $this->will($stub);
    }
    public function willReturnSelf() : self
    {
        $stub = new \PHPUnit\Framework\MockObject\Stub\ReturnSelf();
        return $this->will($stub);
    }
    public function willReturnOnConsecutiveCalls(...$values) : self
    {
        $stub = new \PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls($values);
        return $this->will($stub);
    }
    public function willThrowException(\Throwable $exception) : self
    {
        $stub = new \PHPUnit\Framework\MockObject\Stub\Exception($exception);
        return $this->will($stub);
    }
    /**
     * @return $this
     */
    public function after($id) : self
    {
        $this->matcher->setAfterMatchBuilderId($id);
        return $this;
    }
    /**
     * @param mixed[] $arguments
     *
     * @throws \PHPUnit\Framework\Exception
     * @throws MethodNameNotConfiguredException
     * @throws MethodParametersAlreadyConfiguredException
     *
     * @return $this
     */
    public function with(...$arguments) : self
    {
        $this->ensureParametersCanBeConfigured();
        $this->matcher->setParametersRule(new \PHPUnit\Framework\MockObject\Rule\Parameters($arguments));
        return $this;
    }
    /**
     * @param array ...$arguments
     *
     * @throws \PHPUnit\Framework\Exception
     * @throws MethodNameNotConfiguredException
     * @throws MethodParametersAlreadyConfiguredException
     *
     * @return $this
     *
     * @deprecated https://github.com/sebastianbergmann/phpunit/issues/4564
     */
    public function withConsecutive(...$arguments) : self
    {
        $this->ensureParametersCanBeConfigured();
        (new \PHPUnit\Util\Warning())->createForTestCaseObjectOnCallStack('The withConsecutive() method has been deprecated. It will be removed in PHPUnit 11.');
        $this->matcher->setParametersRule(new \PHPUnit\Framework\MockObject\Rule\ConsecutiveParameters($arguments));
        return $this;
    }
    /**
     * @throws MethodNameNotConfiguredException
     * @throws MethodParametersAlreadyConfiguredException
     *
     * @return $this
     */
    public function withAnyParameters() : self
    {
        $this->ensureParametersCanBeConfigured();
        $this->matcher->setParametersRule(new \PHPUnit\Framework\MockObject\Rule\AnyParameters());
        return $this;
    }
    /**
     * @param Constraint|string $constraint
     *
     * @throws \PHPUnit\Framework\InvalidArgumentException
     * @throws MethodCannotBeConfiguredException
     * @throws MethodNameAlreadyConfiguredException
     *
     * @return $this
     */
    public function method($constraint) : self
    {
        if ($this->matcher->hasMethodNameRule()) {
            throw new \PHPUnit\Framework\MockObject\MethodNameAlreadyConfiguredException();
        }
        $configurableMethodNames = \array_map(static function (\PHPUnit\Framework\MockObject\ConfigurableMethod $configurable) {
            return \strtolower($configurable->getName());
        }, $this->configurableMethods);
        if (\is_string($constraint) && !\in_array(\strtolower($constraint), $configurableMethodNames, \true)) {
            throw new \PHPUnit\Framework\MockObject\MethodCannotBeConfiguredException($constraint);
        }
        $this->matcher->setMethodNameRule(new \PHPUnit\Framework\MockObject\Rule\MethodName($constraint));
        return $this;
    }
    /**
     * @throws MethodNameNotConfiguredException
     * @throws MethodParametersAlreadyConfiguredException
     */
    private function ensureParametersCanBeConfigured() : void
    {
        if (!$this->matcher->hasMethodNameRule()) {
            throw new \PHPUnit\Framework\MockObject\MethodNameNotConfiguredException();
        }
        if ($this->matcher->hasParametersRule()) {
            throw new \PHPUnit\Framework\MockObject\MethodParametersAlreadyConfiguredException();
        }
    }
    private function getConfiguredMethod() : ?\PHPUnit\Framework\MockObject\ConfigurableMethod
    {
        $configuredMethod = null;
        foreach ($this->configurableMethods as $configurableMethod) {
            if ($this->matcher->getMethodNameRule()->matchesName($configurableMethod->getName())) {
                if ($configuredMethod !== null) {
                    return null;
                }
                $configuredMethod = $configurableMethod;
            }
        }
        return $configuredMethod;
    }
    /**
     * @throws IncompatibleReturnValueException
     */
    private function ensureTypeOfReturnValues(array $values) : void
    {
        $configuredMethod = $this->getConfiguredMethod();
        if ($configuredMethod === null) {
            return;
        }
        foreach ($values as $value) {
            if (!$configuredMethod->mayReturn($value)) {
                throw new \PHPUnit\Framework\MockObject\IncompatibleReturnValueException($configuredMethod, $value);
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Builder;

use PHPUnit\Framework\MockObject\Stub\Stub;
use Throwable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
interface InvocationStubber
{
    public function will(\PHPUnit\Framework\MockObject\Stub\Stub $stub) : \PHPUnit\Framework\MockObject\Builder\Identity;
    public function willReturn($value, ...$nextValues) : self;
    /**
     * @param mixed $reference
     */
    public function willReturnReference(&$reference) : self;
    /**
     * @param array<int, array<int, mixed>> $valueMap
     */
    public function willReturnMap(array $valueMap) : self;
    /**
     * @param int $argumentIndex
     */
    public function willReturnArgument($argumentIndex) : self;
    /**
     * @param callable $callback
     */
    public function willReturnCallback($callback) : self;
    public function willReturnSelf() : self;
    /**
     * @param mixed $values
     */
    public function willReturnOnConsecutiveCalls(...$values) : self;
    public function willThrowException(\Throwable $exception) : self;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Builder;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface MethodNameMatch extends \PHPUnit\Framework\MockObject\Builder\ParametersMatch
{
    /**
     * Adds a new method name match and returns the parameter match object for
     * further matching possibilities.
     *
     * @param \PHPUnit\Framework\Constraint\Constraint $name Constraint for matching method, if a string is passed it will use the PHPUnit_Framework_Constraint_IsEqual
     *
     * @return ParametersMatch
     */
    public function method($name);
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Builder;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface ParametersMatch extends \PHPUnit\Framework\MockObject\Builder\Stub
{
    /**
     * Defines the expectation which must occur before the current is valid.
     *
     * @param string $id the identification of the expectation that should
     *                   occur before this one
     *
     * @return Stub
     */
    public function after($id);
    /**
     * Sets the parameters to match for, each parameter to this function will
     * be part of match. To perform specific matches or constraints create a
     * new PHPUnit\Framework\Constraint\Constraint and use it for the parameter.
     * If the parameter value is not a constraint it will use the
     * PHPUnit\Framework\Constraint\IsEqual for the value.
     *
     * Some examples:
     * <code>
     * // match first parameter with value 2
     * $b->with(2);
     * // match first parameter with value 'smock' and second identical to 42
     * $b->with('smock', new PHPUnit\Framework\Constraint\IsEqual(42));
     * </code>
     *
     * @return ParametersMatch
     */
    public function with(...$arguments);
    /**
     * Sets a rule which allows any kind of parameters.
     *
     * Some examples:
     * <code>
     * // match any number of parameters
     * $b->withAnyParameters();
     * </code>
     *
     * @return ParametersMatch
     */
    public function withAnyParameters();
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Builder;

use PHPUnit\Framework\MockObject\Stub\Stub as BaseStub;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Stub extends \PHPUnit\Framework\MockObject\Builder\Identity
{
    /**
     * Stubs the matching method with the stub object $stub. Any invocations of
     * the matched method will now be handled by the stub instead.
     */
    public function will(\PHPUnit\Framework\MockObject\Stub\Stub $stub) : \PHPUnit\Framework\MockObject\Builder\Identity;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use PHPUnit\SebastianBergmann\Type\Type;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ConfigurableMethod
{
    private string $name;
    private \PHPUnit\SebastianBergmann\Type\Type $returnType;
    public function __construct(string $name, \PHPUnit\SebastianBergmann\Type\Type $returnType)
    {
        $this->name = $name;
        $this->returnType = $returnType;
    }
    public function getName() : string
    {
        return $this->name;
    }
    public function mayReturn($value) : bool
    {
        if ($value === null && $this->returnType->allowsNull()) {
            return \true;
        }
        return $this->returnType->isAssignable(\PHPUnit\SebastianBergmann\Type\Type::fromValue($value, \false));
    }
    public function getReturnTypeDeclaration() : string
    {
        return $this->returnType->asString();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class BadMethodCallException extends \BadMethodCallException implements \PHPUnit\Framework\MockObject\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CannotUseAddMethodsException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $type, string $methodName)
    {
        parent::__construct(\sprintf('Trying to set mock method "%s" with addMethods(), but it exists in class "%s". Use onlyMethods() for methods that exist in the class', $methodName, $type));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CannotUseOnlyMethodsException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $type, string $methodName)
    {
        parent::__construct(\sprintf('Trying to set mock method "%s" with onlyMethods, but it does not exist in class "%s". Use addMethods() for methods that do not exist in the class', $methodName, $type));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ClassAlreadyExistsException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $className)
    {
        parent::__construct(\sprintf('Class "%s" already exists', $className));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ClassIsFinalException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $className)
    {
        parent::__construct(\sprintf('Class "%s" is declared "final" and cannot be mocked', $className));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ConfigurableMethodsAlreadyInitializedException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class DuplicateMethodException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    /**
     * @psalm-param list<string> $methods
     */
    public function __construct(array $methods)
    {
        parent::__construct(\sprintf('Cannot stub or mock using a method list that contains duplicates: "%s" (duplicate: "%s")', \implode(', ', $methods), \implode(', ', \array_unique(\array_diff_assoc($methods, \array_unique($methods))))));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class IncompatibleReturnValueException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    /**
     * @param mixed $value
     */
    public function __construct(\PHPUnit\Framework\MockObject\ConfigurableMethod $method, $value)
    {
        parent::__construct(\sprintf('Method %s may not return value of type %s, its return declaration is "%s"', $method->getName(), \is_object($value) ? \get_class($value) : \gettype($value), $method->getReturnTypeDeclaration()));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvalidMethodNameException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $method)
    {
        parent::__construct(\sprintf('Cannot stub or mock method with invalid name "%s"', $method));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MatchBuilderNotFoundException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $id)
    {
        parent::__construct(\sprintf('No builder found for match builder identification <%s>', $id));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MatcherAlreadyRegisteredException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $id)
    {
        parent::__construct(\sprintf('Matcher with id <%s> is already registered', $id));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MethodCannotBeConfiguredException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $method)
    {
        parent::__construct(\sprintf('Trying to configure method "%s" which cannot be configured because it does not exist, has not been specified, is final, or is static', $method));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MethodNameAlreadyConfiguredException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct()
    {
        parent::__construct('Method name is already configured');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MethodNameNotConfiguredException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct()
    {
        parent::__construct('Method name is not configured');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MethodParametersAlreadyConfiguredException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct()
    {
        parent::__construct('Method parameters already configured');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class OriginalConstructorInvocationRequiredException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct()
    {
        parent::__construct('Proxying to original methods requires invoking the original constructor');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReflectionException extends \RuntimeException implements \PHPUnit\Framework\MockObject\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReturnValueNotConfiguredException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        parent::__construct(\sprintf('Return value inference disabled and no expectation set up for %s::%s()', $invocation->getClassName(), $invocation->getMethodName()));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RuntimeException extends \RuntimeException implements \PHPUnit\Framework\MockObject\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SoapExtensionNotAvailableException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct()
    {
        parent::__construct('The SOAP extension is required to generate a test double from WSDL');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class UnknownClassException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $className)
    {
        parent::__construct(\sprintf('Class "%s" does not exist', $className));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class UnknownTraitException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $traitName)
    {
        parent::__construct(\sprintf('Trait "%s" does not exist', $traitName));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class UnknownTypeException extends \PHPUnit\Framework\Exception implements \PHPUnit\Framework\MockObject\Exception
{
    public function __construct(string $type)
    {
        parent::__construct(\sprintf('Class or interface "%s" does not exist', $type));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use const PHP_EOL;
use const PHP_MAJOR_VERSION;
use const PREG_OFFSET_CAPTURE;
use const WSDL_CACHE_NONE;
use function array_merge;
use function array_pop;
use function array_unique;
use function class_exists;
use function count;
use function explode;
use function extension_loaded;
use function implode;
use function in_array;
use function interface_exists;
use function is_array;
use function is_object;
use function md5;
use function mt_rand;
use function preg_match;
use function preg_match_all;
use function range;
use function serialize;
use function sort;
use function sprintf;
use function str_replace;
use function strlen;
use function strpos;
use function strtolower;
use function substr;
use function trait_exists;
use PHPUnit\Doctrine\Instantiator\Exception\ExceptionInterface as InstantiatorException;
use PHPUnit\Doctrine\Instantiator\Instantiator;
use Exception;
use Iterator;
use IteratorAggregate;
use PHPUnit\Framework\InvalidArgumentException;
use ReflectionClass;
use ReflectionMethod;
use PHPUnit\SebastianBergmann\Template\Template;
use SoapClient;
use SoapFault;
use Throwable;
use Traversable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Generator
{
    use TemplateLoader;
    /**
     * @var array
     */
    private const EXCLUDED_METHOD_NAMES = ['__CLASS__' => \true, '__DIR__' => \true, '__FILE__' => \true, '__FUNCTION__' => \true, '__LINE__' => \true, '__METHOD__' => \true, '__NAMESPACE__' => \true, '__TRAIT__' => \true, '__clone' => \true, '__halt_compiler' => \true];
    private static array $cache = [];
    /**
     * Returns a mock object for the specified class.
     *
     * @param null|array $methods
     *
     * @throws \PHPUnit\Framework\InvalidArgumentException
     * @throws ClassAlreadyExistsException
     * @throws ClassIsFinalException
     * @throws DuplicateMethodException
     * @throws InvalidMethodNameException
     * @throws OriginalConstructorInvocationRequiredException
     * @throws ReflectionException
     * @throws RuntimeException
     * @throws UnknownTypeException
     */
    public function getMock(string $type, $methods = [], array $arguments = [], string $mockClassName = '', bool $callOriginalConstructor = \true, bool $callOriginalClone = \true, bool $callAutoload = \true, bool $cloneArguments = \true, bool $callOriginalMethods = \false, object $proxyTarget = null, bool $allowMockingUnknownTypes = \true, bool $returnValueGeneration = \true) : \PHPUnit\Framework\MockObject\MockObject
    {
        if (!\is_array($methods) && null !== $methods) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(2, 'array');
        }
        if ($type === 'Traversable' || $type === '\\Traversable') {
            $type = 'Iterator';
        }
        if (!$allowMockingUnknownTypes && !\class_exists($type, $callAutoload) && !\interface_exists($type, $callAutoload)) {
            throw new \PHPUnit\Framework\MockObject\UnknownTypeException($type);
        }
        if (null !== $methods) {
            foreach ($methods as $method) {
                if (!\preg_match('~[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*~', (string) $method)) {
                    throw new \PHPUnit\Framework\MockObject\InvalidMethodNameException((string) $method);
                }
            }
            if ($methods !== \array_unique($methods)) {
                throw new \PHPUnit\Framework\MockObject\DuplicateMethodException($methods);
            }
        }
        if ($mockClassName !== '' && \class_exists($mockClassName, \false)) {
            try {
                $reflector = new \ReflectionClass($mockClassName);
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
            if (!$reflector->implementsInterface(\PHPUnit\Framework\MockObject\MockObject::class)) {
                throw new \PHPUnit\Framework\MockObject\ClassAlreadyExistsException($mockClassName);
            }
        }
        if (!$callOriginalConstructor && $callOriginalMethods) {
            throw new \PHPUnit\Framework\MockObject\OriginalConstructorInvocationRequiredException();
        }
        $mock = $this->generate($type, $methods, $mockClassName, $callOriginalClone, $callAutoload, $cloneArguments, $callOriginalMethods);
        return $this->getObject($mock, $type, $callOriginalConstructor, $callAutoload, $arguments, $callOriginalMethods, $proxyTarget, $returnValueGeneration);
    }
    /**
     * Returns a mock object for the specified abstract class with all abstract
     * methods of the class mocked.
     *
     * Concrete methods to mock can be specified with the $mockedMethods parameter.
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $originalClassName
     * @psalm-return MockObject&RealInstanceType
     *
     * @throws \PHPUnit\Framework\InvalidArgumentException
     * @throws ClassAlreadyExistsException
     * @throws ClassIsFinalException
     * @throws DuplicateMethodException
     * @throws InvalidMethodNameException
     * @throws OriginalConstructorInvocationRequiredException
     * @throws ReflectionException
     * @throws RuntimeException
     * @throws UnknownClassException
     * @throws UnknownTypeException
     */
    public function getMockForAbstractClass(string $originalClassName, array $arguments = [], string $mockClassName = '', bool $callOriginalConstructor = \true, bool $callOriginalClone = \true, bool $callAutoload = \true, array $mockedMethods = null, bool $cloneArguments = \true) : \PHPUnit\Framework\MockObject\MockObject
    {
        if (\class_exists($originalClassName, $callAutoload) || \interface_exists($originalClassName, $callAutoload)) {
            try {
                $reflector = new \ReflectionClass($originalClassName);
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
            $methods = $mockedMethods;
            foreach ($reflector->getMethods() as $method) {
                if ($method->isAbstract() && !\in_array($method->getName(), $methods ?? [], \true)) {
                    $methods[] = $method->getName();
                }
            }
            if (empty($methods)) {
                $methods = null;
            }
            return $this->getMock($originalClassName, $methods, $arguments, $mockClassName, $callOriginalConstructor, $callOriginalClone, $callAutoload, $cloneArguments);
        }
        throw new \PHPUnit\Framework\MockObject\UnknownClassException($originalClassName);
    }
    /**
     * Returns a mock object for the specified trait with all abstract methods
     * of the trait mocked. Concrete methods to mock can be specified with the
     * `$mockedMethods` parameter.
     *
     * @psalm-param trait-string $traitName
     *
     * @throws \PHPUnit\Framework\InvalidArgumentException
     * @throws ClassAlreadyExistsException
     * @throws ClassIsFinalException
     * @throws DuplicateMethodException
     * @throws InvalidMethodNameException
     * @throws OriginalConstructorInvocationRequiredException
     * @throws ReflectionException
     * @throws RuntimeException
     * @throws UnknownClassException
     * @throws UnknownTraitException
     * @throws UnknownTypeException
     */
    public function getMockForTrait(string $traitName, array $arguments = [], string $mockClassName = '', bool $callOriginalConstructor = \true, bool $callOriginalClone = \true, bool $callAutoload = \true, array $mockedMethods = null, bool $cloneArguments = \true) : \PHPUnit\Framework\MockObject\MockObject
    {
        if (!\trait_exists($traitName, $callAutoload)) {
            throw new \PHPUnit\Framework\MockObject\UnknownTraitException($traitName);
        }
        $className = $this->generateClassName($traitName, '', 'Trait_');
        $classTemplate = $this->loadTemplate('trait_class.tpl');
        $classTemplate->setVar(['prologue' => 'abstract ', 'class_name' => $className['className'], 'trait_name' => $traitName]);
        $mockTrait = new \PHPUnit\Framework\MockObject\MockTrait($classTemplate->render(), $className['className']);
        $mockTrait->generate();
        return $this->getMockForAbstractClass($className['className'], $arguments, $mockClassName, $callOriginalConstructor, $callOriginalClone, $callAutoload, $mockedMethods, $cloneArguments);
    }
    /**
     * Returns an object for the specified trait.
     *
     * @psalm-param trait-string $traitName
     *
     * @throws ReflectionException
     * @throws RuntimeException
     * @throws UnknownTraitException
     */
    public function getObjectForTrait(string $traitName, string $traitClassName = '', bool $callAutoload = \true, bool $callOriginalConstructor = \false, array $arguments = []) : object
    {
        if (!\trait_exists($traitName, $callAutoload)) {
            throw new \PHPUnit\Framework\MockObject\UnknownTraitException($traitName);
        }
        $className = $this->generateClassName($traitName, $traitClassName, 'Trait_');
        $classTemplate = $this->loadTemplate('trait_class.tpl');
        $classTemplate->setVar(['prologue' => '', 'class_name' => $className['className'], 'trait_name' => $traitName]);
        return $this->getObject(new \PHPUnit\Framework\MockObject\MockTrait($classTemplate->render(), $className['className']), '', $callOriginalConstructor, $callAutoload, $arguments);
    }
    /**
     * @throws ClassIsFinalException
     * @throws ReflectionException
     * @throws RuntimeException
     */
    public function generate(string $type, array $methods = null, string $mockClassName = '', bool $callOriginalClone = \true, bool $callAutoload = \true, bool $cloneArguments = \true, bool $callOriginalMethods = \false) : \PHPUnit\Framework\MockObject\MockClass
    {
        if ($mockClassName !== '') {
            return $this->generateMock($type, $methods, $mockClassName, $callOriginalClone, $callAutoload, $cloneArguments, $callOriginalMethods);
        }
        $key = \md5($type . \serialize($methods) . \serialize($callOriginalClone) . \serialize($cloneArguments) . \serialize($callOriginalMethods));
        if (!isset(self::$cache[$key])) {
            self::$cache[$key] = $this->generateMock($type, $methods, $mockClassName, $callOriginalClone, $callAutoload, $cloneArguments, $callOriginalMethods);
        }
        return self::$cache[$key];
    }
    /**
     * @throws RuntimeException
     * @throws SoapExtensionNotAvailableException
     */
    public function generateClassFromWsdl(string $wsdlFile, string $className, array $methods = [], array $options = []) : string
    {
        if (!\extension_loaded('soap')) {
            throw new \PHPUnit\Framework\MockObject\SoapExtensionNotAvailableException();
        }
        $options = \array_merge($options, ['cache_wsdl' => \WSDL_CACHE_NONE]);
        try {
            $client = new \SoapClient($wsdlFile, $options);
            $_methods = \array_unique($client->__getFunctions());
            unset($client);
        } catch (\SoapFault $e) {
            throw new \PHPUnit\Framework\MockObject\RuntimeException($e->getMessage(), (int) $e->getCode(), $e);
        }
        \sort($_methods);
        $methodTemplate = $this->loadTemplate('wsdl_method.tpl');
        $methodsBuffer = '';
        foreach ($_methods as $method) {
            \preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*\\(/', $method, $matches, \PREG_OFFSET_CAPTURE);
            $lastFunction = \array_pop($matches[0]);
            $nameStart = $lastFunction[1];
            $nameEnd = $nameStart + \strlen($lastFunction[0]) - 1;
            $name = \str_replace('(', '', $lastFunction[0]);
            if (empty($methods) || \in_array($name, $methods, \true)) {
                $args = \explode(',', \str_replace(')', '', \substr($method, $nameEnd + 1)));
                foreach (\range(0, \count($args) - 1) as $i) {
                    $parameterStart = \strpos($args[$i], '$');
                    if (!$parameterStart) {
                        continue;
                    }
                    $args[$i] = \substr($args[$i], $parameterStart);
                }
                $methodTemplate->setVar(['method_name' => $name, 'arguments' => \implode(', ', $args)]);
                $methodsBuffer .= $methodTemplate->render();
            }
        }
        $optionsBuffer = '[';
        foreach ($options as $key => $value) {
            $optionsBuffer .= $key . ' => ' . $value;
        }
        $optionsBuffer .= ']';
        $classTemplate = $this->loadTemplate('wsdl_class.tpl');
        $namespace = '';
        if (\strpos($className, '\\') !== \false) {
            $parts = \explode('\\', $className);
            $className = \array_pop($parts);
            $namespace = 'namespace ' . \implode('\\', $parts) . ';' . "\n\n";
        }
        $classTemplate->setVar(['namespace' => $namespace, 'class_name' => $className, 'wsdl' => $wsdlFile, 'options' => $optionsBuffer, 'methods' => $methodsBuffer]);
        return $classTemplate->render();
    }
    /**
     * @throws ReflectionException
     *
     * @return string[]
     */
    public function getClassMethods(string $className) : array
    {
        try {
            $class = new \ReflectionClass($className);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        $methods = [];
        foreach ($class->getMethods() as $method) {
            if ($method->isPublic() || $method->isAbstract()) {
                $methods[] = $method->getName();
            }
        }
        return $methods;
    }
    /**
     * @throws ReflectionException
     *
     * @return MockMethod[]
     */
    public function mockClassMethods(string $className, bool $callOriginalMethods, bool $cloneArguments) : array
    {
        try {
            $class = new \ReflectionClass($className);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        $methods = [];
        foreach ($class->getMethods() as $method) {
            if (($method->isPublic() || $method->isAbstract()) && $this->canMethodBeDoubled($method)) {
                $methods[] = \PHPUnit\Framework\MockObject\MockMethod::fromReflection($method, $callOriginalMethods, $cloneArguments);
            }
        }
        return $methods;
    }
    /**
     * @throws ReflectionException
     *
     * @return MockMethod[]
     */
    public function mockInterfaceMethods(string $interfaceName, bool $cloneArguments) : array
    {
        try {
            $class = new \ReflectionClass($interfaceName);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        $methods = [];
        foreach ($class->getMethods() as $method) {
            $methods[] = \PHPUnit\Framework\MockObject\MockMethod::fromReflection($method, \false, $cloneArguments);
        }
        return $methods;
    }
    /**
     * @psalm-param class-string $interfaceName
     *
     * @throws ReflectionException
     *
     * @return ReflectionMethod[]
     */
    private function userDefinedInterfaceMethods(string $interfaceName) : array
    {
        try {
            // @codeCoverageIgnoreStart
            $interface = new \ReflectionClass($interfaceName);
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        $methods = [];
        foreach ($interface->getMethods() as $method) {
            if (!$method->isUserDefined()) {
                continue;
            }
            $methods[] = $method;
        }
        return $methods;
    }
    /**
     * @throws ReflectionException
     * @throws RuntimeException
     */
    private function getObject(\PHPUnit\Framework\MockObject\MockType $mockClass, $type = '', bool $callOriginalConstructor = \false, bool $callAutoload = \false, array $arguments = [], bool $callOriginalMethods = \false, object $proxyTarget = null, bool $returnValueGeneration = \true)
    {
        $className = $mockClass->generate();
        if ($callOriginalConstructor) {
            if (\count($arguments) === 0) {
                $object = new $className();
            } else {
                try {
                    $class = new \ReflectionClass($className);
                    // @codeCoverageIgnoreStart
                } catch (\ReflectionException $e) {
                    throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
                }
                // @codeCoverageIgnoreEnd
                $object = $class->newInstanceArgs($arguments);
            }
        } else {
            try {
                $object = (new \PHPUnit\Doctrine\Instantiator\Instantiator())->instantiate($className);
            } catch (\PHPUnit\Doctrine\Instantiator\Exception\ExceptionInterface $e) {
                throw new \PHPUnit\Framework\MockObject\RuntimeException($e->getMessage());
            }
        }
        if ($callOriginalMethods) {
            if (!\is_object($proxyTarget)) {
                if (\count($arguments) === 0) {
                    $proxyTarget = new $type();
                } else {
                    try {
                        $class = new \ReflectionClass($type);
                        // @codeCoverageIgnoreStart
                    } catch (\ReflectionException $e) {
                        throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
                    }
                    // @codeCoverageIgnoreEnd
                    $proxyTarget = $class->newInstanceArgs($arguments);
                }
            }
            $object->__phpunit_setOriginalObject($proxyTarget);
        }
        if ($object instanceof \PHPUnit\Framework\MockObject\MockObject) {
            $object->__phpunit_setReturnValueGeneration($returnValueGeneration);
        }
        return $object;
    }
    /**
     * @throws ClassIsFinalException
     * @throws ReflectionException
     * @throws RuntimeException
     */
    private function generateMock(string $type, ?array $explicitMethods, string $mockClassName, bool $callOriginalClone, bool $callAutoload, bool $cloneArguments, bool $callOriginalMethods) : \PHPUnit\Framework\MockObject\MockClass
    {
        $classTemplate = $this->loadTemplate('mocked_class.tpl');
        $additionalInterfaces = [];
        $mockedCloneMethod = \false;
        $unmockedCloneMethod = \false;
        $isClass = \false;
        $isInterface = \false;
        $class = null;
        $mockMethods = new \PHPUnit\Framework\MockObject\MockMethodSet();
        $_mockClassName = $this->generateClassName($type, $mockClassName, 'Mock_');
        if (\class_exists($_mockClassName['fullClassName'], $callAutoload)) {
            $isClass = \true;
        } elseif (\interface_exists($_mockClassName['fullClassName'], $callAutoload)) {
            $isInterface = \true;
        }
        if (!$isClass && !$isInterface) {
            $prologue = 'class ' . $_mockClassName['originalClassName'] . "\n{\n}\n\n";
            if (!empty($_mockClassName['namespaceName'])) {
                $prologue = 'namespace ' . $_mockClassName['namespaceName'] . " {\n\n" . $prologue . "}\n\n" . "namespace {\n\n";
                $epilogue = "\n\n}";
            }
            $mockedCloneMethod = \true;
        } else {
            try {
                $class = new \ReflectionClass($_mockClassName['fullClassName']);
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
            if ($class->isFinal()) {
                throw new \PHPUnit\Framework\MockObject\ClassIsFinalException($_mockClassName['fullClassName']);
            }
            // @see https://github.com/sebastianbergmann/phpunit/issues/2995
            if ($isInterface && $class->implementsInterface(\Throwable::class)) {
                $actualClassName = \Exception::class;
                $additionalInterfaces[] = $class->getName();
                $isInterface = \false;
                try {
                    $class = new \ReflectionClass($actualClassName);
                    // @codeCoverageIgnoreStart
                } catch (\ReflectionException $e) {
                    throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
                }
                // @codeCoverageIgnoreEnd
                foreach ($this->userDefinedInterfaceMethods($_mockClassName['fullClassName']) as $method) {
                    $methodName = $method->getName();
                    if ($class->hasMethod($methodName)) {
                        try {
                            $classMethod = $class->getMethod($methodName);
                            // @codeCoverageIgnoreStart
                        } catch (\ReflectionException $e) {
                            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
                        }
                        // @codeCoverageIgnoreEnd
                        if (!$this->canMethodBeDoubled($classMethod)) {
                            continue;
                        }
                    }
                    $mockMethods->addMethods(\PHPUnit\Framework\MockObject\MockMethod::fromReflection($method, $callOriginalMethods, $cloneArguments));
                }
                $_mockClassName = $this->generateClassName($actualClassName, $_mockClassName['className'], 'Mock_');
            }
            // @see https://github.com/sebastianbergmann/phpunit-mock-objects/issues/103
            if ($isInterface && $class->implementsInterface(\Traversable::class) && !$class->implementsInterface(\Iterator::class) && !$class->implementsInterface(\IteratorAggregate::class)) {
                $additionalInterfaces[] = \Iterator::class;
                $mockMethods->addMethods(...$this->mockClassMethods(\Iterator::class, $callOriginalMethods, $cloneArguments));
            }
            if ($class->hasMethod('__clone')) {
                try {
                    $cloneMethod = $class->getMethod('__clone');
                    // @codeCoverageIgnoreStart
                } catch (\ReflectionException $e) {
                    throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
                }
                // @codeCoverageIgnoreEnd
                if (!$cloneMethod->isFinal()) {
                    if ($callOriginalClone && !$isInterface) {
                        $unmockedCloneMethod = \true;
                    } else {
                        $mockedCloneMethod = \true;
                    }
                }
            } else {
                $mockedCloneMethod = \true;
            }
        }
        if ($isClass && $explicitMethods === []) {
            $mockMethods->addMethods(...$this->mockClassMethods($_mockClassName['fullClassName'], $callOriginalMethods, $cloneArguments));
        }
        if ($isInterface && ($explicitMethods === [] || $explicitMethods === null)) {
            $mockMethods->addMethods(...$this->mockInterfaceMethods($_mockClassName['fullClassName'], $cloneArguments));
        }
        if (\is_array($explicitMethods)) {
            foreach ($explicitMethods as $methodName) {
                if ($class !== null && $class->hasMethod($methodName)) {
                    try {
                        $method = $class->getMethod($methodName);
                        // @codeCoverageIgnoreStart
                    } catch (\ReflectionException $e) {
                        throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
                    }
                    // @codeCoverageIgnoreEnd
                    if ($this->canMethodBeDoubled($method)) {
                        $mockMethods->addMethods(\PHPUnit\Framework\MockObject\MockMethod::fromReflection($method, $callOriginalMethods, $cloneArguments));
                    }
                } else {
                    $mockMethods->addMethods(\PHPUnit\Framework\MockObject\MockMethod::fromName($_mockClassName['fullClassName'], $methodName, $cloneArguments));
                }
            }
        }
        $mockedMethods = '';
        $configurable = [];
        foreach ($mockMethods->asArray() as $mockMethod) {
            $mockedMethods .= $mockMethod->generateCode();
            $configurable[] = new \PHPUnit\Framework\MockObject\ConfigurableMethod($mockMethod->getName(), $mockMethod->getReturnType());
        }
        $method = '';
        if (!$mockMethods->hasMethod('method') && (!isset($class) || !$class->hasMethod('method'))) {
            $method = \PHP_EOL . '    use \\PHPUnit\\Framework\\MockObject\\Method;';
        }
        $cloneTrait = '';
        if ($mockedCloneMethod) {
            $cloneTrait = \PHP_EOL . '    use \\PHPUnit\\Framework\\MockObject\\MockedCloneMethod;';
        }
        if ($unmockedCloneMethod) {
            $cloneTrait = \PHP_EOL . '    use \\PHPUnit\\Framework\\MockObject\\UnmockedCloneMethod;';
        }
        $classTemplate->setVar(['prologue' => $prologue ?? '', 'epilogue' => $epilogue ?? '', 'class_declaration' => $this->generateMockClassDeclaration($_mockClassName, $isInterface, $additionalInterfaces), 'clone' => $cloneTrait, 'mock_class_name' => $_mockClassName['className'], 'mocked_methods' => $mockedMethods, 'method' => $method]);
        return new \PHPUnit\Framework\MockObject\MockClass($classTemplate->render(), $_mockClassName['className'], $configurable);
    }
    private function generateClassName(string $type, string $className, string $prefix) : array
    {
        if ($type[0] === '\\') {
            $type = \substr($type, 1);
        }
        $classNameParts = \explode('\\', $type);
        if (\count($classNameParts) > 1) {
            $type = \array_pop($classNameParts);
            $namespaceName = \implode('\\', $classNameParts);
            $fullClassName = $namespaceName . '\\' . $type;
        } else {
            $namespaceName = '';
            $fullClassName = $type;
        }
        if ($className === '') {
            do {
                $className = $prefix . $type . '_' . \substr(\md5((string) \mt_rand()), 0, 8);
            } while (\class_exists($className, \false));
        }
        return ['className' => $className, 'originalClassName' => $type, 'fullClassName' => $fullClassName, 'namespaceName' => $namespaceName];
    }
    private function generateMockClassDeclaration(array $mockClassName, bool $isInterface, array $additionalInterfaces = []) : string
    {
        $buffer = 'class ';
        $additionalInterfaces[] = \PHPUnit\Framework\MockObject\MockObject::class;
        $interfaces = \implode(', ', $additionalInterfaces);
        if ($isInterface) {
            $buffer .= \sprintf('%s implements %s', $mockClassName['className'], $interfaces);
            if (!\in_array($mockClassName['originalClassName'], $additionalInterfaces, \true)) {
                $buffer .= ', ';
                if (!empty($mockClassName['namespaceName'])) {
                    $buffer .= $mockClassName['namespaceName'] . '\\';
                }
                $buffer .= $mockClassName['originalClassName'];
            }
        } else {
            $buffer .= \sprintf('%s extends %s%s implements %s', $mockClassName['className'], !empty($mockClassName['namespaceName']) ? $mockClassName['namespaceName'] . '\\' : '', $mockClassName['originalClassName'], $interfaces);
        }
        return $buffer;
    }
    private function canMethodBeDoubled(\ReflectionMethod $method) : bool
    {
        if ($this->isConstructor($method)) {
            return \false;
        }
        if ($method->isDestructor()) {
            return \false;
        }
        if ($method->isFinal()) {
            return \false;
        }
        if ($method->isPrivate()) {
            return \false;
        }
        return !$this->isMethodNameExcluded($method->getName());
    }
    /**
     * @see https://github.com/sebastianbergmann/phpunit/issues/4139#issuecomment-605409765
     */
    private function isConstructor(\ReflectionMethod $method) : bool
    {
        $methodName = \strtolower($method->getName());
        if ($methodName === '__construct') {
            return \true;
        }
        if (\PHP_MAJOR_VERSION >= 8) {
            return \false;
        }
        $className = \strtolower($method->getDeclaringClass()->getName());
        return $methodName === $className;
    }
    private function isMethodNameExcluded(string $name) : bool
    {
        return isset(self::EXCLUDED_METHOD_NAMES[$name]);
    }
}

        @trigger_error({deprecation}, E_USER_DEPRECATED);
declare(strict_types=1);

{prologue}{class_declaration}
{
    use \PHPUnit\Framework\MockObject\Api;{method}{clone}
{mocked_methods}}{epilogue}

    {modifier} function {reference}{method_name}({arguments_decl}){return_declaration}
    {{deprecation}
        $__phpunit_arguments = [{arguments_call}];
        $__phpunit_count     = func_num_args();

        if ($__phpunit_count > {arguments_count}) {
            $__phpunit_arguments_tmp = func_get_args();

            for ($__phpunit_i = {arguments_count}; $__phpunit_i < $__phpunit_count; $__phpunit_i++) {
                $__phpunit_arguments[] = $__phpunit_arguments_tmp[$__phpunit_i];
            }
        }

        $__phpunit_result = $this->__phpunit_getInvocationHandler()->invoke(
            new \PHPUnit\Framework\MockObject\Invocation(
                '{class_name}', '{method_name}', $__phpunit_arguments, '{return_type}', $this, {clone_arguments}
            )
        );

        return $__phpunit_result;
    }

    {modifier} function {reference}{method_name}({arguments_decl}){return_declaration}
    {{deprecation}
        $__phpunit_arguments = [{arguments_call}];
        $__phpunit_count     = func_num_args();

        if ($__phpunit_count > {arguments_count}) {
            $__phpunit_arguments_tmp = func_get_args();

            for ($__phpunit_i = {arguments_count}; $__phpunit_i < $__phpunit_count; $__phpunit_i++) {
                $__phpunit_arguments[] = $__phpunit_arguments_tmp[$__phpunit_i];
            }
        }

        $this->__phpunit_getInvocationHandler()->invoke(
            new \PHPUnit\Framework\MockObject\Invocation(
                '{class_name}', '{method_name}', $__phpunit_arguments, '{return_type}', $this, {clone_arguments}
            )
        );
    }

    {modifier} function {reference}{method_name}({arguments_decl}){return_declaration}
    {
        throw new \PHPUnit\Framework\MockObject\BadMethodCallException('Static method "{method_name}" cannot be invoked on mock object');
    }

    {modifier} function {reference}{method_name}({arguments_decl}){return_declaration}
    {
        $__phpunit_arguments = [{arguments_call}];
        $__phpunit_count     = func_num_args();

        if ($__phpunit_count > {arguments_count}) {
            $__phpunit_arguments_tmp = func_get_args();

            for ($__phpunit_i = {arguments_count}; $__phpunit_i < $__phpunit_count; $__phpunit_i++) {
                $__phpunit_arguments[] = $__phpunit_arguments_tmp[$__phpunit_i];
            }
        }

        $this->__phpunit_getInvocationHandler()->invoke(
            new \PHPUnit\Framework\MockObject\Invocation(
                '{class_name}', '{method_name}', $__phpunit_arguments, '{return_type}', $this, {clone_arguments}, true
            )
        );

        return call_user_func_array(array($this->__phpunit_originalObject, "{method_name}"), $__phpunit_arguments);
    }

    {modifier} function {reference}{method_name}({arguments_decl}){return_declaration}
    {
        $__phpunit_arguments = [{arguments_call}];
        $__phpunit_count     = func_num_args();

        if ($__phpunit_count > {arguments_count}) {
            $__phpunit_arguments_tmp = func_get_args();

            for ($__phpunit_i = {arguments_count}; $__phpunit_i < $__phpunit_count; $__phpunit_i++) {
                $__phpunit_arguments[] = $__phpunit_arguments_tmp[$__phpunit_i];
            }
        }

        $this->__phpunit_getInvocationHandler()->invoke(
            new \PHPUnit\Framework\MockObject\Invocation(
                '{class_name}', '{method_name}', $__phpunit_arguments, '{return_type}', $this, {clone_arguments}, true
            )
        );

        call_user_func_array(array($this->__phpunit_originalObject, "{method_name}"), $__phpunit_arguments);
    }
declare(strict_types=1);

{prologue}class {class_name}
{
    use {trait_name};
}
declare(strict_types=1);

{namespace}class {class_name} extends \SoapClient
{
    public function __construct($wsdl, array $options)
    {
        parent::__construct('{wsdl}', $options);
    }
{methods}}

    public function {method_name}({arguments})
    {
    }
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function array_map;
use function explode;
use function get_class;
use function implode;
use function is_object;
use function sprintf;
use function strpos;
use function strtolower;
use function substr;
use PHPUnit\Doctrine\Instantiator\Instantiator;
use PHPUnit\Framework\SelfDescribing;
use PHPUnit\Util\Type;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
use stdClass;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Invocation implements \PHPUnit\Framework\SelfDescribing
{
    private string $className;
    private string $methodName;
    private array $parameters;
    private string $returnType;
    private bool $isReturnTypeNullable = \false;
    private bool $proxiedCall;
    private object $object;
    public function __construct(string $className, string $methodName, array $parameters, string $returnType, object $object, bool $cloneObjects = \false, bool $proxiedCall = \false)
    {
        $this->className = $className;
        $this->methodName = $methodName;
        $this->parameters = $parameters;
        $this->object = $object;
        $this->proxiedCall = $proxiedCall;
        if (\strtolower($methodName) === '__tostring') {
            $returnType = 'string';
        }
        if (\strpos($returnType, '?') === 0) {
            $returnType = \substr($returnType, 1);
            $this->isReturnTypeNullable = \true;
        }
        $this->returnType = $returnType;
        if (!$cloneObjects) {
            return;
        }
        foreach ($this->parameters as $key => $value) {
            if (\is_object($value)) {
                $this->parameters[$key] = $this->cloneObject($value);
            }
        }
    }
    public function getClassName() : string
    {
        return $this->className;
    }
    public function getMethodName() : string
    {
        return $this->methodName;
    }
    public function getParameters() : array
    {
        return $this->parameters;
    }
    /**
     * @throws RuntimeException
     *
     * @return mixed Mocked return value
     */
    public function generateReturnValue()
    {
        if ($this->isReturnTypeNullable || $this->proxiedCall) {
            return;
        }
        $returnType = $this->returnType;
        if (\strpos($returnType, '|') !== \false) {
            $types = \explode('|', $returnType);
            $returnType = $types[0];
            foreach ($types as $type) {
                if ($type === 'null') {
                    return;
                }
            }
        }
        switch (\strtolower($returnType)) {
            case '':
            case 'void':
                return;
            case 'string':
                return '';
            case 'float':
                return 0.0;
            case 'int':
                return 0;
            case 'bool':
                return \false;
            case 'array':
                return [];
            case 'static':
                return (new \PHPUnit\Doctrine\Instantiator\Instantiator())->instantiate(\get_class($this->object));
            case 'object':
                return new \stdClass();
            case 'callable':
            case 'closure':
                return static function () : void {
                };
            case 'traversable':
            case 'generator':
            case 'iterable':
                $generator = static function () : \Generator {
                    yield;
                };
                return $generator();
            case 'mixed':
                return null;
            default:
                return (new \PHPUnit\Framework\MockObject\Generator())->getMock($this->returnType, [], [], '', \false);
        }
    }
    public function toString() : string
    {
        $exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
        return \sprintf('%s::%s(%s)%s', $this->className, $this->methodName, \implode(', ', \array_map([$exporter, 'shortenedExport'], $this->parameters)), $this->returnType ? \sprintf(': %s', $this->returnType) : '');
    }
    public function getObject() : object
    {
        return $this->object;
    }
    private function cloneObject(object $original) : object
    {
        if (\PHPUnit\Util\Type::isCloneable($original)) {
            return clone $original;
        }
        return $original;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function strtolower;
use Exception;
use PHPUnit\Framework\MockObject\Builder\InvocationMocker;
use PHPUnit\Framework\MockObject\Rule\InvocationOrder;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvocationHandler
{
    /**
     * @var Matcher[]
     */
    private array $matchers = [];
    /**
     * @var Matcher[]
     */
    private array $matcherMap = [];
    /**
     * @var ConfigurableMethod[]
     */
    private array $configurableMethods;
    private bool $returnValueGeneration;
    private ?\PHPUnit\Framework\MockObject\ReturnValueNotConfiguredException $deferredError = null;
    public function __construct(array $configurableMethods, bool $returnValueGeneration)
    {
        $this->configurableMethods = $configurableMethods;
        $this->returnValueGeneration = $returnValueGeneration;
    }
    public function hasMatchers() : bool
    {
        foreach ($this->matchers as $matcher) {
            if ($matcher->hasMatchers()) {
                return \true;
            }
        }
        return \false;
    }
    /**
     * Looks up the match builder with identification $id and returns it.
     *
     * @param string $id The identification of the match builder
     */
    public function lookupMatcher(string $id) : ?\PHPUnit\Framework\MockObject\Matcher
    {
        if (isset($this->matcherMap[$id])) {
            return $this->matcherMap[$id];
        }
        return null;
    }
    /**
     * Registers a matcher with the identification $id. The matcher can later be
     * looked up using lookupMatcher() to figure out if it has been invoked.
     *
     * @param string  $id      The identification of the matcher
     * @param Matcher $matcher The builder which is being registered
     *
     * @throws MatcherAlreadyRegisteredException
     */
    public function registerMatcher(string $id, \PHPUnit\Framework\MockObject\Matcher $matcher) : void
    {
        if (isset($this->matcherMap[$id])) {
            throw new \PHPUnit\Framework\MockObject\MatcherAlreadyRegisteredException($id);
        }
        $this->matcherMap[$id] = $matcher;
    }
    public function expects(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $rule) : \PHPUnit\Framework\MockObject\Builder\InvocationMocker
    {
        $matcher = new \PHPUnit\Framework\MockObject\Matcher($rule);
        $this->addMatcher($matcher);
        return new \PHPUnit\Framework\MockObject\Builder\InvocationMocker($this, $matcher, ...$this->configurableMethods);
    }
    /**
     * @throws Exception
     * @throws RuntimeException
     */
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        $exception = null;
        $hasReturnValue = \false;
        $returnValue = null;
        foreach ($this->matchers as $match) {
            try {
                if ($match->matches($invocation)) {
                    $value = $match->invoked($invocation);
                    if (!$hasReturnValue) {
                        $returnValue = $value;
                        $hasReturnValue = \true;
                    }
                }
            } catch (\Exception $e) {
                $exception = $e;
            }
        }
        if ($exception !== null) {
            throw $exception;
        }
        if ($hasReturnValue) {
            return $returnValue;
        }
        if (!$this->returnValueGeneration) {
            $exception = new \PHPUnit\Framework\MockObject\ReturnValueNotConfiguredException($invocation);
            if (\strtolower($invocation->getMethodName()) === '__tostring') {
                $this->deferredError = $exception;
                return '';
            }
            throw $exception;
        }
        return $invocation->generateReturnValue();
    }
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        foreach ($this->matchers as $matcher) {
            if (!$matcher->matches($invocation)) {
                return \false;
            }
        }
        return \true;
    }
    /**
     * @throws Throwable
     */
    public function verify() : void
    {
        foreach ($this->matchers as $matcher) {
            $matcher->verify();
        }
        if ($this->deferredError) {
            throw $this->deferredError;
        }
    }
    private function addMatcher(\PHPUnit\Framework\MockObject\Matcher $matcher) : void
    {
        $this->matchers[] = $matcher;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function assert;
use function implode;
use function sprintf;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\MockObject\Rule\AnyInvokedCount;
use PHPUnit\Framework\MockObject\Rule\AnyParameters;
use PHPUnit\Framework\MockObject\Rule\InvocationOrder;
use PHPUnit\Framework\MockObject\Rule\InvokedCount;
use PHPUnit\Framework\MockObject\Rule\MethodName;
use PHPUnit\Framework\MockObject\Rule\ParametersRule;
use PHPUnit\Framework\MockObject\Stub\Stub;
use PHPUnit\Framework\TestFailure;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Matcher
{
    private \PHPUnit\Framework\MockObject\Rule\InvocationOrder $invocationRule;
    private ?string $afterMatchBuilderId = null;
    private bool $afterMatchBuilderIsInvoked = \false;
    private ?\PHPUnit\Framework\MockObject\Rule\MethodName $methodNameRule = null;
    private ?\PHPUnit\Framework\MockObject\Rule\ParametersRule $parametersRule = null;
    private ?\PHPUnit\Framework\MockObject\Stub\Stub $stub = null;
    public function __construct(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $rule)
    {
        $this->invocationRule = $rule;
    }
    public function hasMatchers() : bool
    {
        return !$this->invocationRule instanceof \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount;
    }
    public function hasMethodNameRule() : bool
    {
        return $this->methodNameRule !== null;
    }
    public function getMethodNameRule() : \PHPUnit\Framework\MockObject\Rule\MethodName
    {
        return $this->methodNameRule;
    }
    public function setMethodNameRule(\PHPUnit\Framework\MockObject\Rule\MethodName $rule) : void
    {
        $this->methodNameRule = $rule;
    }
    public function hasParametersRule() : bool
    {
        return $this->parametersRule !== null;
    }
    public function setParametersRule(\PHPUnit\Framework\MockObject\Rule\ParametersRule $rule) : void
    {
        $this->parametersRule = $rule;
    }
    public function setStub(\PHPUnit\Framework\MockObject\Stub\Stub $stub) : void
    {
        $this->stub = $stub;
    }
    public function setAfterMatchBuilderId(string $id) : void
    {
        $this->afterMatchBuilderId = $id;
    }
    /**
     * @throws ExpectationFailedException
     * @throws MatchBuilderNotFoundException
     * @throws MethodNameNotConfiguredException
     * @throws RuntimeException
     */
    public function invoked(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        if ($this->methodNameRule === null) {
            throw new \PHPUnit\Framework\MockObject\MethodNameNotConfiguredException();
        }
        if ($this->afterMatchBuilderId !== null) {
            $matcher = $invocation->getObject()->__phpunit_getInvocationHandler()->lookupMatcher($this->afterMatchBuilderId);
            if (!$matcher) {
                throw new \PHPUnit\Framework\MockObject\MatchBuilderNotFoundException($this->afterMatchBuilderId);
            }
            \assert($matcher instanceof self);
            if ($matcher->invocationRule->hasBeenInvoked()) {
                $this->afterMatchBuilderIsInvoked = \true;
            }
        }
        $this->invocationRule->invoked($invocation);
        try {
            if ($this->parametersRule !== null) {
                $this->parametersRule->apply($invocation);
            }
        } catch (\PHPUnit\Framework\ExpectationFailedException $e) {
            throw new \PHPUnit\Framework\ExpectationFailedException(\sprintf("Expectation failed for %s when %s\n%s", $this->methodNameRule->toString(), $this->invocationRule->toString(), $e->getMessage()), $e->getComparisonFailure());
        }
        if ($this->stub) {
            return $this->stub->invoke($invocation);
        }
        return $invocation->generateReturnValue();
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     * @throws MatchBuilderNotFoundException
     * @throws MethodNameNotConfiguredException
     * @throws RuntimeException
     */
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        if ($this->afterMatchBuilderId !== null) {
            $matcher = $invocation->getObject()->__phpunit_getInvocationHandler()->lookupMatcher($this->afterMatchBuilderId);
            if (!$matcher) {
                throw new \PHPUnit\Framework\MockObject\MatchBuilderNotFoundException($this->afterMatchBuilderId);
            }
            \assert($matcher instanceof self);
            if (!$matcher->invocationRule->hasBeenInvoked()) {
                return \false;
            }
        }
        if ($this->methodNameRule === null) {
            throw new \PHPUnit\Framework\MockObject\MethodNameNotConfiguredException();
        }
        if (!$this->invocationRule->matches($invocation)) {
            return \false;
        }
        try {
            if (!$this->methodNameRule->matches($invocation)) {
                return \false;
            }
        } catch (\PHPUnit\Framework\ExpectationFailedException $e) {
            throw new \PHPUnit\Framework\ExpectationFailedException(\sprintf("Expectation failed for %s when %s\n%s", $this->methodNameRule->toString(), $this->invocationRule->toString(), $e->getMessage()), $e->getComparisonFailure());
        }
        return \true;
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     * @throws MethodNameNotConfiguredException
     */
    public function verify() : void
    {
        if ($this->methodNameRule === null) {
            throw new \PHPUnit\Framework\MockObject\MethodNameNotConfiguredException();
        }
        try {
            $this->invocationRule->verify();
            if ($this->parametersRule === null) {
                $this->parametersRule = new \PHPUnit\Framework\MockObject\Rule\AnyParameters();
            }
            $invocationIsAny = $this->invocationRule instanceof \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount;
            $invocationIsNever = $this->invocationRule instanceof \PHPUnit\Framework\MockObject\Rule\InvokedCount && $this->invocationRule->isNever();
            if (!$invocationIsAny && !$invocationIsNever) {
                $this->parametersRule->verify();
            }
        } catch (\PHPUnit\Framework\ExpectationFailedException $e) {
            throw new \PHPUnit\Framework\ExpectationFailedException(\sprintf("Expectation failed for %s when %s.\n%s", $this->methodNameRule->toString(), $this->invocationRule->toString(), \PHPUnit\Framework\TestFailure::exceptionToString($e)));
        }
    }
    public function toString() : string
    {
        $list = [];
        if ($this->invocationRule !== null) {
            $list[] = $this->invocationRule->toString();
        }
        if ($this->methodNameRule !== null) {
            $list[] = 'where ' . $this->methodNameRule->toString();
        }
        if ($this->parametersRule !== null) {
            $list[] = 'and ' . $this->parametersRule->toString();
        }
        if ($this->afterMatchBuilderId !== null) {
            $list[] = 'after ' . $this->afterMatchBuilderId;
        }
        if ($this->stub !== null) {
            $list[] = 'will ' . $this->stub->toString();
        }
        return \implode(' ', $list);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function is_string;
use function sprintf;
use function strtolower;
use PHPUnit\Framework\Constraint\Constraint;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MethodNameConstraint extends \PHPUnit\Framework\Constraint\Constraint
{
    private string $methodName;
    public function __construct(string $methodName)
    {
        $this->methodName = $methodName;
    }
    public function toString() : string
    {
        return \sprintf('is "%s"', $this->methodName);
    }
    protected function matches($other) : bool
    {
        if (!\is_string($other)) {
            return \false;
        }
        return \strtolower($this->methodName) === \strtolower($other);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function array_merge;
use PHPUnit\Framework\TestCase;
use ReflectionClass;
/**
 * @psalm-template MockedType
 *
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class MockBuilder
{
    private \PHPUnit\Framework\TestCase $testCase;
    /**
     * @var string
     */
    private $type;
    private ?array $methods = [];
    private bool $emptyMethodsArray = \false;
    private string $mockClassName = '';
    private array $constructorArgs = [];
    private bool $originalConstructor = \true;
    private bool $originalClone = \true;
    private bool $autoload = \true;
    private bool $cloneArguments = \false;
    private bool $callOriginalMethods = \false;
    private ?object $proxyTarget = null;
    private bool $allowMockingUnknownTypes = \true;
    private bool $returnValueGeneration = \true;
    private \PHPUnit\Framework\MockObject\Generator $generator;
    /**
     * @param string|string[] $type
     *
     * @psalm-param class-string<MockedType>|string|string[] $type
     */
    public function __construct(\PHPUnit\Framework\TestCase $testCase, $type)
    {
        $this->testCase = $testCase;
        $this->type = $type;
        $this->generator = new \PHPUnit\Framework\MockObject\Generator();
    }
    /**
     * Creates a mock object using a fluent interface.
     *
     * @throws \PHPUnit\Framework\InvalidArgumentException
     * @throws ClassAlreadyExistsException
     * @throws ClassIsFinalException
     * @throws DuplicateMethodException
     * @throws InvalidMethodNameException
     * @throws OriginalConstructorInvocationRequiredException
     * @throws ReflectionException
     * @throws RuntimeException
     * @throws UnknownTypeException
     *
     * @psalm-return MockObject&MockedType
     */
    public function getMock() : \PHPUnit\Framework\MockObject\MockObject
    {
        $object = $this->generator->getMock($this->type, !$this->emptyMethodsArray ? $this->methods : null, $this->constructorArgs, $this->mockClassName, $this->originalConstructor, $this->originalClone, $this->autoload, $this->cloneArguments, $this->callOriginalMethods, $this->proxyTarget, $this->allowMockingUnknownTypes, $this->returnValueGeneration);
        $this->testCase->registerMockObject($object);
        return $object;
    }
    /**
     * Creates a mock object for an abstract class using a fluent interface.
     *
     * @psalm-return MockObject&MockedType
     *
     * @throws \PHPUnit\Framework\Exception
     * @throws ReflectionException
     * @throws RuntimeException
     */
    public function getMockForAbstractClass() : \PHPUnit\Framework\MockObject\MockObject
    {
        $object = $this->generator->getMockForAbstractClass($this->type, $this->constructorArgs, $this->mockClassName, $this->originalConstructor, $this->originalClone, $this->autoload, $this->methods, $this->cloneArguments);
        $this->testCase->registerMockObject($object);
        return $object;
    }
    /**
     * Creates a mock object for a trait using a fluent interface.
     *
     * @psalm-return MockObject&MockedType
     *
     * @throws \PHPUnit\Framework\Exception
     * @throws ReflectionException
     * @throws RuntimeException
     */
    public function getMockForTrait() : \PHPUnit\Framework\MockObject\MockObject
    {
        $object = $this->generator->getMockForTrait($this->type, $this->constructorArgs, $this->mockClassName, $this->originalConstructor, $this->originalClone, $this->autoload, $this->methods, $this->cloneArguments);
        $this->testCase->registerMockObject($object);
        return $object;
    }
    /**
     * Specifies the subset of methods to mock, requiring each to exist in the class.
     *
     * @param string[] $methods
     *
     * @throws CannotUseOnlyMethodsException
     * @throws ReflectionException
     *
     * @return $this
     */
    public function onlyMethods(array $methods) : self
    {
        if (empty($methods)) {
            $this->emptyMethodsArray = \true;
            return $this;
        }
        try {
            $reflector = new \ReflectionClass($this->type);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        foreach ($methods as $method) {
            if (!$reflector->hasMethod($method)) {
                throw new \PHPUnit\Framework\MockObject\CannotUseOnlyMethodsException($this->type, $method);
            }
        }
        $this->methods = \array_merge($this->methods ?? [], $methods);
        return $this;
    }
    /**
     * Specifies methods that don't exist in the class which you want to mock.
     *
     * @param string[] $methods
     *
     * @throws CannotUseAddMethodsException
     * @throws ReflectionException
     * @throws RuntimeException
     *
     * @return $this
     */
    public function addMethods(array $methods) : self
    {
        if (empty($methods)) {
            $this->emptyMethodsArray = \true;
            return $this;
        }
        try {
            $reflector = new \ReflectionClass($this->type);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        foreach ($methods as $method) {
            if ($reflector->hasMethod($method)) {
                throw new \PHPUnit\Framework\MockObject\CannotUseAddMethodsException($this->type, $method);
            }
        }
        $this->methods = \array_merge($this->methods ?? [], $methods);
        return $this;
    }
    /**
     * Specifies the arguments for the constructor.
     *
     * @return $this
     */
    public function setConstructorArgs(array $args) : self
    {
        $this->constructorArgs = $args;
        return $this;
    }
    /**
     * Specifies the name for the mock class.
     *
     * @return $this
     */
    public function setMockClassName(string $name) : self
    {
        $this->mockClassName = $name;
        return $this;
    }
    /**
     * Disables the invocation of the original constructor.
     *
     * @return $this
     */
    public function disableOriginalConstructor() : self
    {
        $this->originalConstructor = \false;
        return $this;
    }
    /**
     * Enables the invocation of the original constructor.
     *
     * @return $this
     */
    public function enableOriginalConstructor() : self
    {
        $this->originalConstructor = \true;
        return $this;
    }
    /**
     * Disables the invocation of the original clone constructor.
     *
     * @return $this
     */
    public function disableOriginalClone() : self
    {
        $this->originalClone = \false;
        return $this;
    }
    /**
     * Enables the invocation of the original clone constructor.
     *
     * @return $this
     */
    public function enableOriginalClone() : self
    {
        $this->originalClone = \true;
        return $this;
    }
    /**
     * Disables the use of class autoloading while creating the mock object.
     *
     * @return $this
     */
    public function disableAutoload() : self
    {
        $this->autoload = \false;
        return $this;
    }
    /**
     * Enables the use of class autoloading while creating the mock object.
     *
     * @return $this
     */
    public function enableAutoload() : self
    {
        $this->autoload = \true;
        return $this;
    }
    /**
     * Disables the cloning of arguments passed to mocked methods.
     *
     * @return $this
     */
    public function disableArgumentCloning() : self
    {
        $this->cloneArguments = \false;
        return $this;
    }
    /**
     * Enables the cloning of arguments passed to mocked methods.
     *
     * @return $this
     */
    public function enableArgumentCloning() : self
    {
        $this->cloneArguments = \true;
        return $this;
    }
    /**
     * Enables the invocation of the original methods.
     *
     * @return $this
     */
    public function enableProxyingToOriginalMethods() : self
    {
        $this->callOriginalMethods = \true;
        return $this;
    }
    /**
     * Disables the invocation of the original methods.
     *
     * @return $this
     */
    public function disableProxyingToOriginalMethods() : self
    {
        $this->callOriginalMethods = \false;
        $this->proxyTarget = null;
        return $this;
    }
    /**
     * Sets the proxy target.
     *
     * @return $this
     */
    public function setProxyTarget(object $object) : self
    {
        $this->proxyTarget = $object;
        return $this;
    }
    /**
     * @return $this
     */
    public function allowMockingUnknownTypes() : self
    {
        $this->allowMockingUnknownTypes = \true;
        return $this;
    }
    /**
     * @return $this
     */
    public function disallowMockingUnknownTypes() : self
    {
        $this->allowMockingUnknownTypes = \false;
        return $this;
    }
    /**
     * @return $this
     */
    public function enableAutoReturnValueGeneration() : self
    {
        $this->returnValueGeneration = \true;
        return $this;
    }
    /**
     * @return $this
     */
    public function disableAutoReturnValueGeneration() : self
    {
        $this->returnValueGeneration = \false;
        return $this;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function call_user_func;
use function class_exists;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MockClass implements \PHPUnit\Framework\MockObject\MockType
{
    private string $classCode;
    /**
     * @var class-string
     */
    private string $mockName;
    /**
     * @var ConfigurableMethod[]
     */
    private array $configurableMethods;
    /**
     * @psalm-param class-string $mockName
     */
    public function __construct(string $classCode, string $mockName, array $configurableMethods)
    {
        $this->classCode = $classCode;
        $this->mockName = $mockName;
        $this->configurableMethods = $configurableMethods;
    }
    /**
     * @psalm-return class-string
     */
    public function generate() : string
    {
        if (!\class_exists($this->mockName, \false)) {
            eval($this->classCode);
            \call_user_func([$this->mockName, '__phpunit_initConfigurableMethods'], ...$this->configurableMethods);
        }
        return $this->mockName;
    }
    public function getClassCode() : string
    {
        return $this->classCode;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function implode;
use function is_string;
use function preg_match;
use function preg_replace;
use function sprintf;
use function substr_count;
use function trim;
use function var_export;
use ReflectionMethod;
use ReflectionNamedType;
use ReflectionParameter;
use ReflectionUnionType;
use PHPUnit\SebastianBergmann\Type\ReflectionMapper;
use PHPUnit\SebastianBergmann\Type\Type;
use PHPUnit\SebastianBergmann\Type\UnknownType;
use PHPUnit\SebastianBergmann\Type\VoidType;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MockMethod
{
    use TemplateLoader;
    private string $className;
    private string $methodName;
    private bool $cloneArguments;
    private string $modifier;
    private string $argumentsForDeclaration;
    private string $argumentsForCall;
    private \PHPUnit\SebastianBergmann\Type\Type $returnType;
    private string $reference;
    private bool $callOriginalMethod;
    private bool $static;
    private ?string $deprecation = null;
    /**
     * @throws ReflectionException
     * @throws RuntimeException
     */
    public static function fromReflection(\ReflectionMethod $method, bool $callOriginalMethod, bool $cloneArguments) : self
    {
        if ($method->isPrivate()) {
            $modifier = 'private';
        } elseif ($method->isProtected()) {
            $modifier = 'protected';
        } else {
            $modifier = 'public';
        }
        if ($method->isStatic()) {
            $modifier .= ' static';
        }
        if ($method->returnsReference()) {
            $reference = '&';
        } else {
            $reference = '';
        }
        $docComment = $method->getDocComment();
        if (\is_string($docComment) && \preg_match('#\\*[ \\t]*+@deprecated[ \\t]*+(.*?)\\r?+\\n[ \\t]*+\\*(?:[ \\t]*+@|/$)#s', $docComment, $deprecation)) {
            $deprecation = \trim(\preg_replace('#[ \\t]*\\r?\\n[ \\t]*+\\*[ \\t]*+#', ' ', $deprecation[1]));
        } else {
            $deprecation = null;
        }
        return new self($method->getDeclaringClass()->getName(), $method->getName(), $cloneArguments, $modifier, self::getMethodParametersForDeclaration($method), self::getMethodParametersForCall($method), (new \PHPUnit\SebastianBergmann\Type\ReflectionMapper())->fromMethodReturnType($method), $reference, $callOriginalMethod, $method->isStatic(), $deprecation);
    }
    public static function fromName(string $fullClassName, string $methodName, bool $cloneArguments) : self
    {
        return new self($fullClassName, $methodName, $cloneArguments, 'public', '', '', new \PHPUnit\SebastianBergmann\Type\UnknownType(), '', \false, \false, null);
    }
    public function __construct(string $className, string $methodName, bool $cloneArguments, string $modifier, string $argumentsForDeclaration, string $argumentsForCall, \PHPUnit\SebastianBergmann\Type\Type $returnType, string $reference, bool $callOriginalMethod, bool $static, ?string $deprecation)
    {
        $this->className = $className;
        $this->methodName = $methodName;
        $this->cloneArguments = $cloneArguments;
        $this->modifier = $modifier;
        $this->argumentsForDeclaration = $argumentsForDeclaration;
        $this->argumentsForCall = $argumentsForCall;
        $this->returnType = $returnType;
        $this->reference = $reference;
        $this->callOriginalMethod = $callOriginalMethod;
        $this->static = $static;
        $this->deprecation = $deprecation;
    }
    public function getName() : string
    {
        return $this->methodName;
    }
    /**
     * @throws RuntimeException
     */
    public function generateCode() : string
    {
        if ($this->static) {
            $templateFile = 'mocked_static_method.tpl';
        } elseif ($this->returnType instanceof \PHPUnit\SebastianBergmann\Type\VoidType) {
            $templateFile = \sprintf('%s_method_void.tpl', $this->callOriginalMethod ? 'proxied' : 'mocked');
        } else {
            $templateFile = \sprintf('%s_method.tpl', $this->callOriginalMethod ? 'proxied' : 'mocked');
        }
        $deprecation = $this->deprecation;
        if (null !== $this->deprecation) {
            $deprecation = "The {$this->className}::{$this->methodName} method is deprecated ({$this->deprecation}).";
            $deprecationTemplate = $this->loadTemplate('deprecation.tpl');
            $deprecationTemplate->setVar(['deprecation' => \var_export($deprecation, \true)]);
            $deprecation = $deprecationTemplate->render();
        }
        $template = $this->loadTemplate($templateFile);
        $template->setVar(['arguments_decl' => $this->argumentsForDeclaration, 'arguments_call' => $this->argumentsForCall, 'return_declaration' => !empty($this->returnType->asString()) ? ': ' . $this->returnType->asString() : '', 'return_type' => $this->returnType->asString(), 'arguments_count' => !empty($this->argumentsForCall) ? \substr_count($this->argumentsForCall, ',') + 1 : 0, 'class_name' => $this->className, 'method_name' => $this->methodName, 'modifier' => $this->modifier, 'reference' => $this->reference, 'clone_arguments' => $this->cloneArguments ? 'true' : 'false', 'deprecation' => $deprecation]);
        return $template->render();
    }
    public function getReturnType() : \PHPUnit\SebastianBergmann\Type\Type
    {
        return $this->returnType;
    }
    /**
     * Returns the parameters of a function or method.
     *
     * @throws RuntimeException
     */
    private static function getMethodParametersForDeclaration(\ReflectionMethod $method) : string
    {
        $parameters = [];
        foreach ($method->getParameters() as $i => $parameter) {
            $name = '$' . $parameter->getName();
            /* Note: PHP extensions may use empty names for reference arguments
             * or "..." for methods taking a variable number of arguments.
             */
            if ($name === '$' || $name === '$...') {
                $name = '$arg' . $i;
            }
            $nullable = '';
            $default = '';
            $reference = '';
            $typeDeclaration = '';
            $type = null;
            $typeName = null;
            if ($parameter->hasType()) {
                $type = $parameter->getType();
                if ($type instanceof \ReflectionNamedType) {
                    $typeName = $type->getName();
                }
            }
            if ($parameter->isVariadic()) {
                $name = '...' . $name;
            } elseif ($parameter->isDefaultValueAvailable()) {
                $default = ' = ' . self::exportDefaultValue($parameter);
            } elseif ($parameter->isOptional()) {
                $default = ' = null';
            }
            if ($type !== null) {
                if ($typeName !== 'mixed' && $parameter->allowsNull() && !$type instanceof \ReflectionUnionType) {
                    $nullable = '?';
                }
                if ($typeName === 'self') {
                    $typeDeclaration = $method->getDeclaringClass()->getName() . ' ';
                } elseif ($typeName !== null) {
                    $typeDeclaration = $typeName . ' ';
                } elseif ($type instanceof \ReflectionUnionType) {
                    $typeDeclaration = self::unionTypeAsString($type, $method->getDeclaringClass()->getName());
                }
            }
            if ($parameter->isPassedByReference()) {
                $reference = '&';
            }
            $parameters[] = $nullable . $typeDeclaration . $reference . $name . $default;
        }
        return \implode(', ', $parameters);
    }
    /**
     * Returns the parameters of a function or method.
     *
     * @throws ReflectionException
     */
    private static function getMethodParametersForCall(\ReflectionMethod $method) : string
    {
        $parameters = [];
        foreach ($method->getParameters() as $i => $parameter) {
            $name = '$' . $parameter->getName();
            /* Note: PHP extensions may use empty names for reference arguments
             * or "..." for methods taking a variable number of arguments.
             */
            if ($name === '$' || $name === '$...') {
                $name = '$arg' . $i;
            }
            if ($parameter->isVariadic()) {
                continue;
            }
            if ($parameter->isPassedByReference()) {
                $parameters[] = '&' . $name;
            } else {
                $parameters[] = $name;
            }
        }
        return \implode(', ', $parameters);
    }
    /**
     * @throws ReflectionException
     */
    private static function exportDefaultValue(\ReflectionParameter $parameter) : string
    {
        try {
            return (string) \var_export($parameter->getDefaultValue(), \true);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\MockObject\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    private static function unionTypeAsString(\ReflectionUnionType $union, string $self) : string
    {
        $types = [];
        foreach ($union->getTypes() as $type) {
            if ((string) $type === 'self') {
                $types[] = $self;
            } else {
                $types[] = $type;
            }
        }
        return \implode('|', $types) . ' ';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function array_key_exists;
use function array_values;
use function strtolower;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MockMethodSet
{
    /**
     * @var MockMethod[]
     */
    private array $methods = [];
    public function addMethods(\PHPUnit\Framework\MockObject\MockMethod ...$methods) : void
    {
        foreach ($methods as $method) {
            $this->methods[\strtolower($method->getName())] = $method;
        }
    }
    /**
     * @return MockMethod[]
     */
    public function asArray() : array
    {
        return \array_values($this->methods);
    }
    public function hasMethod(string $methodName) : bool
    {
        return \array_key_exists(\strtolower($methodName), $this->methods);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use PHPUnit\Framework\MockObject\Builder\InvocationMocker as BuilderInvocationMocker;
use PHPUnit\Framework\MockObject\Rule\InvocationOrder;
/**
 * @method BuilderInvocationMocker method($constraint)
 *
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
interface MockObject extends \PHPUnit\Framework\MockObject\Stub
{
    public function __phpunit_setOriginalObject($originalObject) : void;
    public function __phpunit_verify(bool $unsetInvocationMocker = \true) : void;
    public function expects(\PHPUnit\Framework\MockObject\Rule\InvocationOrder $invocationRule) : \PHPUnit\Framework\MockObject\Builder\InvocationMocker;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use function class_exists;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MockTrait implements \PHPUnit\Framework\MockObject\MockType
{
    private string $classCode;
    /**
     * @var class-string
     */
    private string $mockName;
    /**
     * @psalm-param class-string $mockName
     */
    public function __construct(string $classCode, string $mockName)
    {
        $this->classCode = $classCode;
        $this->mockName = $mockName;
    }
    /**
     * @psalm-return class-string
     */
    public function generate() : string
    {
        if (!\class_exists($this->mockName, \false)) {
            eval($this->classCode);
        }
        return $this->mockName;
    }
    public function getClassCode() : string
    {
        return $this->classCode;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface MockType
{
    /**
     * @psalm-return class-string
     */
    public function generate() : string;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class AnyInvokedCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
{
    public function toString() : string
    {
        return 'invoked zero or more times';
    }
    public function verify() : void
    {
    }
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        return \true;
    }
    protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class AnyParameters implements \PHPUnit\Framework\MockObject\Rule\ParametersRule
{
    public function toString() : string
    {
        return 'with any parameters';
    }
    public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
    }
    public function verify() : void
    {
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use function count;
use function gettype;
use function is_iterable;
use function sprintf;
use PHPUnit\Framework\Constraint\Constraint;
use PHPUnit\Framework\Constraint\IsEqual;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\InvalidParameterGroupException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ConsecutiveParameters implements \PHPUnit\Framework\MockObject\Rule\ParametersRule
{
    private array $parameterGroups = [];
    private array $invocations = [];
    /**
     * @throws \PHPUnit\Framework\Exception
     */
    public function __construct(array $parameterGroups)
    {
        foreach ($parameterGroups as $index => $parameters) {
            if (!\is_iterable($parameters)) {
                throw new \PHPUnit\Framework\InvalidParameterGroupException(\sprintf('Parameter group #%d must be an array or Traversable, got %s', $index, \gettype($parameters)));
            }
            foreach ($parameters as $parameter) {
                if (!$parameter instanceof \PHPUnit\Framework\Constraint\Constraint) {
                    $parameter = new \PHPUnit\Framework\Constraint\IsEqual($parameter);
                }
                $this->parameterGroups[$index][] = $parameter;
            }
        }
    }
    public function toString() : string
    {
        return 'with consecutive parameters';
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
        $this->invocations[] = $invocation;
        $callIndex = \count($this->invocations) - 1;
        $this->verifyInvocation($invocation, $callIndex);
    }
    /**
     * @throws \PHPUnit\Framework\ExpectationFailedException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function verify() : void
    {
        foreach ($this->invocations as $callIndex => $invocation) {
            $this->verifyInvocation($invocation, $callIndex);
        }
    }
    /**
     * Verify a single invocation.
     *
     * @param int $callIndex
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    private function verifyInvocation(\PHPUnit\Framework\MockObject\Invocation $invocation, $callIndex) : void
    {
        if (!isset($this->parameterGroups[$callIndex])) {
            // no parameter assertion for this call index
            return;
        }
        $parameters = $this->parameterGroups[$callIndex];
        if (\count($invocation->getParameters()) < \count($parameters)) {
            throw new \PHPUnit\Framework\ExpectationFailedException(\sprintf('Parameter count for invocation %s is too low.', $invocation->toString()));
        }
        foreach ($parameters as $i => $parameter) {
            $parameter->evaluate($invocation->getParameters()[$i], \sprintf('Parameter %s for invocation #%d %s does not match expected ' . 'value.', $i, $callIndex, $invocation->toString()));
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use function count;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
use PHPUnit\Framework\MockObject\Verifiable;
use PHPUnit\Framework\SelfDescribing;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
abstract class InvocationOrder implements \PHPUnit\Framework\SelfDescribing, \PHPUnit\Framework\MockObject\Verifiable
{
    /**
     * @var BaseInvocation[]
     */
    private array $invocations = [];
    public function getInvocationCount() : int
    {
        return \count($this->invocations);
    }
    public function hasBeenInvoked() : bool
    {
        return \count($this->invocations) > 0;
    }
    public final function invoked(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        $this->invocations[] = $invocation;
        return $this->invokedDo($invocation);
    }
    public abstract function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool;
    protected abstract function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation);
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvokedAtLeastCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
{
    private int $requiredInvocations;
    /**
     * @param int $requiredInvocations
     */
    public function __construct($requiredInvocations)
    {
        $this->requiredInvocations = $requiredInvocations;
    }
    public function toString() : string
    {
        return 'invoked at least ' . $this->requiredInvocations . ' times';
    }
    /**
     * Verifies that the current expectation is valid. If everything is OK the
     * code should just return, if not it must throw an exception.
     *
     * @throws ExpectationFailedException
     */
    public function verify() : void
    {
        $count = $this->getInvocationCount();
        if ($count < $this->requiredInvocations) {
            throw new \PHPUnit\Framework\ExpectationFailedException('Expected invocation at least ' . $this->requiredInvocations . ' times but it occurred ' . $count . ' time(s).');
        }
    }
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        return \true;
    }
    protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvokedAtLeastOnce extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
{
    public function toString() : string
    {
        return 'invoked at least once';
    }
    /**
     * Verifies that the current expectation is valid. If everything is OK the
     * code should just return, if not it must throw an exception.
     *
     * @throws ExpectationFailedException
     */
    public function verify() : void
    {
        $count = $this->getInvocationCount();
        if ($count < 1) {
            throw new \PHPUnit\Framework\ExpectationFailedException('Expected invocation at least once but it never occurred.');
        }
    }
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        return \true;
    }
    protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvokedAtMostCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
{
    private int $allowedInvocations;
    /**
     * @param int $allowedInvocations
     */
    public function __construct($allowedInvocations)
    {
        $this->allowedInvocations = $allowedInvocations;
    }
    public function toString() : string
    {
        return 'invoked at most ' . $this->allowedInvocations . ' times';
    }
    /**
     * Verifies that the current expectation is valid. If everything is OK the
     * code should just return, if not it must throw an exception.
     *
     * @throws ExpectationFailedException
     */
    public function verify() : void
    {
        $count = $this->getInvocationCount();
        if ($count > $this->allowedInvocations) {
            throw new \PHPUnit\Framework\ExpectationFailedException('Expected invocation at most ' . $this->allowedInvocations . ' times but it occurred ' . $count . ' time(s).');
        }
    }
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        return \true;
    }
    protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use function sprintf;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvokedCount extends \PHPUnit\Framework\MockObject\Rule\InvocationOrder
{
    private int $expectedCount;
    /**
     * @param int $expectedCount
     */
    public function __construct($expectedCount)
    {
        $this->expectedCount = $expectedCount;
    }
    public function isNever() : bool
    {
        return $this->expectedCount === 0;
    }
    public function toString() : string
    {
        return 'invoked ' . $this->expectedCount . ' time(s)';
    }
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        return \true;
    }
    /**
     * Verifies that the current expectation is valid. If everything is OK the
     * code should just return, if not it must throw an exception.
     *
     * @throws ExpectationFailedException
     */
    public function verify() : void
    {
        $count = $this->getInvocationCount();
        if ($count !== $this->expectedCount) {
            throw new \PHPUnit\Framework\ExpectationFailedException(\sprintf('Method was expected to be called %d times, ' . 'actually called %d times.', $this->expectedCount, $count));
        }
    }
    /**
     * @throws ExpectationFailedException
     */
    protected function invokedDo(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
        $count = $this->getInvocationCount();
        if ($count > $this->expectedCount) {
            $message = $invocation->toString() . ' ';
            switch ($this->expectedCount) {
                case 0:
                    $message .= 'was not expected to be called.';
                    break;
                case 1:
                    $message .= 'was not expected to be called more than once.';
                    break;
                default:
                    $message .= \sprintf('was not expected to be called more than %d times.', $this->expectedCount);
            }
            throw new \PHPUnit\Framework\ExpectationFailedException($message);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use function is_string;
use PHPUnit\Framework\Constraint\Constraint;
use PHPUnit\Framework\InvalidArgumentException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
use PHPUnit\Framework\MockObject\MethodNameConstraint;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MethodName
{
    private \PHPUnit\Framework\Constraint\Constraint $constraint;
    /**
     * @param Constraint|string $constraint
     *
     * @throws InvalidArgumentException
     */
    public function __construct($constraint)
    {
        if (\is_string($constraint)) {
            $constraint = new \PHPUnit\Framework\MockObject\MethodNameConstraint($constraint);
        }
        if (!$constraint instanceof \PHPUnit\Framework\Constraint\Constraint) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'PHPUnit\\Framework\\Constraint\\Constraint object or string');
        }
        $this->constraint = $constraint;
    }
    public function toString() : string
    {
        return 'method name ' . $this->constraint->toString();
    }
    /**
     * @throws \PHPUnit\Framework\ExpectationFailedException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function matches(\PHPUnit\Framework\MockObject\Invocation $invocation) : bool
    {
        return $this->matchesName($invocation->getMethodName());
    }
    /**
     * @throws \PHPUnit\Framework\ExpectationFailedException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function matchesName(string $methodName) : bool
    {
        return (bool) $this->constraint->evaluate($methodName, '', \true);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use function count;
use function get_class;
use function sprintf;
use Exception;
use PHPUnit\Framework\Constraint\Constraint;
use PHPUnit\Framework\Constraint\IsAnything;
use PHPUnit\Framework\Constraint\IsEqual;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Parameters implements \PHPUnit\Framework\MockObject\Rule\ParametersRule
{
    /**
     * @var Constraint[]
     */
    private array $parameters = [];
    private ?\PHPUnit\Framework\MockObject\Invocation $invocation = null;
    /**
     * @var bool|ExpectationFailedException
     */
    private $parameterVerificationResult;
    /**
     * @throws \PHPUnit\Framework\Exception
     */
    public function __construct(array $parameters)
    {
        foreach ($parameters as $parameter) {
            if (!$parameter instanceof \PHPUnit\Framework\Constraint\Constraint) {
                $parameter = new \PHPUnit\Framework\Constraint\IsEqual($parameter);
            }
            $this->parameters[] = $parameter;
        }
    }
    public function toString() : string
    {
        $text = 'with parameter';
        foreach ($this->parameters as $index => $parameter) {
            if ($index > 0) {
                $text .= ' and';
            }
            $text .= ' ' . $index . ' ' . $parameter->toString();
        }
        return $text;
    }
    /**
     * @throws Exception
     */
    public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
        $this->invocation = $invocation;
        $this->parameterVerificationResult = null;
        try {
            $this->parameterVerificationResult = $this->doVerify();
        } catch (\PHPUnit\Framework\ExpectationFailedException $e) {
            $this->parameterVerificationResult = $e;
            throw $this->parameterVerificationResult;
        }
    }
    /**
     * Checks if the invocation $invocation matches the current rules. If it
     * does the rule will get the invoked() method called which should check
     * if an expectation is met.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    public function verify() : void
    {
        $this->doVerify();
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws ExpectationFailedException
     */
    private function doVerify() : bool
    {
        if (isset($this->parameterVerificationResult)) {
            return $this->guardAgainstDuplicateEvaluationOfParameterConstraints();
        }
        if ($this->invocation === null) {
            throw new \PHPUnit\Framework\ExpectationFailedException('Mocked method does not exist.');
        }
        if (\count($this->invocation->getParameters()) < \count($this->parameters)) {
            $message = 'Parameter count for invocation %s is too low.';
            // The user called `->with($this->anything())`, but may have meant
            // `->withAnyParameters()`.
            //
            // @see https://github.com/sebastianbergmann/phpunit-mock-objects/issues/199
            if (\count($this->parameters) === 1 && \get_class($this->parameters[0]) === \PHPUnit\Framework\Constraint\IsAnything::class) {
                $message .= "\nTo allow 0 or more parameters with any value, omit ->with() or use ->withAnyParameters() instead.";
            }
            throw new \PHPUnit\Framework\ExpectationFailedException(\sprintf($message, $this->invocation->toString()));
        }
        foreach ($this->parameters as $i => $parameter) {
            $parameter->evaluate($this->invocation->getParameters()[$i], \sprintf('Parameter %s for invocation %s does not match expected ' . 'value.', $i, $this->invocation->toString()));
        }
        return \true;
    }
    /**
     * @throws ExpectationFailedException
     */
    private function guardAgainstDuplicateEvaluationOfParameterConstraints() : bool
    {
        if ($this->parameterVerificationResult instanceof \PHPUnit\Framework\ExpectationFailedException) {
            throw $this->parameterVerificationResult;
        }
        return (bool) $this->parameterVerificationResult;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Rule;

use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\MockObject\Invocation as BaseInvocation;
use PHPUnit\Framework\MockObject\Verifiable;
use PHPUnit\Framework\SelfDescribing;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
interface ParametersRule extends \PHPUnit\Framework\SelfDescribing, \PHPUnit\Framework\MockObject\Verifiable
{
    /**
     * @throws ExpectationFailedException if the invocation violates the rule
     */
    public function apply(\PHPUnit\Framework\MockObject\Invocation $invocation) : void;
    public function verify() : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use PHPUnit\Framework\MockObject\Builder\InvocationStubber;
/**
 * @method InvocationStubber method($constraint)
 *
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
interface Stub
{
    public function __phpunit_getInvocationHandler() : \PHPUnit\Framework\MockObject\InvocationHandler;
    public function __phpunit_hasMatchers() : bool;
    public function __phpunit_setReturnValueGeneration(bool $returnValueGeneration) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use function array_shift;
use function sprintf;
use PHPUnit\Framework\MockObject\Invocation;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ConsecutiveCalls implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    private array $stack;
    /**
     * @var mixed
     */
    private $value;
    public function __construct(array $stack)
    {
        $this->stack = $stack;
    }
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        $this->value = \array_shift($this->stack);
        if ($this->value instanceof \PHPUnit\Framework\MockObject\Stub\Stub) {
            $this->value = $this->value->invoke($invocation);
        }
        return $this->value;
    }
    public function toString() : string
    {
        $exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
        return \sprintf('return user-specified value %s', $exporter->export($this->value));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use function sprintf;
use PHPUnit\Framework\MockObject\Invocation;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Exception implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    private \Throwable $exception;
    public function __construct(\Throwable $exception)
    {
        $this->exception = $exception;
    }
    /**
     * @throws Throwable
     */
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation) : void
    {
        throw $this->exception;
    }
    public function toString() : string
    {
        $exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
        return \sprintf('raise user-specified exception %s', $exporter->export($this->exception));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use function sprintf;
use PHPUnit\Framework\MockObject\Invocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReturnArgument implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    private int $argumentIndex;
    public function __construct($argumentIndex)
    {
        $this->argumentIndex = $argumentIndex;
    }
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        if (isset($invocation->getParameters()[$this->argumentIndex])) {
            return $invocation->getParameters()[$this->argumentIndex];
        }
    }
    public function toString() : string
    {
        return \sprintf('return argument #%d', $this->argumentIndex);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use function call_user_func_array;
use function get_class;
use function is_array;
use function is_object;
use function sprintf;
use PHPUnit\Framework\MockObject\Invocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReturnCallback implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    private $callback;
    public function __construct($callback)
    {
        $this->callback = $callback;
    }
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        return \call_user_func_array($this->callback, $invocation->getParameters());
    }
    public function toString() : string
    {
        if (\is_array($this->callback)) {
            if (\is_object($this->callback[0])) {
                $class = \get_class($this->callback[0]);
                $type = '->';
            } else {
                $class = $this->callback[0];
                $type = '::';
            }
            return \sprintf('return result of user defined callback %s%s%s() with the ' . 'passed arguments', $class, $type, $this->callback[1]);
        }
        return 'return result of user defined callback ' . $this->callback . ' with the passed arguments';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use function sprintf;
use PHPUnit\Framework\MockObject\Invocation;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReturnReference implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    /**
     * @var mixed
     */
    private $reference;
    public function __construct(&$reference)
    {
        $this->reference =& $reference;
    }
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        return $this->reference;
    }
    public function toString() : string
    {
        $exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
        return \sprintf('return user-specified reference %s', $exporter->export($this->reference));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use PHPUnit\Framework\MockObject\Invocation;
use PHPUnit\Framework\MockObject\RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReturnSelf implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    /**
     * @throws RuntimeException
     */
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        return $invocation->getObject();
    }
    public function toString() : string
    {
        return 'return the current object';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use function sprintf;
use PHPUnit\Framework\MockObject\Invocation;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReturnStub implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    /**
     * @var mixed
     */
    private $value;
    public function __construct($value)
    {
        $this->value = $value;
    }
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        return $this->value;
    }
    public function toString() : string
    {
        $exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
        return \sprintf('return user-specified value %s', $exporter->export($this->value));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use function array_pop;
use function count;
use function is_array;
use PHPUnit\Framework\MockObject\Invocation;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ReturnValueMap implements \PHPUnit\Framework\MockObject\Stub\Stub
{
    private array $valueMap;
    public function __construct(array $valueMap)
    {
        $this->valueMap = $valueMap;
    }
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation)
    {
        $parameterCount = \count($invocation->getParameters());
        foreach ($this->valueMap as $map) {
            if (!\is_array($map) || $parameterCount !== \count($map) - 1) {
                continue;
            }
            $return = \array_pop($map);
            if ($invocation->getParameters() === $map) {
                return $return;
            }
        }
    }
    public function toString() : string
    {
        return 'return value from a map';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject\Stub;

use PHPUnit\Framework\MockObject\Invocation;
use PHPUnit\Framework\SelfDescribing;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Stub extends \PHPUnit\Framework\SelfDescribing
{
    /**
     * Fakes the processing of the invocation $invocation by returning a
     * specific value.
     *
     * @param Invocation $invocation The invocation which was mocked and matched by the current method and argument matchers
     */
    public function invoke(\PHPUnit\Framework\MockObject\Invocation $invocation);
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use PHPUnit\SebastianBergmann\Template\Exception as TemplateException;
use PHPUnit\SebastianBergmann\Template\Template;
/**
 * @internal This trait is not covered by the backward compatibility promise for PHPUnit
 */
trait TemplateLoader
{
    /**
     * @var Template[]
     */
    private static array $templates = [];
    /**
     * @throws RuntimeException
     */
    private function loadTemplate(string $template) : \PHPUnit\SebastianBergmann\Template\Template
    {
        $filename = __DIR__ . \DIRECTORY_SEPARATOR . 'Generator' . \DIRECTORY_SEPARATOR . $template;
        if (!isset(self::$templates[$filename])) {
            try {
                self::$templates[$filename] = new \PHPUnit\SebastianBergmann\Template\Template($filename);
            } catch (\PHPUnit\SebastianBergmann\Template\Exception $e) {
                throw new \PHPUnit\Framework\MockObject\RuntimeException($e->getMessage(), (int) $e->getCode(), $e);
            }
        }
        return self::$templates[$filename];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\MockObject;

use PHPUnit\Framework\ExpectationFailedException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Verifiable
{
    /**
     * Verifies that the current expectation is valid. If everything is OK the
     * code should just return, if not it must throw an exception.
     *
     * @throws ExpectationFailedException
     */
    public function verify() : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Reorderable
{
    public function sortId() : string;
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function provides() : array;
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function requires() : array;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface SelfDescribing
{
    /**
     * Returns a string representation of the object.
     */
    public function toString() : string;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface SkippedTest extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SkippedTestCase extends \PHPUnit\Framework\TestCase
{
    /**
     * @var bool
     */
    protected $backupGlobals = \false;
    /**
     * @var bool
     */
    protected $backupStaticAttributes = \false;
    /**
     * @var bool
     */
    protected $runTestInSeparateProcess = \false;
    private string $message;
    public function __construct(string $className, string $methodName, string $message = '')
    {
        parent::__construct($className . '::' . $methodName);
        $this->message = $message;
    }
    public function getMessage() : string
    {
        return $this->message;
    }
    /**
     * Returns a string representation of the test case.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function toString() : string
    {
        return $this->getName();
    }
    /**
     * @throws Exception
     */
    protected function runTest() : void
    {
        $this->markTestSkipped($this->message);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use Countable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
interface Test extends \Countable
{
    public function run(\PHPUnit\Framework\TestResult $result) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function assert;
use function get_class;
use function sprintf;
use function trim;
use PHPUnit\Metadata\BackupGlobals;
use PHPUnit\Metadata\BackupStaticProperties;
use PHPUnit\Metadata\DataProviderFacade;
use PHPUnit\Metadata\GroupsFacade;
use PHPUnit\Metadata\PreserveGlobalState;
use PHPUnit\Metadata\Registry as MetadataRegistry;
use PHPUnit\Util\Filter;
use PHPUnit\Util\InvalidDataSetException;
use ReflectionClass;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestBuilder
{
    public function build(\ReflectionClass $theClass, string $methodName) : \PHPUnit\Framework\Test
    {
        $className = $theClass->getName();
        if (!$theClass->isInstantiable()) {
            return new \PHPUnit\Framework\ErrorTestCase(\sprintf('Cannot instantiate class "%s".', $className));
        }
        try {
            $data = (new \PHPUnit\Metadata\DataProviderFacade())->providedData($className, $methodName);
        } catch (\PHPUnit\Framework\IncompleteTestError $e) {
            $data = new \PHPUnit\Framework\IncompleteTestCase($className, $methodName, \sprintf("Test for %s::%s marked incomplete by data provider\n%s", $className, $methodName, $this->throwableToString($e)));
        } catch (\PHPUnit\Framework\SkippedTestError $e) {
            $data = new \PHPUnit\Framework\SkippedTestCase($className, $methodName, \sprintf("Test for %s::%s skipped by data provider\n%s", $className, $methodName, $this->throwableToString($e)));
        } catch (\Throwable $t) {
            $data = new \PHPUnit\Framework\ErrorTestCase(\sprintf("The data provider specified for %s::%s is invalid.\n%s", $className, $methodName, $this->throwableToString($t)));
        }
        if (isset($data)) {
            $test = $this->buildDataProviderTestSuite($methodName, $className, $data, $this->shouldTestMethodBeRunInSeparateProcess($className, $methodName), $this->shouldGlobalStateBePreserved($className, $methodName), $this->shouldAllTestMethodsOfTestClassBeRunInSingleSeparateProcess($className), $this->backupSettings($className, $methodName));
        } else {
            $test = new $className($methodName);
        }
        if ($test instanceof \PHPUnit\Framework\TestCase) {
            $this->configureTestCase($test, $this->shouldTestMethodBeRunInSeparateProcess($className, $methodName), $this->shouldGlobalStateBePreserved($className, $methodName), $this->shouldAllTestMethodsOfTestClassBeRunInSingleSeparateProcess($className), $this->backupSettings($className, $methodName));
        }
        return $test;
    }
    /**
     * @psalm-param class-string $className
     *
     * @param array|ErrorTestCase|IncompleteTestCase|SkippedTestCase $data
     */
    private function buildDataProviderTestSuite(string $methodName, string $className, $data, bool $runTestInSeparateProcess, ?bool $preserveGlobalState, bool $runClassInSeparateProcess, array $backupSettings) : \PHPUnit\Framework\DataProviderTestSuite
    {
        $dataProviderTestSuite = new \PHPUnit\Framework\DataProviderTestSuite($className . '::' . $methodName);
        $groups = (new \PHPUnit\Metadata\GroupsFacade())->groups($className, $methodName);
        if ($data instanceof \PHPUnit\Framework\ErrorTestCase || $data instanceof \PHPUnit\Framework\SkippedTestCase || $data instanceof \PHPUnit\Framework\IncompleteTestCase) {
            $dataProviderTestSuite->addTest($data, $groups);
        } else {
            foreach ($data as $_dataName => $_data) {
                $_test = new $className($methodName);
                \assert($_test instanceof \PHPUnit\Framework\TestCase);
                $_test->setData($_dataName, $_data);
                $this->configureTestCase($_test, $runTestInSeparateProcess, $preserveGlobalState, $runClassInSeparateProcess, $backupSettings);
                $dataProviderTestSuite->addTest($_test, $groups);
            }
        }
        return $dataProviderTestSuite;
    }
    private function configureTestCase(\PHPUnit\Framework\TestCase $test, bool $runTestInSeparateProcess, ?bool $preserveGlobalState, bool $runClassInSeparateProcess, array $backupSettings) : void
    {
        if ($runTestInSeparateProcess) {
            $test->setRunTestInSeparateProcess(\true);
            if ($preserveGlobalState !== null) {
                $test->setPreserveGlobalState($preserveGlobalState);
            }
        }
        if ($runClassInSeparateProcess) {
            $test->setRunClassInSeparateProcess(\true);
            if ($preserveGlobalState !== null) {
                $test->setPreserveGlobalState($preserveGlobalState);
            }
        }
        if ($backupSettings['backupGlobals'] !== null) {
            $test->setBackupGlobals($backupSettings['backupGlobals']);
        }
        if ($backupSettings['backupStaticProperties'] !== null) {
            $test->setBackupStaticAttributes($backupSettings['backupStaticProperties']);
        }
    }
    private function throwableToString(\Throwable $t) : string
    {
        $message = $t->getMessage();
        if (empty(\trim($message))) {
            $message = '<no message>';
        }
        if ($t instanceof \PHPUnit\Util\InvalidDataSetException) {
            return \sprintf("%s\n%s", $message, \PHPUnit\Util\Filter::getFilteredStacktrace($t));
        }
        return \sprintf("%s: %s\n%s", \get_class($t), $message, \PHPUnit\Util\Filter::getFilteredStacktrace($t));
    }
    /**
     * @psalm-param class-string $className
     *
     * @psalm-return array{backupGlobals: ?bool, backupStaticProperties: ?bool}
     */
    private function backupSettings(string $className, string $methodName) : array
    {
        $metadataForClass = \PHPUnit\Metadata\Registry::parser()->forClass($className);
        $metadataForMethod = \PHPUnit\Metadata\Registry::parser()->forMethod($className, $methodName);
        $backupGlobals = null;
        if ($metadataForMethod->isBackupGlobals()->isNotEmpty()) {
            $metadata = $metadataForMethod->isBackupGlobals()->asArray()[0];
            \assert($metadata instanceof \PHPUnit\Metadata\BackupGlobals);
            if ($metadata->enabled() !== null) {
                $backupGlobals = $metadata->enabled();
            }
        } elseif ($metadataForClass->isBackupGlobals()->isNotEmpty()) {
            $metadata = $metadataForClass->isBackupGlobals()->asArray()[0];
            \assert($metadata instanceof \PHPUnit\Metadata\BackupGlobals);
            if ($metadata->enabled() !== null) {
                $backupGlobals = $metadata->enabled();
            }
        }
        $backupStaticProperties = null;
        if ($metadataForMethod->isBackupStaticProperties()->isNotEmpty()) {
            $metadata = $metadataForMethod->isBackupStaticProperties()->asArray()[0];
            \assert($metadata instanceof \PHPUnit\Metadata\BackupStaticProperties);
            if ($metadata->enabled() !== null) {
                $backupStaticProperties = $metadata->enabled();
            }
        } elseif ($metadataForClass->isBackupStaticProperties()->isNotEmpty()) {
            $metadata = $metadataForMethod->isBackupStaticProperties()->asArray()[0];
            \assert($metadata instanceof \PHPUnit\Metadata\BackupStaticProperties);
            if ($metadata->enabled() !== null) {
                $backupStaticProperties = $metadata->enabled();
            }
        }
        return ['backupGlobals' => $backupGlobals, 'backupStaticProperties' => $backupStaticProperties];
    }
    /**
     * @psalm-param class-string $className
     */
    private function shouldGlobalStateBePreserved(string $className, string $methodName) : ?bool
    {
        $metadataForMethod = \PHPUnit\Metadata\Registry::parser()->forMethod($className, $methodName);
        if ($metadataForMethod->isPreserveGlobalState()->isNotEmpty()) {
            $metadata = $metadataForMethod->isPreserveGlobalState()->asArray()[0];
            \assert($metadata instanceof \PHPUnit\Metadata\PreserveGlobalState);
            return $metadata->enabled();
        }
        $metadataForClass = \PHPUnit\Metadata\Registry::parser()->forClass($className);
        if ($metadataForClass->isPreserveGlobalState()->isNotEmpty()) {
            $metadata = $metadataForClass->isPreserveGlobalState()->asArray()[0];
            \assert($metadata instanceof \PHPUnit\Metadata\PreserveGlobalState);
            return $metadata->enabled();
        }
        return null;
    }
    /**
     * @psalm-param class-string $className
     */
    private function shouldTestMethodBeRunInSeparateProcess(string $className, string $methodName) : bool
    {
        if (\PHPUnit\Metadata\Registry::parser()->forClass($className)->isRunTestsInSeparateProcesses()->isNotEmpty()) {
            return \true;
        }
        if (\PHPUnit\Metadata\Registry::parser()->forMethod($className, $methodName)->isRunInSeparateProcess()->isNotEmpty()) {
            return \true;
        }
        return \false;
    }
    /**
     * @psalm-param class-string $className
     */
    private function shouldAllTestMethodsOfTestClassBeRunInSingleSeparateProcess(string $className) : bool
    {
        return \PHPUnit\Metadata\Registry::parser()->forClass($className)->isRunClassInSeparateProcess()->isNotEmpty();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const LC_ALL;
use const LC_COLLATE;
use const LC_CTYPE;
use const LC_MONETARY;
use const LC_NUMERIC;
use const LC_TIME;
use const PATHINFO_FILENAME;
use const PHP_EOL;
use const PHP_URL_PATH;
use function array_flip;
use function array_keys;
use function array_merge;
use function array_search;
use function array_unique;
use function array_values;
use function basename;
use function call_user_func;
use function chdir;
use function class_exists;
use function clearstatcache;
use function count;
use function defined;
use function explode;
use function get_class;
use function getcwd;
use function implode;
use function in_array;
use function ini_set;
use function is_array;
use function is_callable;
use function is_int;
use function is_object;
use function is_string;
use function libxml_clear_errors;
use function method_exists;
use function ob_end_clean;
use function ob_get_contents;
use function ob_get_level;
use function ob_start;
use function parse_url;
use function pathinfo;
use function preg_replace;
use function setlocale;
use function sprintf;
use function strpos;
use function substr;
use PHPUnit\DeepCopy\DeepCopy;
use PHPUnit\Framework\Constraint\Exception as ExceptionConstraint;
use PHPUnit\Framework\Constraint\ExceptionCode;
use PHPUnit\Framework\Constraint\ExceptionMessage;
use PHPUnit\Framework\Constraint\ExceptionMessageRegularExpression;
use PHPUnit\Framework\Constraint\LogicalOr;
use PHPUnit\Framework\MockObject\Generator as MockGenerator;
use PHPUnit\Framework\MockObject\MockBuilder;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\MockObject\Rule\AnyInvokedCount as AnyInvokedCountMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount as InvokedAtLeastCountMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce as InvokedAtLeastOnceMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount as InvokedAtMostCountMatcher;
use PHPUnit\Framework\MockObject\Rule\InvokedCount as InvokedCountMatcher;
use PHPUnit\Framework\MockObject\Stub;
use PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls as ConsecutiveCallsStub;
use PHPUnit\Framework\MockObject\Stub\Exception as ExceptionStub;
use PHPUnit\Framework\MockObject\Stub\ReturnArgument as ReturnArgumentStub;
use PHPUnit\Framework\MockObject\Stub\ReturnCallback as ReturnCallbackStub;
use PHPUnit\Framework\MockObject\Stub\ReturnSelf as ReturnSelfStub;
use PHPUnit\Framework\MockObject\Stub\ReturnStub;
use PHPUnit\Framework\MockObject\Stub\ReturnValueMap as ReturnValueMapStub;
use PHPUnit\Framework\TestSize\TestSize;
use PHPUnit\Framework\TestStatus\TestStatus;
use PHPUnit\Metadata\GroupsFacade;
use PHPUnit\Metadata\HookFacade;
use PHPUnit\Metadata\Registry as MetadataRegistry;
use PHPUnit\Metadata\RequirementsFacade;
use PHPUnit\Runner\PhptTestCase;
use PHPUnit\Util\Error\Deprecation;
use PHPUnit\Util\Error\Error;
use PHPUnit\Util\Error\Notice;
use PHPUnit\Util\Error\Warning as WarningError;
use PHPUnit\Util\Exception as UtilException;
use PHPUnit\Util\Test as TestUtil;
use PHPUnit\Util\Type;
use ReflectionClass;
use ReflectionException;
use PHPUnit\SebastianBergmann\Comparator\Comparator;
use PHPUnit\SebastianBergmann\Comparator\Factory as ComparatorFactory;
use PHPUnit\SebastianBergmann\Diff\Differ;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
use PHPUnit\SebastianBergmann\GlobalState\ExcludeList as GlobalStateExcludeList;
use PHPUnit\SebastianBergmann\GlobalState\Restorer;
use PHPUnit\SebastianBergmann\GlobalState\Snapshot;
use PHPUnit\SebastianBergmann\ObjectEnumerator\Enumerator;
use SoapClient;
use Throwable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
abstract class TestCase extends \PHPUnit\Framework\Assert implements \PHPUnit\Framework\Reorderable, \PHPUnit\Framework\SelfDescribing, \PHPUnit\Framework\Test
{
    private const LOCALE_CATEGORIES = [\LC_ALL, \LC_COLLATE, \LC_CTYPE, \LC_MONETARY, \LC_NUMERIC, \LC_TIME];
    /**
     * @var ?bool
     */
    protected $backupGlobals;
    /**
     * @var string[]
     */
    protected $backupGlobalsExcludeList = [];
    /**
     * @var bool
     */
    protected $backupStaticAttributes;
    /**
     * @var array<string,array<int,string>>
     */
    protected $backupStaticAttributesExcludeList = [];
    /**
     * @var bool
     */
    protected $runTestInSeparateProcess;
    /**
     * @var bool
     */
    protected $preserveGlobalState = \true;
    /**
     * @var list<ExecutionOrderDependency>
     */
    protected array $providedTests = [];
    private ?bool $runClassInSeparateProcess = null;
    private bool $inIsolation = \false;
    private array $data = [];
    /**
     * @var int|string
     */
    private $dataName = '';
    private ?string $expectedException = null;
    private ?string $expectedExceptionMessage = null;
    private ?string $expectedExceptionMessageRegExp = null;
    /**
     * @var null|int|string
     */
    private $expectedExceptionCode;
    private string $name;
    /**
     * @var list<ExecutionOrderDependency>
     */
    private array $dependencies = [];
    private array $dependencyInput = [];
    /**
     * @var array<string,string>
     */
    private array $iniSettings = [];
    private array $locale = [];
    /**
     * @var MockObject[]
     */
    private array $mockObjects = [];
    private ?\PHPUnit\Framework\MockObject\Generator $mockObjectGenerator = null;
    private ?\PHPUnit\Framework\TestStatus\TestStatus $status = null;
    private int $numberOfAssertionsPerformed = 0;
    private ?\PHPUnit\Framework\TestResult $result = null;
    /**
     * @var mixed
     */
    private $testResult;
    private string $output = '';
    private ?string $outputExpectedRegex = null;
    private ?string $outputExpectedString = null;
    /**
     * @var mixed
     */
    private $outputCallback = \false;
    private bool $outputBufferingActive = \false;
    private int $outputBufferingLevel;
    private bool $outputRetrievedForAssertion = \false;
    private ?\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot = null;
    private ?bool $beStrictAboutChangesToGlobalState = \false;
    private bool $registerMockObjectsFromTestArgumentsRecursively = \false;
    /**
     * @var string[]
     */
    private array $warnings = [];
    /**
     * @var string[]
     */
    private array $groups = [];
    private bool $doesNotPerformAssertions = \false;
    /**
     * @var Comparator[]
     */
    private array $customComparators = [];
    /**
     * @var string[]
     */
    private array $doubledTypes = [];
    /**
     * Returns a matcher that matches when the method is executed
     * zero or more times.
     */
    public static function any() : \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\AnyInvokedCount();
    }
    /**
     * Returns a matcher that matches when the method is never executed.
     */
    public static function never() : \PHPUnit\Framework\MockObject\Rule\InvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedCount(0);
    }
    /**
     * Returns a matcher that matches when the method is executed
     * at least N times.
     */
    public static function atLeast(int $requiredInvocations) : \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastCount($requiredInvocations);
    }
    /**
     * Returns a matcher that matches when the method is executed at least once.
     */
    public static function atLeastOnce() : \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedAtLeastOnce();
    }
    /**
     * Returns a matcher that matches when the method is executed exactly once.
     */
    public static function once() : \PHPUnit\Framework\MockObject\Rule\InvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedCount(1);
    }
    /**
     * Returns a matcher that matches when the method is executed
     * exactly $count times.
     */
    public static function exactly(int $count) : \PHPUnit\Framework\MockObject\Rule\InvokedCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedCount($count);
    }
    /**
     * Returns a matcher that matches when the method is executed
     * at most N times.
     */
    public static function atMost(int $allowedInvocations) : \PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount
    {
        return new \PHPUnit\Framework\MockObject\Rule\InvokedAtMostCount($allowedInvocations);
    }
    public static function returnValue($value) : \PHPUnit\Framework\MockObject\Stub\ReturnStub
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnStub($value);
    }
    public static function returnValueMap(array $valueMap) : \PHPUnit\Framework\MockObject\Stub\ReturnValueMap
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnValueMap($valueMap);
    }
    public static function returnArgument(int $argumentIndex) : \PHPUnit\Framework\MockObject\Stub\ReturnArgument
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnArgument($argumentIndex);
    }
    public static function returnCallback($callback) : \PHPUnit\Framework\MockObject\Stub\ReturnCallback
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnCallback($callback);
    }
    /**
     * Returns the current object.
     *
     * This method is useful when mocking a fluent interface.
     */
    public static function returnSelf() : \PHPUnit\Framework\MockObject\Stub\ReturnSelf
    {
        return new \PHPUnit\Framework\MockObject\Stub\ReturnSelf();
    }
    public static function throwException(\Throwable $exception) : \PHPUnit\Framework\MockObject\Stub\Exception
    {
        return new \PHPUnit\Framework\MockObject\Stub\Exception($exception);
    }
    public static function onConsecutiveCalls(...$args) : \PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls
    {
        return new \PHPUnit\Framework\MockObject\Stub\ConsecutiveCalls($args);
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function __construct(string $name)
    {
        $this->setName($name);
    }
    /**
     * This method is called before the first test of this test class is run.
     */
    public static function setUpBeforeClass() : void
    {
    }
    /**
     * This method is called after the last test of this test class is run.
     */
    public static function tearDownAfterClass() : void
    {
    }
    /**
     * This method is called before each test.
     */
    protected function setUp() : void
    {
    }
    /**
     * This method is called after each test.
     */
    protected function tearDown() : void
    {
    }
    /**
     * Returns a string representation of the test case.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     */
    public function toString() : string
    {
        $buffer = \sprintf('%s::%s', (new \ReflectionClass($this))->getName(), $this->getName(\false));
        return $buffer . $this->getDataSetAsStringWithData();
    }
    public function count() : int
    {
        return 1;
    }
    public function getActualOutputForAssertion() : string
    {
        $this->outputRetrievedForAssertion = \true;
        return $this->output();
    }
    public function expectOutputRegex(string $expectedRegex) : void
    {
        $this->outputExpectedRegex = $expectedRegex;
    }
    public function expectOutputString(string $expectedString) : void
    {
        $this->outputExpectedString = $expectedString;
    }
    /**
     * @psalm-param class-string<\Throwable> $exception
     */
    public function expectException(string $exception) : void
    {
        $this->expectedException = $exception;
    }
    /**
     * @param int|string $code
     */
    public function expectExceptionCode($code) : void
    {
        $this->expectedExceptionCode = $code;
    }
    public function expectExceptionMessage(string $message) : void
    {
        $this->expectedExceptionMessage = $message;
    }
    public function expectExceptionMessageMatches(string $regularExpression) : void
    {
        $this->expectedExceptionMessageRegExp = $regularExpression;
    }
    /**
     * Sets up an expectation for an exception to be raised by the code under test.
     * Information for expected exception class, expected exception message, and
     * expected exception code are retrieved from a given Exception object.
     */
    public function expectExceptionObject(\Exception $exception) : void
    {
        $this->expectException(\get_class($exception));
        $this->expectExceptionMessage($exception->getMessage());
        $this->expectExceptionCode($exception->getCode());
    }
    public function expectNotToPerformAssertions() : void
    {
        $this->doesNotPerformAssertions = \true;
    }
    public function expectDeprecation() : void
    {
        $this->expectedException = \PHPUnit\Util\Error\Deprecation::class;
    }
    public function expectDeprecationMessage(string $message) : void
    {
        $this->expectExceptionMessage($message);
    }
    public function expectDeprecationMessageMatches(string $regularExpression) : void
    {
        $this->expectExceptionMessageMatches($regularExpression);
    }
    public function expectNotice() : void
    {
        $this->expectedException = \PHPUnit\Util\Error\Notice::class;
    }
    public function expectNoticeMessage(string $message) : void
    {
        $this->expectExceptionMessage($message);
    }
    public function expectNoticeMessageMatches(string $regularExpression) : void
    {
        $this->expectExceptionMessageMatches($regularExpression);
    }
    public function expectWarning() : void
    {
        $this->expectedException = \PHPUnit\Util\Error\Warning::class;
    }
    public function expectWarningMessage(string $message) : void
    {
        $this->expectExceptionMessage($message);
    }
    public function expectWarningMessageMatches(string $regularExpression) : void
    {
        $this->expectExceptionMessageMatches($regularExpression);
    }
    public function expectError() : void
    {
        $this->expectedException = \PHPUnit\Util\Error\Error::class;
    }
    public function expectErrorMessage(string $message) : void
    {
        $this->expectExceptionMessage($message);
    }
    public function expectErrorMessageMatches(string $regularExpression) : void
    {
        $this->expectExceptionMessageMatches($regularExpression);
    }
    public function status() : \PHPUnit\Framework\TestStatus\TestStatus
    {
        if ($this->status === null) {
            return \PHPUnit\Framework\TestStatus\TestStatus::unknown();
        }
        return $this->status;
    }
    public function markAsRisky() : void
    {
        $this->status = \PHPUnit\Framework\TestStatus\TestStatus::risky();
    }
    public function hasFailed() : bool
    {
        $status = $this->status();
        return $status->isFailure() || $status->isError();
    }
    /**
     * Runs the test case and collects the results in a TestResult object.
     *
     * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
     * @throws \SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws CodeCoverageException
     * @throws UtilException
     */
    public function run(\PHPUnit\Framework\TestResult $result) : void
    {
        if (!$this instanceof \PHPUnit\Framework\ErrorTestCase && !$this instanceof \PHPUnit\Framework\WarningTestCase) {
            $this->result = $result;
        }
        if (!$this instanceof \PHPUnit\Framework\ErrorTestCase && !$this instanceof \PHPUnit\Framework\WarningTestCase && !$this instanceof \PHPUnit\Framework\SkippedTestCase && !$this->handleDependencies()) {
            return;
        }
        if (!$this->shouldRunInSeparateProcess()) {
            (new \PHPUnit\Framework\TestRunner())->run($this, $result);
        } else {
            (new \PHPUnit\Framework\TestRunner())->runInSeparateProcess($this, $result, $this->runClassInSeparateProcess && !$this->runTestInSeparateProcess, $this->preserveGlobalState);
        }
        $this->result = null;
    }
    /**
     * Returns a builder object to create mock objects using a fluent interface.
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $className
     * @psalm-return MockBuilder<RealInstanceType>
     */
    public function getMockBuilder(string $className) : \PHPUnit\Framework\MockObject\MockBuilder
    {
        $this->recordDoubledType($className);
        return new \PHPUnit\Framework\MockObject\MockBuilder($this, $className);
    }
    public function registerComparator(\PHPUnit\SebastianBergmann\Comparator\Comparator $comparator) : void
    {
        \PHPUnit\SebastianBergmann\Comparator\Factory::getInstance()->register($comparator);
        $this->customComparators[] = $comparator;
    }
    /**
     * @return string[]
     *
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function doubledTypes() : array
    {
        return \array_unique($this->doubledTypes);
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function groups() : array
    {
        return $this->groups;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setGroups(array $groups) : void
    {
        $this->groups = $groups;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function getName(bool $withDataSet = \true) : string
    {
        if ($withDataSet) {
            return $this->name . $this->getDataSetAsString();
        }
        return $this->name;
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     *
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function size() : \PHPUnit\Framework\TestSize\TestSize
    {
        return (new \PHPUnit\Metadata\GroupsFacade())->size(static::class, $this->getName(\false));
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function hasOutput() : bool
    {
        if ($this->output === '') {
            return \false;
        }
        if ($this->hasExpectationOnOutput()) {
            return \false;
        }
        return \true;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function output() : string
    {
        if (!$this->outputBufferingActive) {
            return $this->output;
        }
        return (string) \ob_get_contents();
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function doesNotPerformAssertions() : bool
    {
        return $this->doesNotPerformAssertions;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function hasExpectationOnOutput() : bool
    {
        return \is_string($this->outputExpectedString) || \is_string($this->outputExpectedRegex) || $this->outputRetrievedForAssertion;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function registerMockObjectsFromTestArgumentsRecursively() : void
    {
        $this->registerMockObjectsFromTestArgumentsRecursively = \true;
    }
    /**
     * @throws Throwable
     *
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function runBare() : void
    {
        $this->numberOfAssertionsPerformed = 0;
        $this->snapshotGlobalState();
        $this->startOutputBuffering();
        \clearstatcache();
        $currentWorkingDirectory = \getcwd();
        $hookMethods = (new \PHPUnit\Metadata\HookFacade())->hookMethods(static::class);
        $hasMetRequirements = \false;
        try {
            $this->checkRequirements();
            $hasMetRequirements = \true;
            if ($this->inIsolation) {
                foreach ($hookMethods['beforeClass'] as $method) {
                    $this->{$method}();
                }
            }
            if (\method_exists(static::class, $this->name) && \PHPUnit\Metadata\Registry::parser()->forMethod(static::class, $this->name)->isDoesNotPerformAssertions()->isNotEmpty()) {
                $this->doesNotPerformAssertions = \true;
            }
            foreach ($hookMethods['before'] as $method) {
                $this->{$method}();
            }
            foreach ($hookMethods['preCondition'] as $method) {
                $this->{$method}();
            }
            $this->testResult = $this->runTest();
            $this->verifyMockObjects();
            foreach ($hookMethods['postCondition'] as $method) {
                $this->{$method}();
            }
            if (!empty($this->warnings)) {
                throw new \PHPUnit\Framework\Warning(\implode("\n", \array_unique($this->warnings)));
            }
            $this->status = \PHPUnit\Framework\TestStatus\TestStatus::success();
        } catch (\PHPUnit\Framework\IncompleteTest $e) {
            $this->status = \PHPUnit\Framework\TestStatus\TestStatus::incomplete($e->getMessage());
        } catch (\PHPUnit\Framework\SkippedTest $e) {
            $this->status = \PHPUnit\Framework\TestStatus\TestStatus::skipped($e->getMessage());
        } catch (\PHPUnit\Framework\Warning $e) {
            $this->status = \PHPUnit\Framework\TestStatus\TestStatus::warning($e->getMessage());
        } catch (\PHPUnit\Framework\AssertionFailedError $e) {
            $this->status = \PHPUnit\Framework\TestStatus\TestStatus::failure($e->getMessage());
        } catch (\Throwable $_e) {
            $e = $_e;
            $this->status = \PHPUnit\Framework\TestStatus\TestStatus::error($_e->getMessage());
        }
        $this->mockObjects = [];
        // Tear down the fixture. An exception raised in tearDown() will be
        // caught and passed on when no exception was raised before.
        try {
            if ($hasMetRequirements) {
                foreach ($hookMethods['after'] as $method) {
                    $this->{$method}();
                }
                if ($this->inIsolation) {
                    foreach ($hookMethods['afterClass'] as $method) {
                        $this->{$method}();
                    }
                }
            }
        } catch (\Throwable $_e) {
            $e = $e ?? $_e;
        }
        try {
            $this->stopOutputBuffering();
        } catch (\PHPUnit\Framework\RiskyTestError $_e) {
            $e = $e ?? $_e;
        }
        if (isset($_e)) {
            $this->status = \PHPUnit\Framework\TestStatus\TestStatus::error($_e->getMessage());
        }
        \clearstatcache();
        if ($currentWorkingDirectory !== \getcwd()) {
            \chdir($currentWorkingDirectory);
        }
        $this->restoreGlobalState();
        $this->unregisterCustomComparators();
        $this->cleanupIniSettings();
        $this->cleanupLocaleSettings();
        \libxml_clear_errors();
        // Perform assertion on output.
        if (!isset($e)) {
            try {
                if ($this->outputExpectedRegex !== null) {
                    $this->assertMatchesRegularExpression($this->outputExpectedRegex, $this->output);
                } elseif ($this->outputExpectedString !== null) {
                    $this->assertEquals($this->outputExpectedString, $this->output);
                }
            } catch (\Throwable $_e) {
                $e = $_e;
            }
        }
        if (isset($e)) {
            $this->onNotSuccessfulTest($e);
        }
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setName(string $name) : void
    {
        $this->name = $name;
        if (\is_callable($this->sortId(), \true)) {
            $this->providedTests = [new \PHPUnit\Framework\ExecutionOrderDependency($this->sortId())];
        }
    }
    /**
     * @param list<ExecutionOrderDependency> $dependencies
     *
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setDependencies(array $dependencies) : void
    {
        $this->dependencies = $dependencies;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setDependencyInput(array $dependencyInput) : void
    {
        $this->dependencyInput = $dependencyInput;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function dependencyInput() : array
    {
        return $this->dependencyInput;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setBeStrictAboutChangesToGlobalState(?bool $beStrictAboutChangesToGlobalState) : void
    {
        $this->beStrictAboutChangesToGlobalState = $beStrictAboutChangesToGlobalState;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setBackupGlobals(?bool $backupGlobals) : void
    {
        if ($this->backupGlobals === null && $backupGlobals !== null) {
            $this->backupGlobals = $backupGlobals;
        }
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setBackupStaticAttributes(?bool $backupStaticAttributes) : void
    {
        if ($this->backupStaticAttributes === null && $backupStaticAttributes !== null) {
            $this->backupStaticAttributes = $backupStaticAttributes;
        }
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setRunTestInSeparateProcess(bool $runTestInSeparateProcess) : void
    {
        if ($this->runTestInSeparateProcess === null) {
            $this->runTestInSeparateProcess = $runTestInSeparateProcess;
        }
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setRunClassInSeparateProcess(bool $runClassInSeparateProcess) : void
    {
        if ($this->runClassInSeparateProcess === null) {
            $this->runClassInSeparateProcess = $runClassInSeparateProcess;
        }
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setPreserveGlobalState(bool $preserveGlobalState) : void
    {
        $this->preserveGlobalState = $preserveGlobalState;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setInIsolation(bool $inIsolation) : void
    {
        $this->inIsolation = $inIsolation;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function isInIsolation() : bool
    {
        return $this->inIsolation;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function result()
    {
        return $this->testResult;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setResult($result) : void
    {
        $this->testResult = $result;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setOutputCallback(callable $callback) : void
    {
        $this->outputCallback = $callback;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function registerMockObject(\PHPUnit\Framework\MockObject\MockObject $mockObject) : void
    {
        $this->mockObjects[] = $mockObject;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function addToAssertionCount(int $count) : void
    {
        $this->numberOfAssertionsPerformed += $count;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function numberOfAssertionsPerformed() : int
    {
        return $this->numberOfAssertionsPerformed;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function usesDataProvider() : bool
    {
        return !empty($this->data);
    }
    /**
     * @return int|string
     *
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function dataName()
    {
        return $this->dataName;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function getDataSetAsString() : string
    {
        $buffer = '';
        if (!empty($this->data)) {
            if (\is_int($this->dataName)) {
                $buffer .= \sprintf(' with data set #%d', $this->dataName);
            } else {
                $buffer .= \sprintf(' with data set "%s"', $this->dataName);
            }
        }
        return $buffer;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function getDataSetAsStringWithData() : string
    {
        if (empty($this->data)) {
            return '';
        }
        return $this->getDataSetAsString() . \sprintf(' (%s)', (new \PHPUnit\SebastianBergmann\Exporter\Exporter())->shortenedRecursiveExport($this->data));
    }
    /**
     * Gets the data set of a TestCase.
     *
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function getProvidedData() : array
    {
        return $this->data;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function addWarning(string $warning) : void
    {
        $this->warnings[] = $warning;
    }
    /**
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function sortId() : string
    {
        $id = $this->name;
        if (\strpos($id, '::') === \false) {
            $id = static::class . '::' . $id;
        }
        if ($this->usesDataProvider()) {
            $id .= $this->getDataSetAsString();
        }
        return $id;
    }
    /**
     * Returns the normalized test name as class::method.
     *
     * @return list<ExecutionOrderDependency>
     */
    public function provides() : array
    {
        return $this->providedTests;
    }
    /**
     * Returns a list of normalized dependency names, class::method.
     *
     * This list can differ from the raw dependencies as the resolver has
     * no need for the [!][shallow]clone prefix that is filtered out
     * during normalization.
     *
     * @return list<ExecutionOrderDependency>
     */
    public function requires() : array
    {
        return $this->dependencies;
    }
    /**
     * @param int|string $dataName
     *
     * @internal This method is not covered by the backward compatibility promise for PHPUnit
     */
    public function setData($dataName, array $data) : void
    {
        $this->dataName = $dataName;
        $this->data = $data;
    }
    /**
     * Override to run the test and assert its state.
     *
     * @throws \SebastianBergmann\ObjectEnumerator\InvalidArgumentException
     * @throws AssertionFailedError
     * @throws Exception
     * @throws ExpectationFailedException
     * @throws Throwable
     */
    protected function runTest()
    {
        $testArguments = \array_merge($this->data, $this->dependencyInput);
        $this->registerMockObjectsFromTestArguments($testArguments);
        try {
            $testResult = $this->{$this->name}(...\array_values($testArguments));
        } catch (\Throwable $exception) {
            if (!$this->checkExceptionExpectations($exception)) {
                throw $exception;
            }
            if ($this->expectedException !== null) {
                if ($this->expectedException === \PHPUnit\Util\Error\Error::class) {
                    $this->assertThat($exception, \PHPUnit\Framework\Constraint\LogicalOr::fromConstraints(new \PHPUnit\Framework\Constraint\Exception(\PHPUnit\Util\Error\Error::class), new \PHPUnit\Framework\Constraint\Exception(\Error::class)));
                } else {
                    $this->assertThat($exception, new \PHPUnit\Framework\Constraint\Exception($this->expectedException));
                }
            }
            if ($this->expectedExceptionMessage !== null) {
                $this->assertThat($exception, new \PHPUnit\Framework\Constraint\ExceptionMessage($this->expectedExceptionMessage));
            }
            if ($this->expectedExceptionMessageRegExp !== null) {
                $this->assertThat($exception, new \PHPUnit\Framework\Constraint\ExceptionMessageRegularExpression($this->expectedExceptionMessageRegExp));
            }
            if ($this->expectedExceptionCode !== null) {
                $this->assertThat($exception, new \PHPUnit\Framework\Constraint\ExceptionCode($this->expectedExceptionCode));
            }
            return;
        }
        if ($this->expectedException !== null) {
            $this->assertThat(null, new \PHPUnit\Framework\Constraint\Exception($this->expectedException));
        } elseif ($this->expectedExceptionMessage !== null) {
            $this->numberOfAssertionsPerformed++;
            throw new \PHPUnit\Framework\AssertionFailedError(\sprintf('Failed asserting that exception with message "%s" is thrown', $this->expectedExceptionMessage));
        } elseif ($this->expectedExceptionMessageRegExp !== null) {
            $this->numberOfAssertionsPerformed++;
            throw new \PHPUnit\Framework\AssertionFailedError(\sprintf('Failed asserting that exception with message matching "%s" is thrown', $this->expectedExceptionMessageRegExp));
        } elseif ($this->expectedExceptionCode !== null) {
            $this->numberOfAssertionsPerformed++;
            throw new \PHPUnit\Framework\AssertionFailedError(\sprintf('Failed asserting that exception with code "%s" is thrown', $this->expectedExceptionCode));
        }
        return $testResult;
    }
    /**
     * This method is a wrapper for the ini_set() function that automatically
     * resets the modified php.ini setting to its original value after the
     * test is run.
     *
     * @throws Exception
     */
    protected function iniSet(string $varName, string $newValue) : void
    {
        $currentValue = \ini_set($varName, $newValue);
        if ($currentValue !== \false) {
            $this->iniSettings[$varName] = $currentValue;
        } else {
            throw new \PHPUnit\Framework\Exception(\sprintf('INI setting "%s" could not be set to "%s".', $varName, $newValue));
        }
    }
    /**
     * This method is a wrapper for the setlocale() function that automatically
     * resets the locale to its original value after the test is run.
     *
     * @throws Exception
     */
    protected function setLocale(...$args) : void
    {
        if (\count($args) < 2) {
            throw new \PHPUnit\Framework\Exception();
        }
        [$category, $locale] = $args;
        if (!\in_array($category, self::LOCALE_CATEGORIES, \true)) {
            throw new \PHPUnit\Framework\Exception();
        }
        if (!\is_array($locale) && !\is_string($locale)) {
            throw new \PHPUnit\Framework\Exception();
        }
        $this->locale[$category] = \setlocale($category, 0);
        $result = \setlocale(...$args);
        if ($result === \false) {
            throw new \PHPUnit\Framework\Exception('The locale functionality is not implemented on your platform, ' . 'the specified locale does not exist or the category name is ' . 'invalid.');
        }
    }
    /**
     * Makes configurable stub for the specified class.
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param    class-string<RealInstanceType> $originalClassName
     * @psalm-return   Stub&RealInstanceType
     */
    protected function createStub(string $originalClassName) : \PHPUnit\Framework\MockObject\Stub
    {
        return $this->createMockObject($originalClassName);
    }
    /**
     * Returns a mock object for the specified class.
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $originalClassName
     * @psalm-return MockObject&RealInstanceType
     */
    protected function createMock(string $originalClassName) : \PHPUnit\Framework\MockObject\MockObject
    {
        return $this->createMockObject($originalClassName);
    }
    /**
     * Returns a configured mock object for the specified class.
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $originalClassName
     * @psalm-return MockObject&RealInstanceType
     */
    protected function createConfiguredMock(string $originalClassName, array $configuration) : \PHPUnit\Framework\MockObject\MockObject
    {
        $o = $this->createMockObject($originalClassName);
        foreach ($configuration as $method => $return) {
            $o->method($method)->willReturn($return);
        }
        return $o;
    }
    /**
     * Returns a partial mock object for the specified class.
     *
     * @param string[] $methods
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $originalClassName
     * @psalm-return MockObject&RealInstanceType
     */
    protected function createPartialMock(string $originalClassName, array $methods) : \PHPUnit\Framework\MockObject\MockObject
    {
        return $this->getMockBuilder($originalClassName)->disableOriginalConstructor()->disableOriginalClone()->disableArgumentCloning()->disallowMockingUnknownTypes()->onlyMethods($methods)->getMock();
    }
    /**
     * Returns a test proxy for the specified class.
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $originalClassName
     * @psalm-return MockObject&RealInstanceType
     */
    protected function createTestProxy(string $originalClassName, array $constructorArguments = []) : \PHPUnit\Framework\MockObject\MockObject
    {
        return $this->getMockBuilder($originalClassName)->setConstructorArgs($constructorArguments)->enableProxyingToOriginalMethods()->getMock();
    }
    /**
     * Mocks the specified class and returns the name of the mocked class.
     *
     * @param null|array $methods $methods
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType>|string $originalClassName
     * @psalm-return class-string<MockObject&RealInstanceType>
     */
    protected function getMockClass(string $originalClassName, $methods = [], array $arguments = [], string $mockClassName = '', bool $callOriginalConstructor = \false, bool $callOriginalClone = \true, bool $callAutoload = \true, bool $cloneArguments = \false) : string
    {
        $this->recordDoubledType($originalClassName);
        $mock = $this->getMockObjectGenerator()->getMock($originalClassName, $methods, $arguments, $mockClassName, $callOriginalConstructor, $callOriginalClone, $callAutoload, $cloneArguments);
        return \get_class($mock);
    }
    /**
     * Returns a mock object for the specified abstract class with all abstract
     * methods of the class mocked. Concrete methods are not mocked by default.
     * To mock concrete methods, use the 7th parameter ($mockedMethods).
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $originalClassName
     * @psalm-return MockObject&RealInstanceType
     */
    protected function getMockForAbstractClass(string $originalClassName, array $arguments = [], string $mockClassName = '', bool $callOriginalConstructor = \true, bool $callOriginalClone = \true, bool $callAutoload = \true, array $mockedMethods = [], bool $cloneArguments = \false) : \PHPUnit\Framework\MockObject\MockObject
    {
        $this->recordDoubledType($originalClassName);
        $mockObject = $this->getMockObjectGenerator()->getMockForAbstractClass($originalClassName, $arguments, $mockClassName, $callOriginalConstructor, $callOriginalClone, $callAutoload, $mockedMethods, $cloneArguments);
        $this->registerMockObject($mockObject);
        return $mockObject;
    }
    /**
     * Returns a mock object based on the given WSDL file.
     *
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType>|string $originalClassName
     * @psalm-return MockObject&RealInstanceType
     */
    protected function getMockFromWsdl(string $wsdlFile, string $originalClassName = '', string $mockClassName = '', array $methods = [], bool $callOriginalConstructor = \true, array $options = []) : \PHPUnit\Framework\MockObject\MockObject
    {
        $this->recordDoubledType(\SoapClient::class);
        if ($originalClassName === '') {
            $fileName = \pathinfo(\basename(\parse_url($wsdlFile, \PHP_URL_PATH)), \PATHINFO_FILENAME);
            $originalClassName = \preg_replace('/\\W/', '', $fileName);
        }
        if (!\class_exists($originalClassName)) {
            eval($this->getMockObjectGenerator()->generateClassFromWsdl($wsdlFile, $originalClassName, $methods, $options));
        }
        $mockObject = $this->getMockObjectGenerator()->getMock($originalClassName, $methods, ['', $options], $mockClassName, $callOriginalConstructor, \false, \false);
        $this->registerMockObject($mockObject);
        return $mockObject;
    }
    /**
     * Returns a mock object for the specified trait with all abstract methods
     * of the trait mocked. Concrete methods to mock can be specified with the
     * `$mockedMethods` parameter.
     *
     * @psalm-param trait-string $traitName
     */
    protected function getMockForTrait(string $traitName, array $arguments = [], string $mockClassName = '', bool $callOriginalConstructor = \true, bool $callOriginalClone = \true, bool $callAutoload = \true, array $mockedMethods = [], bool $cloneArguments = \false) : \PHPUnit\Framework\MockObject\MockObject
    {
        $this->recordDoubledType($traitName);
        $mockObject = $this->getMockObjectGenerator()->getMockForTrait($traitName, $arguments, $mockClassName, $callOriginalConstructor, $callOriginalClone, $callAutoload, $mockedMethods, $cloneArguments);
        $this->registerMockObject($mockObject);
        return $mockObject;
    }
    /**
     * Returns an object for the specified trait.
     *
     * @psalm-param trait-string $traitName
     */
    protected function getObjectForTrait(string $traitName, array $arguments = [], string $traitClassName = '', bool $callOriginalConstructor = \true, bool $callOriginalClone = \true, bool $callAutoload = \true) : object
    {
        $this->recordDoubledType($traitName);
        return $this->getMockObjectGenerator()->getObjectForTrait($traitName, $traitClassName, $callAutoload, $callOriginalConstructor, $arguments);
    }
    /**
     * Performs assertions shared by all tests of a test case.
     *
     * This method is called between setUp() and test.
     */
    protected function assertPreConditions() : void
    {
    }
    /**
     * Performs assertions shared by all tests of a test case.
     *
     * This method is called between test and tearDown().
     */
    protected function assertPostConditions() : void
    {
    }
    /**
     * This method is called when a test method did not execute successfully.
     *
     * @throws Throwable
     */
    protected function onNotSuccessfulTest(\Throwable $t) : void
    {
        throw $t;
    }
    protected function recordDoubledType(string $originalClassName) : void
    {
        $this->doubledTypes[] = $originalClassName;
    }
    /**
     * @throws Throwable
     */
    private function verifyMockObjects() : void
    {
        foreach ($this->mockObjects as $mockObject) {
            if ($mockObject->__phpunit_hasMatchers()) {
                $this->numberOfAssertionsPerformed++;
            }
            $mockObject->__phpunit_verify($this->shouldInvocationMockerBeReset($mockObject));
        }
    }
    /**
     * @throws SkippedTestError
     * @throws SyntheticSkippedError
     * @throws Warning
     */
    private function checkRequirements() : void
    {
        if (!$this->name || !\method_exists($this, $this->name)) {
            return;
        }
        $missingRequirements = (new \PHPUnit\Metadata\RequirementsFacade())->requirementsNotSatisfiedFor(static::class, $this->name);
        if (!empty($missingRequirements)) {
            $this->markTestSkipped(\implode(\PHP_EOL, $missingRequirements));
        }
    }
    private function handleDependencies() : bool
    {
        if ([] === $this->dependencies || $this->inIsolation) {
            return \true;
        }
        $passed = $this->result->passed();
        $passedKeys = \array_keys($passed);
        $numKeys = \count($passedKeys);
        for ($i = 0; $i < $numKeys; $i++) {
            $pos = \strpos($passedKeys[$i], ' with data set');
            if ($pos !== \false) {
                $passedKeys[$i] = \substr($passedKeys[$i], 0, $pos);
            }
        }
        $passedKeys = \array_flip(\array_unique($passedKeys));
        foreach ($this->dependencies as $dependency) {
            if (!$dependency->isValid()) {
                $this->markSkippedForNotSpecifyingDependency();
                return \false;
            }
            if ($dependency->targetIsClass()) {
                $dependencyClassName = $dependency->getTargetClassName();
                if (\array_search($dependencyClassName, $this->result->passedClasses(), \true) === \false) {
                    $this->markSkippedForMissingDependency($dependency);
                    return \false;
                }
                continue;
            }
            $dependencyTarget = $dependency->getTarget();
            if (!isset($passedKeys[$dependencyTarget])) {
                if (!$this->isCallableTestMethod($dependencyTarget)) {
                    $this->markWarningForUncallableDependency($dependency);
                } else {
                    $this->markSkippedForMissingDependency($dependency);
                }
                return \false;
            }
            if (isset($passed[$dependencyTarget])) {
                if ($passed[$dependencyTarget]['size']->isKnown() && $this->size()->isKnown() && $passed[$dependencyTarget]['size']->isGreaterThan($this->size())) {
                    $this->result->addFailure($this, new \PHPUnit\Framework\SkippedTestError('This test depends on a test that is larger than itself.'), 0);
                    return \false;
                }
                if ($dependency->deepClone()) {
                    $deepCopy = new \PHPUnit\DeepCopy\DeepCopy();
                    $deepCopy->skipUncloneable(\false);
                    $this->dependencyInput[$dependencyTarget] = $deepCopy->copy($passed[$dependencyTarget]['result']);
                } elseif ($dependency->shallowClone()) {
                    $this->dependencyInput[$dependencyTarget] = clone $passed[$dependencyTarget]['result'];
                } else {
                    $this->dependencyInput[$dependencyTarget] = $passed[$dependencyTarget]['result'];
                }
            } else {
                $this->dependencyInput[$dependencyTarget] = null;
            }
        }
        return \true;
    }
    private function markSkippedForNotSpecifyingDependency() : void
    {
        $message = 'This method has an invalid @depends annotation.';
        $this->status = \PHPUnit\Framework\TestStatus\TestStatus::skipped($message);
        $this->result->startTest($this);
        $this->result->addFailure($this, new \PHPUnit\Framework\SkippedTestError($message), 0);
        $this->result->endTest($this, 0);
    }
    private function markSkippedForMissingDependency(\PHPUnit\Framework\ExecutionOrderDependency $dependency) : void
    {
        $message = \sprintf('This test depends on "%s" to pass.', $dependency->getTarget());
        $this->status = \PHPUnit\Framework\TestStatus\TestStatus::skipped($message);
        $this->result->startTest($this);
        $this->result->addFailure($this, new \PHPUnit\Framework\SkippedTestError($message), 0);
        $this->result->endTest($this, 0);
    }
    private function markWarningForUncallableDependency(\PHPUnit\Framework\ExecutionOrderDependency $dependency) : void
    {
        $message = \sprintf('This test depends on "%s" which does not exist.', $dependency->getTarget());
        $this->status = \PHPUnit\Framework\TestStatus\TestStatus::warning($message);
        $this->result->startTest($this);
        $this->result->addWarning($this, new \PHPUnit\Framework\Warning($message), 0);
        $this->result->endTest($this, 0);
    }
    /**
     * Get the mock object generator, creating it if it doesn't exist.
     */
    private function getMockObjectGenerator() : \PHPUnit\Framework\MockObject\Generator
    {
        if ($this->mockObjectGenerator === null) {
            $this->mockObjectGenerator = new \PHPUnit\Framework\MockObject\Generator();
        }
        return $this->mockObjectGenerator;
    }
    private function startOutputBuffering() : void
    {
        \ob_start();
        $this->outputBufferingActive = \true;
        $this->outputBufferingLevel = \ob_get_level();
    }
    /**
     * @throws RiskyTestError
     */
    private function stopOutputBuffering() : void
    {
        if (\ob_get_level() !== $this->outputBufferingLevel) {
            while (\ob_get_level() >= $this->outputBufferingLevel) {
                \ob_end_clean();
            }
            throw new \PHPUnit\Framework\RiskyTestError('Test code or tested code did not (only) close its own output buffers');
        }
        $this->output = \ob_get_contents();
        if ($this->outputCallback !== \false) {
            $this->output = (string) \call_user_func($this->outputCallback, $this->output);
        }
        \ob_end_clean();
        $this->outputBufferingActive = \false;
        $this->outputBufferingLevel = \ob_get_level();
    }
    private function snapshotGlobalState() : void
    {
        if ($this->runTestInSeparateProcess || $this->inIsolation || !$this->backupGlobals && !$this->backupStaticAttributes) {
            return;
        }
        $this->snapshot = $this->createGlobalStateSnapshot($this->backupGlobals === \true);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws RiskyTestError
     */
    private function restoreGlobalState() : void
    {
        if (!$this->snapshot instanceof \PHPUnit\SebastianBergmann\GlobalState\Snapshot) {
            return;
        }
        if ($this->beStrictAboutChangesToGlobalState) {
            try {
                $this->compareGlobalStateSnapshots($this->snapshot, $this->createGlobalStateSnapshot($this->backupGlobals === \true));
            } catch (\PHPUnit\Framework\RiskyTestError $rte) {
                // Intentionally left empty
            }
        }
        $restorer = new \PHPUnit\SebastianBergmann\GlobalState\Restorer();
        if ($this->backupGlobals) {
            $restorer->restoreGlobalVariables($this->snapshot);
        }
        if ($this->backupStaticAttributes) {
            $restorer->restoreStaticAttributes($this->snapshot);
        }
        $this->snapshot = null;
        if (isset($rte)) {
            throw $rte;
        }
    }
    private function createGlobalStateSnapshot(bool $backupGlobals) : \PHPUnit\SebastianBergmann\GlobalState\Snapshot
    {
        $excludeList = new \PHPUnit\SebastianBergmann\GlobalState\ExcludeList();
        foreach ($this->backupGlobalsExcludeList as $globalVariable) {
            $excludeList->addGlobalVariable($globalVariable);
        }
        if (!\defined('PHPUNIT_TESTSUITE')) {
            $excludeList->addClassNamePrefix('PHPUnit');
            $excludeList->addClassNamePrefix('PHPUnit\\SebastianBergmann\\CodeCoverage');
            $excludeList->addClassNamePrefix('PHPUnit\\SebastianBergmann\\FileIterator');
            $excludeList->addClassNamePrefix('PHPUnit\\SebastianBergmann\\Invoker');
            $excludeList->addClassNamePrefix('PHPUnit\\SebastianBergmann\\Template');
            $excludeList->addClassNamePrefix('PHPUnit\\SebastianBergmann\\Timer');
            $excludeList->addClassNamePrefix('PHPUnit\\Doctrine\\Instantiator');
            $excludeList->addStaticAttribute(\PHPUnit\SebastianBergmann\Comparator\Factory::class, 'instance');
            foreach ($this->backupStaticAttributesExcludeList as $class => $attributes) {
                foreach ($attributes as $attribute) {
                    $excludeList->addStaticAttribute($class, $attribute);
                }
            }
        }
        return new \PHPUnit\SebastianBergmann\GlobalState\Snapshot($excludeList, $backupGlobals, (bool) $this->backupStaticAttributes, \false, \false, \false, \false, \false, \false, \false);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws RiskyTestError
     */
    private function compareGlobalStateSnapshots(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $before, \PHPUnit\SebastianBergmann\GlobalState\Snapshot $after) : void
    {
        $backupGlobals = $this->backupGlobals === null || $this->backupGlobals;
        if ($backupGlobals) {
            $this->compareGlobalStateSnapshotPart($before->globalVariables(), $after->globalVariables(), "--- Global variables before the test\n+++ Global variables after the test\n");
            $this->compareGlobalStateSnapshotPart($before->superGlobalVariables(), $after->superGlobalVariables(), "--- Super-global variables before the test\n+++ Super-global variables after the test\n");
        }
        if ($this->backupStaticAttributes) {
            $this->compareGlobalStateSnapshotPart($before->staticAttributes(), $after->staticAttributes(), "--- Static attributes before the test\n+++ Static attributes after the test\n");
        }
    }
    /**
     * @throws RiskyTestError
     */
    private function compareGlobalStateSnapshotPart(array $before, array $after, string $header) : void
    {
        if ($before != $after) {
            $differ = new \PHPUnit\SebastianBergmann\Diff\Differ($header);
            $exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
            $diff = $differ->diff($exporter->export($before), $exporter->export($after));
            throw new \PHPUnit\Framework\RiskyTestError($diff);
        }
    }
    /**
     * @throws \SebastianBergmann\ObjectEnumerator\InvalidArgumentException
     */
    private function shouldInvocationMockerBeReset(\PHPUnit\Framework\MockObject\MockObject $mock) : bool
    {
        $enumerator = new \PHPUnit\SebastianBergmann\ObjectEnumerator\Enumerator();
        foreach ($enumerator->enumerate($this->dependencyInput) as $object) {
            if ($mock === $object) {
                return \false;
            }
        }
        if (!\is_array($this->testResult) && !\is_object($this->testResult)) {
            return \true;
        }
        return !\in_array($mock, $enumerator->enumerate($this->testResult), \true);
    }
    /**
     * @throws \SebastianBergmann\ObjectEnumerator\InvalidArgumentException
     * @throws \SebastianBergmann\ObjectReflector\InvalidArgumentException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function registerMockObjectsFromTestArguments(array $testArguments, array &$visited = []) : void
    {
        if ($this->registerMockObjectsFromTestArgumentsRecursively) {
            foreach ((new \PHPUnit\SebastianBergmann\ObjectEnumerator\Enumerator())->enumerate($testArguments) as $object) {
                if ($object instanceof \PHPUnit\Framework\MockObject\MockObject) {
                    $this->registerMockObject($object);
                }
            }
        } else {
            foreach ($testArguments as $testArgument) {
                if ($testArgument instanceof \PHPUnit\Framework\MockObject\MockObject) {
                    if (\PHPUnit\Util\Type::isCloneable($testArgument)) {
                        $testArgument = clone $testArgument;
                    }
                    $this->registerMockObject($testArgument);
                } elseif (\is_array($testArgument) && !\in_array($testArgument, $visited, \true)) {
                    $visited[] = $testArgument;
                    $this->registerMockObjectsFromTestArguments($testArgument, $visited);
                }
            }
        }
    }
    private function unregisterCustomComparators() : void
    {
        $factory = \PHPUnit\SebastianBergmann\Comparator\Factory::getInstance();
        foreach ($this->customComparators as $comparator) {
            $factory->unregister($comparator);
        }
        $this->customComparators = [];
    }
    private function cleanupIniSettings() : void
    {
        foreach ($this->iniSettings as $varName => $oldValue) {
            \ini_set($varName, $oldValue);
        }
        $this->iniSettings = [];
    }
    private function cleanupLocaleSettings() : void
    {
        foreach ($this->locale as $category => $locale) {
            \setlocale($category, $locale);
        }
        $this->locale = [];
    }
    /**
     * @throws Exception
     */
    private function checkExceptionExpectations(\Throwable $throwable) : bool
    {
        $result = \false;
        if ($this->expectedException !== null || $this->expectedExceptionCode !== null || $this->expectedExceptionMessage !== null || $this->expectedExceptionMessageRegExp !== null) {
            $result = \true;
        }
        if ($throwable instanceof \PHPUnit\Framework\Exception) {
            $result = \false;
        }
        if (\is_string($this->expectedException)) {
            try {
                $reflector = new \ReflectionClass($this->expectedException);
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
            if ($this->expectedException === 'PHPUnit\\Framework\\Exception' || $this->expectedException === '\\PHPUnit\\Framework\\Exception' || $reflector->isSubclassOf(\PHPUnit\Framework\Exception::class)) {
                $result = \true;
            }
        }
        return $result;
    }
    private function shouldRunInSeparateProcess() : bool
    {
        return ($this->runTestInSeparateProcess || $this->runClassInSeparateProcess) && !$this->inIsolation && !$this instanceof \PHPUnit\Runner\PhptTestCase;
    }
    private function isCallableTestMethod(string $dependency) : bool
    {
        [$className, $methodName] = \explode('::', $dependency);
        if (!\class_exists($className)) {
            return \false;
        }
        try {
            $class = new \ReflectionClass($className);
        } catch (\ReflectionException $e) {
            return \false;
        }
        if (!$class->isSubclassOf(__CLASS__)) {
            return \false;
        }
        if (!$class->hasMethod($methodName)) {
            return \false;
        }
        return \PHPUnit\Util\Test::isTestMethod($class->getMethod($methodName));
    }
    /**
     * @psalm-template RealInstanceType of object
     * @psalm-param class-string<RealInstanceType> $originalClassName
     * @psalm-return MockObject&RealInstanceType
     */
    private function createMockObject(string $originalClassName) : \PHPUnit\Framework\MockObject\MockObject
    {
        return $this->getMockBuilder($originalClassName)->disableOriginalConstructor()->disableOriginalClone()->disableArgumentCloning()->disallowMockingUnknownTypes()->getMock();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function get_class;
use function sprintf;
use function trim;
use PHPUnit\Util\Error\Error;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestFailure
{
    private ?\PHPUnit\Framework\Test $failedTest = null;
    private \Throwable $thrownException;
    private string $testName;
    /**
     * Returns a description for an exception.
     */
    public static function exceptionToString(\Throwable $e) : string
    {
        if ($e instanceof \PHPUnit\Framework\SelfDescribing) {
            $buffer = $e->toString();
            if ($e instanceof \PHPUnit\Framework\ExpectationFailedException && $e->getComparisonFailure()) {
                $buffer .= $e->getComparisonFailure()->getDiff();
            }
            if ($e instanceof \PHPUnit\Framework\PHPTAssertionFailedError) {
                $buffer .= $e->getDiff();
            }
            if (!empty($buffer)) {
                $buffer = \trim($buffer) . "\n";
            }
            return $buffer;
        }
        if ($e instanceof \PHPUnit\Util\Error\Error) {
            return $e->getMessage() . "\n";
        }
        if ($e instanceof \PHPUnit\Framework\ExceptionWrapper) {
            return $e->getClassName() . ': ' . $e->getMessage() . "\n";
        }
        return \get_class($e) . ': ' . $e->getMessage() . "\n";
    }
    /**
     * Constructs a TestFailure with the given test and exception.
     */
    public function __construct(\PHPUnit\Framework\Test $failedTest, \Throwable $t)
    {
        $this->testName = $this->describe($failedTest);
        if (!$failedTest instanceof \PHPUnit\Framework\TestCase || !$failedTest->isInIsolation()) {
            $this->failedTest = $failedTest;
        }
        $this->thrownException = $t;
    }
    /**
     * Returns a short description of the failure.
     */
    public function toString() : string
    {
        return \sprintf('%s: %s', $this->testName, $this->thrownException->getMessage());
    }
    /**
     * Returns a description for the thrown exception.
     */
    public function getExceptionAsString() : string
    {
        return self::exceptionToString($this->thrownException);
    }
    /**
     * Returns the name of the failing test (including data set, if any).
     */
    public function getTestName() : string
    {
        return $this->testName;
    }
    /**
     * Returns the failing test.
     *
     * Note: The test object is not set when the test is executed in process
     * isolation.
     *
     * @see Exception
     */
    public function failedTest() : ?\PHPUnit\Framework\Test
    {
        return $this->failedTest;
    }
    /**
     * Gets the thrown exception.
     */
    public function thrownException() : \Throwable
    {
        return $this->thrownException;
    }
    /**
     * Returns the exception's message.
     */
    public function exceptionMessage() : string
    {
        return $this->thrownException()->getMessage();
    }
    /**
     * Returns true if the thrown exception
     * is of type AssertionFailedError.
     */
    public function isFailure() : bool
    {
        return $this->thrownException() instanceof \PHPUnit\Framework\AssertionFailedError;
    }
    private function describe(\PHPUnit\Framework\Test $test) : string
    {
        if ($test instanceof \PHPUnit\Framework\SelfDescribing) {
            return $test->toString();
        }
        return \get_class($test);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use Throwable;
/**
 * @internal
 */
interface TestListener
{
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void;
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void;
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void;
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void;
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void;
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void;
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void;
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void;
    public function startTest(\PHPUnit\Framework\Test $test) : void;
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function count;
use function get_class;
use Countable;
use Error;
use PHPUnit\Framework\TestSize\TestSize;
use PHPUnit\Metadata\GroupsFacade;
use PHPUnit\Util\Printer;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestResult implements \Countable
{
    /**
     * @psalm-var array<string,array{result: mixed, size: \PHPUnit\Framework\TestSize\TestSize}>
     */
    private array $passed = [];
    /**
     * @psalm-var list<string>
     */
    private array $passedTestClasses = [];
    private bool $currentTestSuiteFailed = \false;
    /**
     * @psalm-var list<TestFailure>
     */
    private array $errors = [];
    /**
     * @psalm-var list<TestFailure>
     */
    private array $failures = [];
    /**
     * @psalm-var list<TestFailure>
     */
    private array $warnings = [];
    /**
     * @psalm-var list<TestFailure>
     */
    private array $notImplemented = [];
    /**
     * @psalm-var list<TestFailure>
     */
    private array $risky = [];
    /**
     * @psalm-var list<TestFailure>
     */
    private array $skipped = [];
    /**
     * @psalm-var list<TestListener>
     */
    private array $listeners = [];
    private int $runTests = 0;
    private float $time = 0;
    private bool $convertDeprecationsToExceptions = \true;
    private bool $convertErrorsToExceptions = \true;
    private bool $convertNoticesToExceptions = \true;
    private bool $convertWarningsToExceptions = \true;
    private bool $stop = \false;
    private bool $stopOnError = \false;
    private bool $stopOnFailure = \false;
    private bool $stopOnWarning = \false;
    private bool $beStrictAboutTestsThatDoNotTestAnything = \true;
    private bool $beStrictAboutOutputDuringTests = \false;
    private bool $beStrictAboutTodoAnnotatedTests = \false;
    private bool $beStrictAboutResourceUsageDuringSmallTests = \false;
    private bool $enforceTimeLimit = \false;
    private bool $forceCoversAnnotation = \false;
    private int $timeoutForSmallTests = 1;
    private int $timeoutForMediumTests = 10;
    private int $timeoutForLargeTests = 60;
    private bool $stopOnRisky = \false;
    private bool $stopOnIncomplete = \false;
    private bool $stopOnSkipped = \false;
    private bool $lastTestFailed = \false;
    private int $defaultTimeLimit = 0;
    private bool $stopOnDefect = \false;
    private bool $registerMockObjectsFromTestArgumentsRecursively = \false;
    /**
     * @deprecated Use the `TestHook` interfaces instead
     *
     * @codeCoverageIgnore
     */
    public function addListener(\PHPUnit\Framework\TestListener $listener) : void
    {
        $this->listeners[] = $listener;
    }
    /**
     * @deprecated Use the `TestHook` interfaces instead
     *
     * @codeCoverageIgnore
     */
    public function flushListeners() : void
    {
        foreach ($this->listeners as $listener) {
            if ($listener instanceof \PHPUnit\Util\Printer) {
                $listener->flush();
            }
        }
    }
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->recordError($test, $t);
        if ($this->stopOnError || $this->stopOnFailure) {
            $this->stop();
        }
        // @see https://github.com/sebastianbergmann/phpunit/issues/1953
        if ($t instanceof \Error) {
            $t = new \PHPUnit\Framework\ExceptionWrapper($t);
        }
        foreach ($this->listeners as $listener) {
            $listener->addError($test, $t, $time);
        }
        $this->lastTestFailed = \true;
        $this->time += $time;
    }
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
        if ($this->stopOnWarning || $this->stopOnDefect) {
            $this->stop();
        }
        $this->recordWarning($test, $e);
        foreach ($this->listeners as $listener) {
            $listener->addWarning($test, $e, $time);
        }
        $this->time += $time;
    }
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        if ($e instanceof \PHPUnit\Framework\RiskyTestError || $e instanceof \PHPUnit\Framework\OutputError) {
            $this->recordRisky($test, $e);
            $notifyMethod = 'addRiskyTest';
            if ($test instanceof \PHPUnit\Framework\TestCase) {
                $test->markAsRisky();
            }
            if ($this->stopOnRisky || $this->stopOnDefect) {
                $this->stop();
            }
        } elseif ($e instanceof \PHPUnit\Framework\IncompleteTest) {
            $this->recordNotImplemented($test, $e);
            $notifyMethod = 'addIncompleteTest';
            if ($this->stopOnIncomplete) {
                $this->stop();
            }
        } elseif ($e instanceof \PHPUnit\Framework\SkippedTest) {
            $this->recordSkipped($test, $e);
            $notifyMethod = 'addSkippedTest';
            if ($this->stopOnSkipped) {
                $this->stop();
            }
        } else {
            $this->failures[] = new \PHPUnit\Framework\TestFailure($test, $e);
            $notifyMethod = 'addFailure';
            if ($this->stopOnFailure || $this->stopOnDefect) {
                $this->stop();
            }
        }
        foreach ($this->listeners as $listener) {
            $listener->{$notifyMethod}($test, $e, $time);
        }
        $this->lastTestFailed = \true;
        $this->time += $time;
    }
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
        $this->currentTestSuiteFailed = \false;
        foreach ($this->listeners as $listener) {
            $listener->startTestSuite($suite);
        }
    }
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
        if (!$this->currentTestSuiteFailed) {
            $this->passedTestClasses[] = $suite->getName();
        }
        foreach ($this->listeners as $listener) {
            $listener->endTestSuite($suite);
        }
    }
    public function startTest(\PHPUnit\Framework\Test $test) : void
    {
        $this->lastTestFailed = \false;
        $this->runTests += \count($test);
        foreach ($this->listeners as $listener) {
            $listener->startTest($test);
        }
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        foreach ($this->listeners as $listener) {
            $listener->endTest($test, $time);
        }
        if (!$this->lastTestFailed && $test instanceof \PHPUnit\Framework\TestCase) {
            $class = \get_class($test);
            $key = $class . '::' . $test->getName();
            $size = \PHPUnit\Framework\TestSize\TestSize::unknown();
            if ($class !== \PHPUnit\Framework\WarningTestCase::class) {
                $size = (new \PHPUnit\Metadata\GroupsFacade())->size($class, $test->getName(\false));
            }
            $this->passed[$key] = ['result' => $test->result(), 'size' => $size];
            $this->time += $time;
        }
        if ($this->lastTestFailed && $test instanceof \PHPUnit\Framework\TestCase) {
            $this->currentTestSuiteFailed = \true;
        }
    }
    public function allHarmless() : bool
    {
        return $this->riskyCount() === 0;
    }
    public function riskyCount() : int
    {
        return \count($this->risky);
    }
    public function allCompletelyImplemented() : bool
    {
        return $this->notImplementedCount() === 0;
    }
    public function notImplementedCount() : int
    {
        return \count($this->notImplemented);
    }
    /**
     * @psalm-return list<TestFailure>
     */
    public function risky() : array
    {
        return $this->risky;
    }
    /**
     * @psalm-return list<TestFailure>
     */
    public function notImplemented() : array
    {
        return $this->notImplemented;
    }
    public function noneSkipped() : bool
    {
        return $this->skippedCount() === 0;
    }
    public function skippedCount() : int
    {
        return \count($this->skipped);
    }
    /**
     * @psalm-return list<TestFailure>
     */
    public function skipped() : array
    {
        return $this->skipped;
    }
    public function errorCount() : int
    {
        return \count($this->errors);
    }
    /**
     * @psalm-return list<TestFailure>
     */
    public function errors() : array
    {
        return $this->errors;
    }
    public function failureCount() : int
    {
        return \count($this->failures);
    }
    /**
     * @psalm-return list<TestFailure>
     */
    public function failures() : array
    {
        return $this->failures;
    }
    public function warningCount() : int
    {
        return \count($this->warnings);
    }
    /**
     * @psalm-return list<TestFailure>
     */
    public function warnings() : array
    {
        return $this->warnings;
    }
    /**
     * @psalm-return array<string,array{result: mixed, size: \PHPUnit\Framework\TestSize\TestSize}>
     */
    public function passed() : array
    {
        return $this->passed;
    }
    public function passedClasses() : array
    {
        return $this->passedTestClasses;
    }
    public function count() : int
    {
        return $this->runTests;
    }
    public function shouldStop() : bool
    {
        return $this->stop;
    }
    public function stop() : void
    {
        $this->stop = \true;
    }
    public function convertDeprecationsToExceptions(bool $flag) : void
    {
        $this->convertDeprecationsToExceptions = $flag;
    }
    public function shouldDeprecationsBeConvertedToExceptions() : bool
    {
        return $this->convertDeprecationsToExceptions;
    }
    public function convertErrorsToExceptions(bool $flag) : void
    {
        $this->convertErrorsToExceptions = $flag;
    }
    public function shouldErrorsBeConvertedToExceptions() : bool
    {
        return $this->convertErrorsToExceptions;
    }
    public function convertNoticesToExceptions(bool $flag) : void
    {
        $this->convertNoticesToExceptions = $flag;
    }
    public function shouldNoticeBeConvertedToExceptions() : bool
    {
        return $this->convertNoticesToExceptions;
    }
    public function convertWarningsToExceptions(bool $flag) : void
    {
        $this->convertWarningsToExceptions = $flag;
    }
    public function shouldWarningsBeConvertedToExceptions() : bool
    {
        return $this->convertWarningsToExceptions;
    }
    public function stopOnError(bool $flag) : void
    {
        $this->stopOnError = $flag;
    }
    public function stopOnFailure(bool $flag) : void
    {
        $this->stopOnFailure = $flag;
    }
    public function stopOnWarning(bool $flag) : void
    {
        $this->stopOnWarning = $flag;
    }
    public function beStrictAboutTestsThatDoNotTestAnything(bool $flag) : void
    {
        $this->beStrictAboutTestsThatDoNotTestAnything = $flag;
    }
    public function isStrictAboutTestsThatDoNotTestAnything() : bool
    {
        return $this->beStrictAboutTestsThatDoNotTestAnything;
    }
    public function beStrictAboutOutputDuringTests(bool $flag) : void
    {
        $this->beStrictAboutOutputDuringTests = $flag;
    }
    public function isStrictAboutOutputDuringTests() : bool
    {
        return $this->beStrictAboutOutputDuringTests;
    }
    public function beStrictAboutResourceUsageDuringSmallTests(bool $flag) : void
    {
        $this->beStrictAboutResourceUsageDuringSmallTests = $flag;
    }
    public function isStrictAboutResourceUsageDuringSmallTests() : bool
    {
        return $this->beStrictAboutResourceUsageDuringSmallTests;
    }
    public function enforceTimeLimit(bool $flag) : void
    {
        $this->enforceTimeLimit = $flag;
    }
    public function enforcesTimeLimit() : bool
    {
        return $this->enforceTimeLimit;
    }
    public function beStrictAboutTodoAnnotatedTests(bool $flag) : void
    {
        $this->beStrictAboutTodoAnnotatedTests = $flag;
    }
    public function isStrictAboutTodoAnnotatedTests() : bool
    {
        return $this->beStrictAboutTodoAnnotatedTests;
    }
    public function forceCoversAnnotation() : void
    {
        $this->forceCoversAnnotation = \true;
    }
    public function enforcesCoversAnnotation() : bool
    {
        return $this->forceCoversAnnotation;
    }
    public function stopOnRisky(bool $flag) : void
    {
        $this->stopOnRisky = $flag;
    }
    public function stopOnIncomplete(bool $flag) : void
    {
        $this->stopOnIncomplete = $flag;
    }
    public function stopOnSkipped(bool $flag) : void
    {
        $this->stopOnSkipped = $flag;
    }
    public function stopOnDefect(bool $flag) : void
    {
        $this->stopOnDefect = $flag;
    }
    public function time() : float
    {
        return $this->time;
    }
    public function wasSuccessful() : bool
    {
        return $this->wasSuccessfulIgnoringWarnings() && empty($this->warnings);
    }
    public function wasSuccessfulIgnoringWarnings() : bool
    {
        return empty($this->errors) && empty($this->failures);
    }
    public function wasSuccessfulAndNoTestIsRiskyOrSkippedOrIncomplete() : bool
    {
        return $this->wasSuccessful() && $this->allHarmless() && $this->allCompletelyImplemented() && $this->noneSkipped();
    }
    public function setDefaultTimeLimit(int $timeout) : void
    {
        $this->defaultTimeLimit = $timeout;
    }
    public function defaultTimeLimit() : int
    {
        return $this->defaultTimeLimit;
    }
    public function setTimeoutForSmallTests(int $timeout) : void
    {
        $this->timeoutForSmallTests = $timeout;
    }
    public function timeoutForSmallTests() : int
    {
        return $this->timeoutForSmallTests;
    }
    public function setTimeoutForMediumTests(int $timeout) : void
    {
        $this->timeoutForMediumTests = $timeout;
    }
    public function timeoutForMediumTests() : int
    {
        return $this->timeoutForMediumTests;
    }
    public function setTimeoutForLargeTests(int $timeout) : void
    {
        $this->timeoutForLargeTests = $timeout;
    }
    public function timeoutForLargeTests() : int
    {
        return $this->timeoutForLargeTests;
    }
    public function registerMockObjectsFromTestArgumentsRecursively() : void
    {
        $this->registerMockObjectsFromTestArgumentsRecursively = \true;
    }
    public function shouldMockObjectsFromTestArgumentsBeRegisteredRecursively() : bool
    {
        return $this->registerMockObjectsFromTestArgumentsRecursively;
    }
    private function recordError(\PHPUnit\Framework\Test $test, \Throwable $t) : void
    {
        $this->errors[] = new \PHPUnit\Framework\TestFailure($test, $t);
    }
    private function recordNotImplemented(\PHPUnit\Framework\Test $test, \Throwable $t) : void
    {
        $this->notImplemented[] = new \PHPUnit\Framework\TestFailure($test, $t);
    }
    private function recordRisky(\PHPUnit\Framework\Test $test, \Throwable $t) : void
    {
        $this->risky[] = new \PHPUnit\Framework\TestFailure($test, $t);
    }
    private function recordSkipped(\PHPUnit\Framework\Test $test, \Throwable $t) : void
    {
        $this->skipped[] = new \PHPUnit\Framework\TestFailure($test, $t);
    }
    private function recordWarning(\PHPUnit\Framework\Test $test, \Throwable $t) : void
    {
        $this->warnings[] = new \PHPUnit\Framework\TestFailure($test, $t);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
use function defined;
use function get_class;
use function get_include_path;
use function serialize;
use function sprintf;
use function var_export;
use AssertionError;
use PHPUnit\Metadata\CodeCoverageFacade;
use PHPUnit\Metadata\Registry as MetadataRegistry;
use PHPUnit\Runner\CodeCoverage;
use PHPUnit\Util\Error\Handler;
use PHPUnit\Util\ExcludeList;
use PHPUnit\Util\GlobalState;
use PHPUnit\Util\PHP\AbstractPhpProcess;
use ReflectionClass;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception as OriginalCodeCoverageException;
use PHPUnit\SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException;
use PHPUnit\SebastianBergmann\Invoker\Invoker;
use PHPUnit\SebastianBergmann\Invoker\TimeoutException;
use PHPUnit\SebastianBergmann\ResourceOperations\ResourceOperations;
use PHPUnit\SebastianBergmann\Template\Template;
use PHPUnit\SebastianBergmann\Timer\Timer;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestRunner
{
    /**
     * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws CodeCoverageException
     * @throws UnintentionallyCoveredCodeException
     */
    public function run(\PHPUnit\Framework\TestCase $test, \PHPUnit\Framework\TestResult $result) : void
    {
        \PHPUnit\Framework\Assert::resetCount();
        if ($result->shouldMockObjectsFromTestArgumentsBeRegisteredRecursively()) {
            $test->registerMockObjectsFromTestArgumentsRecursively();
        }
        $shouldCodeCoverageBeCollected = (new \PHPUnit\Metadata\CodeCoverageFacade())->shouldCodeCoverageBeCollectedFor(\get_class($test), $test->getName(\false));
        $error = \false;
        $failure = \false;
        $warning = \false;
        $incomplete = \false;
        $risky = \false;
        $skipped = \false;
        $result->startTest($test);
        if ($result->shouldDeprecationsBeConvertedToExceptions() || $result->shouldErrorsBeConvertedToExceptions() || $result->shouldNoticeBeConvertedToExceptions() || $result->shouldWarningsBeConvertedToExceptions()) {
            $errorHandler = new \PHPUnit\Util\Error\Handler($result->shouldDeprecationsBeConvertedToExceptions(), $result->shouldErrorsBeConvertedToExceptions(), $result->shouldNoticeBeConvertedToExceptions(), $result->shouldWarningsBeConvertedToExceptions());
            $errorHandler->register();
        }
        $collectCodeCoverage = \PHPUnit\Runner\CodeCoverage::isActive() && !$test instanceof \PHPUnit\Framework\ErrorTestCase && !$test instanceof \PHPUnit\Framework\WarningTestCase && $shouldCodeCoverageBeCollected;
        if ($collectCodeCoverage) {
            \PHPUnit\Runner\CodeCoverage::start($test);
        }
        $monitorFunctions = $result->isStrictAboutResourceUsageDuringSmallTests() && !$test instanceof \PHPUnit\Framework\ErrorTestCase && !$test instanceof \PHPUnit\Framework\WarningTestCase && $test->size()->isSmall() && \function_exists('xdebug_start_function_monitor');
        if ($monitorFunctions) {
            /* @noinspection ForgottenDebugOutputInspection */
            \xdebug_start_function_monitor(\PHPUnit\SebastianBergmann\ResourceOperations\ResourceOperations::getFunctions());
        }
        $timer = new \PHPUnit\SebastianBergmann\Timer\Timer();
        $timer->start();
        try {
            $invoker = new \PHPUnit\SebastianBergmann\Invoker\Invoker();
            if (!$test instanceof \PHPUnit\Framework\ErrorTestCase && !$test instanceof \PHPUnit\Framework\WarningTestCase && $result->enforcesTimeLimit() && ($result->defaultTimeLimit() || $test->size()->isKnown()) && $invoker->canInvokeWithTimeout()) {
                $_timeout = $result->defaultTimeLimit();
                if ($test->size()->isSmall()) {
                    $_timeout = $result->timeoutForSmallTests();
                } elseif ($test->size()->isMedium()) {
                    $_timeout = $result->timeoutForMediumTests();
                } elseif ($test->size()->isLarge()) {
                    $_timeout = $result->timeoutForLargeTests();
                }
                $invoker->invoke([$test, 'runBare'], [], $_timeout);
            } else {
                $test->runBare();
            }
        } catch (\PHPUnit\SebastianBergmann\Invoker\TimeoutException $e) {
            $result->addFailure($test, new \PHPUnit\Framework\RiskyTestError($e->getMessage()), $_timeout);
            $risky = \true;
        } catch (\PHPUnit\Framework\AssertionFailedError $e) {
            $failure = \true;
            if ($e instanceof \PHPUnit\Framework\RiskyTestError) {
                $risky = \true;
            } elseif ($e instanceof \PHPUnit\Framework\IncompleteTestError) {
                $incomplete = \true;
            } elseif ($e instanceof \PHPUnit\Framework\SkippedTestError) {
                $skipped = \true;
            }
        } catch (\AssertionError $e) {
            $test->addToAssertionCount(1);
            $failure = \true;
            $frame = $e->getTrace()[0];
            $e = new \PHPUnit\Framework\AssertionFailedError(\sprintf('%s in %s:%s', $e->getMessage(), $frame['file'], $frame['line']));
        } catch (\PHPUnit\Framework\Warning $e) {
            $warning = \true;
        } catch (\PHPUnit\Framework\Exception $e) {
            $error = \true;
        } catch (\Throwable $e) {
            $e = new \PHPUnit\Framework\ExceptionWrapper($e);
            $error = \true;
        }
        $time = $timer->stop()->asSeconds();
        $test->addToAssertionCount(\PHPUnit\Framework\Assert::getCount());
        if ($monitorFunctions) {
            $excludeList = new \PHPUnit\Util\ExcludeList();
            /** @noinspection ForgottenDebugOutputInspection */
            $functions = \xdebug_get_monitored_functions();
            /* @noinspection ForgottenDebugOutputInspection */
            \xdebug_stop_function_monitor();
            foreach ($functions as $function) {
                if (!$excludeList->isExcluded($function['filename'])) {
                    $result->addFailure($test, new \PHPUnit\Framework\RiskyTestError(\sprintf('%s() used in %s:%s', $function['function'], $function['filename'], $function['lineno'])), $time);
                }
            }
        }
        if ($result->isStrictAboutTestsThatDoNotTestAnything() && $test->numberOfAssertionsPerformed() === 0) {
            $risky = \true;
        }
        if (!$error && !$failure && !$warning && !$incomplete && !$skipped && !$risky && $result->enforcesCoversAnnotation() && !$this->hasCoverageMetadata(\get_class($test), $test->getName(\false))) {
            $result->addFailure($test, new \PHPUnit\Framework\MissingCoversAnnotationException('This test does not have a @covers annotation but is expected to have one'), $time);
            $risky = \true;
        }
        if ($collectCodeCoverage) {
            $append = !$risky && !$incomplete && !$skipped;
            $linesToBeCovered = [];
            $linesToBeUsed = [];
            if ($append) {
                try {
                    $linesToBeCovered = (new \PHPUnit\Metadata\CodeCoverageFacade())->linesToBeCovered(\get_class($test), $test->getName(\false));
                    $linesToBeUsed = (new \PHPUnit\Metadata\CodeCoverageFacade())->linesToBeUsed(\get_class($test), $test->getName(\false));
                } catch (\PHPUnit\Framework\InvalidCoversTargetException $cce) {
                    $result->addWarning($test, new \PHPUnit\Framework\Warning($cce->getMessage()), $time);
                }
            }
            try {
                \PHPUnit\Runner\CodeCoverage::stop($append, $linesToBeCovered, $linesToBeUsed);
            } catch (\PHPUnit\SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException $cce) {
                $unintentionallyCoveredCodeError = new \PHPUnit\Framework\UnintentionallyCoveredCodeError('This test executed code that is not listed as code to be covered or used:' . \PHP_EOL . $cce->getMessage());
            } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $cce) {
                $error = \true;
                $e = $e ?? $cce;
            }
        }
        if (isset($errorHandler)) {
            $errorHandler->unregister();
            unset($errorHandler);
        }
        if ($error) {
            $result->addError($test, $e, $time);
        } elseif ($failure) {
            $result->addFailure($test, $e, $time);
        } elseif ($warning) {
            $result->addWarning($test, $e, $time);
        } elseif (isset($unintentionallyCoveredCodeError)) {
            $result->addFailure($test, $unintentionallyCoveredCodeError, $time);
        } elseif ($result->isStrictAboutTestsThatDoNotTestAnything() && !$test->doesNotPerformAssertions() && $test->numberOfAssertionsPerformed() === 0) {
            $reflected = new \ReflectionClass($test);
            $name = $test->getName(\false);
            if ($name && $reflected->hasMethod($name)) {
                $reflected = $reflected->getMethod($name);
            }
            $result->addFailure($test, new \PHPUnit\Framework\RiskyTestError(\sprintf("This test did not perform any assertions\n\n%s:%d", $reflected->getFileName(), $reflected->getStartLine())), $time);
        } elseif ($result->isStrictAboutTestsThatDoNotTestAnything() && $test->doesNotPerformAssertions() && $test->numberOfAssertionsPerformed() > 0) {
            $result->addFailure($test, new \PHPUnit\Framework\RiskyTestError(\sprintf('This test is annotated with "@doesNotPerformAssertions" but performed %d assertions', $test->numberOfAssertionsPerformed())), $time);
        } elseif ($result->isStrictAboutOutputDuringTests() && $test->hasOutput()) {
            $result->addFailure($test, new \PHPUnit\Framework\OutputError(\sprintf('This test printed output: %s', $test->output())), $time);
        } elseif ($result->isStrictAboutTodoAnnotatedTests() && $this->hasTodoMetadata(\get_class($test), $test->getName(\false))) {
            $result->addFailure($test, new \PHPUnit\Framework\RiskyTestError('Test method is annotated with @todo'), $time);
        }
        $result->endTest($test, $time);
    }
    public function runInSeparateProcess(\PHPUnit\Framework\TestCase $test, \PHPUnit\Framework\TestResult $result, bool $runEntireClass, bool $preserveGlobalState) : void
    {
        $class = new \ReflectionClass($test);
        if ($runEntireClass) {
            $template = new \PHPUnit\SebastianBergmann\Template\Template(__DIR__ . '/../Util/PHP/Template/TestCaseClass.tpl');
        } else {
            $template = new \PHPUnit\SebastianBergmann\Template\Template(__DIR__ . '/../Util/PHP/Template/TestCaseMethod.tpl');
        }
        if ($preserveGlobalState) {
            $constants = \PHPUnit\Util\GlobalState::getConstantsAsString();
            $globals = \PHPUnit\Util\GlobalState::getGlobalsAsString();
            $includedFiles = \PHPUnit\Util\GlobalState::getIncludedFilesAsString();
            $iniSettings = \PHPUnit\Util\GlobalState::getIniSettingsAsString();
        } else {
            $constants = '';
            if (!empty($GLOBALS['__PHPUNIT_BOOTSTRAP'])) {
                $globals = '$GLOBALS[\'__PHPUNIT_BOOTSTRAP\'] = ' . \var_export($GLOBALS['__PHPUNIT_BOOTSTRAP'], \true) . ";\n";
            } else {
                $globals = '';
            }
            $includedFiles = '';
            $iniSettings = '';
        }
        $coverage = \PHPUnit\Runner\CodeCoverage::isActive() ? 'true' : 'false';
        $isStrictAboutTestsThatDoNotTestAnything = $result->isStrictAboutTestsThatDoNotTestAnything() ? 'true' : 'false';
        $isStrictAboutOutputDuringTests = $result->isStrictAboutOutputDuringTests() ? 'true' : 'false';
        $enforcesTimeLimit = $result->enforcesTimeLimit() ? 'true' : 'false';
        $isStrictAboutTodoAnnotatedTests = $result->isStrictAboutTodoAnnotatedTests() ? 'true' : 'false';
        $isStrictAboutResourceUsageDuringSmallTests = $result->isStrictAboutResourceUsageDuringSmallTests() ? 'true' : 'false';
        if (\defined('PHPUNIT_COMPOSER_INSTALL')) {
            $composerAutoload = \var_export(PHPUNIT_COMPOSER_INSTALL, \true);
        } else {
            $composerAutoload = '\'\'';
        }
        if (\defined('__PHPUNIT_PHAR__')) {
            $phar = \var_export(__PHPUNIT_PHAR__, \true);
        } else {
            $phar = '\'\'';
        }
        $codeCoverageFilter = null;
        $cachesStaticAnalysis = 'false';
        $codeCoverageCacheDirectory = null;
        $pathCoverage = 'false';
        if (\PHPUnit\Runner\CodeCoverage::isActive()) {
            $codeCoverageFilter = \PHPUnit\Runner\CodeCoverage::instance()->filter();
            if (\PHPUnit\Runner\CodeCoverage::instance()->collectsBranchAndPathCoverage()) {
                $pathCoverage = 'true';
            }
            if (\PHPUnit\Runner\CodeCoverage::instance()->cachesStaticAnalysis()) {
                $cachesStaticAnalysis = 'true';
                $codeCoverageCacheDirectory = \PHPUnit\Runner\CodeCoverage::instance()->cacheDirectory();
            }
        }
        $data = \var_export(\serialize($test->getProvidedData()), \true);
        $dataName = \var_export($test->dataName(), \true);
        $dependencyInput = \var_export(\serialize($test->dependencyInput()), \true);
        $includePath = \var_export(\get_include_path(), \true);
        $codeCoverageFilter = \var_export(\serialize($codeCoverageFilter), \true);
        $codeCoverageCacheDirectory = \var_export(\serialize($codeCoverageCacheDirectory), \true);
        // must do these fixes because TestCaseMethod.tpl has unserialize('{data}') in it, and we can't break BC
        // the lines above used to use addcslashes() rather than var_export(), which breaks null byte escape sequences
        $data = "'." . $data . ".'";
        $dataName = "'.(" . $dataName . ").'";
        $dependencyInput = "'." . $dependencyInput . ".'";
        $includePath = "'." . $includePath . ".'";
        $codeCoverageFilter = "'." . $codeCoverageFilter . ".'";
        $codeCoverageCacheDirectory = "'." . $codeCoverageCacheDirectory . ".'";
        $configurationFilePath = $GLOBALS['__PHPUNIT_CONFIGURATION_FILE'] ?? '';
        $var = ['composerAutoload' => $composerAutoload, 'phar' => $phar, 'filename' => $class->getFileName(), 'className' => $class->getName(), 'collectCodeCoverageInformation' => $coverage, 'cachesStaticAnalysis' => $cachesStaticAnalysis, 'codeCoverageCacheDirectory' => $codeCoverageCacheDirectory, 'pathCoverage' => $pathCoverage, 'data' => $data, 'dataName' => $dataName, 'dependencyInput' => $dependencyInput, 'constants' => $constants, 'globals' => $globals, 'include_path' => $includePath, 'included_files' => $includedFiles, 'iniSettings' => $iniSettings, 'isStrictAboutTestsThatDoNotTestAnything' => $isStrictAboutTestsThatDoNotTestAnything, 'isStrictAboutOutputDuringTests' => $isStrictAboutOutputDuringTests, 'enforcesTimeLimit' => $enforcesTimeLimit, 'isStrictAboutTodoAnnotatedTests' => $isStrictAboutTodoAnnotatedTests, 'isStrictAboutResourceUsageDuringSmallTests' => $isStrictAboutResourceUsageDuringSmallTests, 'codeCoverageFilter' => $codeCoverageFilter, 'configurationFilePath' => $configurationFilePath, 'name' => $test->getName(\false)];
        if (!$runEntireClass) {
            $var['methodName'] = $test->getName(\false);
        }
        $template->setVar($var);
        $php = \PHPUnit\Util\PHP\AbstractPhpProcess::factory();
        $php->runTestJob($template->render(), $test, $result);
    }
    /**
     * @psalm-param class-string $className
     */
    private function hasCoverageMetadata(string $className, string $methodName) : bool
    {
        $metadata = \PHPUnit\Metadata\Registry::parser()->forClassAndMethod($className, $methodName);
        if ($metadata->isCovers()->isNotEmpty()) {
            return \true;
        }
        if ($metadata->isCoversClass()->isNotEmpty()) {
            return \true;
        }
        if ($metadata->isCoversMethod()->isNotEmpty()) {
            return \true;
        }
        if ($metadata->isCoversFunction()->isNotEmpty()) {
            return \true;
        }
        if ($metadata->isCoversNothing()->isNotEmpty()) {
            return \true;
        }
        return \false;
    }
    /**
     * @psalm-param class-string $className
     */
    private function hasTodoMetadata(string $className, string $methodName) : bool
    {
        $metadata = \PHPUnit\Metadata\Registry::parser()->forClassAndMethod($className, $methodName);
        return $metadata->isTodo()->isNotEmpty();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestSize;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
abstract class Known extends \PHPUnit\Framework\TestSize\TestSize
{
    /**
     * @psalm-assert-if-true Known $this
     */
    public function isKnown() : bool
    {
        return \true;
    }
    public abstract function isGreaterThan(self $other) : bool;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestSize;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Large extends \PHPUnit\Framework\TestSize\Known
{
    /**
     * @psalm-assert-if-true Large $this
     */
    public function isLarge() : bool
    {
        return \true;
    }
    public function isGreaterThan(\PHPUnit\Framework\TestSize\TestSize $other) : bool
    {
        return !$other->isLarge();
    }
    public function asString() : string
    {
        return 'large';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestSize;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Medium extends \PHPUnit\Framework\TestSize\Known
{
    /**
     * @psalm-assert-if-true Medium $this
     */
    public function isMedium() : bool
    {
        return \true;
    }
    public function isGreaterThan(\PHPUnit\Framework\TestSize\TestSize $other) : bool
    {
        return $other->isSmall();
    }
    public function asString() : string
    {
        return 'medium';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestSize;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Small extends \PHPUnit\Framework\TestSize\Known
{
    /**
     * @psalm-assert-if-true Small $this
     */
    public function isSmall() : bool
    {
        return \true;
    }
    public function isGreaterThan(\PHPUnit\Framework\TestSize\TestSize $other) : bool
    {
        return \false;
    }
    public function asString() : string
    {
        return 'small';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestSize;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
abstract class TestSize
{
    public static function unknown() : self
    {
        return new \PHPUnit\Framework\TestSize\Unknown();
    }
    public static function small() : self
    {
        return new \PHPUnit\Framework\TestSize\Small();
    }
    public static function medium() : self
    {
        return new \PHPUnit\Framework\TestSize\Medium();
    }
    public static function large() : self
    {
        return new \PHPUnit\Framework\TestSize\Large();
    }
    /**
     * @psalm-assert-if-true Known $this
     */
    public function isKnown() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Unknown $this
     */
    public function isUnknown() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Small $this
     */
    public function isSmall() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Medium $this
     */
    public function isMedium() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Large $this
     */
    public function isLarge() : bool
    {
        return \false;
    }
    public abstract function asString() : string;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestSize;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Unknown extends \PHPUnit\Framework\TestSize\TestSize
{
    /**
     * @psalm-assert-if-true Unknown $this
     */
    public function isUnknown() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'unknown';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Error extends \PHPUnit\Framework\TestStatus\Known
{
    /**
     * @psalm-assert-if-true Error $this
     */
    public function isError() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'error';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Failure extends \PHPUnit\Framework\TestStatus\Known
{
    /**
     * @psalm-assert-if-true Failure $this
     */
    public function isFailure() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'failure';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Incomplete extends \PHPUnit\Framework\TestStatus\Known
{
    /**
     * @psalm-assert-if-true Incomplete $this
     */
    public function isIncomplete() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'incomplete';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
abstract class Known extends \PHPUnit\Framework\TestStatus\TestStatus
{
    /**
     * @psalm-assert-if-true Known $this
     */
    public function isKnown() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Risky extends \PHPUnit\Framework\TestStatus\Known
{
    /**
     * @psalm-assert-if-true Risky $this
     */
    public function isRisky() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'risky';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Skipped extends \PHPUnit\Framework\TestStatus\Known
{
    /**
     * @psalm-assert-if-true Skipped $this
     */
    public function isSkipped() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'skipped';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Success extends \PHPUnit\Framework\TestStatus\Known
{
    /**
     * @psalm-assert-if-true Success $this
     */
    public function isSuccess() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'success';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
abstract class TestStatus
{
    private string $message;
    public static function unknown() : self
    {
        return new \PHPUnit\Framework\TestStatus\Unknown();
    }
    public static function success() : self
    {
        return new \PHPUnit\Framework\TestStatus\Success();
    }
    public static function skipped(string $message = '') : self
    {
        return new \PHPUnit\Framework\TestStatus\Skipped($message);
    }
    public static function incomplete(string $message = '') : self
    {
        return new \PHPUnit\Framework\TestStatus\Incomplete($message);
    }
    public static function failure(string $message = '') : self
    {
        return new \PHPUnit\Framework\TestStatus\Failure($message);
    }
    public static function error(string $message = '') : self
    {
        return new \PHPUnit\Framework\TestStatus\Error($message);
    }
    public static function warning(string $message = '') : self
    {
        return new \PHPUnit\Framework\TestStatus\Warning($message);
    }
    public static function risky(string $message = '') : self
    {
        return new \PHPUnit\Framework\TestStatus\Risky($message);
    }
    private function __construct(string $message = '')
    {
        $this->message = $message;
    }
    /**
     * @psalm-assert-if-true Known $this
     */
    public function isKnown() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Unknown $this
     */
    public function isUnknown() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Success $this
     */
    public function isSuccess() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Skipped $this
     */
    public function isSkipped() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Incomplete $this
     */
    public function isIncomplete() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Failure $this
     */
    public function isFailure() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Error $this
     */
    public function isError() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Warning $this
     */
    public function isWarning() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Risky $this
     */
    public function isRisky() : bool
    {
        return \false;
    }
    public function message() : string
    {
        return $this->message;
    }
    public abstract function asString() : string;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Unknown extends \PHPUnit\Framework\TestStatus\TestStatus
{
    /**
     * @psalm-assert-if-true Unknown $this
     */
    public function isUnknown() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'unknown';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework\TestStatus;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Warning extends \PHPUnit\Framework\TestStatus\Known
{
    /**
     * @psalm-assert-if-true Warning $this
     */
    public function isWarning() : bool
    {
        return \true;
    }
    public function asString() : string
    {
        return 'warning';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use const PHP_EOL;
use function array_keys;
use function array_map;
use function array_unique;
use function call_user_func;
use function class_exists;
use function count;
use function implode;
use function is_bool;
use function is_callable;
use function is_file;
use function is_object;
use function is_string;
use function method_exists;
use function sprintf;
use function strpos;
use function substr;
use Iterator;
use IteratorAggregate;
use PHPUnit\Metadata\GroupsFacade;
use PHPUnit\Metadata\HookFacade;
use PHPUnit\Metadata\RequirementsFacade;
use PHPUnit\Runner\Filter\Factory;
use PHPUnit\Runner\PhptTestCase;
use PHPUnit\Util\Test as TestUtil;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class TestSuite implements \IteratorAggregate, \PHPUnit\Framework\Reorderable, \PHPUnit\Framework\SelfDescribing, \PHPUnit\Framework\Test
{
    /**
     * Enable or disable the backup and restoration of the $GLOBALS array.
     */
    protected ?bool $backupGlobals = null;
    /**
     * Enable or disable the backup and restoration of static attributes.
     */
    protected ?bool $backupStaticAttributes = null;
    protected bool $runTestInSeparateProcess = \false;
    /**
     * The name of the test suite.
     */
    protected string $name = '';
    /**
     * The test groups of the test suite.
     *
     * @psalm-var array<string,list<Test>>
     */
    protected array $groups = [];
    /**
     * The tests in the test suite.
     *
     * @var Test[]
     */
    protected array $tests = [];
    /**
     * The number of tests in the test suite.
     */
    protected int $numTests = -1;
    protected bool $testCase = \false;
    /**
     * @var string[]
     */
    protected array $foundClasses = [];
    protected ?array $providedTests = null;
    protected ?array $requiredTests = null;
    private ?bool $beStrictAboutChangesToGlobalState = null;
    private ?\PHPUnit\Runner\Filter\Factory $iteratorFilter = null;
    /**
     * @psalm-var array<int,string>
     */
    private array $warnings = [];
    /**
     * Constructs a new TestSuite.
     *
     *   - PHPUnit\Framework\TestSuite() constructs an empty TestSuite.
     *
     *   - PHPUnit\Framework\TestSuite(ReflectionClass) constructs a
     *     TestSuite from the given class.
     *
     *   - PHPUnit\Framework\TestSuite(ReflectionClass, String)
     *     constructs a TestSuite from the given class with the given
     *     name.
     *
     *   - PHPUnit\Framework\TestSuite(String) either constructs a
     *     TestSuite from the given class (if the passed string is the
     *     name of an existing class) or constructs an empty TestSuite
     *     with the given name.
     *
     * @param ReflectionClass|string $theClass
     *
     * @throws Exception
     */
    public function __construct($theClass = '', string $name = '')
    {
        if (!\is_string($theClass) && !$theClass instanceof \ReflectionClass) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'ReflectionClass object or string');
        }
        if (!$theClass instanceof \ReflectionClass) {
            if (\class_exists($theClass, \true)) {
                if ($name === '') {
                    $name = $theClass;
                }
                try {
                    $theClass = new \ReflectionClass($theClass);
                } catch (\ReflectionException $e) {
                    throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
                }
                // @codeCoverageIgnoreEnd
            } else {
                $this->setName($theClass);
                return;
            }
        }
        if (!$theClass->isSubclassOf(\PHPUnit\Framework\TestCase::class)) {
            $this->setName((string) $theClass);
            return;
        }
        if ($name !== '') {
            $this->setName($name);
        } else {
            $this->setName($theClass->getName());
        }
        $constructor = $theClass->getConstructor();
        if ($constructor !== null && !$constructor->isPublic()) {
            $this->addTest(new \PHPUnit\Framework\WarningTestCase(\sprintf('Class "%s" has no public constructor.', $theClass->getName())));
            return;
        }
        foreach ($theClass->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) {
            if ($method->getDeclaringClass()->getName() === \PHPUnit\Framework\Assert::class) {
                continue;
            }
            if ($method->getDeclaringClass()->getName() === \PHPUnit\Framework\TestCase::class) {
                continue;
            }
            if (!\PHPUnit\Util\Test::isTestMethod($method)) {
                continue;
            }
            $this->addTestMethod($theClass, $method);
        }
        if (empty($this->tests)) {
            $this->addTest(new \PHPUnit\Framework\WarningTestCase(\sprintf('No tests found in class "%s".', $theClass->getName())));
        }
        $this->testCase = \true;
    }
    /**
     * Returns a string representation of the test suite.
     */
    public function toString() : string
    {
        return $this->getName();
    }
    /**
     * Adds a test to the suite.
     *
     * @param array $groups
     */
    public function addTest(\PHPUnit\Framework\Test $test, $groups = []) : void
    {
        try {
            $class = new \ReflectionClass($test);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        if (!$class->isAbstract()) {
            $this->tests[] = $test;
            $this->clearCaches();
            if ($test instanceof self && empty($groups)) {
                $groups = $test->getGroups();
            }
            if ($this->containsOnlyVirtualGroups($groups)) {
                $groups[] = 'default';
            }
            foreach ($groups as $group) {
                if (!isset($this->groups[$group])) {
                    $this->groups[$group] = [$test];
                } else {
                    $this->groups[$group][] = $test;
                }
            }
            if ($test instanceof \PHPUnit\Framework\TestCase) {
                $test->setGroups($groups);
            }
        }
    }
    /**
     * Adds the tests from the given class to the suite.
     *
     * @psalm-param object|class-string $testClass
     *
     * @throws Exception
     */
    public function addTestSuite($testClass) : void
    {
        if (!(\is_object($testClass) || \is_string($testClass) && \class_exists($testClass))) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(1, 'class name or object');
        }
        if (!\is_object($testClass)) {
            try {
                $testClass = new \ReflectionClass($testClass);
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
        }
        if ($testClass instanceof self) {
            $this->addTest($testClass);
        } elseif ($testClass instanceof \ReflectionClass) {
            if (!$testClass->isAbstract() && $testClass->isSubclassOf(\PHPUnit\Framework\TestCase::class)) {
                $this->addTest(new self($testClass));
            }
        } else {
            throw new \PHPUnit\Framework\Exception();
        }
    }
    public function addWarning(string $warning) : void
    {
        $this->warnings[] = $warning;
    }
    /**
     * Wraps both <code>addTest()</code> and <code>addTestSuite</code>
     * as well as the separate import statements for the user's convenience.
     *
     * If the named file cannot be read or there are no new tests that can be
     * added, a <code>PHPUnit\Framework\WarningTestCase</code> will be created instead,
     * leaving the current test run untouched.
     *
     * @throws \PHPUnit\Runner\Exception
     * @throws Exception
     */
    public function addTestFile(string $filename) : void
    {
        if (\is_file($filename) && \substr($filename, -5) === '.phpt') {
            $this->addTest(new \PHPUnit\Runner\PhptTestCase($filename));
            return;
        }
        $this->addTestSuite((new \PHPUnit\Runner\TestSuiteLoader())->load($filename));
    }
    /**
     * Wrapper for addTestFile() that adds multiple test files.
     *
     * @throws Exception
     */
    public function addTestFiles(iterable $fileNames) : void
    {
        foreach ($fileNames as $filename) {
            $this->addTestFile((string) $filename);
        }
    }
    /**
     * Counts the number of test cases that will be run by this test.
     *
     * @todo refactor usage of numTests in DefaultResultPrinter
     */
    public function count() : int
    {
        $this->numTests = 0;
        foreach ($this as $test) {
            $this->numTests += \count($test);
        }
        return $this->numTests;
    }
    /**
     * Returns the name of the suite.
     */
    public function getName() : string
    {
        return $this->name;
    }
    /**
     * Returns the test groups of the suite.
     *
     * @psalm-return list<string>
     */
    public function getGroups() : array
    {
        return \array_map(static function ($key) : string {
            return (string) $key;
        }, \array_keys($this->groups));
    }
    public function getGroupDetails() : array
    {
        return $this->groups;
    }
    /**
     * Set tests groups of the test case.
     */
    public function setGroupDetails(array $groups) : void
    {
        $this->groups = $groups;
    }
    /**
     * Runs the tests and collects their result in a TestResult.
     *
     * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
     * @throws \SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws CodeCoverageException
     * @throws Warning
     */
    public function run(\PHPUnit\Framework\TestResult $result) : void
    {
        if (\count($this) === 0) {
            return;
        }
        /** @psalm-var class-string $className */
        $className = $this->name;
        $hookMethods = (new \PHPUnit\Metadata\HookFacade())->hookMethods($className);
        $result->startTestSuite($this);
        $test = null;
        if ($this->testCase && \class_exists($this->name, \false)) {
            try {
                foreach ($hookMethods['beforeClass'] as $beforeClassMethod) {
                    if (\method_exists($this->name, $beforeClassMethod)) {
                        if ($missingRequirements = (new \PHPUnit\Metadata\RequirementsFacade())->requirementsNotSatisfiedFor($this->name, $beforeClassMethod)) {
                            $this->markTestSuiteSkipped(\implode(\PHP_EOL, $missingRequirements));
                        }
                        \call_user_func([$this->name, $beforeClassMethod]);
                    }
                }
            } catch (\PHPUnit\Framework\SkippedTestSuiteError $error) {
                foreach ($this->tests() as $test) {
                    $result->startTest($test);
                    $result->addFailure($test, $error, 0);
                    $result->endTest($test, 0);
                }
                $result->endTestSuite($this);
                return;
            } catch (\Throwable $t) {
                $errorAdded = \false;
                foreach ($this->tests() as $test) {
                    if ($result->shouldStop()) {
                        break;
                    }
                    $result->startTest($test);
                    if (!$errorAdded) {
                        $result->addError($test, $t, 0);
                        $errorAdded = \true;
                    } else {
                        $result->addFailure($test, new \PHPUnit\Framework\SkippedTestError('Test skipped because of an error in hook method'), 0);
                    }
                    $result->endTest($test, 0);
                }
                $result->endTestSuite($this);
                return;
            }
        }
        foreach ($this as $test) {
            if ($result->shouldStop()) {
                break;
            }
            if ($test instanceof \PHPUnit\Framework\TestCase || $test instanceof self) {
                $test->setBeStrictAboutChangesToGlobalState($this->beStrictAboutChangesToGlobalState);
                $test->setBackupGlobals($this->backupGlobals);
                $test->setBackupStaticAttributes($this->backupStaticAttributes);
                $test->setRunTestInSeparateProcess($this->runTestInSeparateProcess);
            }
            $test->run($result);
        }
        if ($this->testCase && \class_exists($this->name, \false)) {
            foreach ($hookMethods['afterClass'] as $afterClassMethod) {
                if (\method_exists($this->name, $afterClassMethod)) {
                    try {
                        \call_user_func([$this->name, $afterClassMethod]);
                    } catch (\Throwable $t) {
                        $message = "Exception in {$this->name}::{$afterClassMethod}" . \PHP_EOL . $t->getMessage();
                        $error = new \PHPUnit\Framework\SyntheticError($message, 0, $t->getFile(), $t->getLine(), $t->getTrace());
                        $placeholderTest = clone $test;
                        $placeholderTest->setName($afterClassMethod);
                        $result->startTest($placeholderTest);
                        $result->addFailure($placeholderTest, $error, 0);
                        $result->endTest($placeholderTest, 0);
                    }
                }
            }
        }
        $result->endTestSuite($this);
    }
    public function setRunTestInSeparateProcess(bool $runTestInSeparateProcess) : void
    {
        $this->runTestInSeparateProcess = $runTestInSeparateProcess;
    }
    public function setName(string $name) : void
    {
        $this->name = $name;
    }
    /**
     * Returns the tests as an enumeration.
     *
     * @return Test[]
     */
    public function tests() : array
    {
        return $this->tests;
    }
    /**
     * Set tests of the test suite.
     *
     * @param Test[] $tests
     */
    public function setTests(array $tests) : void
    {
        $this->tests = $tests;
    }
    /**
     * Mark the test suite as skipped.
     *
     * @param string $message
     *
     * @throws SkippedTestSuiteError
     *
     * @psalm-return never-return
     */
    public function markTestSuiteSkipped($message = '') : void
    {
        throw new \PHPUnit\Framework\SkippedTestSuiteError($message);
    }
    /**
     * @param bool $beStrictAboutChangesToGlobalState
     */
    public function setBeStrictAboutChangesToGlobalState($beStrictAboutChangesToGlobalState) : void
    {
        if (null === $this->beStrictAboutChangesToGlobalState && \is_bool($beStrictAboutChangesToGlobalState)) {
            $this->beStrictAboutChangesToGlobalState = $beStrictAboutChangesToGlobalState;
        }
    }
    /**
     * @param bool $backupGlobals
     */
    public function setBackupGlobals($backupGlobals) : void
    {
        if (null === $this->backupGlobals && \is_bool($backupGlobals)) {
            $this->backupGlobals = $backupGlobals;
        }
    }
    /**
     * @param bool $backupStaticAttributes
     */
    public function setBackupStaticAttributes($backupStaticAttributes) : void
    {
        if (null === $this->backupStaticAttributes && \is_bool($backupStaticAttributes)) {
            $this->backupStaticAttributes = $backupStaticAttributes;
        }
    }
    /**
     * Returns an iterator for this test suite.
     */
    public function getIterator() : \Iterator
    {
        $iterator = new \PHPUnit\Framework\TestSuiteIterator($this);
        if ($this->iteratorFilter !== null) {
            $iterator = $this->iteratorFilter->factory($iterator, $this);
        }
        return $iterator;
    }
    public function injectFilter(\PHPUnit\Runner\Filter\Factory $filter) : void
    {
        $this->iteratorFilter = $filter;
        foreach ($this as $test) {
            if ($test instanceof self) {
                $test->injectFilter($filter);
            }
        }
    }
    /**
     * @psalm-return array<int,string>
     */
    public function warnings() : array
    {
        return \array_unique($this->warnings);
    }
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function provides() : array
    {
        if ($this->providedTests === null) {
            $this->providedTests = [];
            if (\is_callable($this->sortId(), \true)) {
                $this->providedTests[] = new \PHPUnit\Framework\ExecutionOrderDependency($this->sortId());
            }
            foreach ($this->tests as $test) {
                if (!$test instanceof \PHPUnit\Framework\Reorderable) {
                    // @codeCoverageIgnoreStart
                    continue;
                    // @codeCoverageIgnoreEnd
                }
                $this->providedTests = \PHPUnit\Framework\ExecutionOrderDependency::mergeUnique($this->providedTests, $test->provides());
            }
        }
        return $this->providedTests;
    }
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function requires() : array
    {
        if ($this->requiredTests === null) {
            $this->requiredTests = [];
            foreach ($this->tests as $test) {
                if (!$test instanceof \PHPUnit\Framework\Reorderable) {
                    // @codeCoverageIgnoreStart
                    continue;
                    // @codeCoverageIgnoreEnd
                }
                $this->requiredTests = \PHPUnit\Framework\ExecutionOrderDependency::mergeUnique(\PHPUnit\Framework\ExecutionOrderDependency::filterInvalid($this->requiredTests), $test->requires());
            }
            $this->requiredTests = \PHPUnit\Framework\ExecutionOrderDependency::diff($this->requiredTests, $this->provides());
        }
        return $this->requiredTests;
    }
    public function sortId() : string
    {
        return $this->getName() . '::class';
    }
    /**
     * @throws Exception
     */
    protected function addTestMethod(\ReflectionClass $class, \ReflectionMethod $method) : void
    {
        $methodName = $method->getName();
        $test = (new \PHPUnit\Framework\TestBuilder())->build($class, $methodName);
        if ($test instanceof \PHPUnit\Framework\TestCase || $test instanceof \PHPUnit\Framework\DataProviderTestSuite) {
            $test->setDependencies(\PHPUnit\Util\Test::getDependencies($class->getName(), $methodName));
        }
        $this->addTest($test, (new \PHPUnit\Metadata\GroupsFacade())->groups($class->getName(), $methodName));
    }
    private function clearCaches() : void
    {
        $this->numTests = -1;
        $this->providedTests = null;
        $this->requiredTests = null;
    }
    private function containsOnlyVirtualGroups(array $groups) : bool
    {
        foreach ($groups as $group) {
            if (\strpos($group, '__phpunit_') !== 0) {
                return \false;
            }
        }
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

use function assert;
use function count;
use RecursiveIterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestSuiteIterator implements \RecursiveIterator
{
    private int $position = 0;
    /**
     * @var Test[]
     */
    private array $tests;
    public function __construct(\PHPUnit\Framework\TestSuite $testSuite)
    {
        $this->tests = $testSuite->tests();
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->tests);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\Framework\Test
    {
        return $this->tests[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
    /**
     * @throws NoChildTestSuiteException
     */
    public function getChildren() : self
    {
        if (!$this->hasChildren()) {
            throw new \PHPUnit\Framework\NoChildTestSuiteException('The current item is not a TestSuite instance and therefore does not have any children.');
        }
        $current = $this->current();
        \assert($current instanceof \PHPUnit\Framework\TestSuite);
        return new self($current);
    }
    public function hasChildren() : bool
    {
        return $this->valid() && $this->current() instanceof \PHPUnit\Framework\TestSuite;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Framework;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class WarningTestCase extends \PHPUnit\Framework\TestCase
{
    /**
     * @var bool
     */
    protected $backupGlobals = \false;
    /**
     * @var bool
     */
    protected $backupStaticAttributes = \false;
    /**
     * @var bool
     */
    protected $runTestInSeparateProcess = \false;
    private string $message;
    public function __construct(string $message = '')
    {
        $this->message = $message;
        parent::__construct('Warning');
    }
    public function getMessage() : string
    {
        return $this->message;
    }
    /**
     * Returns a string representation of the test case.
     */
    public function toString() : string
    {
        return 'Warning';
    }
    /**
     * @throws Exception
     *
     * @psalm-return never-return
     */
    protected function runTest() : void
    {
        throw new \PHPUnit\Framework\Warning($this->message);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class After extends \PHPUnit\Metadata\Metadata
{
    public function isAfter() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class AfterClass extends \PHPUnit\Metadata\Metadata
{
    public function isAfterClass() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class BackupGlobals extends \PHPUnit\Metadata\Metadata
{
    private ?bool $enabled;
    public function __construct(?bool $enabled)
    {
        $this->enabled = $enabled;
    }
    public function isBackupGlobals() : bool
    {
        return \true;
    }
    public function enabled() : ?bool
    {
        return $this->enabled;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class BackupStaticProperties extends \PHPUnit\Metadata\Metadata
{
    private ?bool $enabled;
    public function __construct(?bool $enabled)
    {
        $this->enabled = $enabled;
    }
    public function isBackupStaticProperties() : bool
    {
        return \true;
    }
    public function enabled() : ?bool
    {
        return $this->enabled;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Before extends \PHPUnit\Metadata\Metadata
{
    public function isBefore() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class BeforeClass extends \PHPUnit\Metadata\Metadata
{
    public function isBeforeClass() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class CodeCoverageIgnore extends \PHPUnit\Metadata\Metadata
{
    public function isCodeCoverageIgnore() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Covers extends \PHPUnit\Metadata\Metadata
{
    private string $target;
    public function __construct(string $target)
    {
        $this->target = $target;
    }
    public function isCovers() : bool
    {
        return \true;
    }
    public function target() : string
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class CoversClass extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    public function isCoversClass() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    /**
     * @psalm-return class-string
     */
    public function asStringForCodeUnitMapper() : string
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class CoversDefaultClass extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    public function isCoversDefaultClass() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class CoversFunction extends \PHPUnit\Metadata\Metadata
{
    private string $functionName;
    public function __construct(string $functionName)
    {
        $this->functionName = $functionName;
    }
    public function isCoversFunction() : bool
    {
        return \true;
    }
    public function functionName() : string
    {
        return $this->functionName;
    }
    public function asStringForCodeUnitMapper() : string
    {
        return '::' . $this->functionName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class CoversMethod extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    public function isCoversMethod() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
    public function asStringForCodeUnitMapper() : string
    {
        return $this->className . '::' . $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class CoversNothing extends \PHPUnit\Metadata\Metadata
{
    public function isCoversNothing() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class DataProvider extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    public function isDataProvider() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Depends extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    private bool $deepClone;
    private bool $shallowClone;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName, bool $deepClone, bool $shallowClone)
    {
        $this->className = $className;
        $this->methodName = $methodName;
        $this->deepClone = $deepClone;
        $this->shallowClone = $shallowClone;
    }
    public function isDepends() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
    public function deepClone() : bool
    {
        return $this->deepClone;
    }
    public function shallowClone() : bool
    {
        return $this->shallowClone;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class DoesNotPerformAssertions extends \PHPUnit\Metadata\Metadata
{
    public function isDoesNotPerformAssertions() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

interface Exception extends \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use RuntimeException;
final class InvalidVersionRequirementException extends \RuntimeException implements \PHPUnit\Metadata\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use RuntimeException;
final class NoVersionRequirementException extends \RuntimeException implements \PHPUnit\Metadata\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function assert;
use function count;
use function in_array;
use function interface_exists;
use function sprintf;
use function strpos;
use PHPUnit\Framework\CodeCoverageException;
use PHPUnit\Framework\ErrorTestCase;
use PHPUnit\Framework\IncompleteTestCase;
use PHPUnit\Framework\InvalidCoversTargetException;
use PHPUnit\Framework\SkippedTestCase;
use PHPUnit\Framework\WarningTestCase;
use PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection;
use PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException;
use PHPUnit\SebastianBergmann\CodeUnit\Mapper;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CodeCoverageFacade
{
    /**
     * @throws CodeCoverageException
     *
     * @return array|bool
     * @psalm-param class-string $className
     */
    public function linesToBeCovered(string $className, string $methodName)
    {
        if (!$this->shouldCodeCoverageBeCollectedFor($className, $methodName)) {
            return \false;
        }
        $metadataForClass = \PHPUnit\Metadata\Registry::parser()->forClass($className);
        $classShortcut = null;
        if ($metadataForClass->isCoversDefaultClass()->isNotEmpty()) {
            if (\count($metadataForClass->isCoversDefaultClass()) > 1) {
                throw new \PHPUnit\Framework\CodeCoverageException(\sprintf('More than one @coversDefaultClass annotation for class or interface "%s"', $className));
            }
            $classShortcut = $metadataForClass->isCoversDefaultClass()->asArray()[0]->className();
        }
        $codeUnits = \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromArray([]);
        $mapper = new \PHPUnit\SebastianBergmann\CodeUnit\Mapper();
        foreach (\PHPUnit\Metadata\Registry::parser()->forClassAndMethod($className, $methodName) as $metadata) {
            if ($metadata->isCoversClass() || $metadata->isCoversMethod() || $metadata->isCoversFunction()) {
                \assert($metadata instanceof \PHPUnit\Metadata\CoversClass || $metadata instanceof \PHPUnit\Metadata\CoversMethod || $metadata instanceof \PHPUnit\Metadata\CoversFunction);
                try {
                    $codeUnits = $codeUnits->mergeWith($mapper->stringToCodeUnits($metadata->asStringForCodeUnitMapper()));
                } catch (\PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException $e) {
                    if ($metadata->isCoversClass()) {
                        $type = 'Class';
                    } elseif ($metadata->isCoversMethod()) {
                        $type = 'Method';
                    } else {
                        $type = 'Function';
                    }
                    throw new \PHPUnit\Framework\InvalidCoversTargetException(\sprintf('%s "%s" is not a valid target for code coverage', $type, $metadata->asStringForCodeUnitMapper()), (int) $e->getCode(), $e);
                }
            } elseif ($metadata->isCovers()) {
                \assert($metadata instanceof \PHPUnit\Metadata\Covers);
                $target = $metadata->target();
                if (\interface_exists($target)) {
                    throw new \PHPUnit\Framework\InvalidCoversTargetException(\sprintf('Trying to @cover interface "%s".', $target));
                }
                if ($classShortcut !== null && \strpos($target, '::') === 0) {
                    $target = $classShortcut . $target;
                }
                try {
                    $codeUnits = $codeUnits->mergeWith($mapper->stringToCodeUnits($target));
                } catch (\PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException $e) {
                    throw new \PHPUnit\Framework\InvalidCoversTargetException(\sprintf('"@covers %s" is invalid', $target), (int) $e->getCode(), $e);
                }
            }
        }
        return $mapper->codeUnitsToSourceLines($codeUnits);
    }
    /**
     * Returns lines of code specified with the @uses annotation.
     *
     * @throws CodeCoverageException
     * @psalm-param class-string $className
     */
    public function linesToBeUsed(string $className, string $methodName) : array
    {
        $metadataForClass = \PHPUnit\Metadata\Registry::parser()->forClass($className);
        $classShortcut = null;
        if ($metadataForClass->isUsesDefaultClass()->isNotEmpty()) {
            if (\count($metadataForClass->isUsesDefaultClass()) > 1) {
                throw new \PHPUnit\Framework\CodeCoverageException(\sprintf('More than one @usesDefaultClass annotation for class or interface "%s"', $className));
            }
            $classShortcut = $metadataForClass->isUsesDefaultClass()->asArray()[0]->className();
        }
        $codeUnits = \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromArray([]);
        $mapper = new \PHPUnit\SebastianBergmann\CodeUnit\Mapper();
        foreach (\PHPUnit\Metadata\Registry::parser()->forClassAndMethod($className, $methodName) as $metadata) {
            if ($metadata->isUsesClass() || $metadata->isUsesMethod() || $metadata->isUsesFunction()) {
                \assert($metadata instanceof \PHPUnit\Metadata\UsesClass || $metadata instanceof \PHPUnit\Metadata\UsesMethod || $metadata instanceof \PHPUnit\Metadata\UsesFunction);
                try {
                    $codeUnits = $codeUnits->mergeWith($mapper->stringToCodeUnits($metadata->asStringForCodeUnitMapper()));
                } catch (\PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException $e) {
                    if ($metadata->isUsesClass()) {
                        $type = 'Class';
                    } elseif ($metadata->isUsesMethod()) {
                        $type = 'Method';
                    } else {
                        $type = 'Function';
                    }
                    throw new \PHPUnit\Framework\InvalidCoversTargetException(\sprintf('%s "%s" is not a valid target for code coverage', $type, $metadata->asStringForCodeUnitMapper()), (int) $e->getCode(), $e);
                }
            } elseif ($metadata->isUses()) {
                \assert($metadata instanceof \PHPUnit\Metadata\Uses);
                $target = $metadata->target();
                if ($classShortcut !== null && \strpos($target, '::') === 0) {
                    $target = $classShortcut . $target;
                }
                try {
                    $codeUnits = $codeUnits->mergeWith($mapper->stringToCodeUnits($target));
                } catch (\PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException $e) {
                    throw new \PHPUnit\Framework\InvalidCoversTargetException(\sprintf('"@uses %s" is invalid', $target), (int) $e->getCode(), $e);
                }
            }
        }
        return $mapper->codeUnitsToSourceLines($codeUnits);
    }
    /**
     * @psalm-param class-string $className
     */
    public function shouldCodeCoverageBeCollectedFor(string $className, string $methodName) : bool
    {
        if (\in_array($className, [\PHPUnit\Framework\ErrorTestCase::class, \PHPUnit\Framework\IncompleteTestCase::class, \PHPUnit\Framework\SkippedTestCase::class, \PHPUnit\Framework\WarningTestCase::class], \true)) {
            return \false;
        }
        $metadataForClass = \PHPUnit\Metadata\Registry::parser()->forClass($className);
        $metadataForMethod = \PHPUnit\Metadata\Registry::parser()->forMethod($className, $methodName);
        // If there is no @covers annotation but a @coversNothing annotation on
        // the test method then code coverage data does not need to be collected
        if ($metadataForMethod->isCoversNothing()->isNotEmpty()) {
            return \false;
        }
        // If there is at least one @covers annotation then
        // code coverage data needs to be collected
        if ($metadataForMethod->isCovers()->isNotEmpty() || $metadataForMethod->isCoversClass()->isNotEmpty() || $metadataForMethod->isCoversMethod()->isNotEmpty() || $metadataForMethod->isCoversFunction()->isNotEmpty()) {
            return \true;
        }
        // If there is no @covers annotation but a @coversNothing annotation
        // then code coverage data does not need to be collected
        if ($metadataForClass->isCoversNothing()->isNotEmpty()) {
            return \false;
        }
        // If there is no @coversNothing annotation then
        // code coverage data may be collected
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function array_key_exists;
use function array_merge;
use function assert;
use function explode;
use function is_array;
use function is_int;
use function preg_match;
use function preg_replace;
use function rtrim;
use function sprintf;
use function str_replace;
use function substr;
use function trim;
use PHPUnit\Framework\InvalidDataProviderException;
use PHPUnit\Framework\SkippedTestError;
use PHPUnit\Util\InvalidDataSetException;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;
use Traversable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class DataProviderFacade
{
    /**
     * @psalm-param class-string $className
     *
     * @throws Exception
     */
    public function providedData(string $className, string $methodName) : ?array
    {
        $dataProvider = \PHPUnit\Metadata\Registry::parser()->forMethod($className, $methodName)->isDataProvider();
        $testWith = \PHPUnit\Metadata\Registry::parser()->forMethod($className, $methodName)->isTestWith();
        if ($dataProvider->isEmpty() && $testWith->isEmpty()) {
            return $this->dataProvidedByTestWithAnnotation($className, $methodName);
        }
        if ($dataProvider->isNotEmpty()) {
            $data = $this->dataProvidedByMethods($dataProvider);
        } else {
            $data = $this->dataProvidedByMetadata($testWith);
        }
        if ($data === []) {
            throw new \PHPUnit\Framework\SkippedTestError('Skipped due to empty data set provided by data provider');
        }
        foreach ($data as $key => $value) {
            if (!\is_array($value)) {
                throw new \PHPUnit\Util\InvalidDataSetException(\sprintf('Data set %s is invalid.', \is_int($key) ? '#' . $key : '"' . $key . '"'));
            }
        }
        return $data;
    }
    private function dataProvidedByMethods(\PHPUnit\Metadata\MetadataCollection $dataProvider) : array
    {
        $result = [];
        foreach ($dataProvider as $_dataProvider) {
            \assert($_dataProvider instanceof \PHPUnit\Metadata\DataProvider);
            try {
                $class = new \ReflectionClass($_dataProvider->className());
                $method = $class->getMethod($_dataProvider->methodName());
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Framework\InvalidDataProviderException($e->getMessage(), (int) $e->getCode(), $e);
                // @codeCoverageIgnoreEnd
            }
            if ($method->isStatic()) {
                $object = null;
            } else {
                $object = $class->newInstanceWithoutConstructor();
            }
            if ($method->getNumberOfParameters() === 0) {
                $data = $method->invoke($object);
            } else {
                $data = $method->invoke($object, $_dataProvider->methodName());
            }
            if ($data instanceof \Traversable) {
                $origData = $data;
                $data = [];
                foreach ($origData as $key => $value) {
                    if (\is_int($key)) {
                        $data[] = $value;
                    } elseif (\array_key_exists($key, $data)) {
                        throw new \PHPUnit\Framework\InvalidDataProviderException(\sprintf('The key "%s" has already been defined by a previous data provider', $key));
                    } else {
                        $data[$key] = $value;
                    }
                }
            }
            if (\is_array($data)) {
                $result = \array_merge($result, $data);
            }
        }
        return $result;
    }
    private function dataProvidedByMetadata(\PHPUnit\Metadata\MetadataCollection $testWith) : array
    {
        $result = [];
        foreach ($testWith as $_testWith) {
            \assert($_testWith instanceof \PHPUnit\Metadata\TestWith);
            $result[] = $_testWith->data();
        }
        return $result;
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws Exception
     */
    private function dataProvidedByTestWithAnnotation(string $className, string $methodName) : ?array
    {
        $docComment = (new \ReflectionMethod($className, $methodName))->getDocComment();
        if (!$docComment) {
            return null;
        }
        $docComment = \str_replace("\r\n", "\n", $docComment);
        $docComment = \preg_replace('/' . '\\n' . '\\s*' . '\\*' . '\\s?' . '/', "\n", $docComment);
        $docComment = (string) \substr($docComment, 0, -1);
        $docComment = \rtrim($docComment, "\n");
        if (!\preg_match('/@testWith\\s+/', $docComment, $matches, \PREG_OFFSET_CAPTURE)) {
            return null;
        }
        $offset = \strlen($matches[0][0]) + $matches[0][1];
        $annotationContent = \substr($docComment, $offset);
        $data = [];
        foreach (\explode("\n", $annotationContent) as $candidateRow) {
            $candidateRow = \trim($candidateRow);
            if ($candidateRow[0] !== '[') {
                break;
            }
            $dataSet = \json_decode($candidateRow, \true);
            if (\json_last_error() !== \JSON_ERROR_NONE) {
                throw new \PHPUnit\Framework\InvalidDataProviderException('The data set for the @testWith annotation cannot be parsed: ' . \json_last_error_msg());
            }
            $data[] = $dataSet;
        }
        if (!$data) {
            throw new \PHPUnit\Framework\InvalidDataProviderException('The data set for the @testWith annotation cannot be parsed.');
        }
        return $data;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function array_flip;
use function array_unique;
use function assert;
use function strtolower;
use function trim;
use PHPUnit\Framework\TestSize\TestSize;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class GroupsFacade
{
    /**
     * @psalm-param class-string $className
     */
    public function groups(string $className, string $methodName) : array
    {
        $groups = [];
        foreach (\PHPUnit\Metadata\Registry::parser()->forClassAndMethod($className, $methodName) as $metadata) {
            \assert($metadata instanceof \PHPUnit\Metadata\Metadata);
            if ($metadata->isGroup()) {
                \assert($metadata instanceof \PHPUnit\Metadata\Group);
                $groups[] = $metadata->groupName();
            }
            if ($metadata->isCoversClass() || $metadata->isCoversMethod() || $metadata->isCoversFunction()) {
                \assert($metadata instanceof \PHPUnit\Metadata\CoversClass || $metadata instanceof \PHPUnit\Metadata\CoversMethod || $metadata instanceof \PHPUnit\Metadata\CoversFunction);
                $groups[] = '__phpunit_covers_' . self::canonicalizeName($metadata->asStringForCodeUnitMapper());
            }
            if ($metadata->isCovers()) {
                \assert($metadata instanceof \PHPUnit\Metadata\Covers);
                $groups[] = '__phpunit_covers_' . self::canonicalizeName($metadata->target());
            }
            if ($metadata->isUsesClass() || $metadata->isUsesMethod() || $metadata->isUsesFunction()) {
                \assert($metadata instanceof \PHPUnit\Metadata\UsesClass || $metadata instanceof \PHPUnit\Metadata\UsesMethod || $metadata instanceof \PHPUnit\Metadata\UsesFunction);
                $groups[] = '__phpunit_uses_' . self::canonicalizeName($metadata->asStringForCodeUnitMapper());
            }
            if ($metadata->isUses()) {
                \assert($metadata instanceof \PHPUnit\Metadata\Uses);
                $groups[] = '__phpunit_uses_' . self::canonicalizeName($metadata->target());
            }
        }
        return \array_unique($groups);
    }
    /**
     * @psalm-param class-string $className
     */
    public function size(string $className, string $methodName) : \PHPUnit\Framework\TestSize\TestSize
    {
        $groups = \array_flip($this->groups($className, $methodName));
        if (isset($groups['large'])) {
            return \PHPUnit\Framework\TestSize\TestSize::large();
        }
        if (isset($groups['medium'])) {
            return \PHPUnit\Framework\TestSize\TestSize::medium();
        }
        if (isset($groups['small'])) {
            return \PHPUnit\Framework\TestSize\TestSize::small();
        }
        return \PHPUnit\Framework\TestSize\TestSize::unknown();
    }
    private static function canonicalizeName(string $name) : string
    {
        return \strtolower(\trim($name, '\\'));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function array_unshift;
use function class_exists;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\TestCase;
use ReflectionClass;
use ReflectionException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class HookFacade
{
    private static array $hookMethods = [];
    /**
     * @psalm-param class-string $className
     */
    public function hookMethods(string $className) : array
    {
        if (!\class_exists($className, \false)) {
            return self::emptyHookMethodsArray();
        }
        if (isset(self::$hookMethods[$className])) {
            return self::$hookMethods[$className];
        }
        self::$hookMethods[$className] = self::emptyHookMethodsArray();
        try {
            foreach ((new \ReflectionClass($className))->getMethods() as $method) {
                if ($method->getDeclaringClass()->getName() === \PHPUnit\Framework\Assert::class) {
                    continue;
                }
                if ($method->getDeclaringClass()->getName() === \PHPUnit\Framework\TestCase::class) {
                    continue;
                }
                $metadata = \PHPUnit\Metadata\Registry::parser()->forMethod($className, $method->getName());
                if ($method->isStatic()) {
                    if ($metadata->isBeforeClass()->isNotEmpty()) {
                        \array_unshift(self::$hookMethods[$className]['beforeClass'], $method->getName());
                    }
                    if ($metadata->isAfterClass()->isNotEmpty()) {
                        self::$hookMethods[$className]['afterClass'][] = $method->getName();
                    }
                }
                if ($metadata->isBefore()->isNotEmpty()) {
                    \array_unshift(self::$hookMethods[$className]['before'], $method->getName());
                }
                if ($metadata->isPreCondition()->isNotEmpty()) {
                    \array_unshift(self::$hookMethods[$className]['preCondition'], $method->getName());
                }
                if ($metadata->isPostCondition()->isNotEmpty()) {
                    self::$hookMethods[$className]['postCondition'][] = $method->getName();
                }
                if ($metadata->isAfter()->isNotEmpty()) {
                    self::$hookMethods[$className]['after'][] = $method->getName();
                }
            }
        } catch (\ReflectionException $e) {
        }
        return self::$hookMethods[$className];
    }
    private static function emptyHookMethodsArray() : array
    {
        return ['beforeClass' => ['setUpBeforeClass'], 'before' => ['setUp'], 'preCondition' => ['assertPreConditions'], 'postCondition' => ['assertPostConditions'], 'after' => ['tearDown'], 'afterClass' => ['tearDownAfterClass']];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use const PHP_OS;
use const PHP_OS_FAMILY;
use const PHP_VERSION;
use function addcslashes;
use function assert;
use function extension_loaded;
use function function_exists;
use function ini_get;
use function method_exists;
use function phpversion;
use function preg_match;
use function sprintf;
use PHPUnit\Runner\Version;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RequirementsFacade
{
    /**
     * @psalm-param class-string $className
     *
     * @psalm-return list<string>
     */
    public function requirementsNotSatisfiedFor(string $className, string $methodName) : array
    {
        $notSatisfied = [];
        foreach (\PHPUnit\Metadata\Registry::parser()->forClassAndMethod($className, $methodName) as $metadata) {
            if ($metadata->isRequiresPhp()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresPhp);
                if (!$metadata->versionRequirement()->isSatisfiedBy(\PHP_VERSION)) {
                    $notSatisfied[] = \sprintf('PHP %s is required.', $metadata->versionRequirement()->asString());
                }
            }
            if ($metadata->isRequiresPhpExtension()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresPhpExtension);
                if (!\extension_loaded($metadata->extension()) || $metadata->hasVersionRequirement() && !$metadata->versionRequirement()->isSatisfiedBy(\phpversion($metadata->extension()))) {
                    $notSatisfied[] = \sprintf('PHP extension %s%s is required.', $metadata->extension(), $metadata->hasVersionRequirement() ? ' ' . $metadata->versionRequirement()->asString() : '');
                }
            }
            if ($metadata->isRequiresPhpunit()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresPhpunit);
                if (!$metadata->versionRequirement()->isSatisfiedBy(\PHPUnit\Runner\Version::id())) {
                    $notSatisfied[] = \sprintf('PHPUnit %s is required.', $metadata->versionRequirement()->asString());
                }
            }
            if ($metadata->isRequiresOperatingSystemFamily()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresOperatingSystemFamily);
                if ($metadata->operatingSystemFamily() !== \PHP_OS_FAMILY) {
                    $notSatisfied[] = \sprintf('Operating system %s is required.', $metadata->operatingSystemFamily());
                }
            }
            if ($metadata->isRequiresOperatingSystem()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresOperatingSystem);
                $pattern = \sprintf('/%s/i', \addcslashes($metadata->operatingSystem(), '/'));
                if (!\preg_match($pattern, \PHP_OS)) {
                    $notSatisfied[] = \sprintf('Operating system %s is required.', $metadata->operatingSystem());
                }
            }
            if ($metadata->isRequiresFunction()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresFunction);
                if (!\function_exists($metadata->functionName())) {
                    $notSatisfied[] = \sprintf('Function %s() is required.', $metadata->functionName());
                }
            }
            if ($metadata->isRequiresMethod()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresMethod);
                if (!\method_exists($metadata->className(), $metadata->methodName())) {
                    $notSatisfied[] = \sprintf('Method %s::%s() is required.', $metadata->className(), $metadata->methodName());
                }
            }
            if ($metadata->isRequiresSetting()) {
                \assert($metadata instanceof \PHPUnit\Metadata\RequiresSetting);
                if (\ini_get($metadata->setting()) !== $metadata->value()) {
                    $notSatisfied[] = \sprintf('Setting "%s" is required to be "%s".', $metadata->setting(), $metadata->value());
                }
            }
        }
        return $notSatisfied;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Group extends \PHPUnit\Metadata\Metadata
{
    private string $groupName;
    public function __construct(string $groupName)
    {
        $this->groupName = $groupName;
    }
    public function isGroup() : bool
    {
        return \true;
    }
    public function groupName() : string
    {
        return $this->groupName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
abstract class Metadata
{
    /**
     * @psalm-assert-if-true After $this
     */
    public function isAfter() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true AfterClass $this
     */
    public function isAfterClass() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true BackupGlobals $this
     */
    public function isBackupGlobals() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true BackupStaticProperties $this
     */
    public function isBackupStaticProperties() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true BeforeClass $this
     */
    public function isBeforeClass() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Before $this
     */
    public function isBefore() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true CodeCoverageIgnore $this
     */
    public function isCodeCoverageIgnore() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Covers $this
     */
    public function isCovers() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true CoversClass $this
     */
    public function isCoversClass() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true CoversDefaultClass $this
     */
    public function isCoversDefaultClass() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true CoversMethod $this
     */
    public function isCoversMethod() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true CoversFunction $this
     */
    public function isCoversFunction() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true CoversNothing $this
     */
    public function isCoversNothing() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true DataProvider $this
     */
    public function isDataProvider() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Depends $this
     */
    public function isDepends() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true DoesNotPerformAssertions $this
     */
    public function isDoesNotPerformAssertions() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Group $this
     */
    public function isGroup() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RunClassInSeparateProcess $this
     */
    public function isRunClassInSeparateProcess() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RunInSeparateProcess $this
     */
    public function isRunInSeparateProcess() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RunTestsInSeparateProcesses $this
     */
    public function isRunTestsInSeparateProcesses() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Test $this
     */
    public function isTest() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true PreCondition $this
     */
    public function isPreCondition() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true PostCondition $this
     */
    public function isPostCondition() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true PreserveGlobalState $this
     */
    public function isPreserveGlobalState() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresMethod $this
     */
    public function isRequiresMethod() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresFunction $this
     */
    public function isRequiresFunction() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresOperatingSystem $this
     */
    public function isRequiresOperatingSystem() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresOperatingSystemFamily $this
     */
    public function isRequiresOperatingSystemFamily() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresPhp $this
     */
    public function isRequiresPhp() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresPhpExtension $this
     */
    public function isRequiresPhpExtension() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresPhpunit $this
     */
    public function isRequiresPhpunit() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true RequiresSetting $this
     */
    public function isRequiresSetting() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true TestDox $this
     */
    public function isTestDox() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true TestWith $this
     */
    public function isTestWith() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Todo $this
     */
    public function isTodo() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true Uses $this
     */
    public function isUses() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true UsesClass $this
     */
    public function isUsesClass() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true UsesDefaultClass $this
     */
    public function isUsesDefaultClass() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true UsesMethod $this
     */
    public function isUsesMethod() : bool
    {
        return \false;
    }
    /**
     * @psalm-assert-if-true UsesFunction $this
     */
    public function isUsesFunction() : bool
    {
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function array_filter;
use function array_merge;
use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class MetadataCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var Metadata[]
     */
    private array $metadata;
    /**
     * @param Metadata[] $metadata
     */
    public static function fromArray(array $metadata) : self
    {
        return new self(...$metadata);
    }
    private function __construct(\PHPUnit\Metadata\Metadata ...$metadata)
    {
        $this->metadata = $metadata;
    }
    /**
     * @return Metadata[]
     */
    public function asArray() : array
    {
        return $this->metadata;
    }
    public function count() : int
    {
        return \count($this->metadata);
    }
    public function isEmpty() : bool
    {
        return $this->count() === 0;
    }
    public function isNotEmpty() : bool
    {
        return $this->count() > 0;
    }
    public function getIterator() : \PHPUnit\Metadata\MetadataCollectionIterator
    {
        return new \PHPUnit\Metadata\MetadataCollectionIterator($this);
    }
    public function mergeWith(self $other) : self
    {
        return new self(...\array_merge($this->asArray(), $other->asArray()));
    }
    public function isAfter() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isAfter();
        }));
    }
    public function isAfterClass() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isAfterClass();
        }));
    }
    public function isBackupGlobals() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isBackupGlobals();
        }));
    }
    public function isBackupStaticProperties() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isBackupStaticProperties();
        }));
    }
    public function isBeforeClass() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isBeforeClass();
        }));
    }
    public function isBefore() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isBefore();
        }));
    }
    public function isCodeCoverageIgnore() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isCodeCoverageIgnore();
        }));
    }
    public function isCovers() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isCovers();
        }));
    }
    public function isCoversClass() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isCoversClass();
        }));
    }
    public function isCoversDefaultClass() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isCoversDefaultClass();
        }));
    }
    public function isCoversMethod() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isCoversMethod();
        }));
    }
    public function isCoversFunction() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isCoversFunction();
        }));
    }
    public function isCoversNothing() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isCoversNothing();
        }));
    }
    public function isDataProvider() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isDataProvider();
        }));
    }
    public function isDepends() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isDepends();
        }));
    }
    public function isDoesNotPerformAssertions() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isDoesNotPerformAssertions();
        }));
    }
    public function isGroup() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isGroup();
        }));
    }
    public function isRunClassInSeparateProcess() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRunClassInSeparateProcess();
        }));
    }
    public function isRunInSeparateProcess() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRunInSeparateProcess();
        }));
    }
    public function isRunTestsInSeparateProcesses() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRunTestsInSeparateProcesses();
        }));
    }
    public function isTest() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isTest();
        }));
    }
    public function isPreCondition() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isPreCondition();
        }));
    }
    public function isPostCondition() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isPostCondition();
        }));
    }
    public function isPreserveGlobalState() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isPreserveGlobalState();
        }));
    }
    public function isRequiresMethod() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresMethod();
        }));
    }
    public function isRequiresFunction() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresFunction();
        }));
    }
    public function isRequiresOperatingSystem() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresOperatingSystem();
        }));
    }
    public function isRequiresOperatingSystemFamily() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresOperatingSystemFamily();
        }));
    }
    public function isRequiresPhp() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresPhp();
        }));
    }
    public function isRequiresPhpExtension() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresPhpExtension();
        }));
    }
    public function isRequiresPhpunit() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresPhpunit();
        }));
    }
    public function isRequiresSetting() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isRequiresSetting();
        }));
    }
    public function isTestDox() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isTestDox();
        }));
    }
    public function isTestWith() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isTestWith();
        }));
    }
    public function isTodo() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isTodo();
        }));
    }
    public function isUses() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isUses();
        }));
    }
    public function isUsesClass() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isUsesClass();
        }));
    }
    public function isUsesDefaultClass() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isUsesDefaultClass();
        }));
    }
    public function isUsesMethod() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isUsesMethod();
        }));
    }
    public function isUsesFunction() : self
    {
        return new self(...\array_filter($this->metadata, static function (\PHPUnit\Metadata\Metadata $metadata) : bool {
            return $metadata->isUsesFunction();
        }));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function count;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MetadataCollectionIterator implements \Iterator
{
    /**
     * @var Metadata[]
     */
    private array $metadata;
    private int $position = 0;
    public function __construct(\PHPUnit\Metadata\MetadataCollection $metadata)
    {
        $this->metadata = $metadata->asArray();
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->metadata);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\Metadata\Metadata
    {
        return $this->metadata[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata\Annotation;

use function array_filter;
use function array_map;
use function array_merge;
use function array_values;
use function count;
use function file;
use function preg_match;
use function preg_match_all;
use function preg_split;
use function realpath;
use function substr;
use function trim;
use PHPUnit\PharIo\Version\VersionConstraintParser;
use PHPUnit\Framework\Warning;
use ReflectionClass;
use ReflectionFunctionAbstract;
use ReflectionMethod;
use Reflector;
/**
 * This is an abstraction around a PHPUnit-specific docBlock,
 * allowing us to ask meaningful questions about a specific
 * reflection symbol.
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class DocBlock
{
    /**
     * @todo This constant should be private (it's public because of TestTest::testGetProvidedDataRegEx)
     */
    public const REGEX_DATA_PROVIDER = '/@dataProvider\\s+([a-zA-Z0-9._:-\\\\x7f-\\xff]+)/';
    private const REGEX_REQUIRES_VERSION = '/@requires\\s+(?P<name>PHP(?:Unit)?)\\s+(?P<operator>[<>=!]{0,2})\\s*(?P<version>[\\d\\.-]+(dev|(RC|alpha|beta)[\\d\\.])?)[ \\t]*\\r?$/m';
    private const REGEX_REQUIRES_VERSION_CONSTRAINT = '/@requires\\s+(?P<name>PHP(?:Unit)?)\\s+(?P<constraint>[\\d\\t \\-.|~^]+)[ \\t]*\\r?$/m';
    private const REGEX_REQUIRES_OS = '/@requires\\s+(?P<name>OS(?:FAMILY)?)\\s+(?P<value>.+?)[ \\t]*\\r?$/m';
    private const REGEX_REQUIRES_SETTING = '/@requires\\s+(?P<name>setting)\\s+(?P<setting>([^ ]+?))\\s*(?P<value>[\\w\\.-]+[\\w\\.]?)?[ \\t]*\\r?$/m';
    private const REGEX_REQUIRES = '/@requires\\s+(?P<name>function|extension)\\s+(?P<value>([^\\s<>=!]+))\\s*(?P<operator>[<>=!]{0,2})\\s*(?P<version>[\\d\\.-]+[\\d\\.]?)?[ \\t]*\\r?$/m';
    private const REGEX_TEST_WITH = '/@testWith\\s+/';
    private string $docComment;
    private bool $isMethod;
    /** @var array<string, array<int, string>> pre-parsed annotations indexed by name and occurrence index */
    private array $symbolAnnotations;
    /**
     * @var null|array<string, mixed>
     *
     * @psalm-var null|(array{
     *   __OFFSET: array<string, int>&array{__FILE: string},
     *   setting?: array<string, string>,
     *   extension_versions?: array<string, array{version: string, operator: string}>
     * }&array<
     *   string,
     *   string|array{version: string, operator: string}|array{constraint: string}|array<int|string, string>
     * >)
     */
    private ?array $parsedRequirements = null;
    private int $startLine;
    private int $endLine;
    private string $fileName;
    private string $name;
    /**
     * @psalm-var class-string
     */
    private string $className;
    public static function ofClass(\ReflectionClass $class) : self
    {
        $className = $class->getName();
        return new self((string) $class->getDocComment(), \false, self::extractAnnotationsFromReflector($class), $class->getStartLine(), $class->getEndLine(), $class->getFileName(), $className, $className);
    }
    /**
     * @psalm-param class-string $classNameInHierarchy
     */
    public static function ofMethod(\ReflectionMethod $method, string $classNameInHierarchy) : self
    {
        return new self((string) $method->getDocComment(), \true, self::extractAnnotationsFromReflector($method), $method->getStartLine(), $method->getEndLine(), $method->getFileName(), $method->getName(), $classNameInHierarchy);
    }
    /**
     * Note: we do not preserve an instance of the reflection object, since it cannot be safely (de-)serialized.
     *
     * @param array<string, array<int, string>> $symbolAnnotations
     *
     * @psalm-param class-string $className
     */
    private function __construct(string $docComment, bool $isMethod, array $symbolAnnotations, int $startLine, int $endLine, string $fileName, string $name, string $className)
    {
        $this->docComment = $docComment;
        $this->isMethod = $isMethod;
        $this->symbolAnnotations = $symbolAnnotations;
        $this->startLine = $startLine;
        $this->endLine = $endLine;
        $this->fileName = $fileName;
        $this->name = $name;
        $this->className = $className;
    }
    /**
     * @psalm-return array{
     *   __OFFSET: array<string, int>&array{__FILE: string},
     *   setting?: array<string, string>,
     *   extension_versions?: array<string, array{version: string, operator: string}>
     * }&array<
     *   string,
     *   string|array{version: string, operator: string}|array{constraint: string}|array<int|string, string>
     * >
     *
     * @throws Warning if the requirements version constraint is not well-formed
     */
    public function requirements() : array
    {
        if ($this->parsedRequirements !== null) {
            return $this->parsedRequirements;
        }
        $offset = $this->startLine;
        $requires = [];
        $recordedSettings = [];
        $extensionVersions = [];
        $recordedOffsets = ['__FILE' => \realpath($this->fileName)];
        // Split docblock into lines and rewind offset to start of docblock
        $lines = \preg_split('/\\r\\n|\\r|\\n/', $this->docComment);
        $offset -= \count($lines);
        foreach ($lines as $line) {
            if (\preg_match(self::REGEX_REQUIRES_OS, $line, $matches)) {
                $requires[$matches['name']] = $matches['value'];
                $recordedOffsets[$matches['name']] = $offset;
            }
            if (\preg_match(self::REGEX_REQUIRES_VERSION, $line, $matches)) {
                $requires[$matches['name']] = ['version' => $matches['version'], 'operator' => $matches['operator']];
                $recordedOffsets[$matches['name']] = $offset;
            }
            if (\preg_match(self::REGEX_REQUIRES_VERSION_CONSTRAINT, $line, $matches)) {
                if (!empty($requires[$matches['name']])) {
                    $offset++;
                    continue;
                }
                try {
                    $versionConstraintParser = new \PHPUnit\PharIo\Version\VersionConstraintParser();
                    $requires[$matches['name'] . '_constraint'] = ['constraint' => $versionConstraintParser->parse(\trim($matches['constraint']))];
                    $recordedOffsets[$matches['name'] . '_constraint'] = $offset;
                } catch (\PHPUnit\PharIo\Version\Exception $e) {
                    throw new \PHPUnit\Framework\Warning($e->getMessage(), $e->getCode(), $e);
                }
            }
            if (\preg_match(self::REGEX_REQUIRES_SETTING, $line, $matches)) {
                $recordedSettings[$matches['setting']] = $matches['value'];
                $recordedOffsets['__SETTING_' . $matches['setting']] = $offset;
            }
            if (\preg_match(self::REGEX_REQUIRES, $line, $matches)) {
                $name = $matches['name'] . 's';
                if (!isset($requires[$name])) {
                    $requires[$name] = [];
                }
                $requires[$name][] = $matches['value'];
                $recordedOffsets[$matches['name'] . '_' . $matches['value']] = $offset;
                if ($name === 'extensions' && !empty($matches['version'])) {
                    $extensionVersions[$matches['value']] = ['version' => $matches['version'], 'operator' => $matches['operator']];
                }
            }
            $offset++;
        }
        return $this->parsedRequirements = \array_merge($requires, ['__OFFSET' => $recordedOffsets], \array_filter(['setting' => $recordedSettings, 'extension_versions' => $extensionVersions]));
    }
    public function symbolAnnotations() : array
    {
        return $this->symbolAnnotations;
    }
    /** @return array<string, array<int, string>> */
    private static function parseDocBlock(string $docBlock) : array
    {
        // Strip away the docblock header and footer to ease parsing of one line annotations
        $docBlock = (string) \substr($docBlock, 3, -2);
        $annotations = [];
        if (\preg_match_all('/@(?P<name>[A-Za-z_-]+)(?:[ \\t]+(?P<value>.*?))?[ \\t]*\\r?$/m', $docBlock, $matches)) {
            $numMatches = \count($matches[0]);
            for ($i = 0; $i < $numMatches; $i++) {
                $annotations[$matches['name'][$i]][] = (string) $matches['value'][$i];
            }
        }
        return $annotations;
    }
    /** @param ReflectionClass|ReflectionFunctionAbstract $reflector */
    private static function extractAnnotationsFromReflector(\Reflector $reflector) : array
    {
        $annotations = [];
        if ($reflector instanceof \ReflectionClass) {
            $annotations = \array_merge($annotations, ...\array_map(static function (\ReflectionClass $trait) : array {
                return self::parseDocBlock((string) $trait->getDocComment());
            }, \array_values($reflector->getTraits())));
        }
        return \array_merge($annotations, self::parseDocBlock((string) $reflector->getDocComment()));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata\Annotation;

use function array_key_exists;
use PHPUnit\Util\Exception;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;
/**
 * Reflection information, and therefore DocBlock information, is static within
 * a single PHP process. It is therefore okay to use a Singleton registry here.
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Registry
{
    private static ?\PHPUnit\Metadata\Annotation\Registry $instance = null;
    /** @var array<string, DocBlock> indexed by class name */
    private array $classDocBlocks = [];
    /** @var array<string, array<string, DocBlock>> indexed by class name and method name */
    private array $methodDocBlocks = [];
    public static function getInstance() : self
    {
        return self::$instance ?? (self::$instance = new self());
    }
    private function __construct()
    {
    }
    /**
     * @throws Exception
     * @psalm-param class-string $class
     */
    public function forClassName(string $class) : \PHPUnit\Metadata\Annotation\DocBlock
    {
        if (\array_key_exists($class, $this->classDocBlocks)) {
            return $this->classDocBlocks[$class];
        }
        try {
            $reflection = new \ReflectionClass($class);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        return $this->classDocBlocks[$class] = \PHPUnit\Metadata\Annotation\DocBlock::ofClass($reflection);
    }
    /**
     * @throws Exception
     * @psalm-param class-string $classInHierarchy
     */
    public function forMethod(string $classInHierarchy, string $method) : \PHPUnit\Metadata\Annotation\DocBlock
    {
        if (isset($this->methodDocBlocks[$classInHierarchy][$method])) {
            return $this->methodDocBlocks[$classInHierarchy][$method];
        }
        try {
            $reflection = new \ReflectionMethod($classInHierarchy, $method);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        return $this->methodDocBlocks[$classInHierarchy][$method] = \PHPUnit\Metadata\Annotation\DocBlock::ofMethod($reflection, $classInHierarchy);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function array_merge;
use function explode;
use function method_exists;
use function strlen;
use function strpos;
use function substr;
use PHPUnit\Framework\Warning;
use PHPUnit\Metadata\Annotation\Registry as AnnotationRegistry;
use PHPUnit\Util\VersionComparisonOperator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class AnnotationParser implements \PHPUnit\Metadata\Parser
{
    /**
     * @psalm-param class-string $className
     *
     * @throws \PHPUnit\Util\Exception
     * @throws Warning
     */
    public function forClass(string $className) : \PHPUnit\Metadata\MetadataCollection
    {
        $result = [];
        foreach (\PHPUnit\Metadata\Annotation\Registry::getInstance()->forClassName($className)->symbolAnnotations() as $annotation => $values) {
            switch ($annotation) {
                case 'backupGlobals':
                    $result[] = new \PHPUnit\Metadata\BackupGlobals($this->stringToBool($values[0]));
                    break;
                case 'backupStaticAttributes':
                    $result[] = new \PHPUnit\Metadata\BackupStaticProperties($this->stringToBool($values[0]));
                    break;
                case 'codeCoverageIgnore':
                    $result[] = new \PHPUnit\Metadata\CodeCoverageIgnore();
                    break;
                case 'covers':
                    foreach ($values as $value) {
                        $value = $this->cleanUpCoversOrUsesTarget($value);
                        $result[] = new \PHPUnit\Metadata\Covers($value);
                    }
                    break;
                case 'coversDefaultClass':
                    $result[] = new \PHPUnit\Metadata\CoversDefaultClass($values[0]);
                    break;
                case 'coversNothing':
                    $result[] = new \PHPUnit\Metadata\CoversNothing();
                    break;
                case 'doesNotPerformAssertions':
                    $result[] = new \PHPUnit\Metadata\DoesNotPerformAssertions();
                    break;
                case 'group':
                case 'ticket':
                    foreach ($values as $value) {
                        $result[] = new \PHPUnit\Metadata\Group($value);
                    }
                    break;
                case 'large':
                    $result[] = new \PHPUnit\Metadata\Group('large');
                    break;
                case 'medium':
                    $result[] = new \PHPUnit\Metadata\Group('medium');
                    break;
                case 'preserveGlobalState':
                    $result[] = new \PHPUnit\Metadata\PreserveGlobalState($this->stringToBool($values[0]));
                    break;
                case 'runClassInSeparateProcess':
                    $result[] = new \PHPUnit\Metadata\RunClassInSeparateProcess();
                    break;
                case 'runTestsInSeparateProcesses':
                    $result[] = new \PHPUnit\Metadata\RunTestsInSeparateProcesses();
                    break;
                case 'small':
                    $result[] = new \PHPUnit\Metadata\Group('small');
                    break;
                case 'testdox':
                    $result[] = new \PHPUnit\Metadata\TestDox($values[0]);
                    break;
                case 'todo':
                    $result[] = new \PHPUnit\Metadata\Todo();
                    break;
                case 'uses':
                    foreach ($values as $value) {
                        $value = $this->cleanUpCoversOrUsesTarget($value);
                        $result[] = new \PHPUnit\Metadata\Uses($value);
                    }
                    break;
                case 'usesDefaultClass':
                    $result[] = new \PHPUnit\Metadata\UsesDefaultClass($values[0]);
                    break;
            }
        }
        $result = \array_merge($result, $this->parseRequirements(\PHPUnit\Metadata\Annotation\Registry::getInstance()->forClassName($className)->requirements()));
        return \PHPUnit\Metadata\MetadataCollection::fromArray($result);
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws \PHPUnit\Util\Exception
     * @throws Warning
     */
    public function forMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        $result = [];
        foreach (\PHPUnit\Metadata\Annotation\Registry::getInstance()->forMethod($className, $methodName)->symbolAnnotations() as $annotation => $values) {
            switch ($annotation) {
                case 'after':
                    $result[] = new \PHPUnit\Metadata\After();
                    break;
                case 'afterClass':
                    $result[] = new \PHPUnit\Metadata\AfterClass();
                    break;
                case 'backupGlobals':
                    $result[] = new \PHPUnit\Metadata\BackupGlobals($this->stringToBool($values[0]));
                    break;
                case 'backupStaticAttributes':
                    $result[] = new \PHPUnit\Metadata\BackupStaticProperties($this->stringToBool($values[0]));
                    break;
                case 'before':
                    $result[] = new \PHPUnit\Metadata\Before();
                    break;
                case 'beforeClass':
                    $result[] = new \PHPUnit\Metadata\BeforeClass();
                    break;
                case 'codeCoverageIgnore':
                    $result[] = new \PHPUnit\Metadata\CodeCoverageIgnore();
                    break;
                case 'covers':
                    foreach ($values as $value) {
                        $value = $this->cleanUpCoversOrUsesTarget($value);
                        $result[] = new \PHPUnit\Metadata\Covers($value);
                    }
                    break;
                case 'coversNothing':
                    $result[] = new \PHPUnit\Metadata\CoversNothing();
                    break;
                case 'dataProvider':
                    foreach ($values as $value) {
                        if (\strpos($value, '::') !== \false) {
                            $result[] = new \PHPUnit\Metadata\DataProvider(...\explode('::', $value));
                            continue;
                        }
                        $result[] = new \PHPUnit\Metadata\DataProvider($className, $value);
                    }
                    break;
                case 'depends':
                    foreach ($values as $value) {
                        $deepClone = \false;
                        $shallowClone = \false;
                        if (\strpos($value, 'clone ') === 0) {
                            $deepClone = \true;
                            $value = \substr($value, \strlen('clone '));
                        } elseif (\strpos($value, 'shallowClone ') === 0) {
                            $shallowClone = \true;
                            $value = \substr($value, \strlen('shallowClone '));
                        }
                        if (\strpos($value, '::') !== \false) {
                            [$className, $methodName] = \explode('::', $value);
                            $result[] = new \PHPUnit\Metadata\Depends($className, $methodName, $deepClone, $shallowClone);
                            continue;
                        }
                        $result[] = new \PHPUnit\Metadata\Depends($className, $value, $deepClone, $shallowClone);
                    }
                    break;
                case 'doesNotPerformAssertions':
                    $result[] = new \PHPUnit\Metadata\DoesNotPerformAssertions();
                    break;
                case 'group':
                case 'ticket':
                    foreach ($values as $value) {
                        $result[] = new \PHPUnit\Metadata\Group($value);
                    }
                    break;
                case 'large':
                    $result[] = new \PHPUnit\Metadata\Group('large');
                    break;
                case 'medium':
                    $result[] = new \PHPUnit\Metadata\Group('medium');
                    break;
                case 'postCondition':
                    $result[] = new \PHPUnit\Metadata\PostCondition();
                    break;
                case 'preCondition':
                    $result[] = new \PHPUnit\Metadata\PreCondition();
                    break;
                case 'preserveGlobalState':
                    $result[] = new \PHPUnit\Metadata\PreserveGlobalState($this->stringToBool($values[0]));
                    break;
                case 'runInSeparateProcess':
                    $result[] = new \PHPUnit\Metadata\RunInSeparateProcess();
                    break;
                case 'small':
                    $result[] = new \PHPUnit\Metadata\Group('small');
                    break;
                case 'test':
                    $result[] = new \PHPUnit\Metadata\Test();
                    break;
                case 'testdox':
                    $result[] = new \PHPUnit\Metadata\TestDox($values[0]);
                    break;
                case 'todo':
                    $result[] = new \PHPUnit\Metadata\Todo();
                    break;
                case 'uses':
                    foreach ($values as $value) {
                        $value = $this->cleanUpCoversOrUsesTarget($value);
                        $result[] = new \PHPUnit\Metadata\Uses($value);
                    }
                    break;
            }
        }
        if (\method_exists($className, $methodName)) {
            $result = \array_merge($result, $this->parseRequirements(\PHPUnit\Metadata\Annotation\Registry::getInstance()->forMethod($className, $methodName)->requirements()));
        }
        return \PHPUnit\Metadata\MetadataCollection::fromArray($result);
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws \PHPUnit\Util\Exception
     * @throws Warning
     */
    public function forClassAndMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        return $this->forClass($className)->mergeWith($this->forMethod($className, $methodName));
    }
    private function stringToBool(string $value) : ?bool
    {
        if ($value === 'enabled') {
            return \true;
        }
        if ($value === 'disabled') {
            return \false;
        }
        return null;
    }
    private function cleanUpCoversOrUsesTarget(string $value) : string
    {
        $value = \preg_replace('/[\\s()]+$/', '', $value);
        return \explode(' ', $value, 2)[0];
    }
    /**
     * @psalm-return list<Metadata>
     */
    private function parseRequirements(array $requirements) : array
    {
        $result = [];
        if (!empty($requirements['PHP'])) {
            $result[] = new \PHPUnit\Metadata\RequiresPhp(new \PHPUnit\Metadata\VersionComparisonRequirement($requirements['PHP']['version'], new \PHPUnit\Util\VersionComparisonOperator(empty($requirements['PHP']['operator']) ? '>=' : $requirements['PHP']['operator'])));
        } elseif (!empty($requirements['PHP_constraint'])) {
            $result[] = new \PHPUnit\Metadata\RequiresPhp(new \PHPUnit\Metadata\VersionConstraintRequirement($requirements['PHP_constraint']['constraint']));
        }
        if (!empty($requirements['extensions'])) {
            foreach ($requirements['extensions'] as $extension) {
                if (isset($requirements['extension_versions'][$extension])) {
                    continue;
                }
                $result[] = new \PHPUnit\Metadata\RequiresPhpExtension($extension, null);
            }
        }
        if (!empty($requirements['extension_versions'])) {
            foreach ($requirements['extension_versions'] as $extension => $version) {
                $result[] = new \PHPUnit\Metadata\RequiresPhpExtension($extension, new \PHPUnit\Metadata\VersionComparisonRequirement($version['version'], new \PHPUnit\Util\VersionComparisonOperator(empty($version['operator']) ? '>=' : $version['operator'])));
            }
        }
        if (!empty($requirements['PHPUnit'])) {
            $result[] = new \PHPUnit\Metadata\RequiresPhpunit(new \PHPUnit\Metadata\VersionComparisonRequirement($requirements['PHPUnit']['version'], new \PHPUnit\Util\VersionComparisonOperator(empty($requirements['PHPUnit']['operator']) ? '>=' : $requirements['PHPUnit']['operator'])));
        } elseif (!empty($requirements['PHPUnit_constraint'])) {
            $result[] = new \PHPUnit\Metadata\RequiresPhpunit(new \PHPUnit\Metadata\VersionConstraintRequirement($requirements['PHPUnit_constraint']['constraint']));
        }
        if (!empty($requirements['OSFAMILY'])) {
            $result[] = new \PHPUnit\Metadata\RequiresOperatingSystemFamily($requirements['OSFAMILY']);
        }
        if (!empty($requirements['OS'])) {
            $result[] = new \PHPUnit\Metadata\RequiresOperatingSystem($requirements['OS']);
        }
        if (!empty($requirements['functions'])) {
            foreach ($requirements['functions'] as $function) {
                $pieces = \explode('::', $function);
                if (\count($pieces) === 2) {
                    $result[] = new \PHPUnit\Metadata\RequiresMethod($pieces[0], $pieces[1]);
                } else {
                    $result[] = new \PHPUnit\Metadata\RequiresFunction($function);
                }
            }
        }
        if (!empty($requirements['setting'])) {
            foreach ($requirements['setting'] as $setting => $value) {
                $result[] = new \PHPUnit\Metadata\RequiresSetting($setting, $value);
            }
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use const JSON_THROW_ON_ERROR;
use function json_decode;
use function strpos;
use PHPUnit\Framework\Attributes\After as AfterAttribute;
use PHPUnit\Framework\Attributes\AfterClass as AfterClassAttribute;
use PHPUnit\Framework\Attributes\BackupGlobals as BackupGlobalsAttribute;
use PHPUnit\Framework\Attributes\BackupStaticProperties as BackupStaticPropertiesAttribute;
use PHPUnit\Framework\Attributes\Before as BeforeAttribute;
use PHPUnit\Framework\Attributes\BeforeClass as BeforeClassAttribute;
use PHPUnit\Framework\Attributes\CodeCoverageIgnore as CodeCoverageIgnoreAttribute;
use PHPUnit\Framework\Attributes\CoversClass as CoversClassAttribute;
use PHPUnit\Framework\Attributes\CoversFunction as CoversFunctionAttribute;
use PHPUnit\Framework\Attributes\CoversNothing as CoversNothingAttribute;
use PHPUnit\Framework\Attributes\DataProvider as DataProviderAttribute;
use PHPUnit\Framework\Attributes\DataProviderExternal as DataProviderExternalAttribute;
use PHPUnit\Framework\Attributes\Depends as DependsAttribute;
use PHPUnit\Framework\Attributes\DependsExternal as DependsExternalAttribute;
use PHPUnit\Framework\Attributes\DependsExternalUsingDeepClone as DependsExternalUsingDeepCloneAttribute;
use PHPUnit\Framework\Attributes\DependsExternalUsingShallowClone as DependsExternalUsingShallowCloneAttribute;
use PHPUnit\Framework\Attributes\DependsUsingDeepClone as DependsUsingDeepCloneAttribute;
use PHPUnit\Framework\Attributes\DependsUsingShallowClone as DependsUsingShallowCloneAttribute;
use PHPUnit\Framework\Attributes\DoesNotPerformAssertions as DoesNotPerformAssertionsAttribute;
use PHPUnit\Framework\Attributes\Group as GroupAttribute;
use PHPUnit\Framework\Attributes\Large as LargeAttribute;
use PHPUnit\Framework\Attributes\Medium as MediumAttribute;
use PHPUnit\Framework\Attributes\PostCondition as PostConditionAttribute;
use PHPUnit\Framework\Attributes\PreCondition as PreConditionAttribute;
use PHPUnit\Framework\Attributes\PreserveGlobalState as PreserveGlobalStateAttribute;
use PHPUnit\Framework\Attributes\RequiresFunction as RequiresFunctionAttribute;
use PHPUnit\Framework\Attributes\RequiresMethod as RequiresMethodAttribute;
use PHPUnit\Framework\Attributes\RequiresOperatingSystem as RequiresOperatingSystemAttribute;
use PHPUnit\Framework\Attributes\RequiresOperatingSystemFamily as RequiresOperatingSystemFamilyAttribute;
use PHPUnit\Framework\Attributes\RequiresPhp as RequiresPhpAttribute;
use PHPUnit\Framework\Attributes\RequiresPhpExtension as RequiresPhpExtensionAttribute;
use PHPUnit\Framework\Attributes\RequiresPhpunit as RequiresPhpunitAttribute;
use PHPUnit\Framework\Attributes\RequiresSetting as RequiresSettingAttribute;
use PHPUnit\Framework\Attributes\RunClassInSeparateProcess as RunClassInSeparateProcessAttribute;
use PHPUnit\Framework\Attributes\RunInSeparateProcess as RunInSeparateProcessAttribute;
use PHPUnit\Framework\Attributes\RunTestsInSeparateProcesses as RunTestsInSeparateProcessesAttribute;
use PHPUnit\Framework\Attributes\Small as SmallAttribute;
use PHPUnit\Framework\Attributes\Test as TestAttribute;
use PHPUnit\Framework\Attributes\TestDox as TestDoxAttribute;
use PHPUnit\Framework\Attributes\TestWith as TestWithAttribute;
use PHPUnit\Framework\Attributes\TestWithJson as TestWithJsonAttribute;
use PHPUnit\Framework\Attributes\Ticket as TicketAttribute;
use PHPUnit\Framework\Attributes\UsesClass as UsesClassAttribute;
use PHPUnit\Framework\Attributes\UsesFunction as UsesFunctionAttribute;
use ReflectionClass;
use ReflectionMethod;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class AttributeParser implements \PHPUnit\Metadata\Parser
{
    /**
     * @psalm-param class-string $className
     */
    public function forClass(string $className) : \PHPUnit\Metadata\MetadataCollection
    {
        $result = [];
        foreach ((new \ReflectionClass($className))->getAttributes() as $attribute) {
            if (\strpos($attribute->getName(), 'PHPUnit\\Framework\\Attributes\\') !== 0) {
                continue;
            }
            $attributeInstance = $attribute->newInstance();
            switch ($attribute->getName()) {
                case \PHPUnit\Framework\Attributes\BackupGlobals::class:
                    $result[] = new \PHPUnit\Metadata\BackupGlobals($attributeInstance->enabled());
                    break;
                case \PHPUnit\Framework\Attributes\BackupStaticProperties::class:
                    $result[] = new \PHPUnit\Metadata\BackupStaticProperties($attributeInstance->enabled());
                    break;
                case \PHPUnit\Framework\Attributes\CodeCoverageIgnore::class:
                    $result[] = new \PHPUnit\Metadata\CodeCoverageIgnore();
                    break;
                case \PHPUnit\Framework\Attributes\CoversClass::class:
                    $result[] = new \PHPUnit\Metadata\CoversClass($attributeInstance->className());
                    break;
                case \PHPUnit\Framework\Attributes\CoversFunction::class:
                    $result[] = new \PHPUnit\Metadata\CoversFunction($attributeInstance->functionName());
                    break;
                case \PHPUnit\Framework\Attributes\CoversNothing::class:
                    $result[] = new \PHPUnit\Metadata\CoversNothing();
                    break;
                case \PHPUnit\Framework\Attributes\DoesNotPerformAssertions::class:
                    $result[] = new \PHPUnit\Metadata\DoesNotPerformAssertions();
                    break;
                case \PHPUnit\Framework\Attributes\Group::class:
                    $result[] = new \PHPUnit\Metadata\Group($attributeInstance->name());
                    break;
                case \PHPUnit\Framework\Attributes\Large::class:
                    $result[] = new \PHPUnit\Metadata\Group('large');
                    break;
                case \PHPUnit\Framework\Attributes\Medium::class:
                    $result[] = new \PHPUnit\Metadata\Group('medium');
                    break;
                case \PHPUnit\Framework\Attributes\PreserveGlobalState::class:
                    $result[] = new \PHPUnit\Metadata\PreserveGlobalState($attributeInstance->enabled());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresMethod::class:
                    $result[] = new \PHPUnit\Metadata\RequiresMethod($attributeInstance->className(), $attributeInstance->methodName());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresFunction::class:
                    $result[] = new \PHPUnit\Metadata\RequiresFunction($attributeInstance->functionName());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresOperatingSystem::class:
                    $result[] = new \PHPUnit\Metadata\RequiresOperatingSystem($attributeInstance->regularExpression());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresOperatingSystemFamily::class:
                    $result[] = new \PHPUnit\Metadata\RequiresOperatingSystemFamily($attributeInstance->operatingSystemFamily());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresPhp::class:
                    $result[] = new \PHPUnit\Metadata\RequiresPhp(\PHPUnit\Metadata\VersionConstraintRequirement::from($attributeInstance->versionRequirement()));
                    break;
                case \PHPUnit\Framework\Attributes\RequiresPhpExtension::class:
                    $versionConstraint = null;
                    if ($attributeInstance->hasVersionRequirement()) {
                        $versionConstraint = \PHPUnit\Metadata\VersionConstraintRequirement::from($attributeInstance->versionRequirement());
                    }
                    $result[] = new \PHPUnit\Metadata\RequiresPhpExtension($attributeInstance->extension(), $versionConstraint);
                    break;
                case \PHPUnit\Framework\Attributes\RequiresPhpunit::class:
                    $result[] = new \PHPUnit\Metadata\RequiresPhpunit(\PHPUnit\Metadata\VersionConstraintRequirement::from($attributeInstance->versionRequirement()));
                    break;
                case \PHPUnit\Framework\Attributes\RequiresSetting::class:
                    $result[] = new \PHPUnit\Metadata\RequiresSetting($attributeInstance->setting(), $attributeInstance->value());
                    break;
                case \PHPUnit\Framework\Attributes\RunClassInSeparateProcess::class:
                    $result[] = new \PHPUnit\Metadata\RunClassInSeparateProcess();
                    break;
                case \PHPUnit\Framework\Attributes\RunTestsInSeparateProcesses::class:
                    $result[] = new \PHPUnit\Metadata\RunTestsInSeparateProcesses();
                    break;
                case \PHPUnit\Framework\Attributes\Small::class:
                    $result[] = new \PHPUnit\Metadata\Group('small');
                    break;
                case \PHPUnit\Framework\Attributes\TestDox::class:
                    $result[] = new \PHPUnit\Metadata\TestDox($attributeInstance->text());
                    break;
                case \PHPUnit\Framework\Attributes\Ticket::class:
                    $result[] = new \PHPUnit\Metadata\Group($attributeInstance->text());
                    break;
                case \PHPUnit\Framework\Attributes\UsesClass::class:
                    $result[] = new \PHPUnit\Metadata\UsesClass($attributeInstance->className());
                    break;
                case \PHPUnit\Framework\Attributes\UsesFunction::class:
                    $result[] = new \PHPUnit\Metadata\UsesFunction($attributeInstance->functionName());
                    break;
            }
        }
        return \PHPUnit\Metadata\MetadataCollection::fromArray($result);
    }
    /**
     * @psalm-param class-string $className
     */
    public function forMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        $result = [];
        foreach ((new \ReflectionMethod($className, $methodName))->getAttributes() as $attribute) {
            if (\strpos($attribute->getName(), 'PHPUnit\\Framework\\Attributes\\') !== 0) {
                continue;
            }
            $attributeInstance = $attribute->newInstance();
            switch ($attribute->getName()) {
                case \PHPUnit\Framework\Attributes\After::class:
                    $result[] = new \PHPUnit\Metadata\After();
                    break;
                case \PHPUnit\Framework\Attributes\AfterClass::class:
                    $result[] = new \PHPUnit\Metadata\AfterClass();
                    break;
                case \PHPUnit\Framework\Attributes\BackupGlobals::class:
                    $result[] = new \PHPUnit\Metadata\BackupGlobals($attributeInstance->enabled());
                    break;
                case \PHPUnit\Framework\Attributes\BackupStaticProperties::class:
                    $result[] = new \PHPUnit\Metadata\BackupStaticProperties($attributeInstance->enabled());
                    break;
                case \PHPUnit\Framework\Attributes\Before::class:
                    $result[] = new \PHPUnit\Metadata\Before();
                    break;
                case \PHPUnit\Framework\Attributes\BeforeClass::class:
                    $result[] = new \PHPUnit\Metadata\BeforeClass();
                    break;
                case \PHPUnit\Framework\Attributes\CodeCoverageIgnore::class:
                    $result[] = new \PHPUnit\Metadata\CodeCoverageIgnore();
                    break;
                case \PHPUnit\Framework\Attributes\CoversNothing::class:
                    $result[] = new \PHPUnit\Metadata\CoversNothing();
                    break;
                case \PHPUnit\Framework\Attributes\DataProvider::class:
                    $result[] = new \PHPUnit\Metadata\DataProvider($className, $attributeInstance->methodName());
                    break;
                case \PHPUnit\Framework\Attributes\DataProviderExternal::class:
                    $result[] = new \PHPUnit\Metadata\DataProvider($attributeInstance->className(), $attributeInstance->methodName());
                    break;
                case \PHPUnit\Framework\Attributes\Depends::class:
                    $result[] = new \PHPUnit\Metadata\Depends($className, $attributeInstance->methodName(), \false, \false);
                    break;
                case \PHPUnit\Framework\Attributes\DependsUsingDeepClone::class:
                    $result[] = new \PHPUnit\Metadata\Depends($className, $attributeInstance->methodName(), \true, \false);
                    break;
                case \PHPUnit\Framework\Attributes\DependsUsingShallowClone::class:
                    $result[] = new \PHPUnit\Metadata\Depends($className, $attributeInstance->methodName(), \false, \true);
                    break;
                case \PHPUnit\Framework\Attributes\DependsExternal::class:
                    $result[] = new \PHPUnit\Metadata\Depends($attributeInstance->className(), $attributeInstance->methodName(), \false, \false);
                    break;
                case \PHPUnit\Framework\Attributes\DependsExternalUsingDeepClone::class:
                    $result[] = new \PHPUnit\Metadata\Depends($attributeInstance->className(), $attributeInstance->methodName(), \true, \false);
                    break;
                case \PHPUnit\Framework\Attributes\DependsExternalUsingShallowClone::class:
                    $result[] = new \PHPUnit\Metadata\Depends($attributeInstance->className(), $attributeInstance->methodName(), \false, \true);
                    break;
                case \PHPUnit\Framework\Attributes\DoesNotPerformAssertions::class:
                    $result[] = new \PHPUnit\Metadata\DoesNotPerformAssertions();
                    break;
                case \PHPUnit\Framework\Attributes\Group::class:
                    $result[] = new \PHPUnit\Metadata\Group($attributeInstance->name());
                    break;
                case \PHPUnit\Framework\Attributes\PostCondition::class:
                    $result[] = new \PHPUnit\Metadata\PostCondition();
                    break;
                case \PHPUnit\Framework\Attributes\PreCondition::class:
                    $result[] = new \PHPUnit\Metadata\PreCondition();
                    break;
                case \PHPUnit\Framework\Attributes\PreserveGlobalState::class:
                    $result[] = new \PHPUnit\Metadata\PreserveGlobalState($attributeInstance->enabled());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresMethod::class:
                    $result[] = new \PHPUnit\Metadata\RequiresMethod($attributeInstance->className(), $attributeInstance->methodName());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresFunction::class:
                    $result[] = new \PHPUnit\Metadata\RequiresFunction($attributeInstance->functionName());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresOperatingSystem::class:
                    $result[] = new \PHPUnit\Metadata\RequiresOperatingSystem($attributeInstance->regularExpression());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresOperatingSystemFamily::class:
                    $result[] = new \PHPUnit\Metadata\RequiresOperatingSystemFamily($attributeInstance->operatingSystemFamily());
                    break;
                case \PHPUnit\Framework\Attributes\RequiresPhp::class:
                    $result[] = new \PHPUnit\Metadata\RequiresPhp(\PHPUnit\Metadata\VersionConstraintRequirement::from($attributeInstance->versionRequirement()));
                    break;
                case \PHPUnit\Framework\Attributes\RequiresPhpExtension::class:
                    $versionConstraint = null;
                    if ($attributeInstance->hasVersionRequirement()) {
                        $versionConstraint = \PHPUnit\Metadata\VersionConstraintRequirement::from($attributeInstance->versionRequirement());
                    }
                    $result[] = new \PHPUnit\Metadata\RequiresPhpExtension($attributeInstance->extension(), $versionConstraint);
                    break;
                case \PHPUnit\Framework\Attributes\RequiresPhpunit::class:
                    $result[] = new \PHPUnit\Metadata\RequiresPhpunit(\PHPUnit\Metadata\VersionConstraintRequirement::from($attributeInstance->versionRequirement()));
                    break;
                case \PHPUnit\Framework\Attributes\RequiresSetting::class:
                    $result[] = new \PHPUnit\Metadata\RequiresSetting($attributeInstance->setting(), $attributeInstance->value());
                    break;
                case \PHPUnit\Framework\Attributes\RunInSeparateProcess::class:
                    $result[] = new \PHPUnit\Metadata\RunInSeparateProcess();
                    break;
                case \PHPUnit\Framework\Attributes\Test::class:
                    $result[] = new \PHPUnit\Metadata\Test();
                    break;
                case \PHPUnit\Framework\Attributes\TestDox::class:
                    $result[] = new \PHPUnit\Metadata\TestDox($attributeInstance->text());
                    break;
                case \PHPUnit\Framework\Attributes\TestWith::class:
                    $result[] = new \PHPUnit\Metadata\TestWith($attributeInstance->data());
                    break;
                case \PHPUnit\Framework\Attributes\TestWithJson::class:
                    $result[] = new \PHPUnit\Metadata\TestWith(\json_decode($attributeInstance->json(), \true, 512, \JSON_THROW_ON_ERROR));
                    break;
                case \PHPUnit\Framework\Attributes\Ticket::class:
                    $result[] = new \PHPUnit\Metadata\Group($attributeInstance->text());
                    break;
            }
        }
        return \PHPUnit\Metadata\MetadataCollection::fromArray($result);
    }
    /**
     * @psalm-param class-string $className
     */
    public function forClassAndMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        return $this->forClass($className)->mergeWith($this->forMethod($className, $methodName));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CachingParser implements \PHPUnit\Metadata\Parser
{
    private \PHPUnit\Metadata\Parser $reader;
    private array $classCache = [];
    private array $methodCache = [];
    private array $classAndMethodCache = [];
    public function __construct(\PHPUnit\Metadata\Parser $reader)
    {
        $this->reader = $reader;
    }
    /**
     * @psalm-param class-string $className
     */
    public function forClass(string $className) : \PHPUnit\Metadata\MetadataCollection
    {
        if (isset($this->classCache[$className])) {
            return $this->classCache[$className];
        }
        $this->classCache[$className] = $this->reader->forClass($className);
        return $this->classCache[$className];
    }
    /**
     * @psalm-param class-string $className
     */
    public function forMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        $key = $className . '::' . $methodName;
        if (isset($this->methodCache[$key])) {
            return $this->methodCache[$key];
        }
        $this->methodCache[$key] = $this->reader->forMethod($className, $methodName);
        return $this->methodCache[$key];
    }
    /**
     * @psalm-param class-string $className
     */
    public function forClassAndMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        $key = $className . '::' . $methodName;
        if (isset($this->classAndMethodCache[$key])) {
            return $this->classAndMethodCache[$key];
        }
        $this->classAndMethodCache[$key] = $this->forClass($className)->mergeWith($this->forMethod($className, $methodName));
        return $this->classAndMethodCache[$key];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function array_slice;
use function file;
use function preg_match;
use function strtolower;
use ReflectionMethod;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InlineAnnotationParser
{
    /**
     * @psalm-param class-string $className
     *
     * @psalm-return array<string, array{line: int, value: string}>
     */
    public function parse(string $className, string $methodName) : array
    {
        $method = new \ReflectionMethod($className, $methodName);
        $lines = \file($method->getDeclaringClass()->getFileName());
        $lineNumber = $method->getStartLine();
        $startLine = $method->getStartLine() - 1;
        $endLine = $method->getEndLine() - 1;
        $lines = \array_slice($lines, $startLine, $endLine - $startLine + 1);
        $annotations = [];
        foreach ($lines as $line) {
            if (\preg_match('#/\\*\\*?\\s*@(?P<name>[A-Za-z_-]+)(?:[ \\t]+(?P<value>.*?))?[ \\t]*\\r?\\*/$#m', $line, $matches)) {
                $annotations[\strtolower($matches['name'])] = ['line' => $lineNumber, 'value' => $matches['value']];
            }
            $lineNumber++;
        }
        return $annotations;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Parser
{
    /**
     * @psalm-param class-string $className
     */
    public function forClass(string $className) : \PHPUnit\Metadata\MetadataCollection;
    /**
     * @psalm-param class-string $className
     */
    public function forMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection;
    /**
     * @psalm-param class-string $className
     */
    public function forClassAndMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ParserChain implements \PHPUnit\Metadata\Parser
{
    private \PHPUnit\Metadata\Parser $attributeReader;
    private \PHPUnit\Metadata\Parser $annotationReader;
    public function __construct(\PHPUnit\Metadata\Parser $attributeReader, \PHPUnit\Metadata\Parser $annotationReader)
    {
        $this->attributeReader = $attributeReader;
        $this->annotationReader = $annotationReader;
    }
    /**
     * @psalm-param class-string $className
     */
    public function forClass(string $className) : \PHPUnit\Metadata\MetadataCollection
    {
        $metadata = $this->attributeReader->forClass($className);
        if (!$metadata->isEmpty()) {
            return $metadata;
        }
        return $this->annotationReader->forClass($className);
    }
    /**
     * @psalm-param class-string $className
     */
    public function forMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        $metadata = $this->attributeReader->forMethod($className, $methodName);
        if (!$metadata->isEmpty()) {
            return $metadata;
        }
        return $this->annotationReader->forMethod($className, $methodName);
    }
    /**
     * @psalm-param class-string $className
     */
    public function forClassAndMethod(string $className, string $methodName) : \PHPUnit\Metadata\MetadataCollection
    {
        return $this->forClass($className)->mergeWith($this->forMethod($className, $methodName));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * Attribute and annotation information is static within a single PHP process.
 * It is therefore okay to use a Singleton registry here.
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Registry
{
    private static ?\PHPUnit\Metadata\Parser $instance = null;
    public static function parser() : \PHPUnit\Metadata\Parser
    {
        return self::$instance ?? (self::$instance = self::build());
    }
    private function __construct()
    {
    }
    private static function build() : \PHPUnit\Metadata\Parser
    {
        if (\PHP_MAJOR_VERSION >= 8) {
            return new \PHPUnit\Metadata\CachingParser(new \PHPUnit\Metadata\ParserChain(new \PHPUnit\Metadata\AttributeParser(), new \PHPUnit\Metadata\AnnotationParser()));
        }
        return new \PHPUnit\Metadata\CachingParser(new \PHPUnit\Metadata\AnnotationParser());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class PostCondition extends \PHPUnit\Metadata\Metadata
{
    public function isPostCondition() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class PreCondition extends \PHPUnit\Metadata\Metadata
{
    public function isPreCondition() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class PreserveGlobalState extends \PHPUnit\Metadata\Metadata
{
    private ?bool $enabled;
    public function __construct(?bool $enabled)
    {
        $this->enabled = $enabled;
    }
    public function isPreserveGlobalState() : bool
    {
        return \true;
    }
    public function enabled() : ?bool
    {
        return $this->enabled;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresFunction extends \PHPUnit\Metadata\Metadata
{
    private string $functionName;
    public function __construct(string $functionName)
    {
        $this->functionName = $functionName;
    }
    public function isRequiresFunction() : bool
    {
        return \true;
    }
    public function functionName() : string
    {
        return $this->functionName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresMethod extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    public function isrequiresMethod() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresOperatingSystem extends \PHPUnit\Metadata\Metadata
{
    private string $operatingSystem;
    public function __construct(string $operatingSystem)
    {
        $this->operatingSystem = $operatingSystem;
    }
    public function isRequiresOperatingSystem() : bool
    {
        return \true;
    }
    public function operatingSystem() : string
    {
        return $this->operatingSystem;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresOperatingSystemFamily extends \PHPUnit\Metadata\Metadata
{
    private string $operatingSystemFamily;
    public function __construct(string $operatingSystemFamily)
    {
        $this->operatingSystemFamily = $operatingSystemFamily;
    }
    public function isRequiresOperatingSystemFamily() : bool
    {
        return \true;
    }
    public function operatingSystemFamily() : string
    {
        return $this->operatingSystemFamily;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresPhp extends \PHPUnit\Metadata\Metadata
{
    private \PHPUnit\Metadata\VersionRequirement $versionRequirement;
    public function __construct(\PHPUnit\Metadata\VersionRequirement $versionRequirement)
    {
        $this->versionRequirement = $versionRequirement;
    }
    public function isRequiresPhp() : bool
    {
        return \true;
    }
    public function versionRequirement() : \PHPUnit\Metadata\VersionRequirement
    {
        return $this->versionRequirement;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresPhpExtension extends \PHPUnit\Metadata\Metadata
{
    private string $extension;
    private ?\PHPUnit\Metadata\VersionRequirement $versionRequirement;
    public function __construct(string $extension, ?\PHPUnit\Metadata\VersionRequirement $versionRequirement)
    {
        $this->extension = $extension;
        $this->versionRequirement = $versionRequirement;
    }
    public function isRequiresPhpExtension() : bool
    {
        return \true;
    }
    public function extension() : string
    {
        return $this->extension;
    }
    /**
     * @psalm-assert-if-true !null $this->versionRequirement
     */
    public function hasVersionRequirement() : bool
    {
        return $this->versionRequirement !== null;
    }
    /**
     * @throws NoVersionRequirementException
     */
    public function versionRequirement() : \PHPUnit\Metadata\VersionRequirement
    {
        if ($this->versionRequirement === null) {
            throw new \PHPUnit\Metadata\NoVersionRequirementException();
        }
        return $this->versionRequirement;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresPhpunit extends \PHPUnit\Metadata\Metadata
{
    private \PHPUnit\Metadata\VersionRequirement $versionRequirement;
    public function __construct(\PHPUnit\Metadata\VersionRequirement $versionRequirement)
    {
        $this->versionRequirement = $versionRequirement;
    }
    public function isRequiresPhpunit() : bool
    {
        return \true;
    }
    public function versionRequirement() : \PHPUnit\Metadata\VersionRequirement
    {
        return $this->versionRequirement;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RequiresSetting extends \PHPUnit\Metadata\Metadata
{
    private string $setting;
    private string $value;
    public function __construct(string $setting, string $value)
    {
        $this->setting = $setting;
        $this->value = $value;
    }
    public function isRequiresSetting() : bool
    {
        return \true;
    }
    public function setting() : string
    {
        return $this->setting;
    }
    public function value() : string
    {
        return $this->value;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RunClassInSeparateProcess extends \PHPUnit\Metadata\Metadata
{
    public function isRunClassInSeparateProcess() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RunInSeparateProcess extends \PHPUnit\Metadata\Metadata
{
    public function isRunInSeparateProcess() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class RunTestsInSeparateProcesses extends \PHPUnit\Metadata\Metadata
{
    public function isRunTestsInSeparateProcesses() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Test extends \PHPUnit\Metadata\Metadata
{
    public function isTest() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestDox extends \PHPUnit\Metadata\Metadata
{
    private string $text;
    public function __construct(string $text)
    {
        $this->text = $text;
    }
    public function isTestDox() : bool
    {
        return \true;
    }
    public function text() : string
    {
        return $this->text;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestWith extends \PHPUnit\Metadata\Metadata
{
    private array $data;
    public function __construct(array $data)
    {
        $this->data = $data;
    }
    public function isTestWith() : bool
    {
        return \true;
    }
    public function data() : array
    {
        return $this->data;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Todo extends \PHPUnit\Metadata\Metadata
{
    public function isTodo() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Uses extends \PHPUnit\Metadata\Metadata
{
    private string $target;
    public function __construct(string $target)
    {
        $this->target = $target;
    }
    public function isUses() : bool
    {
        return \true;
    }
    public function target() : string
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class UsesClass extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    public function isUsesClass() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    /**
     * @psalm-return class-string
     */
    public function asStringForCodeUnitMapper() : string
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class UsesDefaultClass extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className)
    {
        $this->className = $className;
    }
    public function isUsesDefaultClass() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class UsesFunction extends \PHPUnit\Metadata\Metadata
{
    private string $functionName;
    public function __construct(string $functionName)
    {
        $this->functionName = $functionName;
    }
    public function isUsesFunction() : bool
    {
        return \true;
    }
    public function functionName() : string
    {
        return $this->functionName;
    }
    public function asStringForCodeUnitMapper() : string
    {
        return '::' . $this->functionName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class UsesMethod extends \PHPUnit\Metadata\Metadata
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $methodName;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $methodName)
    {
        $this->className = $className;
        $this->methodName = $methodName;
    }
    public function isUsesMethod() : bool
    {
        return \true;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function methodName() : string
    {
        return $this->methodName;
    }
    public function asStringForCodeUnitMapper() : string
    {
        return $this->className . '::' . $this->methodName;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function version_compare;
use PHPUnit\Util\VersionComparisonOperator;
/**
 * @psalm-immutable
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class VersionComparisonRequirement extends \PHPUnit\Metadata\VersionRequirement
{
    private string $version;
    private \PHPUnit\Util\VersionComparisonOperator $operator;
    public function __construct(string $version, \PHPUnit\Util\VersionComparisonOperator $operator)
    {
        $this->version = $version;
        $this->operator = $operator;
    }
    public function isSatisfiedBy(string $version) : bool
    {
        return \version_compare($version, $this->version, $this->operator->asString());
    }
    public function asString() : string
    {
        return $this->operator->asString() . ' ' . $this->version;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use PHPUnit\PharIo\Version\Version;
use PHPUnit\PharIo\Version\VersionConstraint;
/**
 * @psalm-immutable
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class VersionConstraintRequirement extends \PHPUnit\Metadata\VersionRequirement
{
    private \PHPUnit\PharIo\Version\VersionConstraint $constraint;
    public function __construct(\PHPUnit\PharIo\Version\VersionConstraint $constraint)
    {
        $this->constraint = $constraint;
    }
    /**
     * @psalm-suppress ImpureMethodCall
     */
    public function isSatisfiedBy(string $version) : bool
    {
        return $this->constraint->complies(new \PHPUnit\PharIo\Version\Version($this->sanitize($version)));
    }
    /**
     * @psalm-suppress ImpureMethodCall
     */
    public function asString() : string
    {
        return $this->constraint->asString();
    }
    private function sanitize(string $version) : string
    {
        return \preg_replace('/^(\\d+\\.\\d+(?:.\\d+)?).*$/', '$1', $version);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Metadata;

use function preg_match;
use PHPUnit\PharIo\Version\UnsupportedVersionConstraintException;
use PHPUnit\PharIo\Version\VersionConstraintParser;
use PHPUnit\Util\VersionComparisonOperator;
/**
 * @psalm-immutable
 *
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
abstract class VersionRequirement
{
    private const VERSION_COMPARISON = '/(?P<operator>[<>=!]{0,2})\\s*(?P<version>[\\d\\.-]+(dev|(RC|alpha|beta)[\\d\\.])?)[ \\t]*\\r?$/m';
    /**
     * @throws InvalidVersionRequirementException
     */
    public static function from(string $versionRequirement) : self
    {
        try {
            return new \PHPUnit\Metadata\VersionConstraintRequirement((new \PHPUnit\PharIo\Version\VersionConstraintParser())->parse($versionRequirement));
        } catch (\PHPUnit\PharIo\Version\UnsupportedVersionConstraintException $e) {
            if (\preg_match(self::VERSION_COMPARISON, $versionRequirement, $matches)) {
                return new \PHPUnit\Metadata\VersionComparisonRequirement($matches['version'], new \PHPUnit\Util\VersionComparisonOperator(!empty($matches['operator']) ? $matches['operator'] : '>='));
            }
        }
        throw new \PHPUnit\Metadata\InvalidVersionRequirementException();
    }
    public abstract function isSatisfiedBy(string $version) : bool;
    public abstract function asString() : string;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use PHPUnit\Framework\TestCase;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\Selector;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CodeCoverage
{
    private static ?\PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage $instance = null;
    private static ?\PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver $driver = null;
    private static bool $collecting = \false;
    /**
     * @throws Exception
     */
    public static function activate(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter, bool $pathCoverage) : void
    {
        self::ensureIsNotActive();
        if ($pathCoverage) {
            self::$driver = (new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Selector())->forLineAndPathCoverage($filter);
        } else {
            self::$driver = (new \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Selector())->forLineCoverage($filter);
        }
        self::$instance = new \PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage(self::$driver, $filter);
    }
    /**
     * @throws Exception
     */
    public static function instance() : \PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage
    {
        self::ensureIsActive();
        return self::$instance;
    }
    /**
     * @throws Exception
     */
    public static function driver() : \PHPUnit\SebastianBergmann\CodeCoverage\Driver\Driver
    {
        self::ensureIsActive();
        return self::$driver;
    }
    /**
     * @throws Exception
     */
    public static function start(\PHPUnit\Framework\TestCase $test) : void
    {
        self::ensureIsActive();
        if (self::$collecting) {
            return;
        }
        self::$collecting = \true;
        self::$instance->start($test);
    }
    /**
     * @throws Exception
     */
    public static function stop(bool $append = \true, $linesToBeCovered = [], array $linesToBeUsed = []) : void
    {
        self::ensureIsActive();
        if (!self::$collecting) {
            return;
        }
        /* @noinspection UnusedFunctionResultInspection */
        self::$instance->stop($append, $linesToBeCovered, $linesToBeUsed);
        self::$collecting = \false;
    }
    public static function deactivate() : void
    {
        self::$driver = null;
        self::$instance = null;
    }
    public static function isActive() : bool
    {
        return self::$instance !== null;
    }
    /**
     * @throws Exception
     */
    private static function ensureIsActive() : void
    {
        if (self::$instance === null) {
            throw new \PHPUnit\Runner\Exception('Code Coverage has not been set up');
        }
    }
    /**
     * @throws Exception
     */
    private static function ensureIsNotActive() : void
    {
        if (self::$instance !== null) {
            throw new \PHPUnit\Runner\Exception('Code Coverage has not been set up');
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use const DIRECTORY_SEPARATOR;
use function array_keys;
use function dirname;
use function file_get_contents;
use function file_put_contents;
use function is_dir;
use function is_file;
use function sprintf;
use PHPUnit\Framework\TestStatus\TestStatus;
use PHPUnit\Util\Filesystem;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class DefaultTestResultCache implements \PHPUnit\Runner\TestResultCache
{
    /**
     * @var int
     */
    private const VERSION = 1;
    /**
     * @var string
     */
    private const DEFAULT_RESULT_CACHE_FILENAME = '.phpunit.result.cache';
    private string $cacheFilename;
    /**
     * @psalm-var array<string, TestStatus>
     */
    private array $defects = [];
    /**
     * @psalm-var array<string, float>
     */
    private array $times = [];
    public function __construct(?string $filepath = null)
    {
        if ($filepath !== null && \is_dir($filepath)) {
            $filepath .= \DIRECTORY_SEPARATOR . self::DEFAULT_RESULT_CACHE_FILENAME;
        }
        $this->cacheFilename = $filepath ?? $_ENV['PHPUNIT_RESULT_CACHE'] ?? self::DEFAULT_RESULT_CACHE_FILENAME;
    }
    public function setStatus(string $testName, \PHPUnit\Framework\TestStatus\TestStatus $status) : void
    {
        if ($status->isSuccess()) {
            return;
        }
        $this->defects[$testName] = $status;
    }
    public function status(string $testName) : \PHPUnit\Framework\TestStatus\TestStatus
    {
        return $this->defects[$testName] ?? \PHPUnit\Framework\TestStatus\TestStatus::unknown();
    }
    public function setTime(string $testName, float $time) : void
    {
        $this->times[$testName] = $time;
    }
    public function time(string $testName) : float
    {
        return $this->times[$testName] ?? 0.0;
    }
    public function load() : void
    {
        if (!\is_file($this->cacheFilename)) {
            return;
        }
        $data = \json_decode(\file_get_contents($this->cacheFilename), \true);
        if ($data === null) {
            return;
        }
        if (!isset($data['version'])) {
            return;
        }
        if ($data['version'] !== self::VERSION) {
            return;
        }
        \assert(isset($data['defects']) && \is_array($data['defects']));
        \assert(isset($data['times']) && \is_array($data['times']));
        foreach (\array_keys($data['defects']) as $test) {
            if ($data['defects'][$test] === 1) {
                $data['defects'][$test] = \PHPUnit\Framework\TestStatus\TestStatus::skipped();
            } elseif ($data['defects'][$test] === 2) {
                $data['defects'][$test] = \PHPUnit\Framework\TestStatus\TestStatus::incomplete();
            } elseif ($data['defects'][$test] === 3) {
                $data['defects'][$test] = \PHPUnit\Framework\TestStatus\TestStatus::failure();
            } elseif ($data['defects'][$test] === 4) {
                $data['defects'][$test] = \PHPUnit\Framework\TestStatus\TestStatus::error();
            } elseif ($data['defects'][$test] === 5) {
                $data['defects'][$test] = \PHPUnit\Framework\TestStatus\TestStatus::risky();
            } elseif ($data['defects'][$test] === 6) {
                $data['defects'][$test] = \PHPUnit\Framework\TestStatus\TestStatus::warning();
            }
        }
        $this->defects = $data['defects'];
        $this->times = $data['times'];
    }
    /**
     * @throws Exception
     */
    public function persist() : void
    {
        if (!\PHPUnit\Util\Filesystem::createDirectory(\dirname($this->cacheFilename))) {
            throw new \PHPUnit\Runner\Exception(\sprintf('Cannot create directory "%s" for result cache file', $this->cacheFilename));
        }
        $data = ['version' => self::VERSION, 'defects' => [], 'times' => $this->times];
        foreach ($this->defects as $test => $status) {
            if ($status->isSkipped()) {
                $data['defects'][$test] = 1;
            } elseif ($status->isIncomplete()) {
                $data['defects'][$test] = 2;
            } elseif ($status->isFailure()) {
                $data['defects'][$test] = 3;
            } elseif ($status->isError()) {
                $data['defects'][$test] = 4;
            } elseif ($status->isRisky()) {
                $data['defects'][$test] = 5;
            } elseif ($status->isWarning()) {
                $data['defects'][$test] = 6;
            }
        }
        \file_put_contents($this->cacheFilename, \json_encode($data), \LOCK_EX);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Exception extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner\Extension;

use function class_exists;
use function sprintf;
use PHPUnit\Runner\Exception;
use PHPUnit\Runner\Hook;
use PHPUnit\TextUI\TestRunner;
use PHPUnit\TextUI\XmlConfiguration\Extension;
use ReflectionClass;
use ReflectionException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ExtensionHandler
{
    /**
     * @throws Exception
     */
    public function registerExtension(\PHPUnit\TextUI\XmlConfiguration\Extension $extensionConfiguration, \PHPUnit\TextUI\TestRunner $runner) : void
    {
        $extension = $this->createInstance($extensionConfiguration);
        if (!$extension instanceof \PHPUnit\Runner\Hook) {
            throw new \PHPUnit\Runner\Exception(\sprintf('Class "%s" does not implement a PHPUnit\\Runner\\Hook interface', $extensionConfiguration->className()));
        }
        $runner->addExtension($extension);
    }
    /**
     * @throws Exception
     */
    private function createInstance(\PHPUnit\TextUI\XmlConfiguration\Extension $extensionConfiguration) : object
    {
        $this->ensureClassExists($extensionConfiguration);
        try {
            $reflector = new \ReflectionClass($extensionConfiguration->className());
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Runner\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        if (!$extensionConfiguration->hasArguments()) {
            return $reflector->newInstance();
        }
        return $reflector->newInstanceArgs($extensionConfiguration->arguments());
    }
    /**
     * @throws Exception
     */
    private function ensureClassExists(\PHPUnit\TextUI\XmlConfiguration\Extension $extensionConfiguration) : void
    {
        if (\class_exists($extensionConfiguration->className(), \false)) {
            return;
        }
        if ($extensionConfiguration->hasSourceFile()) {
            /**
             * @noinspection PhpIncludeInspection
             * @psalm-suppress UnresolvableInclude
             */
            require_once $extensionConfiguration->sourceFile();
        }
        if (!\class_exists($extensionConfiguration->className())) {
            throw new \PHPUnit\Runner\Exception(\sprintf('Class "%s" does not exist', $extensionConfiguration->className()));
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner\Extension;

use PHPUnit\PharIo\Manifest\ApplicationName;
use PHPUnit\PharIo\Manifest\Exception as ManifestException;
use PHPUnit\PharIo\Manifest\ManifestLoader;
use PHPUnit\PharIo\Version\Version as PharIoVersion;
use PHPUnit\Runner\Version;
use PHPUnit\SebastianBergmann\FileIterator\Facade as FileIteratorFacade;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class PharLoader
{
    /**
     * @psalm-return array{loadedExtensions: list<string>, notLoadedExtensions: list<string>}
     */
    public function loadPharExtensionsInDirectory(string $directory) : array
    {
        $loadedExtensions = [];
        $notLoadedExtensions = [];
        foreach ((new \PHPUnit\SebastianBergmann\FileIterator\Facade())->getFilesAsArray($directory, '.phar') as $file) {
            if (!\is_file('phar://' . $file . '/manifest.xml')) {
                $notLoadedExtensions[] = $file . ' is not an extension for PHPUnit';
                continue;
            }
            try {
                $applicationName = new \PHPUnit\PharIo\Manifest\ApplicationName('phpunit/phpunit');
                $version = new \PHPUnit\PharIo\Version\Version(\PHPUnit\Runner\Version::series());
                $manifest = \PHPUnit\PharIo\Manifest\ManifestLoader::fromFile('phar://' . $file . '/manifest.xml');
                if (!$manifest->isExtensionFor($applicationName)) {
                    $notLoadedExtensions[] = $file . ' is not an extension for PHPUnit';
                    continue;
                }
                if (!$manifest->isExtensionFor($applicationName, $version)) {
                    $notLoadedExtensions[] = $file . ' is not compatible with this version of PHPUnit';
                    continue;
                }
            } catch (\PHPUnit\PharIo\Manifest\Exception $e) {
                $notLoadedExtensions[] = $file . ': ' . $e->getMessage();
                continue;
            }
            /**
             * @noinspection PhpIncludeInspection
             * @psalm-suppress UnresolvableInclude
             */
            require $file;
            $loadedExtensions[] = $manifest->getName()->asString() . ' ' . $manifest->getVersion()->getVersionString();
        }
        return ['loadedExtensions' => $loadedExtensions, 'notLoadedExtensions' => $notLoadedExtensions];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner\Filter;

use function in_array;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ExcludeGroupFilterIterator extends \PHPUnit\Runner\Filter\GroupFilterIterator
{
    protected function doAccept(string $hash) : bool
    {
        return !\in_array($hash, $this->groupTests, \true);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner\Filter;

use function assert;
use function sprintf;
use FilterIterator;
use Iterator;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Runner\Exception;
use RecursiveFilterIterator;
use ReflectionClass;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Factory
{
    /**
     * @psalm-var array<int,array{0: \ReflectionClass, 1: array|string}>
     */
    private array $filters = [];
    /**
     * @param array|string $args
     *
     * @throws Exception
     */
    public function addFilter(\ReflectionClass $filter, $args) : void
    {
        if (!$filter->isSubclassOf(\RecursiveFilterIterator::class)) {
            throw new \PHPUnit\Runner\Exception(\sprintf('Class "%s" does not extend RecursiveFilterIterator', $filter->name));
        }
        $this->filters[] = [$filter, $args];
    }
    public function factory(\Iterator $iterator, \PHPUnit\Framework\TestSuite $suite) : \FilterIterator
    {
        foreach ($this->filters as $filter) {
            [$class, $args] = $filter;
            $iterator = $class->newInstance($iterator, $args, $suite);
        }
        \assert($iterator instanceof \FilterIterator);
        return $iterator;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner\Filter;

use function array_map;
use function array_merge;
use function in_array;
use function spl_object_hash;
use PHPUnit\Framework\TestSuite;
use RecursiveFilterIterator;
use RecursiveIterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
abstract class GroupFilterIterator extends \RecursiveFilterIterator
{
    /**
     * @var string[]
     */
    protected array $groupTests = [];
    public function __construct(\RecursiveIterator $iterator, array $groups, \PHPUnit\Framework\TestSuite $suite)
    {
        parent::__construct($iterator);
        foreach ($suite->getGroupDetails() as $group => $tests) {
            if (\in_array((string) $group, $groups, \true)) {
                $testHashes = \array_map('spl_object_hash', $tests);
                $this->groupTests = \array_merge($this->groupTests, $testHashes);
            }
        }
    }
    public function accept() : bool
    {
        $test = $this->getInnerIterator()->current();
        if ($test instanceof \PHPUnit\Framework\TestSuite) {
            return \true;
        }
        return $this->doAccept(\spl_object_hash($test));
    }
    protected abstract function doAccept(string $hash);
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner\Filter;

use function in_array;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class IncludeGroupFilterIterator extends \PHPUnit\Runner\Filter\GroupFilterIterator
{
    protected function doAccept(string $hash) : bool
    {
        return \in_array($hash, $this->groupTests, \true);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner\Filter;

use function end;
use function implode;
use function preg_match;
use function sprintf;
use function str_replace;
use Exception;
use PHPUnit\Framework\ErrorTestCase;
use PHPUnit\Framework\SelfDescribing;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\WarningTestCase;
use PHPUnit\Util\RegularExpression;
use RecursiveFilterIterator;
use RecursiveIterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class NameFilterIterator extends \RecursiveFilterIterator
{
    private ?string $filter = null;
    private ?int $filterMin = null;
    private ?int $filterMax = null;
    /**
     * @throws Exception
     */
    public function __construct(\RecursiveIterator $iterator, string $filter)
    {
        parent::__construct($iterator);
        $this->setFilter($filter);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function accept() : bool
    {
        $test = $this->getInnerIterator()->current();
        if ($test instanceof \PHPUnit\Framework\TestSuite) {
            return \true;
        }
        $tmp = $this->describe($test);
        if ($test instanceof \PHPUnit\Framework\ErrorTestCase || $test instanceof \PHPUnit\Framework\WarningTestCase) {
            $name = $test->getMessage();
        } elseif ($tmp[0] !== '') {
            $name = \implode('::', $tmp);
        } else {
            $name = $tmp[1];
        }
        $accepted = @\preg_match($this->filter, $name, $matches);
        if ($accepted && isset($this->filterMax)) {
            $set = \end($matches);
            $accepted = $set >= $this->filterMin && $set <= $this->filterMax;
        }
        return (bool) $accepted;
    }
    /**
     * @throws Exception
     */
    private function setFilter(string $filter) : void
    {
        if (\PHPUnit\Util\RegularExpression::safeMatch($filter, '') === \false) {
            // Handles:
            //  * testAssertEqualsSucceeds#4
            //  * testAssertEqualsSucceeds#4-8
            if (\preg_match('/^(.*?)#(\\d+)(?:-(\\d+))?$/', $filter, $matches)) {
                if (isset($matches[3]) && $matches[2] < $matches[3]) {
                    $filter = \sprintf('%s.*with data set #(\\d+)$', $matches[1]);
                    $this->filterMin = (int) $matches[2];
                    $this->filterMax = (int) $matches[3];
                } else {
                    $filter = \sprintf('%s.*with data set #%s$', $matches[1], $matches[2]);
                }
            } elseif (\preg_match('/^(.*?)@(.+)$/', $filter, $matches)) {
                $filter = \sprintf('%s.*with data set "%s"$', $matches[1], $matches[2]);
            }
            // Escape delimiters in regular expression. Do NOT use preg_quote,
            // to keep magic characters.
            $filter = \sprintf('/%s/i', \str_replace('/', '\\/', $filter));
        }
        $this->filter = $filter;
    }
    /**
     * @psalm-return array{0: string, 1: string}
     */
    private function describe(\PHPUnit\Framework\Test $test) : array
    {
        if ($test instanceof \PHPUnit\Framework\TestCase) {
            return [\get_class($test), $test->getName()];
        }
        if ($test instanceof \PHPUnit\Framework\SelfDescribing) {
            return ['', $test->toString()];
        }
        return ['', \get_class($test)];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterIncompleteTestHook extends \PHPUnit\Runner\TestHook
{
    public function executeAfterIncompleteTest(string $test, string $message, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterLastTestHook extends \PHPUnit\Runner\Hook
{
    public function executeAfterLastTest() : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterRiskyTestHook extends \PHPUnit\Runner\TestHook
{
    public function executeAfterRiskyTest(string $test, string $message, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterSkippedTestHook extends \PHPUnit\Runner\TestHook
{
    public function executeAfterSkippedTest(string $test, string $message, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterSuccessfulTestHook extends \PHPUnit\Runner\TestHook
{
    public function executeAfterSuccessfulTest(string $test, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterTestErrorHook extends \PHPUnit\Runner\TestHook
{
    public function executeAfterTestError(string $test, string $message, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterTestFailureHook extends \PHPUnit\Runner\TestHook
{
    public function executeAfterTestFailure(string $test, string $message, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterTestHook extends \PHPUnit\Runner\TestHook
{
    /**
     * This hook will fire after any test, regardless of the result.
     *
     * For more fine grained control, have a look at the other hooks
     * that extend PHPUnit\Runner\Hook.
     */
    public function executeAfterTest(string $test, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface AfterTestWarningHook extends \PHPUnit\Runner\TestHook
{
    public function executeAfterTestWarning(string $test, string $message, float $time) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface BeforeFirstTestHook extends \PHPUnit\Runner\Hook
{
    public function executeBeforeFirstTest() : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface BeforeTestHook extends \PHPUnit\Runner\TestHook
{
    public function executeBeforeTest(string $test) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface Hook
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
interface TestHook extends \PHPUnit\Runner\Hook
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\SelfDescribing;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestListener;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\Warning;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 *
 * @deprecated
 */
final class TestListenerAdapter implements \PHPUnit\Framework\TestListener
{
    /**
     * @var TestHook[]
     */
    private array $hooks = [];
    private ?bool $lastTestWasNotSuccessful = null;
    public function add(\PHPUnit\Runner\TestHook $hook) : void
    {
        $this->hooks[] = $hook;
    }
    public function startTest(\PHPUnit\Framework\Test $test) : void
    {
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\BeforeTestHook) {
                $hook->executeBeforeTest($this->describe($test));
            }
        }
        $this->lastTestWasNotSuccessful = \false;
    }
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\AfterTestErrorHook) {
                $hook->executeAfterTestError($this->describe($test), $t->getMessage(), $time);
            }
        }
        $this->lastTestWasNotSuccessful = \true;
    }
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\AfterTestWarningHook) {
                $hook->executeAfterTestWarning($this->describe($test), $e->getMessage(), $time);
            }
        }
        $this->lastTestWasNotSuccessful = \true;
    }
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\AfterTestFailureHook) {
                $hook->executeAfterTestFailure($this->describe($test), $e->getMessage(), $time);
            }
        }
        $this->lastTestWasNotSuccessful = \true;
    }
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\AfterIncompleteTestHook) {
                $hook->executeAfterIncompleteTest($this->describe($test), $t->getMessage(), $time);
            }
        }
        $this->lastTestWasNotSuccessful = \true;
    }
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\AfterRiskyTestHook) {
                $hook->executeAfterRiskyTest($this->describe($test), $t->getMessage(), $time);
            }
        }
        $this->lastTestWasNotSuccessful = \true;
    }
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\AfterSkippedTestHook) {
                $hook->executeAfterSkippedTest($this->describe($test), $t->getMessage(), $time);
            }
        }
        $this->lastTestWasNotSuccessful = \true;
    }
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        if (!$this->lastTestWasNotSuccessful) {
            foreach ($this->hooks as $hook) {
                if ($hook instanceof \PHPUnit\Runner\AfterSuccessfulTestHook) {
                    $hook->executeAfterSuccessfulTest($this->describe($test), $time);
                }
            }
        }
        foreach ($this->hooks as $hook) {
            if ($hook instanceof \PHPUnit\Runner\AfterTestHook) {
                $hook->executeAfterTest($this->describe($test), $time);
            }
        }
    }
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
    }
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
    }
    private function describe(\PHPUnit\Framework\Test $test) : string
    {
        if ($test instanceof \PHPUnit\Framework\SelfDescribing) {
            return $test->toString();
        }
        return \get_class($test);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use PHPUnit\Framework\TestStatus\TestStatus;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class NullTestResultCache implements \PHPUnit\Runner\TestResultCache
{
    public function setStatus(string $testName, \PHPUnit\Framework\TestStatus\TestStatus $status) : void
    {
    }
    public function status(string $testName) : \PHPUnit\Framework\TestStatus\TestStatus
    {
        return \PHPUnit\Framework\TestStatus\TestStatus::unknown();
    }
    public function setTime(string $testName, float $time) : void
    {
    }
    public function time(string $testName) : float
    {
        return 0;
    }
    public function load() : void
    {
    }
    public function persist() : void
    {
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use const DEBUG_BACKTRACE_IGNORE_ARGS;
use const DIRECTORY_SEPARATOR;
use function array_merge;
use function basename;
use function debug_backtrace;
use function defined;
use function dirname;
use function explode;
use function extension_loaded;
use function file;
use function file_get_contents;
use function file_put_contents;
use function is_array;
use function is_file;
use function is_readable;
use function is_string;
use function ltrim;
use function phpversion;
use function preg_match;
use function preg_replace;
use function preg_split;
use function realpath;
use function rtrim;
use function sprintf;
use function str_replace;
use function strncasecmp;
use function strpos;
use function substr;
use function trim;
use function unlink;
use function unserialize;
use function var_export;
use function version_compare;
use PHPUnit\Framework\Assert;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\ExecutionOrderDependency;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\IncompleteTestError;
use PHPUnit\Framework\PHPTAssertionFailedError;
use PHPUnit\Framework\Reorderable;
use PHPUnit\Framework\SelfDescribing;
use PHPUnit\Framework\SkippedTestError;
use PHPUnit\Framework\SyntheticSkippedError;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestResult;
use PHPUnit\Util\PHP\AbstractPhpProcess;
use PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData;
use PHPUnit\SebastianBergmann\Template\Template;
use PHPUnit\SebastianBergmann\Timer\Timer;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class PhptTestCase implements \PHPUnit\Framework\Reorderable, \PHPUnit\Framework\SelfDescribing, \PHPUnit\Framework\Test
{
    private string $filename;
    private \PHPUnit\Util\PHP\AbstractPhpProcess $phpUtil;
    private string $output = '';
    /**
     * Constructs a test case with the given filename.
     *
     * @throws Exception
     */
    public function __construct(string $filename, \PHPUnit\Util\PHP\AbstractPhpProcess $phpUtil = null)
    {
        if (!\is_file($filename)) {
            throw new \PHPUnit\Runner\Exception(\sprintf('File "%s" does not exist.', $filename));
        }
        $this->filename = $filename;
        $this->phpUtil = $phpUtil ?: \PHPUnit\Util\PHP\AbstractPhpProcess::factory();
    }
    /**
     * Counts the number of test cases executed by run(TestResult result).
     */
    public function count() : int
    {
        return 1;
    }
    /**
     * Runs a test and collects its result in a TestResult instance.
     *
     * @throws \SebastianBergmann\CodeCoverage\InvalidArgumentException
     * @throws \SebastianBergmann\CodeCoverage\UnintentionallyCoveredCodeException
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     */
    public function run(\PHPUnit\Framework\TestResult $result) : void
    {
        try {
            $sections = $this->parse();
        } catch (\PHPUnit\Runner\Exception $e) {
            $result->startTest($this);
            $result->addFailure($this, new \PHPUnit\Framework\SkippedTestError($e->getMessage()), 0);
            $result->endTest($this, 0);
            return;
        }
        $code = $this->render($sections['FILE']);
        $xfail = \false;
        $settings = $this->parseIniSection($this->settings(\PHPUnit\Runner\CodeCoverage::isActive()));
        $result->startTest($this);
        if (isset($sections['INI'])) {
            $settings = $this->parseIniSection($sections['INI'], $settings);
        }
        if (isset($sections['ENV'])) {
            $env = $this->parseEnvSection($sections['ENV']);
            $this->phpUtil->setEnv($env);
        }
        $this->phpUtil->setUseStderrRedirection(\true);
        if ($result->enforcesTimeLimit()) {
            $this->phpUtil->setTimeout($result->timeoutForLargeTests());
        }
        $skip = $this->runSkip($sections, $result, $settings);
        if ($skip) {
            return;
        }
        if (isset($sections['XFAIL'])) {
            $xfail = \trim($sections['XFAIL']);
        }
        if (isset($sections['STDIN'])) {
            $this->phpUtil->setStdin($sections['STDIN']);
        }
        if (isset($sections['ARGS'])) {
            $this->phpUtil->setArgs($sections['ARGS']);
        }
        if (\PHPUnit\Runner\CodeCoverage::isActive()) {
            $codeCoverageCacheDirectory = null;
            if (\PHPUnit\Runner\CodeCoverage::instance()->cachesStaticAnalysis()) {
                $codeCoverageCacheDirectory = \PHPUnit\Runner\CodeCoverage::instance()->cacheDirectory();
            }
            $this->renderForCoverage($code, \PHPUnit\Runner\CodeCoverage::instance()->collectsBranchAndPathCoverage(), $codeCoverageCacheDirectory);
        }
        $timer = new \PHPUnit\SebastianBergmann\Timer\Timer();
        $timer->start();
        $jobResult = $this->phpUtil->runJob($code, $this->stringifyIni($settings));
        $time = $timer->stop()->asSeconds();
        $this->output = $jobResult['stdout'] ?? '';
        if (\PHPUnit\Runner\CodeCoverage::isActive() && ($coverage = $this->cleanupForCoverage())) {
            \PHPUnit\Runner\CodeCoverage::instance()->append($coverage, $this, \true, [], []);
        }
        try {
            $this->assertPhptExpectation($sections, $this->output);
        } catch (\PHPUnit\Framework\AssertionFailedError $e) {
            $failure = $e;
            if ($xfail !== \false) {
                $failure = new \PHPUnit\Framework\IncompleteTestError($xfail, 0, $e);
            } elseif ($e instanceof \PHPUnit\Framework\ExpectationFailedException) {
                $comparisonFailure = $e->getComparisonFailure();
                if ($comparisonFailure) {
                    $diff = $comparisonFailure->getDiff();
                } else {
                    $diff = $e->getMessage();
                }
                $hint = $this->getLocationHintFromDiff($diff, $sections);
                $trace = \array_merge($hint, \debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS));
                $failure = new \PHPUnit\Framework\PHPTAssertionFailedError($e->getMessage(), 0, $trace[0]['file'], $trace[0]['line'], $trace, $comparisonFailure ? $diff : '');
            }
            $result->addFailure($this, $failure, $time);
        } catch (\Throwable $t) {
            $result->addError($this, $t, $time);
        }
        if ($xfail !== \false && $result->allCompletelyImplemented()) {
            $result->addFailure($this, new \PHPUnit\Framework\IncompleteTestError('XFAIL section but test passes'), $time);
        }
        $this->runClean($sections, \PHPUnit\Runner\CodeCoverage::isActive());
        $result->endTest($this, $time);
    }
    /**
     * Returns the name of the test case.
     */
    public function getName() : string
    {
        return $this->toString();
    }
    /**
     * Returns a string representation of the test case.
     */
    public function toString() : string
    {
        return $this->filename;
    }
    public function usesDataProvider() : bool
    {
        return \false;
    }
    public function numberOfAssertionsPerformed() : int
    {
        return 1;
    }
    public function output() : string
    {
        return $this->output;
    }
    public function hasOutput() : bool
    {
        return !empty($this->output);
    }
    public function sortId() : string
    {
        return $this->filename;
    }
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function provides() : array
    {
        return [];
    }
    /**
     * @return list<ExecutionOrderDependency>
     */
    public function requires() : array
    {
        return [];
    }
    /**
     * Parse --INI-- section key value pairs and return as array.
     *
     * @param array|string $content
     */
    private function parseIniSection($content, array $ini = []) : array
    {
        if (\is_string($content)) {
            $content = \explode("\n", \trim($content));
        }
        foreach ($content as $setting) {
            if (\strpos($setting, '=') === \false) {
                continue;
            }
            $setting = \explode('=', $setting, 2);
            $name = \trim($setting[0]);
            $value = \trim($setting[1]);
            if ($name === 'extension' || $name === 'zend_extension') {
                if (!isset($ini[$name])) {
                    $ini[$name] = [];
                }
                $ini[$name][] = $value;
                continue;
            }
            $ini[$name] = $value;
        }
        return $ini;
    }
    private function parseEnvSection(string $content) : array
    {
        $env = [];
        foreach (\explode("\n", \trim($content)) as $e) {
            $e = \explode('=', \trim($e), 2);
            if (!empty($e[0]) && isset($e[1])) {
                $env[$e[0]] = $e[1];
            }
        }
        return $env;
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     * @throws ExpectationFailedException
     */
    private function assertPhptExpectation(array $sections, string $output) : void
    {
        $assertions = ['EXPECT' => 'assertEquals', 'EXPECTF' => 'assertStringMatchesFormat', 'EXPECTREGEX' => 'assertMatchesRegularExpression'];
        $actual = \preg_replace('/\\r\\n/', "\n", \trim($output));
        foreach ($assertions as $sectionName => $sectionAssertion) {
            if (isset($sections[$sectionName])) {
                $sectionContent = \preg_replace('/\\r\\n/', "\n", \trim($sections[$sectionName]));
                $expected = $sectionName === 'EXPECTREGEX' ? "/{$sectionContent}/" : $sectionContent;
                if ($expected === '') {
                    throw new \PHPUnit\Runner\Exception('No PHPT expectation found');
                }
                \PHPUnit\Framework\Assert::$sectionAssertion($expected, $actual);
                return;
            }
        }
        throw new \PHPUnit\Runner\Exception('No PHPT assertion found');
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function runSkip(array &$sections, \PHPUnit\Framework\TestResult $result, array $settings) : bool
    {
        if (!isset($sections['SKIPIF'])) {
            return \false;
        }
        $skipif = $this->render($sections['SKIPIF']);
        $jobResult = $this->phpUtil->runJob($skipif, $this->stringifyIni($settings));
        if (!\strncasecmp('skip', \ltrim($jobResult['stdout']), 4)) {
            $message = '';
            if (\preg_match('/^\\s*skip\\s*(.+)\\s*/i', $jobResult['stdout'], $skipMatch)) {
                $message = \substr($skipMatch[1], 2);
            }
            $hint = $this->getLocationHint($message, $sections, 'SKIPIF');
            $trace = \array_merge($hint, \debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS));
            $result->addFailure($this, new \PHPUnit\Framework\SyntheticSkippedError($message, 0, $trace[0]['file'], $trace[0]['line'], $trace), 0);
            $result->endTest($this, 0);
            return \true;
        }
        return \false;
    }
    private function runClean(array &$sections, bool $collectCoverage) : void
    {
        $this->phpUtil->setStdin('');
        $this->phpUtil->setArgs('');
        if (isset($sections['CLEAN'])) {
            $cleanCode = $this->render($sections['CLEAN']);
            $this->phpUtil->runJob($cleanCode, $this->settings($collectCoverage));
        }
    }
    /**
     * @throws Exception
     */
    private function parse() : array
    {
        $sections = [];
        $section = '';
        $unsupportedSections = ['CGI', 'COOKIE', 'DEFLATE_POST', 'EXPECTHEADERS', 'EXTENSIONS', 'GET', 'GZIP_POST', 'HEADERS', 'PHPDBG', 'POST', 'POST_RAW', 'PUT', 'REDIRECTTEST', 'REQUEST'];
        $lineNr = 0;
        foreach (\file($this->filename) as $line) {
            $lineNr++;
            if (\preg_match('/^--([_A-Z]+)--/', $line, $result)) {
                $section = $result[1];
                $sections[$section] = '';
                $sections[$section . '_offset'] = $lineNr;
                continue;
            }
            if (empty($section)) {
                throw new \PHPUnit\Runner\Exception('Invalid PHPT file: empty section header');
            }
            $sections[$section] .= $line;
        }
        if (isset($sections['FILEEOF'])) {
            $sections['FILE'] = \rtrim($sections['FILEEOF'], "\r\n");
            unset($sections['FILEEOF']);
        }
        $this->parseExternal($sections);
        if (!$this->validate($sections)) {
            throw new \PHPUnit\Runner\Exception('Invalid PHPT file');
        }
        foreach ($unsupportedSections as $section) {
            if (isset($sections[$section])) {
                throw new \PHPUnit\Runner\Exception("PHPUnit does not support PHPT {$section} sections");
            }
        }
        return $sections;
    }
    /**
     * @throws Exception
     */
    private function parseExternal(array &$sections) : void
    {
        $allowSections = ['FILE', 'EXPECT', 'EXPECTF', 'EXPECTREGEX'];
        $testDirectory = \dirname($this->filename) . \DIRECTORY_SEPARATOR;
        foreach ($allowSections as $section) {
            if (isset($sections[$section . '_EXTERNAL'])) {
                $externalFilename = \trim($sections[$section . '_EXTERNAL']);
                if (!\is_file($testDirectory . $externalFilename) || !\is_readable($testDirectory . $externalFilename)) {
                    throw new \PHPUnit\Runner\Exception(\sprintf('Could not load --%s-- %s for PHPT file', $section . '_EXTERNAL', $testDirectory . $externalFilename));
                }
                $sections[$section] = \file_get_contents($testDirectory . $externalFilename);
            }
        }
    }
    private function validate(array &$sections) : bool
    {
        $requiredSections = ['FILE', ['EXPECT', 'EXPECTF', 'EXPECTREGEX']];
        foreach ($requiredSections as $section) {
            if (\is_array($section)) {
                $foundSection = \false;
                foreach ($section as $anySection) {
                    if (isset($sections[$anySection])) {
                        $foundSection = \true;
                        break;
                    }
                }
                if (!$foundSection) {
                    return \false;
                }
                continue;
            }
            if (!isset($sections[$section])) {
                return \false;
            }
        }
        return \true;
    }
    private function render(string $code) : string
    {
        return \str_replace(['__DIR__', '__FILE__'], ["'" . \dirname($this->filename) . "'", "'" . $this->filename . "'"], $code);
    }
    private function getCoverageFiles() : array
    {
        $baseDir = \dirname(\realpath($this->filename)) . \DIRECTORY_SEPARATOR;
        $basename = \basename($this->filename, 'phpt');
        return ['coverage' => $baseDir . $basename . 'coverage', 'job' => $baseDir . $basename . 'php'];
    }
    private function renderForCoverage(string &$job, bool $pathCoverage, ?string $codeCoverageCacheDirectory) : void
    {
        $files = $this->getCoverageFiles();
        $template = new \PHPUnit\SebastianBergmann\Template\Template(__DIR__ . '/../Util/PHP/Template/PhptTestCase.tpl');
        $composerAutoload = '\'\'';
        if (\defined('PHPUNIT_COMPOSER_INSTALL') && !\defined('PHPUNIT_TESTSUITE')) {
            $composerAutoload = \var_export(PHPUNIT_COMPOSER_INSTALL, \true);
        }
        $phar = '\'\'';
        if (\defined('__PHPUNIT_PHAR__')) {
            $phar = \var_export(__PHPUNIT_PHAR__, \true);
        }
        $globals = '';
        if (!empty($GLOBALS['__PHPUNIT_BOOTSTRAP'])) {
            $globals = '$GLOBALS[\'__PHPUNIT_BOOTSTRAP\'] = ' . \var_export($GLOBALS['__PHPUNIT_BOOTSTRAP'], \true) . ";\n";
        }
        if ($codeCoverageCacheDirectory === null) {
            $codeCoverageCacheDirectory = 'null';
        } else {
            $codeCoverageCacheDirectory = "'" . $codeCoverageCacheDirectory . "'";
        }
        $template->setVar(['composerAutoload' => $composerAutoload, 'phar' => $phar, 'globals' => $globals, 'job' => $files['job'], 'coverageFile' => $files['coverage'], 'driverMethod' => $pathCoverage ? 'forLineAndPathCoverage' : 'forLineCoverage', 'codeCoverageCacheDirectory' => $codeCoverageCacheDirectory]);
        \file_put_contents($files['job'], $job);
        $job = $template->render();
    }
    private function cleanupForCoverage() : \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData
    {
        $coverage = \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithoutPathCoverage([]);
        $files = $this->getCoverageFiles();
        if (\is_file($files['coverage'])) {
            $buffer = @\file_get_contents($files['coverage']);
            if ($buffer !== \false) {
                $coverage = @\unserialize($buffer);
                if ($coverage === \false) {
                    $coverage = \PHPUnit\SebastianBergmann\CodeCoverage\RawCodeCoverageData::fromXdebugWithoutPathCoverage([]);
                }
            }
        }
        foreach ($files as $file) {
            @\unlink($file);
        }
        return $coverage;
    }
    private function stringifyIni(array $ini) : array
    {
        $settings = [];
        foreach ($ini as $key => $value) {
            if (\is_array($value)) {
                foreach ($value as $val) {
                    $settings[] = $key . '=' . $val;
                }
                continue;
            }
            $settings[] = $key . '=' . $value;
        }
        return $settings;
    }
    private function getLocationHintFromDiff(string $message, array $sections) : array
    {
        $needle = '';
        $previousLine = '';
        $block = 'message';
        foreach (\preg_split('/\\r\\n|\\r|\\n/', $message) as $line) {
            $line = \trim($line);
            if ($block === 'message' && $line === '--- Expected') {
                $block = 'expected';
            }
            if ($block === 'expected' && $line === '@@ @@') {
                $block = 'diff';
            }
            if ($block === 'diff') {
                if (\strpos($line, '+') === 0) {
                    $needle = $this->getCleanDiffLine($previousLine);
                    break;
                }
                if (\strpos($line, '-') === 0) {
                    $needle = $this->getCleanDiffLine($line);
                    break;
                }
            }
            if (!empty($line)) {
                $previousLine = $line;
            }
        }
        return $this->getLocationHint($needle, $sections);
    }
    private function getCleanDiffLine(string $line) : string
    {
        if (\preg_match('/^[\\-+]([\'\\"]?)(.*)\\1$/', $line, $matches)) {
            $line = $matches[2];
        }
        return $line;
    }
    private function getLocationHint(string $needle, array $sections, ?string $sectionName = null) : array
    {
        $needle = \trim($needle);
        if (empty($needle)) {
            return [['file' => \realpath($this->filename), 'line' => 1]];
        }
        if ($sectionName) {
            $search = [$sectionName];
        } else {
            $search = [
                // 'FILE',
                'EXPECT',
                'EXPECTF',
                'EXPECTREGEX',
            ];
        }
        $sectionOffset = null;
        foreach ($search as $section) {
            if (!isset($sections[$section])) {
                continue;
            }
            if (isset($sections[$section . '_EXTERNAL'])) {
                $externalFile = \trim($sections[$section . '_EXTERNAL']);
                return [['file' => \realpath(\dirname($this->filename) . \DIRECTORY_SEPARATOR . $externalFile), 'line' => 1], ['file' => \realpath($this->filename), 'line' => ($sections[$section . '_EXTERNAL_offset'] ?? 0) + 1]];
            }
            $sectionOffset = $sections[$section . '_offset'] ?? 0;
            $offset = $sectionOffset + 1;
            foreach (\preg_split('/\\r\\n|\\r|\\n/', $sections[$section]) as $line) {
                if (\strpos($line, $needle) !== \false) {
                    return [['file' => \realpath($this->filename), 'line' => $offset]];
                }
                $offset++;
            }
        }
        if ($sectionName) {
            // String not found in specified section, show user the start of the named section
            return [['file' => \realpath($this->filename), 'line' => $sectionOffset]];
        }
        // No section specified, show user start of code
        return [['file' => \realpath($this->filename), 'line' => 1]];
    }
    /**
     * @psalm-return list<string>
     */
    private function settings(bool $collectCoverage) : array
    {
        $settings = ['allow_url_fopen=1', 'auto_append_file=', 'auto_prepend_file=', 'disable_functions=', 'display_errors=1', 'docref_ext=.html', 'docref_root=', 'error_append_string=', 'error_prepend_string=', 'error_reporting=-1', 'html_errors=0', 'log_errors=0', 'open_basedir=', 'output_buffering=Off', 'output_handler=', 'report_memleaks=0', 'report_zend_debug=0'];
        if (\extension_loaded('pcov')) {
            if ($collectCoverage) {
                $settings[] = 'pcov.enabled=1';
            } else {
                $settings[] = 'pcov.enabled=0';
            }
        }
        if (\extension_loaded('xdebug')) {
            if (\version_compare(\phpversion('xdebug'), '3', '>=')) {
                if ($collectCoverage) {
                    $settings[] = 'xdebug.mode=coverage';
                } else {
                    $settings[] = 'xdebug.mode=off';
                }
            } else {
                $settings[] = 'xdebug.default_enable=0';
                if ($collectCoverage) {
                    $settings[] = 'xdebug.coverage_enable=1';
                }
            }
        }
        return $settings;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use function preg_match;
use function round;
use PHPUnit\Framework\TestStatus\TestStatus;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ResultCacheExtension implements \PHPUnit\Runner\AfterIncompleteTestHook, \PHPUnit\Runner\AfterLastTestHook, \PHPUnit\Runner\AfterRiskyTestHook, \PHPUnit\Runner\AfterSkippedTestHook, \PHPUnit\Runner\AfterSuccessfulTestHook, \PHPUnit\Runner\AfterTestErrorHook, \PHPUnit\Runner\AfterTestFailureHook, \PHPUnit\Runner\AfterTestWarningHook
{
    private \PHPUnit\Runner\TestResultCache $cache;
    public function __construct(\PHPUnit\Runner\TestResultCache $cache)
    {
        $this->cache = $cache;
    }
    public function flush() : void
    {
        $this->cache->persist();
    }
    public function executeAfterSuccessfulTest(string $test, float $time) : void
    {
        $testName = $this->getTestName($test);
        $this->cache->setTime($testName, \round($time, 3));
    }
    public function executeAfterIncompleteTest(string $test, string $message, float $time) : void
    {
        $testName = $this->getTestName($test);
        $this->cache->setTime($testName, \round($time, 3));
        $this->cache->setStatus($testName, \PHPUnit\Framework\TestStatus\TestStatus::incomplete($message));
    }
    public function executeAfterRiskyTest(string $test, string $message, float $time) : void
    {
        $testName = $this->getTestName($test);
        $this->cache->setTime($testName, \round($time, 3));
        $this->cache->setStatus($testName, \PHPUnit\Framework\TestStatus\TestStatus::risky($message));
    }
    public function executeAfterSkippedTest(string $test, string $message, float $time) : void
    {
        $testName = $this->getTestName($test);
        $this->cache->setTime($testName, \round($time, 3));
        $this->cache->setStatus($testName, \PHPUnit\Framework\TestStatus\TestStatus::skipped($message));
    }
    public function executeAfterTestError(string $test, string $message, float $time) : void
    {
        $testName = $this->getTestName($test);
        $this->cache->setTime($testName, \round($time, 3));
        $this->cache->setStatus($testName, \PHPUnit\Framework\TestStatus\TestStatus::error($message));
    }
    public function executeAfterTestFailure(string $test, string $message, float $time) : void
    {
        $testName = $this->getTestName($test);
        $this->cache->setTime($testName, \round($time, 3));
        $this->cache->setStatus($testName, \PHPUnit\Framework\TestStatus\TestStatus::failure($message));
    }
    public function executeAfterTestWarning(string $test, string $message, float $time) : void
    {
        $testName = $this->getTestName($test);
        $this->cache->setTime($testName, \round($time, 3));
        $this->cache->setStatus($testName, \PHPUnit\Framework\TestStatus\TestStatus::warning($message));
    }
    public function executeAfterLastTest() : void
    {
        $this->flush();
    }
    /**
     * @param string $test A long description format of the current test
     *
     * @return string The test name without TestSuiteClassName:: and @dataprovider details
     */
    private function getTestName(string $test) : string
    {
        $matches = [];
        if (\preg_match('/^(?<name>\\S+::\\S+)(?:(?<dataname> with data set (?:#\\d+|"[^"]+"))\\s\\()?/', $test, $matches)) {
            $test = $matches['name'] . ($matches['dataname'] ?? '');
        }
        return $test;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use PHPUnit\Framework\TestStatus\TestStatus;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface TestResultCache
{
    public function setStatus(string $testName, \PHPUnit\Framework\TestStatus\TestStatus $status) : void;
    public function status(string $testName) : \PHPUnit\Framework\TestStatus\TestStatus;
    public function setTime(string $testName, float $time) : void;
    public function time(string $testName) : float;
    public function load() : void;
    public function persist() : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use function array_diff;
use function array_values;
use function basename;
use function class_exists;
use function get_declared_classes;
use function sprintf;
use function stripos;
use function strlen;
use function substr;
use PHPUnit\Framework\TestCase;
use ReflectionClass;
use ReflectionException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestSuiteLoader
{
    /** @var string[] */
    private static array $loadedClasses = [];
    /** @var string[] */
    private static array $declaredClasses = [];
    public function __construct()
    {
        if (empty(self::$declaredClasses)) {
            self::$declaredClasses = \get_declared_classes();
        }
    }
    /**
     * @throws Exception
     */
    public function load(string $suiteClassFile) : \ReflectionClass
    {
        $suiteClassName = $this->classNameFromFileName($suiteClassFile);
        if (!\class_exists($suiteClassName, \false)) {
            include_once $suiteClassFile;
            $loadedClasses = \array_values(\array_diff(\get_declared_classes(), \array_merge(self::$declaredClasses, self::$loadedClasses)));
            self::$loadedClasses = \array_merge($loadedClasses, self::$loadedClasses);
            if (empty(self::$loadedClasses)) {
                throw $this->exceptionFor($suiteClassName, $suiteClassFile);
            }
        }
        if (!\class_exists($suiteClassName, \false)) {
            // this block will handle namespaced classes
            $offset = 0 - \strlen($suiteClassName);
            foreach (self::$loadedClasses as $loadedClass) {
                if (\stripos(\substr($loadedClass, $offset - 1), '\\' . $suiteClassName) === 0) {
                    $suiteClassName = $loadedClass;
                    break;
                }
            }
        }
        if (!\class_exists($suiteClassName, \false)) {
            throw $this->exceptionFor($suiteClassName, $suiteClassFile);
        }
        try {
            $class = new \ReflectionClass($suiteClassName);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Runner\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        if ($class->isSubclassOf(\PHPUnit\Framework\TestCase::class) && !$class->isAbstract()) {
            return $class;
        }
        if ($class->hasMethod('suite')) {
            try {
                $method = $class->getMethod('suite');
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Runner\Exception($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
            if (!$method->isAbstract() && $method->isPublic() && $method->isStatic()) {
                return $class;
            }
        }
        throw $this->exceptionFor($suiteClassName, $suiteClassFile);
    }
    public function reload(\ReflectionClass $aClass) : \ReflectionClass
    {
        return $aClass;
    }
    private function classNameFromFileName(string $suiteClassFile) : string
    {
        $className = \basename($suiteClassFile, '.php');
        $dotPos = \strpos($className, '.');
        if ($dotPos !== \false) {
            $className = \substr($className, 0, $dotPos);
        }
        return $className;
    }
    private function exceptionFor(string $className, string $filename) : \PHPUnit\Runner\Exception
    {
        return new \PHPUnit\Runner\Exception(\sprintf("Class '%s' could not be found in '%s'.", $className, $filename));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use function array_diff;
use function array_merge;
use function array_reverse;
use function array_splice;
use function count;
use function in_array;
use function max;
use function shuffle;
use function usort;
use PHPUnit\Framework\DataProviderTestSuite;
use PHPUnit\Framework\Reorderable;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestSuite;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestSuiteSorter
{
    /**
     * @var int
     */
    public const ORDER_DEFAULT = 0;
    /**
     * @var int
     */
    public const ORDER_RANDOMIZED = 1;
    /**
     * @var int
     */
    public const ORDER_REVERSED = 2;
    /**
     * @var int
     */
    public const ORDER_DEFECTS_FIRST = 3;
    /**
     * @var int
     */
    public const ORDER_DURATION = 4;
    /**
     * Order tests by @size annotation 'small', 'medium', 'large'.
     *
     * @var int
     */
    public const ORDER_SIZE = 5;
    /**
     * List of sorting weights for all test result codes. A higher number gives higher priority.
     */
    private const DEFECT_SORT_WEIGHT = ['error' => 6, 'failure' => 5, 'warning' => 4, 'incomplete' => 3, 'risky' => 2, 'skipped' => 1, 'unknown' => 0];
    private const SIZE_SORT_WEIGHT = ['small' => 1, 'medium' => 2, 'large' => 3, 'unknown' => 4];
    /**
     * @var array<string, int> Associative array of (string => DEFECT_SORT_WEIGHT) elements
     */
    private array $defectSortOrder = [];
    private \PHPUnit\Runner\TestResultCache $cache;
    /**
     * @var array<string> A list of normalized names of tests before reordering
     */
    private array $originalExecutionOrder = [];
    /**
     * @var array<string> A list of normalized names of tests affected by reordering
     */
    private array $executionOrder = [];
    public function __construct(?\PHPUnit\Runner\TestResultCache $cache = null)
    {
        $this->cache = $cache ?? new \PHPUnit\Runner\NullTestResultCache();
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     * @throws Exception
     */
    public function reorderTestsInSuite(\PHPUnit\Framework\Test $suite, int $order, bool $resolveDependencies, int $orderDefects, bool $isRootTestSuite = \true) : void
    {
        $allowedOrders = [self::ORDER_DEFAULT, self::ORDER_REVERSED, self::ORDER_RANDOMIZED, self::ORDER_DURATION, self::ORDER_SIZE];
        if (!\in_array($order, $allowedOrders, \true)) {
            throw new \PHPUnit\Runner\Exception('$order must be one of TestSuiteSorter::ORDER_[DEFAULT|REVERSED|RANDOMIZED|DURATION|SIZE]');
        }
        $allowedOrderDefects = [self::ORDER_DEFAULT, self::ORDER_DEFECTS_FIRST];
        if (!\in_array($orderDefects, $allowedOrderDefects, \true)) {
            throw new \PHPUnit\Runner\Exception('$orderDefects must be one of TestSuiteSorter::ORDER_DEFAULT, TestSuiteSorter::ORDER_DEFECTS_FIRST');
        }
        if ($isRootTestSuite) {
            $this->originalExecutionOrder = $this->calculateTestExecutionOrder($suite);
        }
        if ($suite instanceof \PHPUnit\Framework\TestSuite) {
            foreach ($suite as $_suite) {
                $this->reorderTestsInSuite($_suite, $order, $resolveDependencies, $orderDefects, \false);
            }
            if ($orderDefects === self::ORDER_DEFECTS_FIRST) {
                $this->addSuiteToDefectSortOrder($suite);
            }
            $this->sort($suite, $order, $resolveDependencies, $orderDefects);
        }
        if ($isRootTestSuite) {
            $this->executionOrder = $this->calculateTestExecutionOrder($suite);
        }
    }
    public function getOriginalExecutionOrder() : array
    {
        return $this->originalExecutionOrder;
    }
    public function getExecutionOrder() : array
    {
        return $this->executionOrder;
    }
    private function sort(\PHPUnit\Framework\TestSuite $suite, int $order, bool $resolveDependencies, int $orderDefects) : void
    {
        if (empty($suite->tests())) {
            return;
        }
        if ($order === self::ORDER_REVERSED) {
            $suite->setTests($this->reverse($suite->tests()));
        } elseif ($order === self::ORDER_RANDOMIZED) {
            $suite->setTests($this->randomize($suite->tests()));
        } elseif ($order === self::ORDER_DURATION && $this->cache !== null) {
            $suite->setTests($this->sortByDuration($suite->tests()));
        } elseif ($order === self::ORDER_SIZE) {
            $suite->setTests($this->sortBySize($suite->tests()));
        }
        if ($orderDefects === self::ORDER_DEFECTS_FIRST && $this->cache !== null) {
            $suite->setTests($this->sortDefectsFirst($suite->tests()));
        }
        if ($resolveDependencies && !$suite instanceof \PHPUnit\Framework\DataProviderTestSuite) {
            /** @var TestCase[] $tests */
            $tests = $suite->tests();
            $suite->setTests($this->resolveDependencies($tests));
        }
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function addSuiteToDefectSortOrder(\PHPUnit\Framework\TestSuite $suite) : void
    {
        $max = 0;
        foreach ($suite->tests() as $test) {
            if (!$test instanceof \PHPUnit\Framework\Reorderable) {
                continue;
            }
            if (!isset($this->defectSortOrder[$test->sortId()])) {
                $this->defectSortOrder[$test->sortId()] = self::DEFECT_SORT_WEIGHT[$this->cache->status($test->sortId())->asString()];
                $max = \max($max, $this->defectSortOrder[$test->sortId()]);
            }
        }
        $this->defectSortOrder[$suite->sortId()] = $max;
    }
    private function reverse(array $tests) : array
    {
        return \array_reverse($tests);
    }
    private function randomize(array $tests) : array
    {
        \shuffle($tests);
        return $tests;
    }
    private function sortDefectsFirst(array $tests) : array
    {
        \usort(
            $tests,
            /**
             * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
             */
            function ($left, $right) {
                return $this->cmpDefectPriorityAndTime($left, $right);
            }
        );
        return $tests;
    }
    private function sortByDuration(array $tests) : array
    {
        \usort(
            $tests,
            /**
             * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
             */
            function ($left, $right) {
                return $this->cmpDuration($left, $right);
            }
        );
        return $tests;
    }
    private function sortBySize(array $tests) : array
    {
        \usort(
            $tests,
            /**
             * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
             */
            function ($left, $right) {
                return $this->cmpSize($left, $right);
            }
        );
        return $tests;
    }
    /**
     * Comparator callback function to sort tests for "reach failure as fast as possible".
     *
     * 1. sort tests by defect weight defined in self::DEFECT_SORT_WEIGHT
     * 2. when tests are equally defective, sort the fastest to the front
     * 3. do not reorder successful tests
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function cmpDefectPriorityAndTime(\PHPUnit\Framework\Test $a, \PHPUnit\Framework\Test $b) : int
    {
        if (!($a instanceof \PHPUnit\Framework\Reorderable && $b instanceof \PHPUnit\Framework\Reorderable)) {
            return 0;
        }
        $priorityA = $this->defectSortOrder[$a->sortId()] ?? 0;
        $priorityB = $this->defectSortOrder[$b->sortId()] ?? 0;
        if ($priorityB <=> $priorityA) {
            // Sort defect weight descending
            return $priorityB <=> $priorityA;
        }
        if ($priorityA || $priorityB) {
            return $this->cmpDuration($a, $b);
        }
        // do not change execution order
        return 0;
    }
    /**
     * Compares test duration for sorting tests by duration ascending.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function cmpDuration(\PHPUnit\Framework\Test $a, \PHPUnit\Framework\Test $b) : int
    {
        if (!($a instanceof \PHPUnit\Framework\Reorderable && $b instanceof \PHPUnit\Framework\Reorderable)) {
            return 0;
        }
        return $this->cache->time($a->sortId()) <=> $this->cache->time($b->sortId());
    }
    /**
     * Compares test size for sorting tests small->medium->large->unknown.
     */
    private function cmpSize(\PHPUnit\Framework\Test $a, \PHPUnit\Framework\Test $b) : int
    {
        $sizeA = $a instanceof \PHPUnit\Framework\TestCase || $a instanceof \PHPUnit\Framework\DataProviderTestSuite ? $a->size()->asString() : 'unknown';
        $sizeB = $b instanceof \PHPUnit\Framework\TestCase || $b instanceof \PHPUnit\Framework\DataProviderTestSuite ? $b->size()->asString() : 'unknown';
        return self::SIZE_SORT_WEIGHT[$sizeA] <=> self::SIZE_SORT_WEIGHT[$sizeB];
    }
    /**
     * Reorder Tests within a TestCase in such a way as to resolve as many dependencies as possible.
     * The algorithm will leave the tests in original running order when it can.
     * For more details see the documentation for test dependencies.
     *
     * Short description of algorithm:
     * 1. Pick the next Test from remaining tests to be checked for dependencies.
     * 2. If the test has no dependencies: mark done, start again from the top
     * 3. If the test has dependencies but none left to do: mark done, start again from the top
     * 4. When we reach the end add any leftover tests to the end. These will be marked 'skipped' during execution.
     *
     * @param array<DataProviderTestSuite|TestCase> $tests
     *
     * @return array<DataProviderTestSuite|TestCase>
     */
    private function resolveDependencies(array $tests) : array
    {
        $newTestOrder = [];
        $i = 0;
        $provided = [];
        do {
            if ([] === \array_diff($tests[$i]->requires(), $provided)) {
                $provided = \array_merge($provided, $tests[$i]->provides());
                $newTestOrder = \array_merge($newTestOrder, \array_splice($tests, $i, 1));
                $i = 0;
            } else {
                $i++;
            }
        } while (!empty($tests) && $i < \count($tests));
        return \array_merge($newTestOrder, $tests);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function calculateTestExecutionOrder(\PHPUnit\Framework\Test $suite) : array
    {
        $tests = [];
        if ($suite instanceof \PHPUnit\Framework\TestSuite) {
            foreach ($suite->tests() as $test) {
                if (!$test instanceof \PHPUnit\Framework\TestSuite && $test instanceof \PHPUnit\Framework\Reorderable) {
                    $tests[] = $test->sortId();
                } else {
                    $tests = \array_merge($tests, $this->calculateTestExecutionOrder($test));
                }
            }
        }
        return $tests;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Runner;

use function array_slice;
use function dirname;
use function explode;
use function implode;
use function strpos;
use PHPUnit\SebastianBergmann\Version as VersionId;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class Version
{
    private static string $pharVersion = '';
    private static string $version = '';
    /**
     * Returns the current version of PHPUnit.
     */
    public static function id() : string
    {
        if (self::$pharVersion !== '') {
            return self::$pharVersion;
        }
        if (self::$version === '') {
            self::$version = (new \PHPUnit\SebastianBergmann\Version('10.0', \dirname(__DIR__, 2)))->getVersion();
        }
        return self::$version;
    }
    public static function series() : string
    {
        if (\strpos(self::id(), '-')) {
            $version = \explode('-', self::id())[0];
        } else {
            $version = self::id();
        }
        return \implode('.', \array_slice(\explode('.', $version), 0, 2));
    }
    public static function getVersionString() : string
    {
        return 'PHPUnit ' . self::id() . ' by Sebastian Bergmann and contributors.';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\CliArguments;

use function array_map;
use function array_merge;
use function class_exists;
use function explode;
use function is_numeric;
use function str_replace;
use PHPUnit\Runner\TestSuiteSorter;
use PHPUnit\TextUI\DefaultResultPrinter;
use PHPUnit\TextUI\XmlConfiguration\Extension;
use PHPUnit\Util\Log\TeamCity;
use PHPUnit\Util\TestDox\CliTestDoxPrinter;
use PHPUnit\SebastianBergmann\CliParser\Exception as CliParserException;
use PHPUnit\SebastianBergmann\CliParser\Parser as CliParser;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Builder
{
    private const LONG_OPTIONS = ['atleast-version=', 'bootstrap=', 'cache-result', 'do-not-cache-result', 'cache-directory=', 'cache-result-file=', 'check-version', 'colors==', 'columns=', 'configuration=', 'coverage-cache=', 'warm-coverage-cache', 'coverage-filter=', 'coverage-clover=', 'coverage-cobertura=', 'coverage-crap4j=', 'coverage-html=', 'coverage-php=', 'coverage-text==', 'coverage-xml=', 'path-coverage', 'debug', 'disallow-test-output', 'disallow-resource-usage', 'disallow-todo-tests', 'default-time-limit=', 'enforce-time-limit', 'exclude-group=', 'extensions=', 'filter=', 'generate-configuration', 'globals-backup', 'group=', 'covers=', 'uses=', 'help', 'resolve-dependencies', 'ignore-dependencies', 'include-path=', 'list-groups', 'list-suites', 'list-tests', 'list-tests-xml=', 'log-junit=', 'log-teamcity=', 'migrate-configuration', 'no-configuration', 'no-coverage', 'no-logging', 'no-interaction', 'no-extensions', 'order-by=', 'printer=', 'process-isolation', 'repeat=', 'dont-report-useless-tests', 'random-order', 'random-order-seed=', 'reverse-order', 'reverse-list', 'static-backup', 'stderr', 'stop-on-defect', 'stop-on-error', 'stop-on-failure', 'stop-on-warning', 'stop-on-incomplete', 'stop-on-risky', 'stop-on-skipped', 'fail-on-empty-test-suite', 'fail-on-incomplete', 'fail-on-risky', 'fail-on-skipped', 'fail-on-warning', 'strict-coverage', 'disable-coverage-ignore', 'strict-global-state', 'teamcity', 'testdox', 'testdox-group=', 'testdox-exclude-group=', 'testdox-html=', 'testdox-text=', 'testdox-xml=', 'test-suffix=', 'testsuite=', 'verbose', 'version'];
    private const SHORT_OPTIONS = 'd:c:hv';
    public function fromParameters(array $parameters, array $additionalLongOptions) : \PHPUnit\TextUI\CliArguments\Configuration
    {
        try {
            $options = (new \PHPUnit\SebastianBergmann\CliParser\Parser())->parse($parameters, self::SHORT_OPTIONS, \array_merge(self::LONG_OPTIONS, $additionalLongOptions));
        } catch (\PHPUnit\SebastianBergmann\CliParser\Exception $e) {
            throw new \PHPUnit\TextUI\CliArguments\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        $argument = null;
        $atLeastVersion = null;
        $backupGlobals = null;
        $backupStaticAttributes = null;
        $beStrictAboutChangesToGlobalState = null;
        $beStrictAboutResourceUsageDuringSmallTests = null;
        $bootstrap = null;
        $cacheDirectory = null;
        $cacheResult = null;
        $cacheResultFile = null;
        $checkVersion = null;
        $colors = null;
        $columns = null;
        $configuration = null;
        $coverageCacheDirectory = null;
        $warmCoverageCache = null;
        $coverageFilter = null;
        $coverageClover = null;
        $coverageCobertura = null;
        $coverageCrap4J = null;
        $coverageHtml = null;
        $coveragePhp = null;
        $coverageText = null;
        $coverageTextShowUncoveredFiles = null;
        $coverageTextShowOnlySummary = null;
        $coverageXml = null;
        $pathCoverage = null;
        $debug = null;
        $defaultTimeLimit = null;
        $disableCodeCoverageIgnore = null;
        $disallowTestOutput = null;
        $disallowTodoAnnotatedTests = null;
        $enforceTimeLimit = null;
        $excludeGroups = null;
        $executionOrder = null;
        $executionOrderDefects = null;
        $extensions = [];
        $unavailableExtensions = [];
        $failOnEmptyTestSuite = null;
        $failOnIncomplete = null;
        $failOnRisky = null;
        $failOnSkipped = null;
        $failOnWarning = null;
        $filter = null;
        $generateConfiguration = null;
        $migrateConfiguration = null;
        $groups = null;
        $testsCovering = null;
        $testsUsing = null;
        $help = null;
        $includePath = null;
        $iniSettings = [];
        $junitLogfile = null;
        $listGroups = null;
        $listSuites = null;
        $listTests = null;
        $listTestsXml = null;
        $noCoverage = null;
        $noExtensions = null;
        $noInteraction = null;
        $noLogging = null;
        $printer = null;
        $processIsolation = null;
        $randomOrderSeed = null;
        $repeat = null;
        $reportUselessTests = null;
        $resolveDependencies = null;
        $reverseList = null;
        $stderr = null;
        $strictCoverage = null;
        $stopOnDefect = null;
        $stopOnError = null;
        $stopOnFailure = null;
        $stopOnIncomplete = null;
        $stopOnRisky = null;
        $stopOnSkipped = null;
        $stopOnWarning = null;
        $teamcityLogfile = null;
        $testdoxExcludeGroups = null;
        $testdoxGroups = null;
        $testdoxHtmlFile = null;
        $testdoxTextFile = null;
        $testdoxXmlFile = null;
        $testSuffixes = null;
        $testSuite = null;
        $unrecognizedOptions = [];
        $unrecognizedOrderBy = null;
        $useDefaultConfiguration = null;
        $verbose = null;
        $version = null;
        if (isset($options[1][0])) {
            $argument = $options[1][0];
        }
        foreach ($options[0] as $option) {
            switch ($option[0]) {
                case '--colors':
                    $colors = $option[1] ?: \PHPUnit\TextUI\DefaultResultPrinter::COLOR_AUTO;
                    break;
                case '--bootstrap':
                    $bootstrap = $option[1];
                    break;
                case '--cache-directory':
                    $cacheDirectory = $option[1];
                    break;
                case '--cache-result':
                    $cacheResult = \true;
                    break;
                case '--do-not-cache-result':
                    $cacheResult = \false;
                    break;
                case '--cache-result-file':
                    $cacheResultFile = $option[1];
                    break;
                case '--columns':
                    if (\is_numeric($option[1])) {
                        $columns = (int) $option[1];
                    } elseif ($option[1] === 'max') {
                        $columns = 'max';
                    }
                    break;
                case 'c':
                case '--configuration':
                    $configuration = $option[1];
                    break;
                case '--coverage-cache':
                    $coverageCacheDirectory = $option[1];
                    break;
                case '--warm-coverage-cache':
                    $warmCoverageCache = \true;
                    break;
                case '--coverage-clover':
                    $coverageClover = $option[1];
                    break;
                case '--coverage-cobertura':
                    $coverageCobertura = $option[1];
                    break;
                case '--coverage-crap4j':
                    $coverageCrap4J = $option[1];
                    break;
                case '--coverage-html':
                    $coverageHtml = $option[1];
                    break;
                case '--coverage-php':
                    $coveragePhp = $option[1];
                    break;
                case '--coverage-text':
                    if ($option[1] === null) {
                        $option[1] = 'php://stdout';
                    }
                    $coverageText = $option[1];
                    $coverageTextShowUncoveredFiles = \false;
                    $coverageTextShowOnlySummary = \false;
                    break;
                case '--coverage-xml':
                    $coverageXml = $option[1];
                    break;
                case '--path-coverage':
                    $pathCoverage = \true;
                    break;
                case 'd':
                    $tmp = \explode('=', $option[1]);
                    if (isset($tmp[0])) {
                        if (isset($tmp[1])) {
                            $iniSettings[$tmp[0]] = $tmp[1];
                        } else {
                            $iniSettings[$tmp[0]] = '1';
                        }
                    }
                    break;
                case '--debug':
                    $debug = \true;
                    break;
                case 'h':
                case '--help':
                    $help = \true;
                    break;
                case '--filter':
                    $filter = $option[1];
                    break;
                case '--testsuite':
                    $testSuite = $option[1];
                    break;
                case '--generate-configuration':
                    $generateConfiguration = \true;
                    break;
                case '--migrate-configuration':
                    $migrateConfiguration = \true;
                    break;
                case '--group':
                    $groups = \explode(',', $option[1]);
                    break;
                case '--exclude-group':
                    $excludeGroups = \explode(',', $option[1]);
                    break;
                case '--covers':
                    $testsCovering = \array_map('strtolower', \explode(',', $option[1]));
                    break;
                case '--uses':
                    $testsUsing = \array_map('strtolower', \explode(',', $option[1]));
                    break;
                case '--test-suffix':
                    $testSuffixes = \explode(',', $option[1]);
                    break;
                case '--include-path':
                    $includePath = $option[1];
                    break;
                case '--list-groups':
                    $listGroups = \true;
                    break;
                case '--list-suites':
                    $listSuites = \true;
                    break;
                case '--list-tests':
                    $listTests = \true;
                    break;
                case '--list-tests-xml':
                    $listTestsXml = $option[1];
                    break;
                case '--printer':
                    $printer = $option[1];
                    break;
                case '--log-junit':
                    $junitLogfile = $option[1];
                    break;
                case '--log-teamcity':
                    $teamcityLogfile = $option[1];
                    break;
                case '--order-by':
                    foreach (\explode(',', $option[1]) as $order) {
                        switch ($order) {
                            case 'default':
                                $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT;
                                $executionOrderDefects = \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT;
                                $resolveDependencies = \true;
                                break;
                            case 'defects':
                                $executionOrderDefects = \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFECTS_FIRST;
                                break;
                            case 'depends':
                                $resolveDependencies = \true;
                                break;
                            case 'duration':
                                $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_DURATION;
                                break;
                            case 'no-depends':
                                $resolveDependencies = \false;
                                break;
                            case 'random':
                                $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_RANDOMIZED;
                                break;
                            case 'reverse':
                                $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_REVERSED;
                                break;
                            case 'size':
                                $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_SIZE;
                                break;
                            default:
                                $unrecognizedOrderBy = $order;
                        }
                    }
                    break;
                case '--process-isolation':
                    $processIsolation = \true;
                    break;
                case '--repeat':
                    $repeat = (int) $option[1];
                    break;
                case '--stderr':
                    $stderr = \true;
                    break;
                case '--stop-on-defect':
                    $stopOnDefect = \true;
                    break;
                case '--stop-on-error':
                    $stopOnError = \true;
                    break;
                case '--stop-on-failure':
                    $stopOnFailure = \true;
                    break;
                case '--stop-on-warning':
                    $stopOnWarning = \true;
                    break;
                case '--stop-on-incomplete':
                    $stopOnIncomplete = \true;
                    break;
                case '--stop-on-risky':
                    $stopOnRisky = \true;
                    break;
                case '--stop-on-skipped':
                    $stopOnSkipped = \true;
                    break;
                case '--fail-on-empty-test-suite':
                    $failOnEmptyTestSuite = \true;
                    break;
                case '--fail-on-incomplete':
                    $failOnIncomplete = \true;
                    break;
                case '--fail-on-risky':
                    $failOnRisky = \true;
                    break;
                case '--fail-on-skipped':
                    $failOnSkipped = \true;
                    break;
                case '--fail-on-warning':
                    $failOnWarning = \true;
                    break;
                case '--teamcity':
                    $printer = \PHPUnit\Util\Log\TeamCity::class;
                    break;
                case '--testdox':
                    $printer = \PHPUnit\Util\TestDox\CliTestDoxPrinter::class;
                    break;
                case '--testdox-group':
                    $testdoxGroups = \explode(',', $option[1]);
                    break;
                case '--testdox-exclude-group':
                    $testdoxExcludeGroups = \explode(',', $option[1]);
                    break;
                case '--testdox-html':
                    $testdoxHtmlFile = $option[1];
                    break;
                case '--testdox-text':
                    $testdoxTextFile = $option[1];
                    break;
                case '--testdox-xml':
                    $testdoxXmlFile = $option[1];
                    break;
                case '--no-configuration':
                    $useDefaultConfiguration = \false;
                    break;
                case '--extensions':
                    foreach (\explode(',', $option[1]) as $extensionClass) {
                        if (!\class_exists($extensionClass)) {
                            $unavailableExtensions[] = $extensionClass;
                            continue;
                        }
                        $extensions[] = new \PHPUnit\TextUI\XmlConfiguration\Extension($extensionClass, '', []);
                    }
                    break;
                case '--no-extensions':
                    $noExtensions = \true;
                    break;
                case '--no-coverage':
                    $noCoverage = \true;
                    break;
                case '--no-logging':
                    $noLogging = \true;
                    break;
                case '--no-interaction':
                    $noInteraction = \true;
                    break;
                case '--globals-backup':
                    $backupGlobals = \true;
                    break;
                case '--static-backup':
                    $backupStaticAttributes = \true;
                    break;
                case 'v':
                case '--verbose':
                    $verbose = \true;
                    break;
                case '--atleast-version':
                    $atLeastVersion = $option[1];
                    break;
                case '--version':
                    $version = \true;
                    break;
                case '--dont-report-useless-tests':
                    $reportUselessTests = \false;
                    break;
                case '--strict-coverage':
                    $strictCoverage = \true;
                    break;
                case '--disable-coverage-ignore':
                    $disableCodeCoverageIgnore = \true;
                    break;
                case '--strict-global-state':
                    $beStrictAboutChangesToGlobalState = \true;
                    break;
                case '--disallow-test-output':
                    $disallowTestOutput = \true;
                    break;
                case '--disallow-resource-usage':
                    $beStrictAboutResourceUsageDuringSmallTests = \true;
                    break;
                case '--default-time-limit':
                    $defaultTimeLimit = (int) $option[1];
                    break;
                case '--enforce-time-limit':
                    $enforceTimeLimit = \true;
                    break;
                case '--disallow-todo-tests':
                    $disallowTodoAnnotatedTests = \true;
                    break;
                case '--reverse-list':
                    $reverseList = \true;
                    break;
                case '--check-version':
                    $checkVersion = \true;
                    break;
                case '--coverage-filter':
                    if ($coverageFilter === null) {
                        $coverageFilter = [];
                    }
                    $coverageFilter[] = $option[1];
                    break;
                case '--random-order':
                    $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_RANDOMIZED;
                    break;
                case '--random-order-seed':
                    $randomOrderSeed = (int) $option[1];
                    break;
                case '--resolve-dependencies':
                    $resolveDependencies = \true;
                    break;
                case '--ignore-dependencies':
                    $resolveDependencies = \false;
                    break;
                case '--reverse-order':
                    $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_REVERSED;
                    break;
                default:
                    $unrecognizedOptions[\str_replace('--', '', $option[0])] = $option[1];
            }
        }
        if (empty($extensions)) {
            $extensions = null;
        }
        if (empty($unavailableExtensions)) {
            $unavailableExtensions = null;
        }
        if (empty($iniSettings)) {
            $iniSettings = null;
        }
        if (empty($coverageFilter)) {
            $coverageFilter = null;
        }
        return new \PHPUnit\TextUI\CliArguments\Configuration($argument, $atLeastVersion, $backupGlobals, $backupStaticAttributes, $beStrictAboutChangesToGlobalState, $beStrictAboutResourceUsageDuringSmallTests, $bootstrap, $cacheDirectory, $cacheResult, $cacheResultFile, $checkVersion, $colors, $columns, $configuration, $coverageClover, $coverageCobertura, $coverageCrap4J, $coverageHtml, $coveragePhp, $coverageText, $coverageTextShowUncoveredFiles, $coverageTextShowOnlySummary, $coverageXml, $pathCoverage, $coverageCacheDirectory, $warmCoverageCache, $debug, $defaultTimeLimit, $disableCodeCoverageIgnore, $disallowTestOutput, $disallowTodoAnnotatedTests, $enforceTimeLimit, $excludeGroups, $executionOrder, $executionOrderDefects, $extensions, $unavailableExtensions, $failOnEmptyTestSuite, $failOnIncomplete, $failOnRisky, $failOnSkipped, $failOnWarning, $filter, $generateConfiguration, $migrateConfiguration, $groups, $testsCovering, $testsUsing, $help, $includePath, $iniSettings, $junitLogfile, $listGroups, $listSuites, $listTests, $listTestsXml, $noCoverage, $noExtensions, $noInteraction, $noLogging, $printer, $processIsolation, $randomOrderSeed, $repeat, $reportUselessTests, $resolveDependencies, $reverseList, $stderr, $strictCoverage, $stopOnDefect, $stopOnError, $stopOnFailure, $stopOnIncomplete, $stopOnRisky, $stopOnSkipped, $stopOnWarning, $teamcityLogfile, $testdoxExcludeGroups, $testdoxGroups, $testdoxHtmlFile, $testdoxTextFile, $testdoxXmlFile, $testSuffixes, $testSuite, $unrecognizedOptions, $unrecognizedOrderBy, $useDefaultConfiguration, $verbose, $version, $coverageFilter);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\CliArguments;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Configuration
{
    private ?string $argument = null;
    private ?string $atLeastVersion = null;
    private ?bool $backupGlobals = null;
    private ?bool $backupStaticAttributes = null;
    private ?bool $beStrictAboutChangesToGlobalState = null;
    private ?bool $beStrictAboutResourceUsageDuringSmallTests = null;
    private ?string $bootstrap = null;
    private ?string $cacheDirectory = null;
    private ?bool $cacheResult = null;
    private ?string $cacheResultFile = null;
    private ?bool $checkVersion = null;
    private ?string $colors = null;
    /**
     * @var null|int|string
     */
    private $columns;
    private ?string $configuration = null;
    private ?array $coverageFilter = null;
    private ?string $coverageClover = null;
    private ?string $coverageCobertura = null;
    private ?string $coverageCrap4J = null;
    private ?string $coverageHtml = null;
    private ?string $coveragePhp = null;
    private ?string $coverageText = null;
    private ?bool $coverageTextShowUncoveredFiles = null;
    private ?bool $coverageTextShowOnlySummary = null;
    private ?string $coverageXml = null;
    private ?bool $pathCoverage = null;
    private ?string $coverageCacheDirectory = null;
    private ?bool $warmCoverageCache = null;
    private ?bool $debug = null;
    private ?int $defaultTimeLimit = null;
    private ?bool $disableCodeCoverageIgnore = null;
    private ?bool $disallowTestOutput = null;
    private ?bool $disallowTodoAnnotatedTests = null;
    private ?bool $enforceTimeLimit = null;
    private ?array $excludeGroups = null;
    private ?int $executionOrder = null;
    private ?int $executionOrderDefects = null;
    private ?array $extensions = null;
    private ?array $unavailableExtensions = null;
    private ?bool $failOnEmptyTestSuite = null;
    private ?bool $failOnIncomplete = null;
    private ?bool $failOnRisky = null;
    private ?bool $failOnSkipped = null;
    private ?bool $failOnWarning = null;
    private ?string $filter = null;
    private ?bool $generateConfiguration = null;
    private ?bool $migrateConfiguration = null;
    private ?array $groups = null;
    private ?array $testsCovering = null;
    private ?array $testsUsing = null;
    private ?bool $help = null;
    private ?string $includePath = null;
    private ?array $iniSettings = null;
    private ?string $junitLogfile = null;
    private ?bool $listGroups = null;
    private ?bool $listSuites = null;
    private ?bool $listTests = null;
    private ?string $listTestsXml = null;
    private ?bool $noCoverage = null;
    private ?bool $noExtensions = null;
    private ?bool $noInteraction = null;
    private ?bool $noLogging = null;
    private ?string $printer = null;
    private ?bool $processIsolation = null;
    private ?int $randomOrderSeed = null;
    private ?int $repeat = null;
    private ?bool $reportUselessTests = null;
    private ?bool $resolveDependencies = null;
    private ?bool $reverseList = null;
    private ?bool $stderr = null;
    private ?bool $strictCoverage = null;
    private ?bool $stopOnDefect = null;
    private ?bool $stopOnError = null;
    private ?bool $stopOnFailure = null;
    private ?bool $stopOnIncomplete = null;
    private ?bool $stopOnRisky = null;
    private ?bool $stopOnSkipped = null;
    private ?bool $stopOnWarning = null;
    private ?string $teamcityLogfile = null;
    private ?array $testdoxExcludeGroups = null;
    private ?array $testdoxGroups = null;
    private ?string $testdoxHtmlFile = null;
    private ?string $testdoxTextFile = null;
    private ?string $testdoxXmlFile = null;
    private ?array $testSuffixes = null;
    private ?string $testSuite = null;
    /**
     * @var string[]
     */
    private array $unrecognizedOptions;
    private ?string $unrecognizedOrderBy = null;
    private ?bool $useDefaultConfiguration = null;
    private ?bool $verbose = null;
    private ?bool $version = null;
    /**
     * @param null|int|string $columns
     */
    public function __construct(?string $argument, ?string $atLeastVersion, ?bool $backupGlobals, ?bool $backupStaticAttributes, ?bool $beStrictAboutChangesToGlobalState, ?bool $beStrictAboutResourceUsageDuringSmallTests, ?string $bootstrap, ?string $cacheDirectory, ?bool $cacheResult, ?string $cacheResultFile, ?bool $checkVersion, ?string $colors, $columns, ?string $configuration, ?string $coverageClover, ?string $coverageCobertura, ?string $coverageCrap4J, ?string $coverageHtml, ?string $coveragePhp, ?string $coverageText, ?bool $coverageTextShowUncoveredFiles, ?bool $coverageTextShowOnlySummary, ?string $coverageXml, ?bool $pathCoverage, ?string $coverageCacheDirectory, ?bool $warmCoverageCache, ?bool $debug, ?int $defaultTimeLimit, ?bool $disableCodeCoverageIgnore, ?bool $disallowTestOutput, ?bool $disallowTodoAnnotatedTests, ?bool $enforceTimeLimit, ?array $excludeGroups, ?int $executionOrder, ?int $executionOrderDefects, ?array $extensions, ?array $unavailableExtensions, ?bool $failOnEmptyTestSuite, ?bool $failOnIncomplete, ?bool $failOnRisky, ?bool $failOnSkipped, ?bool $failOnWarning, ?string $filter, ?bool $generateConfiguration, ?bool $migrateConfiguration, ?array $groups, ?array $testsCovering, ?array $testsUsing, ?bool $help, ?string $includePath, ?array $iniSettings, ?string $junitLogfile, ?bool $listGroups, ?bool $listSuites, ?bool $listTests, ?string $listTestsXml, ?bool $noCoverage, ?bool $noExtensions, ?bool $noInteraction, ?bool $noLogging, ?string $printer, ?bool $processIsolation, ?int $randomOrderSeed, ?int $repeat, ?bool $reportUselessTests, ?bool $resolveDependencies, ?bool $reverseList, ?bool $stderr, ?bool $strictCoverage, ?bool $stopOnDefect, ?bool $stopOnError, ?bool $stopOnFailure, ?bool $stopOnIncomplete, ?bool $stopOnRisky, ?bool $stopOnSkipped, ?bool $stopOnWarning, ?string $teamcityLogfile, ?array $testdoxExcludeGroups, ?array $testdoxGroups, ?string $testdoxHtmlFile, ?string $testdoxTextFile, ?string $testdoxXmlFile, ?array $testSuffixes, ?string $testSuite, array $unrecognizedOptions, ?string $unrecognizedOrderBy, ?bool $useDefaultConfiguration, ?bool $verbose, ?bool $version, ?array $coverageFilter)
    {
        $this->argument = $argument;
        $this->atLeastVersion = $atLeastVersion;
        $this->backupGlobals = $backupGlobals;
        $this->backupStaticAttributes = $backupStaticAttributes;
        $this->beStrictAboutChangesToGlobalState = $beStrictAboutChangesToGlobalState;
        $this->beStrictAboutResourceUsageDuringSmallTests = $beStrictAboutResourceUsageDuringSmallTests;
        $this->bootstrap = $bootstrap;
        $this->cacheDirectory = $cacheDirectory;
        $this->cacheResult = $cacheResult;
        $this->cacheResultFile = $cacheResultFile;
        $this->checkVersion = $checkVersion;
        $this->colors = $colors;
        $this->columns = $columns;
        $this->configuration = $configuration;
        $this->coverageFilter = $coverageFilter;
        $this->coverageClover = $coverageClover;
        $this->coverageCobertura = $coverageCobertura;
        $this->coverageCrap4J = $coverageCrap4J;
        $this->coverageHtml = $coverageHtml;
        $this->coveragePhp = $coveragePhp;
        $this->coverageText = $coverageText;
        $this->coverageTextShowUncoveredFiles = $coverageTextShowUncoveredFiles;
        $this->coverageTextShowOnlySummary = $coverageTextShowOnlySummary;
        $this->coverageXml = $coverageXml;
        $this->pathCoverage = $pathCoverage;
        $this->coverageCacheDirectory = $coverageCacheDirectory;
        $this->warmCoverageCache = $warmCoverageCache;
        $this->debug = $debug;
        $this->defaultTimeLimit = $defaultTimeLimit;
        $this->disableCodeCoverageIgnore = $disableCodeCoverageIgnore;
        $this->disallowTestOutput = $disallowTestOutput;
        $this->disallowTodoAnnotatedTests = $disallowTodoAnnotatedTests;
        $this->enforceTimeLimit = $enforceTimeLimit;
        $this->excludeGroups = $excludeGroups;
        $this->executionOrder = $executionOrder;
        $this->executionOrderDefects = $executionOrderDefects;
        $this->extensions = $extensions;
        $this->unavailableExtensions = $unavailableExtensions;
        $this->failOnEmptyTestSuite = $failOnEmptyTestSuite;
        $this->failOnIncomplete = $failOnIncomplete;
        $this->failOnRisky = $failOnRisky;
        $this->failOnSkipped = $failOnSkipped;
        $this->failOnWarning = $failOnWarning;
        $this->filter = $filter;
        $this->generateConfiguration = $generateConfiguration;
        $this->migrateConfiguration = $migrateConfiguration;
        $this->groups = $groups;
        $this->testsCovering = $testsCovering;
        $this->testsUsing = $testsUsing;
        $this->help = $help;
        $this->includePath = $includePath;
        $this->iniSettings = $iniSettings;
        $this->junitLogfile = $junitLogfile;
        $this->listGroups = $listGroups;
        $this->listSuites = $listSuites;
        $this->listTests = $listTests;
        $this->listTestsXml = $listTestsXml;
        $this->noCoverage = $noCoverage;
        $this->noExtensions = $noExtensions;
        $this->noInteraction = $noInteraction;
        $this->noLogging = $noLogging;
        $this->printer = $printer;
        $this->processIsolation = $processIsolation;
        $this->randomOrderSeed = $randomOrderSeed;
        $this->repeat = $repeat;
        $this->reportUselessTests = $reportUselessTests;
        $this->resolveDependencies = $resolveDependencies;
        $this->reverseList = $reverseList;
        $this->stderr = $stderr;
        $this->strictCoverage = $strictCoverage;
        $this->stopOnDefect = $stopOnDefect;
        $this->stopOnError = $stopOnError;
        $this->stopOnFailure = $stopOnFailure;
        $this->stopOnIncomplete = $stopOnIncomplete;
        $this->stopOnRisky = $stopOnRisky;
        $this->stopOnSkipped = $stopOnSkipped;
        $this->stopOnWarning = $stopOnWarning;
        $this->teamcityLogfile = $teamcityLogfile;
        $this->testdoxExcludeGroups = $testdoxExcludeGroups;
        $this->testdoxGroups = $testdoxGroups;
        $this->testdoxHtmlFile = $testdoxHtmlFile;
        $this->testdoxTextFile = $testdoxTextFile;
        $this->testdoxXmlFile = $testdoxXmlFile;
        $this->testSuffixes = $testSuffixes;
        $this->testSuite = $testSuite;
        $this->unrecognizedOptions = $unrecognizedOptions;
        $this->unrecognizedOrderBy = $unrecognizedOrderBy;
        $this->useDefaultConfiguration = $useDefaultConfiguration;
        $this->verbose = $verbose;
        $this->version = $version;
    }
    public function hasArgument() : bool
    {
        return $this->argument !== null;
    }
    /**
     * @throws Exception
     */
    public function argument() : string
    {
        if ($this->argument === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->argument;
    }
    public function hasAtLeastVersion() : bool
    {
        return $this->atLeastVersion !== null;
    }
    /**
     * @throws Exception
     */
    public function atLeastVersion() : string
    {
        if ($this->atLeastVersion === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->atLeastVersion;
    }
    public function hasBackupGlobals() : bool
    {
        return $this->backupGlobals !== null;
    }
    /**
     * @throws Exception
     */
    public function backupGlobals() : bool
    {
        if ($this->backupGlobals === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->backupGlobals;
    }
    public function hasBackupStaticAttributes() : bool
    {
        return $this->backupStaticAttributes !== null;
    }
    /**
     * @throws Exception
     */
    public function backupStaticAttributes() : bool
    {
        if ($this->backupStaticAttributes === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->backupStaticAttributes;
    }
    public function hasBeStrictAboutChangesToGlobalState() : bool
    {
        return $this->beStrictAboutChangesToGlobalState !== null;
    }
    /**
     * @throws Exception
     */
    public function beStrictAboutChangesToGlobalState() : bool
    {
        if ($this->beStrictAboutChangesToGlobalState === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->beStrictAboutChangesToGlobalState;
    }
    public function hasBeStrictAboutResourceUsageDuringSmallTests() : bool
    {
        return $this->beStrictAboutResourceUsageDuringSmallTests !== null;
    }
    /**
     * @throws Exception
     */
    public function beStrictAboutResourceUsageDuringSmallTests() : bool
    {
        if ($this->beStrictAboutResourceUsageDuringSmallTests === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->beStrictAboutResourceUsageDuringSmallTests;
    }
    public function hasBootstrap() : bool
    {
        return $this->bootstrap !== null;
    }
    /**
     * @throws Exception
     */
    public function bootstrap() : string
    {
        if ($this->bootstrap === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->bootstrap;
    }
    public function hasCacheDirectory() : bool
    {
        return $this->cacheDirectory !== null;
    }
    /**
     * @throws Exception
     */
    public function cacheDirectory() : string
    {
        if ($this->cacheDirectory === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->cacheDirectory;
    }
    public function hasCacheResult() : bool
    {
        return $this->cacheResult !== null;
    }
    /**
     * @throws Exception
     */
    public function cacheResult() : bool
    {
        if ($this->cacheResult === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->cacheResult;
    }
    public function hasCacheResultFile() : bool
    {
        return $this->cacheResultFile !== null;
    }
    /**
     * @throws Exception
     */
    public function cacheResultFile() : string
    {
        if ($this->cacheResultFile === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->cacheResultFile;
    }
    public function hasCheckVersion() : bool
    {
        return $this->checkVersion !== null;
    }
    /**
     * @throws Exception
     */
    public function checkVersion() : bool
    {
        if ($this->checkVersion === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->checkVersion;
    }
    public function hasColors() : bool
    {
        return $this->colors !== null;
    }
    /**
     * @throws Exception
     */
    public function colors() : string
    {
        if ($this->colors === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->colors;
    }
    public function hasColumns() : bool
    {
        return $this->columns !== null;
    }
    /**
     * @throws Exception
     */
    public function columns()
    {
        if ($this->columns === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->columns;
    }
    public function hasConfiguration() : bool
    {
        return $this->configuration !== null;
    }
    /**
     * @throws Exception
     */
    public function configuration() : string
    {
        if ($this->configuration === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->configuration;
    }
    public function hasCoverageFilter() : bool
    {
        return $this->coverageFilter !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageFilter() : array
    {
        if ($this->coverageFilter === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageFilter;
    }
    public function hasCoverageClover() : bool
    {
        return $this->coverageClover !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageClover() : string
    {
        if ($this->coverageClover === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageClover;
    }
    public function hasCoverageCobertura() : bool
    {
        return $this->coverageCobertura !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageCobertura() : string
    {
        if ($this->coverageCobertura === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageCobertura;
    }
    public function hasCoverageCrap4J() : bool
    {
        return $this->coverageCrap4J !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageCrap4J() : string
    {
        if ($this->coverageCrap4J === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageCrap4J;
    }
    public function hasCoverageHtml() : bool
    {
        return $this->coverageHtml !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageHtml() : string
    {
        if ($this->coverageHtml === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageHtml;
    }
    public function hasCoveragePhp() : bool
    {
        return $this->coveragePhp !== null;
    }
    /**
     * @throws Exception
     */
    public function coveragePhp() : string
    {
        if ($this->coveragePhp === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coveragePhp;
    }
    public function hasCoverageText() : bool
    {
        return $this->coverageText !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageText() : string
    {
        if ($this->coverageText === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageText;
    }
    public function hasCoverageTextShowUncoveredFiles() : bool
    {
        return $this->coverageTextShowUncoveredFiles !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageTextShowUncoveredFiles() : bool
    {
        if ($this->coverageTextShowUncoveredFiles === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageTextShowUncoveredFiles;
    }
    public function hasCoverageTextShowOnlySummary() : bool
    {
        return $this->coverageTextShowOnlySummary !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageTextShowOnlySummary() : bool
    {
        if ($this->coverageTextShowOnlySummary === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageTextShowOnlySummary;
    }
    public function hasCoverageXml() : bool
    {
        return $this->coverageXml !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageXml() : string
    {
        if ($this->coverageXml === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageXml;
    }
    public function hasPathCoverage() : bool
    {
        return $this->pathCoverage !== null;
    }
    /**
     * @throws Exception
     */
    public function pathCoverage() : bool
    {
        if ($this->pathCoverage === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->pathCoverage;
    }
    public function hasCoverageCacheDirectory() : bool
    {
        return $this->coverageCacheDirectory !== null;
    }
    /**
     * @throws Exception
     */
    public function coverageCacheDirectory() : string
    {
        if ($this->coverageCacheDirectory === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->coverageCacheDirectory;
    }
    public function hasWarmCoverageCache() : bool
    {
        return $this->warmCoverageCache !== null;
    }
    /**
     * @throws Exception
     */
    public function warmCoverageCache() : bool
    {
        if ($this->warmCoverageCache === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->warmCoverageCache;
    }
    public function hasDebug() : bool
    {
        return $this->debug !== null;
    }
    /**
     * @throws Exception
     */
    public function debug() : bool
    {
        if ($this->debug === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->debug;
    }
    public function hasDefaultTimeLimit() : bool
    {
        return $this->defaultTimeLimit !== null;
    }
    /**
     * @throws Exception
     */
    public function defaultTimeLimit() : int
    {
        if ($this->defaultTimeLimit === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->defaultTimeLimit;
    }
    public function hasDisableCodeCoverageIgnore() : bool
    {
        return $this->disableCodeCoverageIgnore !== null;
    }
    /**
     * @throws Exception
     */
    public function disableCodeCoverageIgnore() : bool
    {
        if ($this->disableCodeCoverageIgnore === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->disableCodeCoverageIgnore;
    }
    public function hasDisallowTestOutput() : bool
    {
        return $this->disallowTestOutput !== null;
    }
    /**
     * @throws Exception
     */
    public function disallowTestOutput() : bool
    {
        if ($this->disallowTestOutput === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->disallowTestOutput;
    }
    public function hasDisallowTodoAnnotatedTests() : bool
    {
        return $this->disallowTodoAnnotatedTests !== null;
    }
    /**
     * @throws Exception
     */
    public function disallowTodoAnnotatedTests() : bool
    {
        if ($this->disallowTodoAnnotatedTests === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->disallowTodoAnnotatedTests;
    }
    public function hasEnforceTimeLimit() : bool
    {
        return $this->enforceTimeLimit !== null;
    }
    /**
     * @throws Exception
     */
    public function enforceTimeLimit() : bool
    {
        if ($this->enforceTimeLimit === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->enforceTimeLimit;
    }
    public function hasExcludeGroups() : bool
    {
        return $this->excludeGroups !== null;
    }
    /**
     * @throws Exception
     */
    public function excludeGroups() : array
    {
        if ($this->excludeGroups === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->excludeGroups;
    }
    public function hasExecutionOrder() : bool
    {
        return $this->executionOrder !== null;
    }
    /**
     * @throws Exception
     */
    public function executionOrder() : int
    {
        if ($this->executionOrder === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->executionOrder;
    }
    public function hasExecutionOrderDefects() : bool
    {
        return $this->executionOrderDefects !== null;
    }
    /**
     * @throws Exception
     */
    public function executionOrderDefects() : int
    {
        if ($this->executionOrderDefects === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->executionOrderDefects;
    }
    public function hasFailOnEmptyTestSuite() : bool
    {
        return $this->failOnEmptyTestSuite !== null;
    }
    /**
     * @throws Exception
     */
    public function failOnEmptyTestSuite() : bool
    {
        if ($this->failOnEmptyTestSuite === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->failOnEmptyTestSuite;
    }
    public function hasFailOnIncomplete() : bool
    {
        return $this->failOnIncomplete !== null;
    }
    /**
     * @throws Exception
     */
    public function failOnIncomplete() : bool
    {
        if ($this->failOnIncomplete === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->failOnIncomplete;
    }
    public function hasFailOnRisky() : bool
    {
        return $this->failOnRisky !== null;
    }
    /**
     * @throws Exception
     */
    public function failOnRisky() : bool
    {
        if ($this->failOnRisky === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->failOnRisky;
    }
    public function hasFailOnSkipped() : bool
    {
        return $this->failOnSkipped !== null;
    }
    /**
     * @throws Exception
     */
    public function failOnSkipped() : bool
    {
        if ($this->failOnSkipped === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->failOnSkipped;
    }
    public function hasFailOnWarning() : bool
    {
        return $this->failOnWarning !== null;
    }
    /**
     * @throws Exception
     */
    public function failOnWarning() : bool
    {
        if ($this->failOnWarning === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->failOnWarning;
    }
    public function hasFilter() : bool
    {
        return $this->filter !== null;
    }
    /**
     * @throws Exception
     */
    public function filter() : string
    {
        if ($this->filter === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->filter;
    }
    public function hasGenerateConfiguration() : bool
    {
        return $this->generateConfiguration !== null;
    }
    /**
     * @throws Exception
     */
    public function generateConfiguration() : bool
    {
        if ($this->generateConfiguration === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->generateConfiguration;
    }
    public function hasMigrateConfiguration() : bool
    {
        return $this->migrateConfiguration !== null;
    }
    /**
     * @throws Exception
     */
    public function migrateConfiguration() : bool
    {
        if ($this->migrateConfiguration === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->migrateConfiguration;
    }
    public function hasGroups() : bool
    {
        return $this->groups !== null;
    }
    /**
     * @throws Exception
     */
    public function groups() : array
    {
        if ($this->groups === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->groups;
    }
    public function hasTestsCovering() : bool
    {
        return $this->testsCovering !== null;
    }
    /**
     * @throws Exception
     */
    public function testsCovering() : array
    {
        if ($this->testsCovering === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testsCovering;
    }
    public function hasTestsUsing() : bool
    {
        return $this->testsUsing !== null;
    }
    /**
     * @throws Exception
     */
    public function testsUsing() : array
    {
        if ($this->testsUsing === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testsUsing;
    }
    public function hasHelp() : bool
    {
        return $this->help !== null;
    }
    /**
     * @throws Exception
     */
    public function help() : bool
    {
        if ($this->help === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->help;
    }
    public function hasIncludePath() : bool
    {
        return $this->includePath !== null;
    }
    /**
     * @throws Exception
     */
    public function includePath() : string
    {
        if ($this->includePath === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->includePath;
    }
    public function hasIniSettings() : bool
    {
        return $this->iniSettings !== null;
    }
    /**
     * @throws Exception
     */
    public function iniSettings() : array
    {
        if ($this->iniSettings === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->iniSettings;
    }
    public function hasJunitLogfile() : bool
    {
        return $this->junitLogfile !== null;
    }
    /**
     * @throws Exception
     */
    public function junitLogfile() : string
    {
        if ($this->junitLogfile === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->junitLogfile;
    }
    public function hasListGroups() : bool
    {
        return $this->listGroups !== null;
    }
    /**
     * @throws Exception
     */
    public function listGroups() : bool
    {
        if ($this->listGroups === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->listGroups;
    }
    public function hasListSuites() : bool
    {
        return $this->listSuites !== null;
    }
    /**
     * @throws Exception
     */
    public function listSuites() : bool
    {
        if ($this->listSuites === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->listSuites;
    }
    public function hasListTests() : bool
    {
        return $this->listTests !== null;
    }
    /**
     * @throws Exception
     */
    public function listTests() : bool
    {
        if ($this->listTests === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->listTests;
    }
    public function hasListTestsXml() : bool
    {
        return $this->listTestsXml !== null;
    }
    /**
     * @throws Exception
     */
    public function listTestsXml() : string
    {
        if ($this->listTestsXml === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->listTestsXml;
    }
    public function hasNoCoverage() : bool
    {
        return $this->noCoverage !== null;
    }
    /**
     * @throws Exception
     */
    public function noCoverage() : bool
    {
        if ($this->noCoverage === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->noCoverage;
    }
    public function hasNoExtensions() : bool
    {
        return $this->noExtensions !== null;
    }
    /**
     * @throws Exception
     */
    public function noExtensions() : bool
    {
        if ($this->noExtensions === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->noExtensions;
    }
    public function hasExtensions() : bool
    {
        return $this->extensions !== null;
    }
    /**
     * @throws Exception
     */
    public function extensions() : array
    {
        if ($this->extensions === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->extensions;
    }
    public function hasUnavailableExtensions() : bool
    {
        return $this->unavailableExtensions !== null;
    }
    /**
     * @throws Exception
     */
    public function unavailableExtensions() : array
    {
        if ($this->unavailableExtensions === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->unavailableExtensions;
    }
    public function hasNoInteraction() : bool
    {
        return $this->noInteraction !== null;
    }
    /**
     * @throws Exception
     */
    public function noInteraction() : bool
    {
        if ($this->noInteraction === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->noInteraction;
    }
    public function hasNoLogging() : bool
    {
        return $this->noLogging !== null;
    }
    /**
     * @throws Exception
     */
    public function noLogging() : bool
    {
        if ($this->noLogging === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->noLogging;
    }
    public function hasPrinter() : bool
    {
        return $this->printer !== null;
    }
    /**
     * @throws Exception
     */
    public function printer() : string
    {
        if ($this->printer === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->printer;
    }
    public function hasProcessIsolation() : bool
    {
        return $this->processIsolation !== null;
    }
    /**
     * @throws Exception
     */
    public function processIsolation() : bool
    {
        if ($this->processIsolation === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->processIsolation;
    }
    public function hasRandomOrderSeed() : bool
    {
        return $this->randomOrderSeed !== null;
    }
    /**
     * @throws Exception
     */
    public function randomOrderSeed() : int
    {
        if ($this->randomOrderSeed === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->randomOrderSeed;
    }
    public function hasRepeat() : bool
    {
        return $this->repeat !== null;
    }
    /**
     * @throws Exception
     */
    public function repeat() : int
    {
        if ($this->repeat === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->repeat;
    }
    public function hasReportUselessTests() : bool
    {
        return $this->reportUselessTests !== null;
    }
    /**
     * @throws Exception
     */
    public function reportUselessTests() : bool
    {
        if ($this->reportUselessTests === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->reportUselessTests;
    }
    public function hasResolveDependencies() : bool
    {
        return $this->resolveDependencies !== null;
    }
    /**
     * @throws Exception
     */
    public function resolveDependencies() : bool
    {
        if ($this->resolveDependencies === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->resolveDependencies;
    }
    public function hasReverseList() : bool
    {
        return $this->reverseList !== null;
    }
    /**
     * @throws Exception
     */
    public function reverseList() : bool
    {
        if ($this->reverseList === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->reverseList;
    }
    public function hasStderr() : bool
    {
        return $this->stderr !== null;
    }
    /**
     * @throws Exception
     */
    public function stderr() : bool
    {
        if ($this->stderr === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stderr;
    }
    public function hasStrictCoverage() : bool
    {
        return $this->strictCoverage !== null;
    }
    /**
     * @throws Exception
     */
    public function strictCoverage() : bool
    {
        if ($this->strictCoverage === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->strictCoverage;
    }
    public function hasStopOnDefect() : bool
    {
        return $this->stopOnDefect !== null;
    }
    /**
     * @throws Exception
     */
    public function stopOnDefect() : bool
    {
        if ($this->stopOnDefect === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stopOnDefect;
    }
    public function hasStopOnError() : bool
    {
        return $this->stopOnError !== null;
    }
    /**
     * @throws Exception
     */
    public function stopOnError() : bool
    {
        if ($this->stopOnError === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stopOnError;
    }
    public function hasStopOnFailure() : bool
    {
        return $this->stopOnFailure !== null;
    }
    /**
     * @throws Exception
     */
    public function stopOnFailure() : bool
    {
        if ($this->stopOnFailure === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stopOnFailure;
    }
    public function hasStopOnIncomplete() : bool
    {
        return $this->stopOnIncomplete !== null;
    }
    /**
     * @throws Exception
     */
    public function stopOnIncomplete() : bool
    {
        if ($this->stopOnIncomplete === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stopOnIncomplete;
    }
    public function hasStopOnRisky() : bool
    {
        return $this->stopOnRisky !== null;
    }
    /**
     * @throws Exception
     */
    public function stopOnRisky() : bool
    {
        if ($this->stopOnRisky === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stopOnRisky;
    }
    public function hasStopOnSkipped() : bool
    {
        return $this->stopOnSkipped !== null;
    }
    /**
     * @throws Exception
     */
    public function stopOnSkipped() : bool
    {
        if ($this->stopOnSkipped === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stopOnSkipped;
    }
    public function hasStopOnWarning() : bool
    {
        return $this->stopOnWarning !== null;
    }
    /**
     * @throws Exception
     */
    public function stopOnWarning() : bool
    {
        if ($this->stopOnWarning === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->stopOnWarning;
    }
    public function hasTeamcityLogfile() : bool
    {
        return $this->teamcityLogfile !== null;
    }
    /**
     * @throws Exception
     */
    public function teamcityLogfile() : string
    {
        if ($this->teamcityLogfile === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->teamcityLogfile;
    }
    public function hasTestdoxExcludeGroups() : bool
    {
        return $this->testdoxExcludeGroups !== null;
    }
    /**
     * @throws Exception
     */
    public function testdoxExcludeGroups() : array
    {
        if ($this->testdoxExcludeGroups === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testdoxExcludeGroups;
    }
    public function hasTestdoxGroups() : bool
    {
        return $this->testdoxGroups !== null;
    }
    /**
     * @throws Exception
     */
    public function testdoxGroups() : array
    {
        if ($this->testdoxGroups === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testdoxGroups;
    }
    public function hasTestdoxHtmlFile() : bool
    {
        return $this->testdoxHtmlFile !== null;
    }
    /**
     * @throws Exception
     */
    public function testdoxHtmlFile() : string
    {
        if ($this->testdoxHtmlFile === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testdoxHtmlFile;
    }
    public function hasTestdoxTextFile() : bool
    {
        return $this->testdoxTextFile !== null;
    }
    /**
     * @throws Exception
     */
    public function testdoxTextFile() : string
    {
        if ($this->testdoxTextFile === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testdoxTextFile;
    }
    public function hasTestdoxXmlFile() : bool
    {
        return $this->testdoxXmlFile !== null;
    }
    /**
     * @throws Exception
     */
    public function testdoxXmlFile() : string
    {
        if ($this->testdoxXmlFile === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testdoxXmlFile;
    }
    public function hasTestSuffixes() : bool
    {
        return $this->testSuffixes !== null;
    }
    /**
     * @throws Exception
     */
    public function testSuffixes() : array
    {
        if ($this->testSuffixes === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testSuffixes;
    }
    public function hasTestSuite() : bool
    {
        return $this->testSuite !== null;
    }
    /**
     * @throws Exception
     */
    public function testSuite() : string
    {
        if ($this->testSuite === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->testSuite;
    }
    public function unrecognizedOptions() : array
    {
        return $this->unrecognizedOptions;
    }
    public function hasUnrecognizedOrderBy() : bool
    {
        return $this->unrecognizedOrderBy !== null;
    }
    /**
     * @throws Exception
     */
    public function unrecognizedOrderBy() : string
    {
        if ($this->unrecognizedOrderBy === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->unrecognizedOrderBy;
    }
    public function hasUseDefaultConfiguration() : bool
    {
        return $this->useDefaultConfiguration !== null;
    }
    /**
     * @throws Exception
     */
    public function useDefaultConfiguration() : bool
    {
        if ($this->useDefaultConfiguration === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->useDefaultConfiguration;
    }
    public function hasVerbose() : bool
    {
        return $this->verbose !== null;
    }
    /**
     * @throws Exception
     */
    public function verbose() : bool
    {
        if ($this->verbose === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->verbose;
    }
    public function hasVersion() : bool
    {
        return $this->version !== null;
    }
    /**
     * @throws Exception
     */
    public function version() : bool
    {
        if ($this->version === null) {
            throw new \PHPUnit\TextUI\CliArguments\Exception();
        }
        return $this->version;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\CliArguments;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Exception extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\CliArguments;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Mapper
{
    /**
     * @throws Exception
     */
    public function mapToLegacyArray(\PHPUnit\TextUI\CliArguments\Configuration $arguments) : array
    {
        $result = ['extensions' => [], 'listGroups' => \false, 'listSuites' => \false, 'listTests' => \false, 'listTestsXml' => \false, 'useDefaultConfiguration' => \true, 'loadedExtensions' => [], 'unavailableExtensions' => [], 'notLoadedExtensions' => []];
        if ($arguments->hasColors()) {
            $result['colors'] = $arguments->colors();
        }
        if ($arguments->hasBootstrap()) {
            $result['bootstrap'] = $arguments->bootstrap();
        }
        if ($arguments->hasCacheDirectory()) {
            $result['cacheDirectory'] = $arguments->cacheDirectory();
        }
        if ($arguments->hasCacheResult()) {
            $result['cacheResult'] = $arguments->cacheResult();
        }
        if ($arguments->hasCacheResultFile()) {
            $result['cacheResultFile'] = $arguments->cacheResultFile();
        }
        if ($arguments->hasColumns()) {
            $result['columns'] = $arguments->columns();
        }
        if ($arguments->hasConfiguration()) {
            $result['configuration'] = $arguments->configuration();
        }
        if ($arguments->hasCoverageCacheDirectory()) {
            $result['coverageCacheDirectory'] = $arguments->coverageCacheDirectory();
        }
        if ($arguments->hasWarmCoverageCache()) {
            $result['warmCoverageCache'] = $arguments->warmCoverageCache();
        }
        if ($arguments->hasCoverageClover()) {
            $result['coverageClover'] = $arguments->coverageClover();
        }
        if ($arguments->hasCoverageCobertura()) {
            $result['coverageCobertura'] = $arguments->coverageCobertura();
        }
        if ($arguments->hasCoverageCrap4J()) {
            $result['coverageCrap4J'] = $arguments->coverageCrap4J();
        }
        if ($arguments->hasCoverageHtml()) {
            $result['coverageHtml'] = $arguments->coverageHtml();
        }
        if ($arguments->hasCoveragePhp()) {
            $result['coveragePHP'] = $arguments->coveragePhp();
        }
        if ($arguments->hasCoverageText()) {
            $result['coverageText'] = $arguments->coverageText();
        }
        if ($arguments->hasCoverageTextShowUncoveredFiles()) {
            $result['coverageTextShowUncoveredFiles'] = $arguments->hasCoverageTextShowUncoveredFiles();
        }
        if ($arguments->hasCoverageTextShowOnlySummary()) {
            $result['coverageTextShowOnlySummary'] = $arguments->coverageTextShowOnlySummary();
        }
        if ($arguments->hasCoverageXml()) {
            $result['coverageXml'] = $arguments->coverageXml();
        }
        if ($arguments->hasPathCoverage()) {
            $result['pathCoverage'] = $arguments->pathCoverage();
        }
        if ($arguments->hasDebug()) {
            $result['debug'] = $arguments->debug();
        }
        if ($arguments->hasHelp()) {
            $result['help'] = $arguments->help();
        }
        if ($arguments->hasFilter()) {
            $result['filter'] = $arguments->filter();
        }
        if ($arguments->hasTestSuite()) {
            $result['testsuite'] = $arguments->testSuite();
        }
        if ($arguments->hasGroups()) {
            $result['groups'] = $arguments->groups();
        }
        if ($arguments->hasExcludeGroups()) {
            $result['excludeGroups'] = $arguments->excludeGroups();
        }
        if ($arguments->hasTestsCovering()) {
            $result['testsCovering'] = $arguments->testsCovering();
        }
        if ($arguments->hasTestsUsing()) {
            $result['testsUsing'] = $arguments->testsUsing();
        }
        if ($arguments->hasTestSuffixes()) {
            $result['testSuffixes'] = $arguments->testSuffixes();
        }
        if ($arguments->hasIncludePath()) {
            $result['includePath'] = $arguments->includePath();
        }
        if ($arguments->hasListGroups()) {
            $result['listGroups'] = $arguments->listGroups();
        }
        if ($arguments->hasListSuites()) {
            $result['listSuites'] = $arguments->listSuites();
        }
        if ($arguments->hasListTests()) {
            $result['listTests'] = $arguments->listTests();
        }
        if ($arguments->hasListTestsXml()) {
            $result['listTestsXml'] = $arguments->listTestsXml();
        }
        if ($arguments->hasPrinter()) {
            $result['printer'] = $arguments->printer();
        }
        if ($arguments->hasJunitLogfile()) {
            $result['junitLogfile'] = $arguments->junitLogfile();
        }
        if ($arguments->hasTeamcityLogfile()) {
            $result['teamcityLogfile'] = $arguments->teamcityLogfile();
        }
        if ($arguments->hasExecutionOrder()) {
            $result['executionOrder'] = $arguments->executionOrder();
        }
        if ($arguments->hasExecutionOrderDefects()) {
            $result['executionOrderDefects'] = $arguments->executionOrderDefects();
        }
        if ($arguments->hasExtensions()) {
            $result['extensions'] = $arguments->extensions();
        }
        if ($arguments->hasUnavailableExtensions()) {
            $result['unavailableExtensions'] = $arguments->unavailableExtensions();
        }
        if ($arguments->hasResolveDependencies()) {
            $result['resolveDependencies'] = $arguments->resolveDependencies();
        }
        if ($arguments->hasProcessIsolation()) {
            $result['processIsolation'] = $arguments->processIsolation();
        }
        if ($arguments->hasRepeat()) {
            $result['repeat'] = $arguments->repeat();
        }
        if ($arguments->hasStderr()) {
            $result['stderr'] = $arguments->stderr();
        }
        if ($arguments->hasStopOnDefect()) {
            $result['stopOnDefect'] = $arguments->stopOnDefect();
        }
        if ($arguments->hasStopOnError()) {
            $result['stopOnError'] = $arguments->stopOnError();
        }
        if ($arguments->hasStopOnFailure()) {
            $result['stopOnFailure'] = $arguments->stopOnFailure();
        }
        if ($arguments->hasStopOnWarning()) {
            $result['stopOnWarning'] = $arguments->stopOnWarning();
        }
        if ($arguments->hasStopOnIncomplete()) {
            $result['stopOnIncomplete'] = $arguments->stopOnIncomplete();
        }
        if ($arguments->hasStopOnRisky()) {
            $result['stopOnRisky'] = $arguments->stopOnRisky();
        }
        if ($arguments->hasStopOnSkipped()) {
            $result['stopOnSkipped'] = $arguments->stopOnSkipped();
        }
        if ($arguments->hasFailOnEmptyTestSuite()) {
            $result['failOnEmptyTestSuite'] = $arguments->failOnEmptyTestSuite();
        }
        if ($arguments->hasFailOnIncomplete()) {
            $result['failOnIncomplete'] = $arguments->failOnIncomplete();
        }
        if ($arguments->hasFailOnRisky()) {
            $result['failOnRisky'] = $arguments->failOnRisky();
        }
        if ($arguments->hasFailOnSkipped()) {
            $result['failOnSkipped'] = $arguments->failOnSkipped();
        }
        if ($arguments->hasFailOnWarning()) {
            $result['failOnWarning'] = $arguments->failOnWarning();
        }
        if ($arguments->hasTestdoxGroups()) {
            $result['testdoxGroups'] = $arguments->testdoxGroups();
        }
        if ($arguments->hasTestdoxExcludeGroups()) {
            $result['testdoxExcludeGroups'] = $arguments->testdoxExcludeGroups();
        }
        if ($arguments->hasTestdoxHtmlFile()) {
            $result['testdoxHTMLFile'] = $arguments->testdoxHtmlFile();
        }
        if ($arguments->hasTestdoxTextFile()) {
            $result['testdoxTextFile'] = $arguments->testdoxTextFile();
        }
        if ($arguments->hasTestdoxXmlFile()) {
            $result['testdoxXMLFile'] = $arguments->testdoxXmlFile();
        }
        if ($arguments->hasUseDefaultConfiguration()) {
            $result['useDefaultConfiguration'] = $arguments->useDefaultConfiguration();
        }
        if ($arguments->hasNoExtensions()) {
            $result['noExtensions'] = $arguments->noExtensions();
        }
        if ($arguments->hasNoCoverage()) {
            $result['noCoverage'] = $arguments->noCoverage();
        }
        if ($arguments->hasNoLogging()) {
            $result['noLogging'] = $arguments->noLogging();
        }
        if ($arguments->hasNoInteraction()) {
            $result['noInteraction'] = $arguments->noInteraction();
        }
        if ($arguments->hasBackupGlobals()) {
            $result['backupGlobals'] = $arguments->backupGlobals();
        }
        if ($arguments->hasBackupStaticAttributes()) {
            $result['backupStaticProperties'] = $arguments->backupStaticAttributes();
        }
        if ($arguments->hasVerbose()) {
            $result['verbose'] = $arguments->verbose();
        }
        if ($arguments->hasReportUselessTests()) {
            $result['reportUselessTests'] = $arguments->reportUselessTests();
        }
        if ($arguments->hasStrictCoverage()) {
            $result['strictCoverage'] = $arguments->strictCoverage();
        }
        if ($arguments->hasDisableCodeCoverageIgnore()) {
            $result['disableCodeCoverageIgnore'] = $arguments->disableCodeCoverageIgnore();
        }
        if ($arguments->hasBeStrictAboutChangesToGlobalState()) {
            $result['beStrictAboutChangesToGlobalState'] = $arguments->beStrictAboutChangesToGlobalState();
        }
        if ($arguments->hasDisallowTestOutput()) {
            $result['disallowTestOutput'] = $arguments->disallowTestOutput();
        }
        if ($arguments->hasBeStrictAboutResourceUsageDuringSmallTests()) {
            $result['beStrictAboutResourceUsageDuringSmallTests'] = $arguments->beStrictAboutResourceUsageDuringSmallTests();
        }
        if ($arguments->hasDefaultTimeLimit()) {
            $result['defaultTimeLimit'] = $arguments->defaultTimeLimit();
        }
        if ($arguments->hasEnforceTimeLimit()) {
            $result['enforceTimeLimit'] = $arguments->enforceTimeLimit();
        }
        if ($arguments->hasDisallowTodoAnnotatedTests()) {
            $result['disallowTodoAnnotatedTests'] = $arguments->disallowTodoAnnotatedTests();
        }
        if ($arguments->hasReverseList()) {
            $result['reverseList'] = $arguments->reverseList();
        }
        if ($arguments->hasCoverageFilter()) {
            $result['coverageFilter'] = $arguments->coverageFilter();
        }
        if ($arguments->hasRandomOrderSeed()) {
            $result['randomOrderSeed'] = $arguments->randomOrderSeed();
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use const PATH_SEPARATOR;
use const PHP_EOL;
use const STDIN;
use function array_keys;
use function assert;
use function class_exists;
use function copy;
use function extension_loaded;
use function fgets;
use function file_get_contents;
use function file_put_contents;
use function fopen;
use function get_class;
use function getcwd;
use function ini_get;
use function ini_set;
use function is_callable;
use function is_dir;
use function is_file;
use function is_string;
use function printf;
use function realpath;
use function sort;
use function sprintf;
use function stream_resolve_include_path;
use function strpos;
use function trim;
use function version_compare;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Runner\Extension\PharLoader;
use PHPUnit\Runner\TestSuiteLoader;
use PHPUnit\Runner\Version;
use PHPUnit\TextUI\CliArguments\Builder;
use PHPUnit\TextUI\CliArguments\Configuration;
use PHPUnit\TextUI\CliArguments\Exception as ArgumentsException;
use PHPUnit\TextUI\CliArguments\Mapper;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\FilterMapper;
use PHPUnit\TextUI\XmlConfiguration\Generator;
use PHPUnit\TextUI\XmlConfiguration\Loader;
use PHPUnit\TextUI\XmlConfiguration\Migrator;
use PHPUnit\TextUI\XmlConfiguration\PhpHandler;
use PHPUnit\Util\Filesystem;
use PHPUnit\Util\Printer;
use PHPUnit\Util\TextTestListRenderer;
use PHPUnit\Util\XmlTestListRenderer;
use ReflectionClass;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
use PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CacheWarmer;
use PHPUnit\SebastianBergmann\FileIterator\Facade as FileIteratorFacade;
use PHPUnit\SebastianBergmann\Timer\Timer;
use Throwable;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
class Command
{
    /**
     * @var array<string,mixed>
     */
    protected array $arguments = [];
    /**
     * @var array<string,mixed>
     */
    protected array $longOptions = [];
    private bool $versionStringPrinted = \false;
    /**
     * @psalm-var list<string>
     */
    private array $warnings = [];
    /**
     * @throws Exception
     */
    public static function main(bool $exit = \true) : int
    {
        try {
            return (new static())->run($_SERVER['argv'], $exit);
        } catch (\Throwable $t) {
            throw new \PHPUnit\TextUI\RuntimeException($t->getMessage(), (int) $t->getCode(), $t);
        }
    }
    /**
     * @throws Exception
     */
    public function run(array $argv, bool $exit = \true) : int
    {
        $this->handleArguments($argv);
        $runner = new \PHPUnit\TextUI\TestRunner();
        if ($this->arguments['test'] instanceof \PHPUnit\Framework\TestSuite) {
            $suite = $this->arguments['test'];
        } else {
            $suite = $this->getTest($this->arguments['test'], $this->arguments['testSuffixes']);
        }
        if ($this->arguments['listGroups']) {
            return $this->handleListGroups($suite, $exit);
        }
        if ($this->arguments['listSuites']) {
            return $this->handleListSuites($exit);
        }
        if ($this->arguments['listTests']) {
            return $this->handleListTests($suite, $exit);
        }
        if ($this->arguments['listTestsXml']) {
            return $this->handleListTestsXml($suite, $this->arguments['listTestsXml'], $exit);
        }
        unset($this->arguments['test'], $this->arguments['testFile']);
        try {
            $result = $runner->run($suite, $this->arguments, $this->warnings, $exit);
        } catch (\Throwable $t) {
            print $t->getMessage() . \PHP_EOL;
        }
        $return = \PHPUnit\TextUI\TestRunner::FAILURE_EXIT;
        if (isset($result) && $result->wasSuccessful()) {
            $return = \PHPUnit\TextUI\TestRunner::SUCCESS_EXIT;
        } elseif (!isset($result) || $result->errorCount() > 0) {
            $return = \PHPUnit\TextUI\TestRunner::EXCEPTION_EXIT;
        }
        if ($exit) {
            exit($return);
        }
        return $return;
    }
    /**
     * Handles the command-line arguments.
     *
     * A child class of PHPUnit\TextUI\Command can hook into the argument
     * parsing by adding the switch(es) to the $longOptions array and point to a
     * callback method that handles the switch(es) in the child class like this
     *
     * <code>
     * <?php
     * class MyCommand extends PHPUnit\TextUI\Command
     * {
     *     public function __construct()
     *     {
     *         // my-switch won't accept a value, it's an on/off
     *         $this->longOptions['my-switch'] = 'myHandler';
     *         // my-secondswitch will accept a value - note the equals sign
     *         $this->longOptions['my-secondswitch='] = 'myOtherHandler';
     *     }
     *
     *     // --my-switch  -> myHandler()
     *     protected function myHandler()
     *     {
     *     }
     *
     *     // --my-secondswitch foo -> myOtherHandler('foo')
     *     protected function myOtherHandler ($value)
     *     {
     *     }
     *
     *     // You will also need this - the static keyword in the
     *     // PHPUnit\TextUI\Command will mean that it'll be
     *     // PHPUnit\TextUI\Command that gets instantiated,
     *     // not MyCommand
     *     public static function main($exit = true)
     *     {
     *         $command = new static;
     *
     *         return $command->run($_SERVER['argv'], $exit);
     *     }
     *
     * }
     * </code>
     *
     * @throws Exception
     */
    protected function handleArguments(array $argv) : void
    {
        try {
            $arguments = (new \PHPUnit\TextUI\CliArguments\Builder())->fromParameters($argv, \array_keys($this->longOptions));
        } catch (\PHPUnit\TextUI\CliArguments\Exception $e) {
            $this->exitWithErrorMessage($e->getMessage());
        }
        \assert(isset($arguments) && $arguments instanceof \PHPUnit\TextUI\CliArguments\Configuration);
        if ($arguments->hasGenerateConfiguration() && $arguments->generateConfiguration()) {
            $this->generateConfiguration();
        }
        if ($arguments->hasAtLeastVersion()) {
            if (\version_compare(\PHPUnit\Runner\Version::id(), $arguments->atLeastVersion(), '>=')) {
                exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
            }
            exit(\PHPUnit\TextUI\TestRunner::FAILURE_EXIT);
        }
        if ($arguments->hasVersion() && $arguments->version()) {
            $this->printVersionString();
            exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
        }
        if ($arguments->hasCheckVersion() && $arguments->checkVersion()) {
            $this->handleVersionCheck();
        }
        if ($arguments->hasHelp()) {
            $this->showHelp();
            exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
        }
        if ($arguments->hasUnrecognizedOrderBy()) {
            $this->exitWithErrorMessage(\sprintf('unrecognized --order-by option: %s', $arguments->unrecognizedOrderBy()));
        }
        if ($arguments->hasIniSettings()) {
            foreach ($arguments->iniSettings() as $name => $value) {
                \ini_set($name, $value);
            }
        }
        if ($arguments->hasIncludePath()) {
            \ini_set('include_path', $arguments->includePath() . \PATH_SEPARATOR . \ini_get('include_path'));
        }
        $this->arguments = (new \PHPUnit\TextUI\CliArguments\Mapper())->mapToLegacyArray($arguments);
        $this->handleCustomOptions($arguments->unrecognizedOptions());
        $this->handleCustomTestSuite();
        if (!isset($this->arguments['testSuffixes'])) {
            $this->arguments['testSuffixes'] = ['Test.php', '.phpt'];
        }
        if (!isset($this->arguments['test']) && $arguments->hasArgument()) {
            $this->arguments['test'] = \realpath($arguments->argument());
            if ($this->arguments['test'] === \false) {
                $this->exitWithErrorMessage(\sprintf('Cannot open file "%s".', $arguments->argument()));
            }
        }
        if (isset($this->arguments['configuration'])) {
            if (\is_dir($this->arguments['configuration'])) {
                $candidate = $this->configurationFileInDirectory($this->arguments['configuration']);
                if ($candidate !== null) {
                    $this->arguments['configuration'] = $candidate;
                }
            }
        } elseif ($this->arguments['useDefaultConfiguration']) {
            $candidate = $this->configurationFileInDirectory(\getcwd());
            if ($candidate !== null) {
                $this->arguments['configuration'] = $candidate;
            }
        }
        if ($arguments->hasMigrateConfiguration() && $arguments->migrateConfiguration()) {
            if (!isset($this->arguments['configuration'])) {
                print 'No configuration file found to migrate.' . \PHP_EOL;
                exit(\PHPUnit\TextUI\TestRunner::EXCEPTION_EXIT);
            }
            $this->migrateConfiguration(\realpath($this->arguments['configuration']));
        }
        if (isset($this->arguments['configuration'])) {
            try {
                $this->arguments['configurationObject'] = (new \PHPUnit\TextUI\XmlConfiguration\Loader())->load($this->arguments['configuration']);
            } catch (\Throwable $e) {
                print $e->getMessage() . \PHP_EOL;
                exit(\PHPUnit\TextUI\TestRunner::FAILURE_EXIT);
            }
            $phpunitConfiguration = $this->arguments['configurationObject']->phpunit();
            (new \PHPUnit\TextUI\XmlConfiguration\PhpHandler())->handle($this->arguments['configurationObject']->php());
            if (isset($this->arguments['bootstrap'])) {
                $this->handleBootstrap($this->arguments['bootstrap']);
            } elseif ($phpunitConfiguration->hasBootstrap()) {
                $this->handleBootstrap($phpunitConfiguration->bootstrap());
            }
            if (!isset($this->arguments['stderr'])) {
                $this->arguments['stderr'] = $phpunitConfiguration->stderr();
            }
            if (!isset($this->arguments['noExtensions']) && $phpunitConfiguration->hasExtensionsDirectory() && \extension_loaded('phar')) {
                $result = (new \PHPUnit\Runner\Extension\PharLoader())->loadPharExtensionsInDirectory($phpunitConfiguration->extensionsDirectory());
                $this->arguments['loadedExtensions'] = $result['loadedExtensions'];
                $this->arguments['notLoadedExtensions'] = $result['notLoadedExtensions'];
                unset($result);
            }
            if (!isset($this->arguments['columns'])) {
                $this->arguments['columns'] = $phpunitConfiguration->columns();
            }
            if (!isset($this->arguments['printer']) && $phpunitConfiguration->hasPrinterClass()) {
                $file = $phpunitConfiguration->hasPrinterFile() ? $phpunitConfiguration->printerFile() : '';
                $this->arguments['printer'] = $this->handlePrinter($phpunitConfiguration->printerClass(), $file);
            }
            if (!isset($this->arguments['testsuite']) && $phpunitConfiguration->hasDefaultTestSuite()) {
                $this->arguments['testsuite'] = $phpunitConfiguration->defaultTestSuite();
            }
            if (!isset($this->arguments['test'])) {
                try {
                    $this->arguments['test'] = (new \PHPUnit\TextUI\TestSuiteMapper())->map($this->arguments['configurationObject']->testSuite(), $this->arguments['testsuite'] ?? '');
                } catch (\PHPUnit\TextUI\Exception $e) {
                    $this->printVersionString();
                    print $e->getMessage() . \PHP_EOL;
                    exit(\PHPUnit\TextUI\TestRunner::EXCEPTION_EXIT);
                }
            }
        } elseif (isset($this->arguments['bootstrap'])) {
            $this->handleBootstrap($this->arguments['bootstrap']);
        }
        if (isset($this->arguments['printer']) && \is_string($this->arguments['printer'])) {
            $this->arguments['printer'] = $this->handlePrinter($this->arguments['printer']);
        }
        if (isset($this->arguments['configurationObject'], $this->arguments['warmCoverageCache'])) {
            $this->handleWarmCoverageCache($this->arguments['configurationObject']);
        }
        if (!isset($this->arguments['test'])) {
            $this->showHelp();
            exit(\PHPUnit\TextUI\TestRunner::EXCEPTION_EXIT);
        }
    }
    /**
     * Handles the loading of the PHPUnit\Util\Printer implementation.
     *
     * @return null|Printer|string
     */
    protected function handlePrinter(string $printerClass, string $printerFile = '')
    {
        if (!\class_exists($printerClass, \false)) {
            if ($printerFile === '') {
                $printerFile = \PHPUnit\Util\Filesystem::classNameToFilename($printerClass);
            }
            $printerFile = \stream_resolve_include_path($printerFile);
            if ($printerFile) {
                /**
                 * @noinspection PhpIncludeInspection
                 * @psalm-suppress UnresolvableInclude
                 */
                require $printerFile;
            }
        }
        if (!\class_exists($printerClass)) {
            $this->exitWithErrorMessage(\sprintf('Could not use "%s" as printer: class does not exist', $printerClass));
        }
        try {
            $class = new \ReflectionClass($printerClass);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\TextUI\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
            // @codeCoverageIgnoreEnd
        }
        if (!$class->implementsInterface(\PHPUnit\TextUI\ResultPrinter::class)) {
            $this->exitWithErrorMessage(\sprintf('Could not use "%s" as printer: class does not implement %s', $printerClass, \PHPUnit\TextUI\ResultPrinter::class));
        }
        if (!$class->isInstantiable()) {
            $this->exitWithErrorMessage(\sprintf('Could not use "%s" as printer: class cannot be instantiated', $printerClass));
        }
        if ($class->isSubclassOf(\PHPUnit\TextUI\ResultPrinter::class)) {
            return $printerClass;
        }
        $outputStream = isset($this->arguments['stderr']) ? 'php://stderr' : null;
        return $class->newInstance($outputStream);
    }
    /**
     * Loads a bootstrap file.
     */
    protected function handleBootstrap(string $filename) : void
    {
        if (@\fopen($filename, 'r') === \false) {
            $this->exitWithErrorMessage(\sprintf('Cannot open boostrap script "%s".' . "\n", $filename));
        }
        try {
            include_once $filename;
        } catch (\Throwable $t) {
            if ($t instanceof \PHPUnit\Exception) {
                $this->exitWithErrorMessage($t->getMessage());
            }
            $this->exitWithErrorMessage(\sprintf('Error in bootstrap script: %s:%s%s', \get_class($t), \PHP_EOL, $t->getMessage()));
        }
    }
    protected function handleVersionCheck() : void
    {
        $this->printVersionString();
        $latestVersion = \file_get_contents('https://phar.phpunit.de/latest-version-of/phpunit');
        $isOutdated = \version_compare($latestVersion, \PHPUnit\Runner\Version::id(), '>');
        if ($isOutdated) {
            \printf('You are not using the latest version of PHPUnit.' . \PHP_EOL . 'The latest version is PHPUnit %s.' . \PHP_EOL, $latestVersion);
        } else {
            print 'You are using the latest version of PHPUnit.' . \PHP_EOL;
        }
        exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
    }
    /**
     * Show the help message.
     */
    protected function showHelp() : void
    {
        $this->printVersionString();
        (new \PHPUnit\TextUI\Help())->writeToConsole();
    }
    /**
     * Custom callback for test suite discovery.
     */
    protected function handleCustomTestSuite() : void
    {
    }
    private function printVersionString() : void
    {
        if ($this->versionStringPrinted) {
            return;
        }
        print \PHPUnit\Runner\Version::getVersionString() . \PHP_EOL . \PHP_EOL;
        $this->versionStringPrinted = \true;
    }
    private function exitWithErrorMessage(string $message) : void
    {
        $this->printVersionString();
        print $message . \PHP_EOL;
        exit(\PHPUnit\TextUI\TestRunner::FAILURE_EXIT);
    }
    private function handleListGroups(\PHPUnit\Framework\TestSuite $suite, bool $exit) : int
    {
        $this->printVersionString();
        print 'Available test group(s):' . \PHP_EOL;
        $groups = $suite->getGroups();
        \sort($groups);
        foreach ($groups as $group) {
            if (\strpos($group, '__phpunit_') === 0) {
                continue;
            }
            \printf(' - %s' . \PHP_EOL, $group);
        }
        if ($exit) {
            exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
        }
        return \PHPUnit\TextUI\TestRunner::SUCCESS_EXIT;
    }
    /**
     * @throws \PHPUnit\Framework\Exception
     * @throws \PHPUnit\TextUI\XmlConfiguration\Exception
     */
    private function handleListSuites(bool $exit) : int
    {
        $this->printVersionString();
        print 'Available test suite(s):' . \PHP_EOL;
        foreach ($this->arguments['configurationObject']->testSuite() as $testSuite) {
            \printf(' - %s' . \PHP_EOL, $testSuite->name());
        }
        if ($exit) {
            exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
        }
        return \PHPUnit\TextUI\TestRunner::SUCCESS_EXIT;
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function handleListTests(\PHPUnit\Framework\TestSuite $suite, bool $exit) : int
    {
        $this->printVersionString();
        $renderer = new \PHPUnit\Util\TextTestListRenderer();
        print $renderer->render($suite);
        if ($exit) {
            exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
        }
        return \PHPUnit\TextUI\TestRunner::SUCCESS_EXIT;
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function handleListTestsXml(\PHPUnit\Framework\TestSuite $suite, string $target, bool $exit) : int
    {
        $this->printVersionString();
        $renderer = new \PHPUnit\Util\XmlTestListRenderer();
        \file_put_contents($target, $renderer->render($suite));
        \printf('Wrote list of tests that would have been run to %s' . \PHP_EOL, $target);
        if ($exit) {
            exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
        }
        return \PHPUnit\TextUI\TestRunner::SUCCESS_EXIT;
    }
    private function generateConfiguration() : void
    {
        $this->printVersionString();
        print 'Generating phpunit.xml in ' . \getcwd() . \PHP_EOL . \PHP_EOL;
        print 'Bootstrap script (relative to path shown above; default: vendor/autoload.php): ';
        $bootstrapScript = \trim(\fgets(\STDIN));
        print 'Tests directory (relative to path shown above; default: tests): ';
        $testsDirectory = \trim(\fgets(\STDIN));
        print 'Source directory (relative to path shown above; default: src): ';
        $src = \trim(\fgets(\STDIN));
        print 'Cache directory (relative to path shown above; default: .phpunit.cache): ';
        $cacheDirectory = \trim(\fgets(\STDIN));
        if ($bootstrapScript === '') {
            $bootstrapScript = 'vendor/autoload.php';
        }
        if ($testsDirectory === '') {
            $testsDirectory = 'tests';
        }
        if ($src === '') {
            $src = 'src';
        }
        if ($cacheDirectory === '') {
            $cacheDirectory = '.phpunit.cache';
        }
        $generator = new \PHPUnit\TextUI\XmlConfiguration\Generator();
        \file_put_contents('phpunit.xml', $generator->generateDefaultConfiguration(\PHPUnit\Runner\Version::series(), $bootstrapScript, $testsDirectory, $src, $cacheDirectory));
        print \PHP_EOL . 'Generated phpunit.xml in ' . \getcwd() . '.' . \PHP_EOL;
        print 'Make sure to exclude the ' . $cacheDirectory . ' directory from version control.' . \PHP_EOL;
        exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
    }
    private function migrateConfiguration(string $filename) : void
    {
        $this->printVersionString();
        \copy($filename, $filename . '.bak');
        print 'Created backup:         ' . $filename . '.bak' . \PHP_EOL;
        try {
            \file_put_contents($filename, (new \PHPUnit\TextUI\XmlConfiguration\Migrator())->migrate($filename));
            print 'Migrated configuration: ' . $filename . \PHP_EOL;
        } catch (\Throwable $t) {
            print 'Migration failed: ' . $t->getMessage() . \PHP_EOL;
            exit(\PHPUnit\TextUI\TestRunner::EXCEPTION_EXIT);
        }
        exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
    }
    private function handleCustomOptions(array $unrecognizedOptions) : void
    {
        foreach ($unrecognizedOptions as $name => $value) {
            if (isset($this->longOptions[$name])) {
                $handler = $this->longOptions[$name];
            }
            $name .= '=';
            if (isset($this->longOptions[$name])) {
                $handler = $this->longOptions[$name];
            }
            if (isset($handler) && \is_callable([$this, $handler])) {
                $this->{$handler}($value);
                unset($handler);
            }
        }
    }
    private function handleWarmCoverageCache(\PHPUnit\TextUI\XmlConfiguration\Configuration $configuration) : void
    {
        $this->printVersionString();
        if (isset($this->arguments['coverageCacheDirectory'])) {
            $cacheDirectory = $this->arguments['coverageCacheDirectory'];
        } elseif ($configuration->codeCoverage()->hasCacheDirectory()) {
            $cacheDirectory = $configuration->codeCoverage()->cacheDirectory()->path();
        } else {
            print 'Cache for static analysis has not been configured' . \PHP_EOL;
            exit(\PHPUnit\TextUI\TestRunner::EXCEPTION_EXIT);
        }
        $filter = new \PHPUnit\SebastianBergmann\CodeCoverage\Filter();
        if ($configuration->codeCoverage()->hasNonEmptyListOfFilesToBeIncludedInCodeCoverageReport()) {
            (new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\FilterMapper())->map($filter, $configuration->codeCoverage());
        } elseif (isset($this->arguments['coverageFilter'])) {
            if (!\is_array($this->arguments['coverageFilter'])) {
                $coverageFilterDirectories = [$this->arguments['coverageFilter']];
            } else {
                $coverageFilterDirectories = $this->arguments['coverageFilter'];
            }
            foreach ($coverageFilterDirectories as $coverageFilterDirectory) {
                $filter->includeDirectory($coverageFilterDirectory);
            }
        } else {
            print 'Filter for code coverage has not been configured' . \PHP_EOL;
            exit(\PHPUnit\TextUI\TestRunner::EXCEPTION_EXIT);
        }
        $timer = new \PHPUnit\SebastianBergmann\Timer\Timer();
        $timer->start();
        print 'Warming cache for static analysis ... ';
        (new \PHPUnit\SebastianBergmann\CodeCoverage\StaticAnalysis\CacheWarmer())->warmCache($cacheDirectory, !$configuration->codeCoverage()->disableCodeCoverageIgnore(), $configuration->codeCoverage()->ignoreDeprecatedCodeUnits(), $filter);
        print 'done [' . $timer->stop()->asString() . ']' . \PHP_EOL;
        exit(\PHPUnit\TextUI\TestRunner::SUCCESS_EXIT);
    }
    private function configurationFileInDirectory(string $directory) : ?string
    {
        $candidates = [$directory . '/phpunit.xml', $directory . '/phpunit.xml.dist'];
        foreach ($candidates as $candidate) {
            if (\is_file($candidate)) {
                return \realpath($candidate);
            }
        }
        return null;
    }
    /**
     * @param array|string $suffixes
     */
    private function getTest(string $suiteClassFile, $suffixes = '') : \PHPUnit\Framework\TestSuite
    {
        if (\is_dir($suiteClassFile)) {
            /** @var string[] $files */
            $files = (new \PHPUnit\SebastianBergmann\FileIterator\Facade())->getFilesAsArray($suiteClassFile, $suffixes);
            $suite = new \PHPUnit\Framework\TestSuite($suiteClassFile);
            $suite->addTestFiles($files);
            return $suite;
        }
        if (\is_file($suiteClassFile) && \substr($suiteClassFile, -5, 5) === '.phpt') {
            $suite = new \PHPUnit\Framework\TestSuite();
            $suite->addTestFile($suiteClassFile);
            return $suite;
        }
        try {
            $testClass = (new \PHPUnit\Runner\TestSuiteLoader())->load($suiteClassFile);
        } catch (\PHPUnit\Exception $e) {
            print $e->getMessage() . \PHP_EOL;
            exit(1);
        }
        return new \PHPUnit\Framework\TestSuite($testClass);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use const PHP_EOL;
use function array_map;
use function array_reverse;
use function count;
use function floor;
use function implode;
use function in_array;
use function is_int;
use function max;
use function preg_split;
use function sprintf;
use function str_pad;
use function str_repeat;
use function strlen;
use function vsprintf;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\Exception;
use PHPUnit\Framework\InvalidArgumentException;
use PHPUnit\Framework\SelfDescribing;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestFailure;
use PHPUnit\Framework\TestResult;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\Warning;
use PHPUnit\Runner\PhptTestCase;
use PHPUnit\Util\Color;
use PHPUnit\Util\Printer;
use PHPUnit\SebastianBergmann\Environment\Console;
use PHPUnit\SebastianBergmann\Timer\ResourceUsageFormatter;
use PHPUnit\SebastianBergmann\Timer\Timer;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class DefaultResultPrinter extends \PHPUnit\Util\Printer implements \PHPUnit\TextUI\ResultPrinter
{
    public const EVENT_TEST_START = 0;
    public const EVENT_TEST_END = 1;
    public const EVENT_TESTSUITE_START = 2;
    public const EVENT_TESTSUITE_END = 3;
    public const COLOR_NEVER = 'never';
    public const COLOR_AUTO = 'auto';
    public const COLOR_ALWAYS = 'always';
    public const COLOR_DEFAULT = self::COLOR_NEVER;
    private const AVAILABLE_COLORS = [self::COLOR_NEVER, self::COLOR_AUTO, self::COLOR_ALWAYS];
    protected int $column = 0;
    protected ?int $maxColumn = null;
    protected bool $lastTestFailed = \false;
    protected int $numAssertions = 0;
    protected int $numTests = -1;
    protected int $numTestsRun = 0;
    protected ?int $numTestsWidth = null;
    protected bool $colors = \false;
    protected bool $debug = \false;
    protected bool $verbose = \false;
    private int $numberOfColumns;
    private bool $reverse;
    private bool $defectListPrinted = \false;
    private \PHPUnit\SebastianBergmann\Timer\Timer $timer;
    /**
     * Constructor.
     *
     * @param null|resource|string $out
     * @param int|string           $numberOfColumns
     *
     * @throws Exception
     */
    public function __construct($out = null, bool $verbose = \false, string $colors = self::COLOR_DEFAULT, bool $debug = \false, $numberOfColumns = 80, bool $reverse = \false)
    {
        parent::__construct($out);
        if (!\in_array($colors, self::AVAILABLE_COLORS, \true)) {
            throw \PHPUnit\Framework\InvalidArgumentException::create(3, \vsprintf('value from "%s", "%s" or "%s"', self::AVAILABLE_COLORS));
        }
        if (!\is_int($numberOfColumns) && $numberOfColumns !== 'max') {
            throw \PHPUnit\Framework\InvalidArgumentException::create(5, 'integer or "max"');
        }
        $console = new \PHPUnit\SebastianBergmann\Environment\Console();
        $maxNumberOfColumns = $console->getNumberOfColumns();
        if ($numberOfColumns === 'max' || $numberOfColumns !== 80 && $numberOfColumns > $maxNumberOfColumns) {
            $numberOfColumns = $maxNumberOfColumns;
        }
        $this->numberOfColumns = $numberOfColumns;
        $this->verbose = $verbose;
        $this->debug = $debug;
        $this->reverse = $reverse;
        if ($colors === self::COLOR_AUTO && $console->hasColorSupport()) {
            $this->colors = \true;
        } else {
            $this->colors = self::COLOR_ALWAYS === $colors;
        }
        $this->timer = new \PHPUnit\SebastianBergmann\Timer\Timer();
        $this->timer->start();
    }
    public function printResult(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printHeader($result);
        $this->printErrors($result);
        $this->printWarnings($result);
        $this->printFailures($result);
        $this->printRisky($result);
        if ($this->verbose) {
            $this->printIncompletes($result);
            $this->printSkipped($result);
        }
        $this->printFooter($result);
    }
    /**
     * An error occurred.
     */
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->writeProgressWithColor('fg-red, bold', 'E');
        $this->lastTestFailed = \true;
    }
    /**
     * A failure occurred.
     */
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        $this->writeProgressWithColor('bg-red, fg-white', 'F');
        $this->lastTestFailed = \true;
    }
    /**
     * A warning occurred.
     */
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
        $this->writeProgressWithColor('fg-yellow, bold', 'W');
        $this->lastTestFailed = \true;
    }
    /**
     * Incomplete test.
     */
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->writeProgressWithColor('fg-yellow, bold', 'I');
        $this->lastTestFailed = \true;
    }
    /**
     * Risky test.
     */
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->writeProgressWithColor('fg-yellow, bold', 'R');
        $this->lastTestFailed = \true;
    }
    /**
     * Skipped test.
     */
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->writeProgressWithColor('fg-cyan, bold', 'S');
        $this->lastTestFailed = \true;
    }
    /**
     * A testsuite started.
     */
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
        if ($this->numTests == -1) {
            $this->numTests = \count($suite);
            $this->numTestsWidth = \strlen((string) $this->numTests);
            $this->maxColumn = $this->numberOfColumns - \strlen('  /  (XXX%)') - 2 * $this->numTestsWidth;
        }
    }
    /**
     * A testsuite ended.
     */
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
    }
    /**
     * A test started.
     */
    public function startTest(\PHPUnit\Framework\Test $test) : void
    {
        if ($this->debug) {
            $this->write(\sprintf("Test '%s' started\n", $this->describe($test)));
        }
    }
    /**
     * A test ended.
     */
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        if ($this->debug) {
            $this->write(\sprintf("Test '%s' ended\n", $this->describe($test)));
        }
        if (!$this->lastTestFailed) {
            $this->writeProgress('.');
        }
        if ($test instanceof \PHPUnit\Framework\TestCase) {
            $this->numAssertions += $test->numberOfAssertionsPerformed();
        } elseif ($test instanceof \PHPUnit\Runner\PhptTestCase) {
            $this->numAssertions++;
        }
        $this->lastTestFailed = \false;
        if ($test instanceof \PHPUnit\Framework\TestCase && !$test->hasExpectationOnOutput()) {
            $this->write($test->output());
        }
    }
    protected function printDefects(array $defects, string $type) : void
    {
        $count = \count($defects);
        if ($count == 0) {
            return;
        }
        if ($this->defectListPrinted) {
            $this->write("\n--\n\n");
        }
        $this->write(\sprintf("There %s %d %s%s:\n", $count == 1 ? 'was' : 'were', $count, $type, $count == 1 ? '' : 's'));
        $i = 1;
        if ($this->reverse) {
            $defects = \array_reverse($defects);
        }
        foreach ($defects as $defect) {
            $this->printDefect($defect, $i++);
        }
        $this->defectListPrinted = \true;
    }
    protected function printDefect(\PHPUnit\Framework\TestFailure $defect, int $count) : void
    {
        $this->printDefectHeader($defect, $count);
        $this->printDefectTrace($defect);
    }
    protected function printDefectHeader(\PHPUnit\Framework\TestFailure $defect, int $count) : void
    {
        $this->write(\sprintf("\n%d) %s\n", $count, $defect->getTestName()));
    }
    protected function printDefectTrace(\PHPUnit\Framework\TestFailure $defect) : void
    {
        $e = $defect->thrownException();
        $this->write((string) $e);
        while ($e = $e->getPrevious()) {
            $this->write("\nCaused by\n" . $e);
        }
    }
    protected function printErrors(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printDefects($result->errors(), 'error');
    }
    protected function printFailures(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printDefects($result->failures(), 'failure');
    }
    protected function printWarnings(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printDefects($result->warnings(), 'warning');
    }
    protected function printIncompletes(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printDefects($result->notImplemented(), 'incomplete test');
    }
    protected function printRisky(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printDefects($result->risky(), 'risky test');
    }
    protected function printSkipped(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printDefects($result->skipped(), 'skipped test');
    }
    protected function printHeader(\PHPUnit\Framework\TestResult $result) : void
    {
        if (\count($result) > 0) {
            $this->write(\PHP_EOL . \PHP_EOL . (new \PHPUnit\SebastianBergmann\Timer\ResourceUsageFormatter())->resourceUsage($this->timer->stop()) . \PHP_EOL . \PHP_EOL);
        }
    }
    protected function printFooter(\PHPUnit\Framework\TestResult $result) : void
    {
        if (\count($result) === 0) {
            $this->writeWithColor('fg-black, bg-yellow', 'No tests executed!');
            return;
        }
        if ($result->wasSuccessfulAndNoTestIsRiskyOrSkippedOrIncomplete()) {
            $this->writeWithColor('fg-black, bg-green', \sprintf('OK (%d test%s, %d assertion%s)', \count($result), \count($result) === 1 ? '' : 's', $this->numAssertions, $this->numAssertions === 1 ? '' : 's'));
            return;
        }
        $color = 'fg-black, bg-yellow';
        if ($result->wasSuccessful()) {
            if ($this->verbose || !$result->allHarmless()) {
                $this->write("\n");
            }
            $this->writeWithColor($color, 'OK, but incomplete, skipped, or risky tests!');
        } else {
            $this->write("\n");
            if ($result->errorCount()) {
                $color = 'fg-white, bg-red';
                $this->writeWithColor($color, 'ERRORS!');
            } elseif ($result->failureCount()) {
                $color = 'fg-white, bg-red';
                $this->writeWithColor($color, 'FAILURES!');
            } elseif ($result->warningCount()) {
                $color = 'fg-black, bg-yellow';
                $this->writeWithColor($color, 'WARNINGS!');
            }
        }
        $this->writeCountString(\count($result), 'Tests', $color, \true);
        $this->writeCountString($this->numAssertions, 'Assertions', $color, \true);
        $this->writeCountString($result->errorCount(), 'Errors', $color);
        $this->writeCountString($result->failureCount(), 'Failures', $color);
        $this->writeCountString($result->warningCount(), 'Warnings', $color);
        $this->writeCountString($result->skippedCount(), 'Skipped', $color);
        $this->writeCountString($result->notImplementedCount(), 'Incomplete', $color);
        $this->writeCountString($result->riskyCount(), 'Risky', $color);
        $this->writeWithColor($color, '.');
    }
    protected function writeProgress(string $progress) : void
    {
        if ($this->debug) {
            return;
        }
        $this->write($progress);
        $this->column++;
        $this->numTestsRun++;
        if ($this->column == $this->maxColumn || $this->numTestsRun == $this->numTests) {
            if ($this->numTestsRun == $this->numTests) {
                $this->write(\str_repeat(' ', $this->maxColumn - $this->column));
            }
            $this->write(\sprintf(' %' . $this->numTestsWidth . 'd / %' . $this->numTestsWidth . 'd (%3s%%)', $this->numTestsRun, $this->numTests, \floor($this->numTestsRun / $this->numTests * 100)));
            if ($this->column == $this->maxColumn) {
                $this->writeNewLine();
            }
        }
    }
    protected function writeNewLine() : void
    {
        $this->column = 0;
        $this->write("\n");
    }
    /**
     * Formats a buffer with a specified ANSI color sequence if colors are
     * enabled.
     */
    protected function colorizeTextBox(string $color, string $buffer) : string
    {
        if (!$this->colors) {
            return $buffer;
        }
        $lines = \preg_split('/\\r\\n|\\r|\\n/', $buffer);
        $padding = \max(\array_map('\\strlen', $lines));
        $styledLines = [];
        foreach ($lines as $line) {
            $styledLines[] = \PHPUnit\Util\Color::colorize($color, \str_pad($line, $padding));
        }
        return \implode(\PHP_EOL, $styledLines);
    }
    /**
     * Writes a buffer out with a color sequence if colors are enabled.
     */
    protected function writeWithColor(string $color, string $buffer, bool $lf = \true) : void
    {
        $this->write($this->colorizeTextBox($color, $buffer));
        if ($lf) {
            $this->write(\PHP_EOL);
        }
    }
    /**
     * Writes progress with a color sequence if colors are enabled.
     */
    protected function writeProgressWithColor(string $color, string $buffer) : void
    {
        $buffer = $this->colorizeTextBox($color, $buffer);
        $this->writeProgress($buffer);
    }
    private function writeCountString(int $count, string $name, string $color, bool $always = \false) : void
    {
        static $first = \true;
        if ($always || $count > 0) {
            $this->writeWithColor($color, \sprintf('%s%s: %d', !$first ? ', ' : '', $name, $count), \false);
            $first = \false;
        }
    }
    private function describe(\PHPUnit\Framework\Test $test) : string
    {
        if ($test instanceof \PHPUnit\Framework\SelfDescribing) {
            return $test->toString();
        }
        return \get_class($test);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use Throwable;
/**
 * @internal This interface is not covered by the backward compatibility promise for PHPUnit
 */
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use RuntimeException;
/**
 * @internal This interface is not covered by the backward compatibility promise for PHPUnit
 */
final class ReflectionException extends \RuntimeException implements \PHPUnit\TextUI\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

/**
 * @internal This interface is not covered by the backward compatibility promise for PHPUnit
 */
final class RuntimeException extends \RuntimeException implements \PHPUnit\TextUI\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use function sprintf;
use RuntimeException;
/**
 * @internal This interface is not covered by the backward compatibility promise for PHPUnit
 */
final class TestDirectoryNotFoundException extends \RuntimeException implements \PHPUnit\TextUI\Exception
{
    public function __construct(string $path)
    {
        parent::__construct(\sprintf('Test directory "%s" not found', $path));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use function sprintf;
use RuntimeException;
/**
 * @internal This interface is not covered by the backward compatibility promise for PHPUnit
 */
final class TestFileNotFoundException extends \RuntimeException implements \PHPUnit\TextUI\Exception
{
    public function __construct(string $path)
    {
        parent::__construct(\sprintf('Test file "%s" not found', $path));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use const PHP_EOL;
use function count;
use function explode;
use function max;
use function preg_replace_callback;
use function str_pad;
use function str_repeat;
use function strlen;
use function wordwrap;
use PHPUnit\Util\Color;
use PHPUnit\SebastianBergmann\Environment\Console;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Help
{
    private const LEFT_MARGIN = '  ';
    private const HELP_TEXT = ['Usage' => [['text' => 'phpunit [options] UnitTest.php'], ['text' => 'phpunit [options] <directory>']], 'Code Coverage Options' => [['arg' => '--coverage-clover <file>', 'desc' => 'Generate code coverage report in Clover XML format'], ['arg' => '--coverage-cobertura <file>', 'desc' => 'Generate code coverage report in Cobertura XML format'], ['arg' => '--coverage-crap4j <file>', 'desc' => 'Generate code coverage report in Crap4J XML format'], ['arg' => '--coverage-html <dir>', 'desc' => 'Generate code coverage report in HTML format'], ['arg' => '--coverage-php <file>', 'desc' => 'Export PHP_CodeCoverage object to file'], ['arg' => '--coverage-text=<file>', 'desc' => 'Generate code coverage report in text format [default: standard output]'], ['arg' => '--coverage-xml <dir>', 'desc' => 'Generate code coverage report in PHPUnit XML format'], ['arg' => '--warm-coverage-cache', 'desc' => 'Warm static analysis cache'], ['arg' => '--coverage-filter <dir>', 'desc' => 'Include <dir> in code coverage analysis'], ['arg' => '--path-coverage', 'desc' => 'Perform path coverage analysis'], ['arg' => '--disable-coverage-ignore', 'desc' => 'Disable annotations for ignoring code coverage'], ['arg' => '--no-coverage', 'desc' => 'Ignore code coverage configuration']], 'Logging Options' => [['arg' => '--log-junit <file>', 'desc' => 'Log test execution in JUnit XML format to file'], ['arg' => '--log-teamcity <file>', 'desc' => 'Log test execution in TeamCity format to file'], ['arg' => '--testdox-html <file>', 'desc' => 'Write agile documentation in HTML format to file'], ['arg' => '--testdox-text <file>', 'desc' => 'Write agile documentation in Text format to file'], ['arg' => '--testdox-xml <file>', 'desc' => 'Write agile documentation in XML format to file'], ['arg' => '--reverse-list', 'desc' => 'Print defects in reverse order'], ['arg' => '--no-logging', 'desc' => 'Ignore logging configuration']], 'Test Selection Options' => [['arg' => '--list-suites', 'desc' => 'List available test suites'], ['arg' => '--testsuite <name>', 'desc' => 'Filter which testsuite to run'], ['arg' => '--list-groups', 'desc' => 'List available test groups'], ['arg' => '--group <name>', 'desc' => 'Only runs tests from the specified group(s)'], ['arg' => '--exclude-group <name>', 'desc' => 'Exclude tests from the specified group(s)'], ['arg' => '--covers <name>', 'desc' => 'Only runs tests annotated with "@covers <name>"'], ['arg' => '--uses <name>', 'desc' => 'Only runs tests annotated with "@uses <name>"'], ['arg' => '--list-tests', 'desc' => 'List available tests'], ['arg' => '--list-tests-xml <file>', 'desc' => 'List available tests in XML format'], ['arg' => '--filter <pattern>', 'desc' => 'Filter which tests to run'], ['arg' => '--test-suffix <suffixes>', 'desc' => 'Only search for test in files with specified suffix(es). Default: Test.php,.phpt']], 'Test Execution Options' => [['arg' => '--dont-report-useless-tests', 'desc' => 'Do not report tests that do not test anything'], ['arg' => '--strict-coverage', 'desc' => 'Be strict about @covers annotation usage'], ['arg' => '--strict-global-state', 'desc' => 'Be strict about changes to global state'], ['arg' => '--disallow-test-output', 'desc' => 'Be strict about output during tests'], ['arg' => '--disallow-resource-usage', 'desc' => 'Be strict about resource usage during small tests'], ['arg' => '--enforce-time-limit', 'desc' => 'Enforce time limit based on test size'], ['arg' => '--default-time-limit <sec>', 'desc' => 'Timeout in seconds for tests without @small, @medium or @large'], ['arg' => '--disallow-todo-tests', 'desc' => 'Disallow @todo-annotated tests'], ['spacer' => ''], ['arg' => '--process-isolation', 'desc' => 'Run each test in a separate PHP process'], ['arg' => '--globals-backup', 'desc' => 'Backup and restore $GLOBALS for each test'], ['arg' => '--static-backup', 'desc' => 'Backup and restore static properties for each test'], ['spacer' => ''], ['arg' => '--colors <flag>', 'desc' => 'Use colors in output ("never", "auto" or "always")'], ['arg' => '--columns <n>', 'desc' => 'Number of columns to use for progress output'], ['arg' => '--columns max', 'desc' => 'Use maximum number of columns for progress output'], ['arg' => '--stderr', 'desc' => 'Write to STDERR instead of STDOUT'], ['arg' => '--stop-on-defect', 'desc' => 'Stop execution upon first not-passed test'], ['arg' => '--stop-on-error', 'desc' => 'Stop execution upon first error'], ['arg' => '--stop-on-failure', 'desc' => 'Stop execution upon first error or failure'], ['arg' => '--stop-on-warning', 'desc' => 'Stop execution upon first warning'], ['arg' => '--stop-on-risky', 'desc' => 'Stop execution upon first risky test'], ['arg' => '--stop-on-skipped', 'desc' => 'Stop execution upon first skipped test'], ['arg' => '--stop-on-incomplete', 'desc' => 'Stop execution upon first incomplete test'], ['arg' => '--fail-on-incomplete', 'desc' => 'Treat incomplete tests as failures'], ['arg' => '--fail-on-risky', 'desc' => 'Treat risky tests as failures'], ['arg' => '--fail-on-skipped', 'desc' => 'Treat skipped tests as failures'], ['arg' => '--fail-on-warning', 'desc' => 'Treat tests with warnings as failures'], ['arg' => '-v|--verbose', 'desc' => 'Output more verbose information'], ['arg' => '--debug', 'desc' => 'Display debugging information'], ['spacer' => ''], ['arg' => '--repeat <times>', 'desc' => 'Runs the test(s) repeatedly'], ['arg' => '--teamcity', 'desc' => 'Report test execution progress in TeamCity format'], ['arg' => '--testdox', 'desc' => 'Report test execution progress in TestDox format'], ['arg' => '--testdox-group', 'desc' => 'Only include tests from the specified group(s)'], ['arg' => '--testdox-exclude-group', 'desc' => 'Exclude tests from the specified group(s)'], ['arg' => '--no-interaction', 'desc' => 'Disable TestDox progress animation'], ['arg' => '--printer <printer>', 'desc' => 'TestListener implementation to use'], ['spacer' => ''], ['arg' => '--order-by <order>', 'desc' => 'Run tests in order: default|defects|duration|no-depends|random|reverse|size'], ['arg' => '--random-order-seed <N>', 'desc' => 'Use a specific random seed <N> for random order'], ['arg' => '--cache-result', 'desc' => 'Write test results to cache file'], ['arg' => '--do-not-cache-result', 'desc' => 'Do not write test results to cache file']], 'Configuration Options' => [['arg' => '--bootstrap <file>', 'desc' => 'A PHP script that is included before the tests run'], ['arg' => '-c|--configuration <file>', 'desc' => 'Read configuration from XML file'], ['arg' => '--no-configuration', 'desc' => 'Ignore default configuration file (phpunit.xml)'], ['arg' => '--extensions <extensions>', 'desc' => 'A comma separated list of PHPUnit extensions to load'], ['arg' => '--no-extensions', 'desc' => 'Do not load PHPUnit extensions'], ['arg' => '--include-path <path(s)>', 'desc' => 'Prepend PHP\'s include_path with given path(s)'], ['arg' => '-d <key[=value]>', 'desc' => 'Sets a php.ini value'], ['arg' => '--cache-directory <dir>', 'desc' => 'Specify cache directory'], ['arg' => '--generate-configuration', 'desc' => 'Generate configuration file with suggested settings'], ['arg' => '--migrate-configuration', 'desc' => 'Migrate configuration file to current format']], 'Miscellaneous Options' => [['arg' => '-h|--help', 'desc' => 'Prints this usage information'], ['arg' => '--version', 'desc' => 'Prints the version and exits'], ['arg' => '--atleast-version <min>', 'desc' => 'Checks that version is greater than min and exits'], ['arg' => '--check-version', 'desc' => 'Check whether PHPUnit is the latest version']]];
    /**
     * @var int Number of columns required to write the longest option name to the console
     */
    private int $maxArgLength = 0;
    /**
     * @var int Number of columns left for the description field after padding and option
     */
    private int $maxDescLength;
    /**
     * @var bool Use color highlights for sections, options and parameters
     */
    private ?bool $hasColor = \false;
    public function __construct(?int $width = null, ?bool $withColor = null)
    {
        if ($width === null) {
            $width = (new \PHPUnit\SebastianBergmann\Environment\Console())->getNumberOfColumns();
        }
        if ($withColor === null) {
            $this->hasColor = (new \PHPUnit\SebastianBergmann\Environment\Console())->hasColorSupport();
        } else {
            $this->hasColor = $withColor;
        }
        foreach (self::HELP_TEXT as $options) {
            foreach ($options as $option) {
                if (isset($option['arg'])) {
                    $this->maxArgLength = \max($this->maxArgLength, isset($option['arg']) ? \strlen($option['arg']) : 0);
                }
            }
        }
        $this->maxDescLength = $width - $this->maxArgLength - 4;
    }
    /**
     * Write the help file to the CLI, adapting width and colors to the console.
     */
    public function writeToConsole() : void
    {
        if ($this->hasColor) {
            $this->writeWithColor();
        } else {
            $this->writePlaintext();
        }
    }
    private function writePlaintext() : void
    {
        foreach (self::HELP_TEXT as $section => $options) {
            print "{$section}:" . \PHP_EOL;
            if ($section !== 'Usage') {
                print \PHP_EOL;
            }
            foreach ($options as $option) {
                if (isset($option['spacer'])) {
                    print \PHP_EOL;
                }
                if (isset($option['text'])) {
                    print self::LEFT_MARGIN . $option['text'] . \PHP_EOL;
                }
                if (isset($option['arg'])) {
                    $arg = \str_pad($option['arg'], $this->maxArgLength);
                    print self::LEFT_MARGIN . $arg . ' ' . $option['desc'] . \PHP_EOL;
                }
            }
            print \PHP_EOL;
        }
    }
    private function writeWithColor() : void
    {
        foreach (self::HELP_TEXT as $section => $options) {
            print \PHPUnit\Util\Color::colorize('fg-yellow', "{$section}:") . \PHP_EOL;
            foreach ($options as $option) {
                if (isset($option['spacer'])) {
                    print \PHP_EOL;
                }
                if (isset($option['text'])) {
                    print self::LEFT_MARGIN . $option['text'] . \PHP_EOL;
                }
                if (isset($option['arg'])) {
                    $arg = \PHPUnit\Util\Color::colorize('fg-green', \str_pad($option['arg'], $this->maxArgLength));
                    $arg = \preg_replace_callback('/(<[^>]+>)/', static function ($matches) {
                        return \PHPUnit\Util\Color::colorize('fg-cyan', $matches[0]);
                    }, $arg);
                    $desc = \explode(\PHP_EOL, \wordwrap($option['desc'], $this->maxDescLength, \PHP_EOL));
                    print self::LEFT_MARGIN . $arg . ' ' . $desc[0] . \PHP_EOL;
                    for ($i = 1; $i < \count($desc); $i++) {
                        print \str_repeat(' ', $this->maxArgLength + 3) . $desc[$i] . \PHP_EOL;
                    }
                }
            }
            print \PHP_EOL;
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use PHPUnit\Framework\TestListener;
use PHPUnit\Framework\TestResult;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
interface ResultPrinter extends \PHPUnit\Framework\TestListener
{
    public function printResult(\PHPUnit\Framework\TestResult $result) : void;
    public function write(string $buffer) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use const DIRECTORY_SEPARATOR;
use const PHP_EOL;
use const PHP_SAPI;
use const PHP_VERSION;
use function array_diff;
use function array_map;
use function assert;
use function class_exists;
use function count;
use function dirname;
use function htmlspecialchars;
use function is_array;
use function is_int;
use function is_string;
use function mt_srand;
use function range;
use function realpath;
use function sprintf;
use function time;
use PHPUnit\Framework\Exception;
use PHPUnit\Framework\TestResult;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Runner\AfterLastTestHook;
use PHPUnit\Runner\BeforeFirstTestHook;
use PHPUnit\Runner\CodeCoverage;
use PHPUnit\Runner\DefaultTestResultCache;
use PHPUnit\Runner\Extension\ExtensionHandler;
use PHPUnit\Runner\Filter\ExcludeGroupFilterIterator;
use PHPUnit\Runner\Filter\Factory;
use PHPUnit\Runner\Filter\IncludeGroupFilterIterator;
use PHPUnit\Runner\Filter\NameFilterIterator;
use PHPUnit\Runner\Hook;
use PHPUnit\Runner\NullTestResultCache;
use PHPUnit\Runner\ResultCacheExtension;
use PHPUnit\Runner\TestHook;
use PHPUnit\Runner\TestListenerAdapter;
use PHPUnit\Runner\TestSuiteSorter;
use PHPUnit\Runner\Version;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\FilterMapper;
use PHPUnit\TextUI\XmlConfiguration\Configuration;
use PHPUnit\TextUI\XmlConfiguration\Loader;
use PHPUnit\TextUI\XmlConfiguration\PhpHandler;
use PHPUnit\Util\Filesystem;
use PHPUnit\Util\Log\JUnit;
use PHPUnit\Util\Log\TeamCity;
use PHPUnit\Util\Printer;
use PHPUnit\Util\TestDox\CliTestDoxPrinter;
use PHPUnit\Util\TestDox\HtmlResultPrinter;
use PHPUnit\Util\TestDox\TextResultPrinter;
use PHPUnit\Util\TestDox\XmlResultPrinter;
use PHPUnit\Util\Xml\SchemaDetector;
use ReflectionClass;
use ReflectionException;
use PHPUnit\SebastianBergmann\CodeCoverage\Exception as CodeCoverageException;
use PHPUnit\SebastianBergmann\CodeCoverage\Filter as CodeCoverageFilter;
use PHPUnit\SebastianBergmann\CodeCoverage\Report\Clover as CloverReport;
use PHPUnit\SebastianBergmann\CodeCoverage\Report\Cobertura as CoberturaReport;
use PHPUnit\SebastianBergmann\CodeCoverage\Report\Crap4j as Crap4jReport;
use PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\Facade as HtmlReport;
use PHPUnit\SebastianBergmann\CodeCoverage\Report\PHP as PhpReport;
use PHPUnit\SebastianBergmann\CodeCoverage\Report\Text as TextReport;
use PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Facade as XmlReport;
use PHPUnit\SebastianBergmann\Comparator\Comparator;
use PHPUnit\SebastianBergmann\Environment\Runtime;
use PHPUnit\SebastianBergmann\Invoker\Invoker;
use PHPUnit\SebastianBergmann\Timer\Timer;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestRunner
{
    public const SUCCESS_EXIT = 0;
    public const FAILURE_EXIT = 1;
    public const EXCEPTION_EXIT = 2;
    private static bool $versionStringPrinted = \false;
    private ?\PHPUnit\SebastianBergmann\CodeCoverage\Filter $codeCoverageFilter = null;
    private ?\PHPUnit\TextUI\ResultPrinter $printer = null;
    private bool $messagePrinted = \false;
    /**
     * @var Hook[]
     */
    private array $extensions = [];
    private \PHPUnit\SebastianBergmann\Timer\Timer $timer;
    public function __construct(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter = null)
    {
        if ($filter === null) {
            $filter = new \PHPUnit\SebastianBergmann\CodeCoverage\Filter();
        }
        $this->codeCoverageFilter = $filter;
        $this->timer = new \PHPUnit\SebastianBergmann\Timer\Timer();
    }
    /**
     * @throws \PHPUnit\Runner\Exception
     * @throws \PHPUnit\TextUI\XmlConfiguration\Exception
     * @throws Exception
     */
    public function run(\PHPUnit\Framework\TestSuite $suite, array $arguments = [], array $warnings = [], bool $exit = \true) : \PHPUnit\Framework\TestResult
    {
        if (isset($arguments['configuration'])) {
            $GLOBALS['__PHPUNIT_CONFIGURATION_FILE'] = $arguments['configuration'];
        }
        $this->handleConfiguration($arguments);
        if (\is_int($arguments['columns']) && $arguments['columns'] < 16) {
            $arguments['columns'] = 16;
            $tooFewColumnsRequested = \true;
        }
        if (isset($arguments['bootstrap'])) {
            $GLOBALS['__PHPUNIT_BOOTSTRAP'] = $arguments['bootstrap'];
        }
        if ($arguments['backupGlobals'] === \true) {
            $suite->setBackupGlobals(\true);
        }
        if ($arguments['backupStaticProperties'] === \true) {
            $suite->setBackupStaticAttributes(\true);
        }
        if ($arguments['beStrictAboutChangesToGlobalState'] === \true) {
            $suite->setBeStrictAboutChangesToGlobalState(\true);
        }
        if ($arguments['executionOrder'] === \PHPUnit\Runner\TestSuiteSorter::ORDER_RANDOMIZED) {
            \mt_srand($arguments['randomOrderSeed']);
        }
        if ($arguments['cacheResult']) {
            if (isset($arguments['cacheDirectory']) && \PHPUnit\Util\Filesystem::createDirectory($arguments['cacheDirectory'])) {
                $cacheResultFile = \realpath($arguments['cacheDirectory']) . \DIRECTORY_SEPARATOR . 'test-results';
            } elseif (isset($arguments['cacheResultFile'])) {
                $cacheResultFile = $arguments['cacheResultFile'];
            } elseif (isset($arguments['configurationObject'])) {
                \assert($arguments['configurationObject'] instanceof \PHPUnit\TextUI\XmlConfiguration\Configuration);
                $cacheResultFile = \dirname(\realpath($arguments['configurationObject']->filename())) . \DIRECTORY_SEPARATOR . '.phpunit.result.cache';
            } else {
                $cacheResultFile = \dirname(\realpath($_SERVER['PHP_SELF'])) . \DIRECTORY_SEPARATOR . '.phpunit.result.cache';
            }
            $cache = new \PHPUnit\Runner\DefaultTestResultCache($cacheResultFile);
            $this->addExtension(new \PHPUnit\Runner\ResultCacheExtension($cache));
        }
        if ($arguments['executionOrder'] !== \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT || $arguments['executionOrderDefects'] !== \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT || $arguments['resolveDependencies']) {
            $cache = $cache ?? new \PHPUnit\Runner\NullTestResultCache();
            $cache->load();
            $sorter = new \PHPUnit\Runner\TestSuiteSorter($cache);
            $sorter->reorderTestsInSuite($suite, $arguments['executionOrder'], $arguments['resolveDependencies'], $arguments['executionOrderDefects']);
            $originalExecutionOrder = $sorter->getOriginalExecutionOrder();
            unset($sorter);
        }
        if (\is_int($arguments['repeat']) && $arguments['repeat'] > 0) {
            $_suite = new \PHPUnit\Framework\TestSuite();
            /* @noinspection PhpUnusedLocalVariableInspection */
            foreach (\range(1, $arguments['repeat']) as $step) {
                $_suite->addTest($suite);
            }
            $suite = $_suite;
            unset($_suite);
        }
        $result = new \PHPUnit\Framework\TestResult();
        $listener = new \PHPUnit\Runner\TestListenerAdapter();
        $listenerNeeded = \false;
        foreach ($this->extensions as $extension) {
            if ($extension instanceof \PHPUnit\Runner\TestHook) {
                $listener->add($extension);
                $listenerNeeded = \true;
            }
        }
        if ($listenerNeeded) {
            $result->addListener($listener);
        }
        unset($listener, $listenerNeeded);
        if (!$arguments['convertDeprecationsToExceptions']) {
            $result->convertDeprecationsToExceptions(\false);
        }
        if (!$arguments['convertErrorsToExceptions']) {
            $result->convertErrorsToExceptions(\false);
        }
        if (!$arguments['convertNoticesToExceptions']) {
            $result->convertNoticesToExceptions(\false);
        }
        if (!$arguments['convertWarningsToExceptions']) {
            $result->convertWarningsToExceptions(\false);
        }
        if ($arguments['stopOnError']) {
            $result->stopOnError(\true);
        }
        if ($arguments['stopOnFailure']) {
            $result->stopOnFailure(\true);
        }
        if ($arguments['stopOnWarning']) {
            $result->stopOnWarning(\true);
        }
        if ($arguments['stopOnIncomplete']) {
            $result->stopOnIncomplete(\true);
        }
        if ($arguments['stopOnRisky']) {
            $result->stopOnRisky(\true);
        }
        if ($arguments['stopOnSkipped']) {
            $result->stopOnSkipped(\true);
        }
        if ($arguments['stopOnDefect']) {
            $result->stopOnDefect(\true);
        }
        if ($arguments['registerMockObjectsFromTestArgumentsRecursively']) {
            $result->registerMockObjectsFromTestArgumentsRecursively();
        }
        if ($this->printer === null) {
            if (isset($arguments['printer'])) {
                if ($arguments['printer'] instanceof \PHPUnit\TextUI\ResultPrinter) {
                    $this->printer = $arguments['printer'];
                } elseif (\is_string($arguments['printer']) && \class_exists($arguments['printer'], \false)) {
                    try {
                        $reflector = new \ReflectionClass($arguments['printer']);
                        if ($reflector->implementsInterface(\PHPUnit\TextUI\ResultPrinter::class)) {
                            $this->printer = $this->createPrinter($arguments['printer'], $arguments);
                        }
                        // @codeCoverageIgnoreStart
                    } catch (\ReflectionException $e) {
                        throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
                    }
                    // @codeCoverageIgnoreEnd
                }
            } else {
                $this->printer = $this->createPrinter(\PHPUnit\TextUI\DefaultResultPrinter::class, $arguments);
            }
        }
        if (isset($originalExecutionOrder) && $this->printer instanceof \PHPUnit\Util\TestDox\CliTestDoxPrinter) {
            \assert($this->printer instanceof \PHPUnit\Util\TestDox\CliTestDoxPrinter);
            $this->printer->setOriginalExecutionOrder($originalExecutionOrder);
            $this->printer->setShowProgressAnimation(!$arguments['noInteraction']);
        }
        $this->printer->write(\PHPUnit\Runner\Version::getVersionString() . "\n");
        self::$versionStringPrinted = \true;
        foreach ($arguments['listeners'] as $listener) {
            $result->addListener($listener);
        }
        $result->addListener($this->printer);
        $coverageFilterFromConfigurationFile = \false;
        $coverageFilterFromOption = \false;
        $codeCoverageReports = 0;
        if (isset($arguments['testdoxHTMLFile'])) {
            $result->addListener(new \PHPUnit\Util\TestDox\HtmlResultPrinter($arguments['testdoxHTMLFile'], $arguments['testdoxGroups'], $arguments['testdoxExcludeGroups']));
        }
        if (isset($arguments['testdoxTextFile'])) {
            $result->addListener(new \PHPUnit\Util\TestDox\TextResultPrinter($arguments['testdoxTextFile'], $arguments['testdoxGroups'], $arguments['testdoxExcludeGroups']));
        }
        if (isset($arguments['testdoxXMLFile'])) {
            $result->addListener(new \PHPUnit\Util\TestDox\XmlResultPrinter($arguments['testdoxXMLFile']));
        }
        if (isset($arguments['teamcityLogfile'])) {
            $result->addListener(new \PHPUnit\Util\Log\TeamCity($arguments['teamcityLogfile']));
        }
        if (isset($arguments['junitLogfile'])) {
            $result->addListener(new \PHPUnit\Util\Log\JUnit($arguments['junitLogfile'], $arguments['reportUselessTests']));
        }
        if (isset($arguments['coverageClover'])) {
            $codeCoverageReports++;
        }
        if (isset($arguments['coverageCobertura'])) {
            $codeCoverageReports++;
        }
        if (isset($arguments['coverageCrap4J'])) {
            $codeCoverageReports++;
        }
        if (isset($arguments['coverageHtml'])) {
            $codeCoverageReports++;
        }
        if (isset($arguments['coveragePHP'])) {
            $codeCoverageReports++;
        }
        if (isset($arguments['coverageText'])) {
            $codeCoverageReports++;
        }
        if (isset($arguments['coverageXml'])) {
            $codeCoverageReports++;
        }
        if ($codeCoverageReports > 0) {
            if (isset($arguments['coverageFilter'])) {
                if (!\is_array($arguments['coverageFilter'])) {
                    $coverageFilterDirectories = [$arguments['coverageFilter']];
                } else {
                    $coverageFilterDirectories = $arguments['coverageFilter'];
                }
                foreach ($coverageFilterDirectories as $coverageFilterDirectory) {
                    $this->codeCoverageFilter->includeDirectory($coverageFilterDirectory);
                }
                $coverageFilterFromOption = \true;
            }
            if (isset($arguments['configurationObject'])) {
                \assert($arguments['configurationObject'] instanceof \PHPUnit\TextUI\XmlConfiguration\Configuration);
                $codeCoverageConfiguration = $arguments['configurationObject']->codeCoverage();
                if ($codeCoverageConfiguration->hasNonEmptyListOfFilesToBeIncludedInCodeCoverageReport()) {
                    $coverageFilterFromConfigurationFile = \true;
                    (new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\FilterMapper())->map($this->codeCoverageFilter, $codeCoverageConfiguration);
                }
            }
        }
        if ($codeCoverageReports > 0) {
            try {
                if (isset($codeCoverageConfiguration) && ($codeCoverageConfiguration->pathCoverage() || isset($arguments['pathCoverage']) && $arguments['pathCoverage'] === \true)) {
                    \PHPUnit\Runner\CodeCoverage::activate($this->codeCoverageFilter, \true);
                } else {
                    \PHPUnit\Runner\CodeCoverage::activate($this->codeCoverageFilter, \false);
                }
                if (isset($arguments['cacheDirectory']) && \PHPUnit\Util\Filesystem::createDirectory($arguments['cacheDirectory'])) {
                    \PHPUnit\Runner\CodeCoverage::instance()->cacheStaticAnalysis(\realpath($arguments['cacheDirectory']) . \DIRECTORY_SEPARATOR . 'code-coverage');
                } elseif (isset($arguments['coverageCacheDirectory']) && \PHPUnit\Util\Filesystem::createDirectory($arguments['coverageCacheDirectory'])) {
                    \PHPUnit\Runner\CodeCoverage::instance()->cacheStaticAnalysis($arguments['coverageCacheDirectory']);
                } elseif (isset($codeCoverageConfiguration) && $codeCoverageConfiguration->hasCacheDirectory() && \PHPUnit\Util\Filesystem::createDirectory($codeCoverageConfiguration->cacheDirectory()->path())) {
                    \PHPUnit\Runner\CodeCoverage::instance()->cacheStaticAnalysis($codeCoverageConfiguration->cacheDirectory()->path());
                }
                \PHPUnit\Runner\CodeCoverage::instance()->excludeSubclassesOfThisClassFromUnintentionallyCoveredCodeCheck(\PHPUnit\SebastianBergmann\Comparator\Comparator::class);
                if ($arguments['strictCoverage']) {
                    \PHPUnit\Runner\CodeCoverage::instance()->enableCheckForUnintentionallyCoveredCode();
                }
                if (isset($arguments['ignoreDeprecatedCodeUnitsFromCodeCoverage'])) {
                    if ($arguments['ignoreDeprecatedCodeUnitsFromCodeCoverage']) {
                        \PHPUnit\Runner\CodeCoverage::instance()->ignoreDeprecatedCode();
                    } else {
                        \PHPUnit\Runner\CodeCoverage::instance()->doNotIgnoreDeprecatedCode();
                    }
                }
                if (isset($arguments['disableCodeCoverageIgnore'])) {
                    if ($arguments['disableCodeCoverageIgnore']) {
                        \PHPUnit\Runner\CodeCoverage::instance()->disableAnnotationsForIgnoringCode();
                    } else {
                        \PHPUnit\Runner\CodeCoverage::instance()->enableAnnotationsForIgnoringCode();
                    }
                }
                if (isset($arguments['configurationObject'])) {
                    $codeCoverageConfiguration = $arguments['configurationObject']->codeCoverage();
                    if ($codeCoverageConfiguration->hasNonEmptyListOfFilesToBeIncludedInCodeCoverageReport()) {
                        if ($codeCoverageConfiguration->includeUncoveredFiles()) {
                            \PHPUnit\Runner\CodeCoverage::instance()->includeUncoveredFiles();
                        } else {
                            \PHPUnit\Runner\CodeCoverage::instance()->excludeUncoveredFiles();
                        }
                    }
                }
                if ($this->codeCoverageFilter->isEmpty()) {
                    if (!$coverageFilterFromConfigurationFile && !$coverageFilterFromOption) {
                        $warnings[] = 'No filter is configured, code coverage will not be processed';
                    } else {
                        $warnings[] = 'Incorrect filter configuration, code coverage will not be processed';
                    }
                    \PHPUnit\Runner\CodeCoverage::deactivate();
                }
            } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $e) {
                $warnings[] = $e->getMessage();
            }
        }
        if ($arguments['verbose']) {
            if (\PHP_SAPI === 'phpdbg') {
                $this->writeMessage('Runtime', 'PHPDBG ' . \PHP_VERSION);
            } else {
                $runtime = 'PHP ' . \PHP_VERSION;
                if (\PHPUnit\Runner\CodeCoverage::isActive()) {
                    $runtime .= ' with ' . \PHPUnit\Runner\CodeCoverage::driver()->nameAndVersion();
                }
                $this->writeMessage('Runtime', $runtime);
            }
            if (isset($arguments['configurationObject'])) {
                \assert($arguments['configurationObject'] instanceof \PHPUnit\TextUI\XmlConfiguration\Configuration);
                $this->writeMessage('Configuration', $arguments['configurationObject']->filename());
            }
            foreach ($arguments['loadedExtensions'] as $extension) {
                $this->writeMessage('Extension', $extension);
            }
            foreach ($arguments['notLoadedExtensions'] as $extension) {
                $this->writeMessage('Extension', $extension);
            }
        }
        if ($arguments['executionOrder'] === \PHPUnit\Runner\TestSuiteSorter::ORDER_RANDOMIZED) {
            $this->writeMessage('Random Seed', (string) $arguments['randomOrderSeed']);
        }
        if (isset($tooFewColumnsRequested)) {
            $warnings[] = 'Less than 16 columns requested, number of columns set to 16';
        }
        if ((new \PHPUnit\SebastianBergmann\Environment\Runtime())->discardsComments()) {
            $warnings[] = 'opcache.save_comments=0 set; annotations will not work';
        }
        if (isset($arguments['conflictBetweenPrinterClassAndTestdox'])) {
            $warnings[] = 'Directives printerClass and testdox are mutually exclusive';
        }
        foreach ($warnings as $warning) {
            $this->writeMessage('Warning', $warning);
        }
        if (isset($arguments['configurationObject'])) {
            \assert($arguments['configurationObject'] instanceof \PHPUnit\TextUI\XmlConfiguration\Configuration);
            if ($arguments['configurationObject']->hasValidationErrors()) {
                if ((new \PHPUnit\Util\Xml\SchemaDetector())->detect($arguments['configurationObject']->filename())->detected()) {
                    $this->writeMessage('Warning', 'Your XML configuration validates against a deprecated schema.');
                    $this->writeMessage('Suggestion', 'Migrate your XML configuration using "--migrate-configuration"!');
                } else {
                    $this->write("\n  Warning - The configuration file did not pass validation!\n  The following problems have been detected:\n");
                    $this->write($arguments['configurationObject']->validationErrors());
                    $this->write("\n  Test results may not be as expected.\n\n");
                }
            }
        }
        $this->printer->write("\n");
        $result->beStrictAboutTestsThatDoNotTestAnything($arguments['reportUselessTests']);
        $result->beStrictAboutOutputDuringTests($arguments['disallowTestOutput']);
        $result->beStrictAboutTodoAnnotatedTests($arguments['disallowTodoAnnotatedTests']);
        $result->beStrictAboutResourceUsageDuringSmallTests($arguments['beStrictAboutResourceUsageDuringSmallTests']);
        if ($arguments['enforceTimeLimit'] === \true && !(new \PHPUnit\SebastianBergmann\Invoker\Invoker())->canInvokeWithTimeout()) {
            $this->writeMessage('Error', 'PHP extension pcntl is required for enforcing time limits');
        }
        $result->enforceTimeLimit($arguments['enforceTimeLimit']);
        $result->setDefaultTimeLimit($arguments['defaultTimeLimit']);
        $result->setTimeoutForSmallTests($arguments['timeoutForSmallTests']);
        $result->setTimeoutForMediumTests($arguments['timeoutForMediumTests']);
        $result->setTimeoutForLargeTests($arguments['timeoutForLargeTests']);
        if (isset($arguments['forceCoversAnnotation']) && $arguments['forceCoversAnnotation'] === \true) {
            $result->forceCoversAnnotation();
        }
        $this->processSuiteFilters($suite, $arguments);
        $suite->setRunTestInSeparateProcess($arguments['processIsolation']);
        foreach ($this->extensions as $extension) {
            if ($extension instanceof \PHPUnit\Runner\BeforeFirstTestHook) {
                $extension->executeBeforeFirstTest();
            }
        }
        $testSuiteWarningsPrinted = \false;
        foreach ($suite->warnings() as $warning) {
            $this->writeMessage('Warning', $warning);
            $testSuiteWarningsPrinted = \true;
        }
        if ($testSuiteWarningsPrinted) {
            $this->write(\PHP_EOL);
        }
        $suite->run($result);
        foreach ($this->extensions as $extension) {
            if ($extension instanceof \PHPUnit\Runner\AfterLastTestHook) {
                $extension->executeAfterLastTest();
            }
        }
        $result->flushListeners();
        $this->printer->printResult($result);
        if (\PHPUnit\Runner\CodeCoverage::isActive()) {
            if (isset($arguments['coverageClover'])) {
                $this->codeCoverageGenerationStart('Clover XML');
                try {
                    $writer = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Clover();
                    $writer->process(\PHPUnit\Runner\CodeCoverage::instance(), $arguments['coverageClover']);
                    $this->codeCoverageGenerationSucceeded();
                    unset($writer);
                } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $e) {
                    $this->codeCoverageGenerationFailed($e);
                }
            }
            if (isset($arguments['coverageCobertura'])) {
                $this->codeCoverageGenerationStart('Cobertura XML');
                try {
                    $writer = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Cobertura();
                    $writer->process(\PHPUnit\Runner\CodeCoverage::instance(), $arguments['coverageCobertura']);
                    $this->codeCoverageGenerationSucceeded();
                    unset($writer);
                } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $e) {
                    $this->codeCoverageGenerationFailed($e);
                }
            }
            if (isset($arguments['coverageCrap4J'])) {
                $this->codeCoverageGenerationStart('Crap4J XML');
                try {
                    $writer = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Crap4j($arguments['crap4jThreshold']);
                    $writer->process(\PHPUnit\Runner\CodeCoverage::instance(), $arguments['coverageCrap4J']);
                    $this->codeCoverageGenerationSucceeded();
                    unset($writer);
                } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $e) {
                    $this->codeCoverageGenerationFailed($e);
                }
            }
            if (isset($arguments['coverageHtml'])) {
                $this->codeCoverageGenerationStart('HTML');
                try {
                    $writer = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Html\Facade($arguments['reportLowUpperBound'], $arguments['reportHighLowerBound'], \sprintf(' and <a href="https://phpunit.de/">PHPUnit %s</a>', \PHPUnit\Runner\Version::id()));
                    $writer->process(\PHPUnit\Runner\CodeCoverage::instance(), $arguments['coverageHtml']);
                    $this->codeCoverageGenerationSucceeded();
                    unset($writer);
                } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $e) {
                    $this->codeCoverageGenerationFailed($e);
                }
            }
            if (isset($arguments['coveragePHP'])) {
                $this->codeCoverageGenerationStart('PHP');
                try {
                    $writer = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\PHP();
                    $writer->process(\PHPUnit\Runner\CodeCoverage::instance(), $arguments['coveragePHP']);
                    $this->codeCoverageGenerationSucceeded();
                    unset($writer);
                } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $e) {
                    $this->codeCoverageGenerationFailed($e);
                }
            }
            if (isset($arguments['coverageText'])) {
                if ($arguments['coverageText'] === 'php://stdout') {
                    $outputStream = $this->printer;
                    $colors = $arguments['colors'] && $arguments['colors'] !== \PHPUnit\TextUI\DefaultResultPrinter::COLOR_NEVER;
                } else {
                    $outputStream = new \PHPUnit\Util\Printer($arguments['coverageText']);
                    $colors = \false;
                }
                $processor = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Text($arguments['reportLowUpperBound'], $arguments['reportHighLowerBound'], $arguments['coverageTextShowUncoveredFiles'], $arguments['coverageTextShowOnlySummary']);
                $outputStream->write($processor->process(\PHPUnit\Runner\CodeCoverage::instance(), $colors));
            }
            if (isset($arguments['coverageXml'])) {
                $this->codeCoverageGenerationStart('PHPUnit XML');
                try {
                    $writer = new \PHPUnit\SebastianBergmann\CodeCoverage\Report\Xml\Facade(\PHPUnit\Runner\Version::id());
                    $writer->process(\PHPUnit\Runner\CodeCoverage::instance(), $arguments['coverageXml']);
                    $this->codeCoverageGenerationSucceeded();
                    unset($writer);
                } catch (\PHPUnit\SebastianBergmann\CodeCoverage\Exception $e) {
                    $this->codeCoverageGenerationFailed($e);
                }
            }
        }
        if ($exit) {
            if (isset($arguments['failOnEmptyTestSuite']) && $arguments['failOnEmptyTestSuite'] === \true && \count($result) === 0) {
                exit(self::FAILURE_EXIT);
            }
            if ($result->wasSuccessfulIgnoringWarnings()) {
                if ($arguments['failOnRisky'] && !$result->allHarmless()) {
                    exit(self::FAILURE_EXIT);
                }
                if ($arguments['failOnWarning'] && $result->warningCount() > 0) {
                    exit(self::FAILURE_EXIT);
                }
                if ($arguments['failOnIncomplete'] && $result->notImplementedCount() > 0) {
                    exit(self::FAILURE_EXIT);
                }
                if ($arguments['failOnSkipped'] && $result->skippedCount() > 0) {
                    exit(self::FAILURE_EXIT);
                }
                exit(self::SUCCESS_EXIT);
            }
            if ($result->errorCount() > 0) {
                exit(self::EXCEPTION_EXIT);
            }
            if ($result->failureCount() > 0) {
                exit(self::FAILURE_EXIT);
            }
        }
        return $result;
    }
    public function addExtension(\PHPUnit\Runner\Hook $extension) : void
    {
        $this->extensions[] = $extension;
    }
    private function write(string $buffer) : void
    {
        if (\PHP_SAPI !== 'cli' && \PHP_SAPI !== 'phpdbg') {
            $buffer = \htmlspecialchars($buffer);
        }
        if ($this->printer !== null) {
            $this->printer->write($buffer);
        } else {
            print $buffer;
        }
    }
    /**
     * @throws \PHPUnit\TextUI\XmlConfiguration\Exception
     * @throws Exception
     */
    private function handleConfiguration(array &$arguments) : void
    {
        if (!isset($arguments['configurationObject']) && isset($arguments['configuration'])) {
            $arguments['configurationObject'] = (new \PHPUnit\TextUI\XmlConfiguration\Loader())->load($arguments['configuration']);
        }
        $arguments['debug'] = $arguments['debug'] ?? \false;
        $arguments['filter'] = $arguments['filter'] ?? \false;
        $arguments['listeners'] = $arguments['listeners'] ?? [];
        if (isset($arguments['configurationObject'])) {
            (new \PHPUnit\TextUI\XmlConfiguration\PhpHandler())->handle($arguments['configurationObject']->php());
            $codeCoverageConfiguration = $arguments['configurationObject']->codeCoverage();
            if (!isset($arguments['noCoverage'])) {
                if (!isset($arguments['coverageClover']) && $codeCoverageConfiguration->hasClover()) {
                    $arguments['coverageClover'] = $codeCoverageConfiguration->clover()->target()->path();
                }
                if (!isset($arguments['coverageCobertura']) && $codeCoverageConfiguration->hasCobertura()) {
                    $arguments['coverageCobertura'] = $codeCoverageConfiguration->cobertura()->target()->path();
                }
                if (!isset($arguments['coverageCrap4J']) && $codeCoverageConfiguration->hasCrap4j()) {
                    $arguments['coverageCrap4J'] = $codeCoverageConfiguration->crap4j()->target()->path();
                    if (!isset($arguments['crap4jThreshold'])) {
                        $arguments['crap4jThreshold'] = $codeCoverageConfiguration->crap4j()->threshold();
                    }
                }
                if (!isset($arguments['coverageHtml']) && $codeCoverageConfiguration->hasHtml()) {
                    $arguments['coverageHtml'] = $codeCoverageConfiguration->html()->target()->path();
                    if (!isset($arguments['reportLowUpperBound'])) {
                        $arguments['reportLowUpperBound'] = $codeCoverageConfiguration->html()->lowUpperBound();
                    }
                    if (!isset($arguments['reportHighLowerBound'])) {
                        $arguments['reportHighLowerBound'] = $codeCoverageConfiguration->html()->highLowerBound();
                    }
                }
                if (!isset($arguments['coveragePHP']) && $codeCoverageConfiguration->hasPhp()) {
                    $arguments['coveragePHP'] = $codeCoverageConfiguration->php()->target()->path();
                }
                if (!isset($arguments['coverageText']) && $codeCoverageConfiguration->hasText()) {
                    $arguments['coverageText'] = $codeCoverageConfiguration->text()->target()->path();
                    $arguments['coverageTextShowUncoveredFiles'] = $codeCoverageConfiguration->text()->showUncoveredFiles();
                    $arguments['coverageTextShowOnlySummary'] = $codeCoverageConfiguration->text()->showOnlySummary();
                }
                if (!isset($arguments['coverageXml']) && $codeCoverageConfiguration->hasXml()) {
                    $arguments['coverageXml'] = $codeCoverageConfiguration->xml()->target()->path();
                }
            }
            $phpunitConfiguration = $arguments['configurationObject']->phpunit();
            $arguments['backupGlobals'] = $arguments['backupGlobals'] ?? $phpunitConfiguration->backupGlobals();
            $arguments['backupStaticProperties'] = $arguments['backupStaticProperties'] ?? $phpunitConfiguration->backupStaticProperties();
            $arguments['beStrictAboutChangesToGlobalState'] = $arguments['beStrictAboutChangesToGlobalState'] ?? $phpunitConfiguration->beStrictAboutChangesToGlobalState();
            $arguments['cacheResult'] = $arguments['cacheResult'] ?? $phpunitConfiguration->cacheResult();
            $arguments['colors'] = $arguments['colors'] ?? $phpunitConfiguration->colors();
            $arguments['convertDeprecationsToExceptions'] = $arguments['convertDeprecationsToExceptions'] ?? $phpunitConfiguration->convertDeprecationsToExceptions();
            $arguments['convertErrorsToExceptions'] = $arguments['convertErrorsToExceptions'] ?? $phpunitConfiguration->convertErrorsToExceptions();
            $arguments['convertNoticesToExceptions'] = $arguments['convertNoticesToExceptions'] ?? $phpunitConfiguration->convertNoticesToExceptions();
            $arguments['convertWarningsToExceptions'] = $arguments['convertWarningsToExceptions'] ?? $phpunitConfiguration->convertWarningsToExceptions();
            $arguments['processIsolation'] = $arguments['processIsolation'] ?? $phpunitConfiguration->processIsolation();
            $arguments['stopOnDefect'] = $arguments['stopOnDefect'] ?? $phpunitConfiguration->stopOnDefect();
            $arguments['stopOnError'] = $arguments['stopOnError'] ?? $phpunitConfiguration->stopOnError();
            $arguments['stopOnFailure'] = $arguments['stopOnFailure'] ?? $phpunitConfiguration->stopOnFailure();
            $arguments['stopOnWarning'] = $arguments['stopOnWarning'] ?? $phpunitConfiguration->stopOnWarning();
            $arguments['stopOnIncomplete'] = $arguments['stopOnIncomplete'] ?? $phpunitConfiguration->stopOnIncomplete();
            $arguments['stopOnRisky'] = $arguments['stopOnRisky'] ?? $phpunitConfiguration->stopOnRisky();
            $arguments['stopOnSkipped'] = $arguments['stopOnSkipped'] ?? $phpunitConfiguration->stopOnSkipped();
            $arguments['failOnEmptyTestSuite'] = $arguments['failOnEmptyTestSuite'] ?? $phpunitConfiguration->failOnEmptyTestSuite();
            $arguments['failOnIncomplete'] = $arguments['failOnIncomplete'] ?? $phpunitConfiguration->failOnIncomplete();
            $arguments['failOnRisky'] = $arguments['failOnRisky'] ?? $phpunitConfiguration->failOnRisky();
            $arguments['failOnSkipped'] = $arguments['failOnSkipped'] ?? $phpunitConfiguration->failOnSkipped();
            $arguments['failOnWarning'] = $arguments['failOnWarning'] ?? $phpunitConfiguration->failOnWarning();
            $arguments['enforceTimeLimit'] = $arguments['enforceTimeLimit'] ?? $phpunitConfiguration->enforceTimeLimit();
            $arguments['defaultTimeLimit'] = $arguments['defaultTimeLimit'] ?? $phpunitConfiguration->defaultTimeLimit();
            $arguments['timeoutForSmallTests'] = $arguments['timeoutForSmallTests'] ?? $phpunitConfiguration->timeoutForSmallTests();
            $arguments['timeoutForMediumTests'] = $arguments['timeoutForMediumTests'] ?? $phpunitConfiguration->timeoutForMediumTests();
            $arguments['timeoutForLargeTests'] = $arguments['timeoutForLargeTests'] ?? $phpunitConfiguration->timeoutForLargeTests();
            $arguments['reportUselessTests'] = $arguments['reportUselessTests'] ?? $phpunitConfiguration->beStrictAboutTestsThatDoNotTestAnything();
            $arguments['strictCoverage'] = $arguments['strictCoverage'] ?? $phpunitConfiguration->beStrictAboutCoversAnnotation();
            $arguments['ignoreDeprecatedCodeUnitsFromCodeCoverage'] = $arguments['ignoreDeprecatedCodeUnitsFromCodeCoverage'] ?? $codeCoverageConfiguration->ignoreDeprecatedCodeUnits();
            $arguments['disallowTestOutput'] = $arguments['disallowTestOutput'] ?? $phpunitConfiguration->beStrictAboutOutputDuringTests();
            $arguments['disallowTodoAnnotatedTests'] = $arguments['disallowTodoAnnotatedTests'] ?? $phpunitConfiguration->beStrictAboutTodoAnnotatedTests();
            $arguments['beStrictAboutResourceUsageDuringSmallTests'] = $arguments['beStrictAboutResourceUsageDuringSmallTests'] ?? $phpunitConfiguration->beStrictAboutResourceUsageDuringSmallTests();
            $arguments['verbose'] = $arguments['verbose'] ?? $phpunitConfiguration->verbose();
            $arguments['reverseDefectList'] = $arguments['reverseDefectList'] ?? $phpunitConfiguration->reverseDefectList();
            $arguments['forceCoversAnnotation'] = $arguments['forceCoversAnnotation'] ?? $phpunitConfiguration->forceCoversAnnotation();
            $arguments['disableCodeCoverageIgnore'] = $arguments['disableCodeCoverageIgnore'] ?? $codeCoverageConfiguration->disableCodeCoverageIgnore();
            $arguments['registerMockObjectsFromTestArgumentsRecursively'] = $arguments['registerMockObjectsFromTestArgumentsRecursively'] ?? $phpunitConfiguration->registerMockObjectsFromTestArgumentsRecursively();
            $arguments['noInteraction'] = $arguments['noInteraction'] ?? $phpunitConfiguration->noInteraction();
            $arguments['executionOrder'] = $arguments['executionOrder'] ?? $phpunitConfiguration->executionOrder();
            $arguments['resolveDependencies'] = $arguments['resolveDependencies'] ?? $phpunitConfiguration->resolveDependencies();
            if (!isset($arguments['bootstrap']) && $phpunitConfiguration->hasBootstrap()) {
                $arguments['bootstrap'] = $phpunitConfiguration->bootstrap();
            }
            if (!isset($arguments['cacheDirectory']) && $phpunitConfiguration->hasCacheDirectory()) {
                $arguments['cacheDirectory'] = $phpunitConfiguration->cacheDirectory();
            }
            if (!isset($arguments['cacheResultFile']) && $phpunitConfiguration->hasCacheResultFile()) {
                $arguments['cacheResultFile'] = $phpunitConfiguration->cacheResultFile();
            }
            if (!isset($arguments['executionOrderDefects'])) {
                $arguments['executionOrderDefects'] = $phpunitConfiguration->defectsFirst() ? \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFECTS_FIRST : \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT;
            }
            if ($phpunitConfiguration->conflictBetweenPrinterClassAndTestdox()) {
                $arguments['conflictBetweenPrinterClassAndTestdox'] = \true;
            }
            $groupCliArgs = [];
            if (!empty($arguments['groups'])) {
                $groupCliArgs = $arguments['groups'];
            }
            $groupConfiguration = $arguments['configurationObject']->groups();
            if (!isset($arguments['groups']) && $groupConfiguration->hasInclude()) {
                $arguments['groups'] = $groupConfiguration->include()->asArrayOfStrings();
            }
            if (!isset($arguments['excludeGroups']) && $groupConfiguration->hasExclude()) {
                $arguments['excludeGroups'] = \array_diff($groupConfiguration->exclude()->asArrayOfStrings(), $groupCliArgs);
            }
            foreach ($arguments['configurationObject']->extensions() as $extension) {
                (new \PHPUnit\Runner\Extension\ExtensionHandler())->registerExtension($extension, $this);
            }
            foreach ($arguments['unavailableExtensions'] as $extension) {
                $arguments['warnings'][] = \sprintf('Extension "%s" is not available', $extension);
            }
            $loggingConfiguration = $arguments['configurationObject']->logging();
            if (!isset($arguments['noLogging'])) {
                if ($loggingConfiguration->hasText()) {
                    $arguments['listeners'][] = new \PHPUnit\TextUI\DefaultResultPrinter($loggingConfiguration->text()->target()->path(), \true);
                }
                if (!isset($arguments['teamcityLogfile']) && $loggingConfiguration->hasTeamCity()) {
                    $arguments['teamcityLogfile'] = $loggingConfiguration->teamCity()->target()->path();
                }
                if (!isset($arguments['junitLogfile']) && $loggingConfiguration->hasJunit()) {
                    $arguments['junitLogfile'] = $loggingConfiguration->junit()->target()->path();
                }
                if (!isset($arguments['testdoxHTMLFile']) && $loggingConfiguration->hasTestDoxHtml()) {
                    $arguments['testdoxHTMLFile'] = $loggingConfiguration->testDoxHtml()->target()->path();
                }
                if (!isset($arguments['testdoxTextFile']) && $loggingConfiguration->hasTestDoxText()) {
                    $arguments['testdoxTextFile'] = $loggingConfiguration->testDoxText()->target()->path();
                }
                if (!isset($arguments['testdoxXMLFile']) && $loggingConfiguration->hasTestDoxXml()) {
                    $arguments['testdoxXMLFile'] = $loggingConfiguration->testDoxXml()->target()->path();
                }
            }
            $testdoxGroupConfiguration = $arguments['configurationObject']->testdoxGroups();
            if (!isset($arguments['testdoxGroups']) && $testdoxGroupConfiguration->hasInclude()) {
                $arguments['testdoxGroups'] = $testdoxGroupConfiguration->include()->asArrayOfStrings();
            }
            if (!isset($arguments['testdoxExcludeGroups']) && $testdoxGroupConfiguration->hasExclude()) {
                $arguments['testdoxExcludeGroups'] = $testdoxGroupConfiguration->exclude()->asArrayOfStrings();
            }
        }
        $extensionHandler = new \PHPUnit\Runner\Extension\ExtensionHandler();
        foreach ($arguments['extensions'] as $extension) {
            $extensionHandler->registerExtension($extension, $this);
        }
        unset($extensionHandler);
        $arguments['backupGlobals'] = $arguments['backupGlobals'] ?? null;
        $arguments['backupStaticProperties'] = $arguments['backupStaticProperties'] ?? null;
        $arguments['beStrictAboutChangesToGlobalState'] = $arguments['beStrictAboutChangesToGlobalState'] ?? null;
        $arguments['beStrictAboutResourceUsageDuringSmallTests'] = $arguments['beStrictAboutResourceUsageDuringSmallTests'] ?? \false;
        $arguments['cacheResult'] = $arguments['cacheResult'] ?? \true;
        $arguments['colors'] = $arguments['colors'] ?? \PHPUnit\TextUI\DefaultResultPrinter::COLOR_DEFAULT;
        $arguments['columns'] = $arguments['columns'] ?? 80;
        $arguments['convertDeprecationsToExceptions'] = $arguments['convertDeprecationsToExceptions'] ?? \true;
        $arguments['convertErrorsToExceptions'] = $arguments['convertErrorsToExceptions'] ?? \true;
        $arguments['convertNoticesToExceptions'] = $arguments['convertNoticesToExceptions'] ?? \true;
        $arguments['convertWarningsToExceptions'] = $arguments['convertWarningsToExceptions'] ?? \true;
        $arguments['crap4jThreshold'] = $arguments['crap4jThreshold'] ?? 30;
        $arguments['disallowTestOutput'] = $arguments['disallowTestOutput'] ?? \false;
        $arguments['disallowTodoAnnotatedTests'] = $arguments['disallowTodoAnnotatedTests'] ?? \false;
        $arguments['defaultTimeLimit'] = $arguments['defaultTimeLimit'] ?? 0;
        $arguments['enforceTimeLimit'] = $arguments['enforceTimeLimit'] ?? \false;
        $arguments['excludeGroups'] = $arguments['excludeGroups'] ?? [];
        $arguments['executionOrder'] = $arguments['executionOrder'] ?? \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT;
        $arguments['executionOrderDefects'] = $arguments['executionOrderDefects'] ?? \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT;
        $arguments['failOnIncomplete'] = $arguments['failOnIncomplete'] ?? \false;
        $arguments['failOnRisky'] = $arguments['failOnRisky'] ?? \false;
        $arguments['failOnSkipped'] = $arguments['failOnSkipped'] ?? \false;
        $arguments['failOnWarning'] = $arguments['failOnWarning'] ?? \false;
        $arguments['groups'] = $arguments['groups'] ?? [];
        $arguments['noInteraction'] = $arguments['noInteraction'] ?? \false;
        $arguments['processIsolation'] = $arguments['processIsolation'] ?? \false;
        $arguments['randomOrderSeed'] = $arguments['randomOrderSeed'] ?? \time();
        $arguments['registerMockObjectsFromTestArgumentsRecursively'] = $arguments['registerMockObjectsFromTestArgumentsRecursively'] ?? \false;
        $arguments['repeat'] = $arguments['repeat'] ?? \false;
        $arguments['reportHighLowerBound'] = $arguments['reportHighLowerBound'] ?? 90;
        $arguments['reportLowUpperBound'] = $arguments['reportLowUpperBound'] ?? 50;
        $arguments['reportUselessTests'] = $arguments['reportUselessTests'] ?? \true;
        $arguments['reverseList'] = $arguments['reverseList'] ?? \false;
        $arguments['resolveDependencies'] = $arguments['resolveDependencies'] ?? \true;
        $arguments['stopOnError'] = $arguments['stopOnError'] ?? \false;
        $arguments['stopOnFailure'] = $arguments['stopOnFailure'] ?? \false;
        $arguments['stopOnIncomplete'] = $arguments['stopOnIncomplete'] ?? \false;
        $arguments['stopOnRisky'] = $arguments['stopOnRisky'] ?? \false;
        $arguments['stopOnSkipped'] = $arguments['stopOnSkipped'] ?? \false;
        $arguments['stopOnWarning'] = $arguments['stopOnWarning'] ?? \false;
        $arguments['stopOnDefect'] = $arguments['stopOnDefect'] ?? \false;
        $arguments['strictCoverage'] = $arguments['strictCoverage'] ?? \false;
        $arguments['testdoxExcludeGroups'] = $arguments['testdoxExcludeGroups'] ?? [];
        $arguments['testdoxGroups'] = $arguments['testdoxGroups'] ?? [];
        $arguments['timeoutForLargeTests'] = $arguments['timeoutForLargeTests'] ?? 60;
        $arguments['timeoutForMediumTests'] = $arguments['timeoutForMediumTests'] ?? 10;
        $arguments['timeoutForSmallTests'] = $arguments['timeoutForSmallTests'] ?? 1;
        $arguments['verbose'] = $arguments['verbose'] ?? \false;
    }
    private function processSuiteFilters(\PHPUnit\Framework\TestSuite $suite, array $arguments) : void
    {
        if (!$arguments['filter'] && empty($arguments['groups']) && empty($arguments['excludeGroups']) && empty($arguments['testsCovering']) && empty($arguments['testsUsing'])) {
            return;
        }
        $filterFactory = new \PHPUnit\Runner\Filter\Factory();
        if (!empty($arguments['excludeGroups'])) {
            $filterFactory->addFilter(new \ReflectionClass(\PHPUnit\Runner\Filter\ExcludeGroupFilterIterator::class), $arguments['excludeGroups']);
        }
        if (!empty($arguments['groups'])) {
            $filterFactory->addFilter(new \ReflectionClass(\PHPUnit\Runner\Filter\IncludeGroupFilterIterator::class), $arguments['groups']);
        }
        if (!empty($arguments['testsCovering'])) {
            $filterFactory->addFilter(new \ReflectionClass(\PHPUnit\Runner\Filter\IncludeGroupFilterIterator::class), \array_map(static function (string $name) : string {
                return '__phpunit_covers_' . $name;
            }, $arguments['testsCovering']));
        }
        if (!empty($arguments['testsUsing'])) {
            $filterFactory->addFilter(new \ReflectionClass(\PHPUnit\Runner\Filter\IncludeGroupFilterIterator::class), \array_map(static function (string $name) : string {
                return '__phpunit_uses_' . $name;
            }, $arguments['testsUsing']));
        }
        if ($arguments['filter']) {
            $filterFactory->addFilter(new \ReflectionClass(\PHPUnit\Runner\Filter\NameFilterIterator::class), $arguments['filter']);
        }
        $suite->injectFilter($filterFactory);
    }
    private function writeMessage(string $type, string $message) : void
    {
        if (!$this->messagePrinted) {
            $this->write("\n");
        }
        $this->write(\sprintf("%-15s%s\n", $type . ':', $message));
        $this->messagePrinted = \true;
    }
    private function createPrinter(string $class, array $arguments) : \PHPUnit\TextUI\ResultPrinter
    {
        $object = new $class(isset($arguments['stderr']) && $arguments['stderr'] === \true ? 'php://stderr' : null, $arguments['verbose'], $arguments['colors'], $arguments['debug'], $arguments['columns'], $arguments['reverseList']);
        \assert($object instanceof \PHPUnit\TextUI\ResultPrinter);
        return $object;
    }
    private function codeCoverageGenerationStart(string $format) : void
    {
        $this->printer->write(\sprintf("\nGenerating code coverage report in %s format ... ", $format));
        $this->timer->start();
    }
    private function codeCoverageGenerationSucceeded() : void
    {
        $this->printer->write(\sprintf("done [%s]\n", $this->timer->stop()->asString()));
    }
    private function codeCoverageGenerationFailed(\Exception $e) : void
    {
        $this->printer->write(\sprintf("failed [%s]\n%s\n", $this->timer->stop()->asString(), $e->getMessage()));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI;

use const PHP_VERSION;
use function explode;
use function in_array;
use function is_dir;
use function is_file;
use function strpos;
use function version_compare;
use PHPUnit\Framework\Exception as FrameworkException;
use PHPUnit\Framework\TestSuite as TestSuiteObject;
use PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection;
use PHPUnit\SebastianBergmann\FileIterator\Facade;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestSuiteMapper
{
    /**
     * @throws RuntimeException
     * @throws TestDirectoryNotFoundException
     * @throws TestFileNotFoundException
     */
    public function map(\PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection $configuration, string $filter) : \PHPUnit\Framework\TestSuite
    {
        try {
            $filterAsArray = $filter ? \explode(',', $filter) : [];
            $result = new \PHPUnit\Framework\TestSuite();
            foreach ($configuration as $testSuiteConfiguration) {
                if (!empty($filterAsArray) && !\in_array($testSuiteConfiguration->name(), $filterAsArray, \true)) {
                    continue;
                }
                $testSuite = new \PHPUnit\Framework\TestSuite($testSuiteConfiguration->name());
                $testSuiteEmpty = \true;
                foreach ($testSuiteConfiguration->directories() as $directory) {
                    if (!\version_compare(\PHP_VERSION, $directory->phpVersion(), $directory->phpVersionOperator()->asString())) {
                        continue;
                    }
                    $exclude = [];
                    foreach ($testSuiteConfiguration->exclude()->asArray() as $file) {
                        $exclude[] = $file->path();
                    }
                    $files = (new \PHPUnit\SebastianBergmann\FileIterator\Facade())->getFilesAsArray($directory->path(), $directory->suffix(), $directory->prefix(), $exclude);
                    if (!empty($files)) {
                        $testSuite->addTestFiles($files);
                        $testSuiteEmpty = \false;
                    } elseif (\strpos($directory->path(), '*') === \false && !\is_dir($directory->path())) {
                        throw new \PHPUnit\TextUI\TestDirectoryNotFoundException($directory->path());
                    }
                }
                foreach ($testSuiteConfiguration->files() as $file) {
                    if (!\is_file($file->path())) {
                        throw new \PHPUnit\TextUI\TestFileNotFoundException($file->path());
                    }
                    if (!\version_compare(\PHP_VERSION, $file->phpVersion(), $file->phpVersionOperator()->asString())) {
                        continue;
                    }
                    $testSuite->addTestFile($file->path());
                    $testSuiteEmpty = \false;
                }
                if (!$testSuiteEmpty) {
                    $result->addTest($testSuite);
                }
            }
            return $result;
        } catch (\PHPUnit\Framework\Exception $e) {
            throw new \PHPUnit\TextUI\RuntimeException($e->getMessage(), (int) $e->getCode(), $e);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage;

use function count;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml;
use PHPUnit\TextUI\XmlConfiguration\Directory;
use PHPUnit\TextUI\XmlConfiguration\Exception;
use PHPUnit\TextUI\XmlConfiguration\FileCollection;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class CodeCoverage
{
    private ?\PHPUnit\TextUI\XmlConfiguration\Directory $cacheDirectory = null;
    private \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $directories;
    private \PHPUnit\TextUI\XmlConfiguration\FileCollection $files;
    private \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $excludeDirectories;
    private \PHPUnit\TextUI\XmlConfiguration\FileCollection $excludeFiles;
    private bool $pathCoverage;
    private bool $includeUncoveredFiles;
    private bool $ignoreDeprecatedCodeUnits;
    private bool $disableCodeCoverageIgnore;
    private ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover $clover = null;
    private ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura $cobertura = null;
    private ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j $crap4j = null;
    private ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html $html = null;
    private ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php $php = null;
    private ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text $text = null;
    private ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml $xml = null;
    public function __construct(?\PHPUnit\TextUI\XmlConfiguration\Directory $cacheDirectory, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $directories, \PHPUnit\TextUI\XmlConfiguration\FileCollection $files, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $excludeDirectories, \PHPUnit\TextUI\XmlConfiguration\FileCollection $excludeFiles, bool $pathCoverage, bool $includeUncoveredFiles, bool $ignoreDeprecatedCodeUnits, bool $disableCodeCoverageIgnore, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover $clover, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura $cobertura, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j $crap4j, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html $html, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php $php, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text $text, ?\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml $xml)
    {
        $this->cacheDirectory = $cacheDirectory;
        $this->directories = $directories;
        $this->files = $files;
        $this->excludeDirectories = $excludeDirectories;
        $this->excludeFiles = $excludeFiles;
        $this->pathCoverage = $pathCoverage;
        $this->includeUncoveredFiles = $includeUncoveredFiles;
        $this->ignoreDeprecatedCodeUnits = $ignoreDeprecatedCodeUnits;
        $this->disableCodeCoverageIgnore = $disableCodeCoverageIgnore;
        $this->clover = $clover;
        $this->cobertura = $cobertura;
        $this->crap4j = $crap4j;
        $this->html = $html;
        $this->php = $php;
        $this->text = $text;
        $this->xml = $xml;
    }
    /**
     * @psalm-assert-if-true !null $this->cacheDirectory
     *
     * @deprecated
     */
    public function hasCacheDirectory() : bool
    {
        return $this->cacheDirectory !== null;
    }
    /**
     * @throws Exception
     *
     * @deprecated
     */
    public function cacheDirectory() : \PHPUnit\TextUI\XmlConfiguration\Directory
    {
        if (!$this->hasCacheDirectory()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('No cache directory has been configured');
        }
        return $this->cacheDirectory;
    }
    public function hasNonEmptyListOfFilesToBeIncludedInCodeCoverageReport() : bool
    {
        return \count($this->directories) > 0 || \count($this->files) > 0;
    }
    public function directories() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection
    {
        return $this->directories;
    }
    public function files() : \PHPUnit\TextUI\XmlConfiguration\FileCollection
    {
        return $this->files;
    }
    public function excludeDirectories() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection
    {
        return $this->excludeDirectories;
    }
    public function excludeFiles() : \PHPUnit\TextUI\XmlConfiguration\FileCollection
    {
        return $this->excludeFiles;
    }
    public function pathCoverage() : bool
    {
        return $this->pathCoverage;
    }
    public function includeUncoveredFiles() : bool
    {
        return $this->includeUncoveredFiles;
    }
    public function ignoreDeprecatedCodeUnits() : bool
    {
        return $this->ignoreDeprecatedCodeUnits;
    }
    public function disableCodeCoverageIgnore() : bool
    {
        return $this->disableCodeCoverageIgnore;
    }
    /**
     * @psalm-assert-if-true !null $this->clover
     */
    public function hasClover() : bool
    {
        return $this->clover !== null;
    }
    /**
     * @throws Exception
     */
    public function clover() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover
    {
        if (!$this->hasClover()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Code Coverage report "Clover XML" has not been configured');
        }
        return $this->clover;
    }
    /**
     * @psalm-assert-if-true !null $this->cobertura
     */
    public function hasCobertura() : bool
    {
        return $this->cobertura !== null;
    }
    /**
     * @throws Exception
     */
    public function cobertura() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura
    {
        if (!$this->hasCobertura()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Code Coverage report "Cobertura XML" has not been configured');
        }
        return $this->cobertura;
    }
    /**
     * @psalm-assert-if-true !null $this->crap4j
     */
    public function hasCrap4j() : bool
    {
        return $this->crap4j !== null;
    }
    /**
     * @throws Exception
     */
    public function crap4j() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j
    {
        if (!$this->hasCrap4j()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Code Coverage report "Crap4J" has not been configured');
        }
        return $this->crap4j;
    }
    /**
     * @psalm-assert-if-true !null $this->html
     */
    public function hasHtml() : bool
    {
        return $this->html !== null;
    }
    /**
     * @throws Exception
     */
    public function html() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html
    {
        if (!$this->hasHtml()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Code Coverage report "HTML" has not been configured');
        }
        return $this->html;
    }
    /**
     * @psalm-assert-if-true !null $this->php
     */
    public function hasPhp() : bool
    {
        return $this->php !== null;
    }
    /**
     * @throws Exception
     */
    public function php() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php
    {
        if (!$this->hasPhp()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Code Coverage report "PHP" has not been configured');
        }
        return $this->php;
    }
    /**
     * @psalm-assert-if-true !null $this->text
     */
    public function hasText() : bool
    {
        return $this->text !== null;
    }
    /**
     * @throws Exception
     */
    public function text() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text
    {
        if (!$this->hasText()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Code Coverage report "Text" has not been configured');
        }
        return $this->text;
    }
    /**
     * @psalm-assert-if-true !null $this->xml
     */
    public function hasXml() : bool
    {
        return $this->xml !== null;
    }
    /**
     * @throws Exception
     */
    public function xml() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml
    {
        if (!$this->hasXml()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Code Coverage report "XML" has not been configured');
        }
        return $this->xml;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Directory
{
    private string $path;
    private string $prefix;
    private string $suffix;
    private string $group;
    public function __construct(string $path, string $prefix, string $suffix, string $group)
    {
        $this->path = $path;
        $this->prefix = $prefix;
        $this->suffix = $suffix;
        $this->group = $group;
    }
    public function path() : string
    {
        return $this->path;
    }
    public function prefix() : string
    {
        return $this->prefix;
    }
    public function suffix() : string
    {
        return $this->suffix;
    }
    public function group() : string
    {
        return $this->group;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class DirectoryCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var Directory[]
     */
    private array $directories;
    /**
     * @param Directory[] $directories
     */
    public static function fromArray(array $directories) : self
    {
        return new self(...$directories);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\Directory ...$directories)
    {
        $this->directories = $directories;
    }
    /**
     * @return Directory[]
     */
    public function asArray() : array
    {
        return $this->directories;
    }
    public function count() : int
    {
        return \count($this->directories);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class DirectoryCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var Directory[]
     */
    private array $directories;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection $directories)
    {
        $this->directories = $directories->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->directories);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\Directory
    {
        return $this->directories[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage;

use PHPUnit\SebastianBergmann\CodeCoverage\Filter;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class FilterMapper
{
    public function map(\PHPUnit\SebastianBergmann\CodeCoverage\Filter $filter, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage $configuration) : void
    {
        foreach ($configuration->directories() as $directory) {
            $filter->includeDirectory($directory->path(), $directory->suffix(), $directory->prefix());
        }
        foreach ($configuration->files() as $file) {
            $filter->includeFile($file->path());
        }
        foreach ($configuration->excludeDirectories() as $directory) {
            $filter->excludeDirectory($directory->path(), $directory->suffix(), $directory->prefix());
        }
        foreach ($configuration->excludeFiles() as $file) {
            $filter->excludeFile($file->path());
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Clover
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Cobertura
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Crap4j
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    private int $threshold;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target, int $threshold)
    {
        $this->target = $target;
        $this->threshold = $threshold;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
    public function threshold() : int
    {
        return $this->threshold;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report;

use PHPUnit\TextUI\XmlConfiguration\Directory;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Html
{
    private \PHPUnit\TextUI\XmlConfiguration\Directory $target;
    private int $lowUpperBound;
    private int $highLowerBound;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\Directory $target, int $lowUpperBound, int $highLowerBound)
    {
        $this->target = $target;
        $this->lowUpperBound = $lowUpperBound;
        $this->highLowerBound = $highLowerBound;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\Directory
    {
        return $this->target;
    }
    public function lowUpperBound() : int
    {
        return $this->lowUpperBound;
    }
    public function highLowerBound() : int
    {
        return $this->highLowerBound;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Php
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Text
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    private bool $showUncoveredFiles;
    private bool $showOnlySummary;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target, bool $showUncoveredFiles, bool $showOnlySummary)
    {
        $this->target = $target;
        $this->showUncoveredFiles = $showUncoveredFiles;
        $this->showOnlySummary = $showOnlySummary;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
    public function showUncoveredFiles() : bool
    {
        return $this->showUncoveredFiles;
    }
    public function showOnlySummary() : bool
    {
        return $this->showOnlySummary;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report;

use PHPUnit\TextUI\XmlConfiguration\Directory;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Xml
{
    private \PHPUnit\TextUI\XmlConfiguration\Directory $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\Directory $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\Directory
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage;
use PHPUnit\TextUI\XmlConfiguration\Logging\Logging;
use PHPUnit\Util\Xml\ValidationResult;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Configuration
{
    private string $filename;
    private \PHPUnit\Util\Xml\ValidationResult $validationResult;
    private \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection $extensions;
    private \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage $codeCoverage;
    private \PHPUnit\TextUI\XmlConfiguration\Groups $groups;
    private \PHPUnit\TextUI\XmlConfiguration\Groups $testdoxGroups;
    private \PHPUnit\TextUI\XmlConfiguration\Logging\Logging $logging;
    private \PHPUnit\TextUI\XmlConfiguration\Php $php;
    private \PHPUnit\TextUI\XmlConfiguration\PHPUnit $phpunit;
    private \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection $testSuite;
    public function __construct(string $filename, \PHPUnit\Util\Xml\ValidationResult $validationResult, \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection $extensions, \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage $codeCoverage, \PHPUnit\TextUI\XmlConfiguration\Groups $groups, \PHPUnit\TextUI\XmlConfiguration\Groups $testdoxGroups, \PHPUnit\TextUI\XmlConfiguration\Logging\Logging $logging, \PHPUnit\TextUI\XmlConfiguration\Php $php, \PHPUnit\TextUI\XmlConfiguration\PHPUnit $phpunit, \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection $testSuite)
    {
        $this->filename = $filename;
        $this->validationResult = $validationResult;
        $this->extensions = $extensions;
        $this->codeCoverage = $codeCoverage;
        $this->groups = $groups;
        $this->testdoxGroups = $testdoxGroups;
        $this->logging = $logging;
        $this->php = $php;
        $this->phpunit = $phpunit;
        $this->testSuite = $testSuite;
    }
    public function filename() : string
    {
        return $this->filename;
    }
    public function hasValidationErrors() : bool
    {
        return $this->validationResult->hasValidationErrors();
    }
    public function validationErrors() : string
    {
        return $this->validationResult->asString();
    }
    public function extensions() : \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection
    {
        return $this->extensions;
    }
    public function codeCoverage() : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage
    {
        return $this->codeCoverage;
    }
    public function groups() : \PHPUnit\TextUI\XmlConfiguration\Groups
    {
        return $this->groups;
    }
    public function testdoxGroups() : \PHPUnit\TextUI\XmlConfiguration\Groups
    {
        return $this->testdoxGroups;
    }
    public function logging() : \PHPUnit\TextUI\XmlConfiguration\Logging\Logging
    {
        return $this->logging;
    }
    public function php() : \PHPUnit\TextUI\XmlConfiguration\Php
    {
        return $this->php;
    }
    public function phpunit() : \PHPUnit\TextUI\XmlConfiguration\PHPUnit
    {
        return $this->phpunit;
    }
    public function testSuite() : \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection
    {
        return $this->testSuite;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Exception extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Directory
{
    private string $path;
    public function __construct(string $path)
    {
        $this->path = $path;
    }
    public function path() : string
    {
        return $this->path;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class DirectoryCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var Directory[]
     */
    private array $directories;
    /**
     * @param Directory[] $directories
     */
    public static function fromArray(array $directories) : self
    {
        return new self(...$directories);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\Directory ...$directories)
    {
        $this->directories = $directories;
    }
    /**
     * @return Directory[]
     */
    public function asArray() : array
    {
        return $this->directories;
    }
    public function count() : int
    {
        return \count($this->directories);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\DirectoryCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\DirectoryCollectionIterator($this);
    }
    public function isEmpty() : bool
    {
        return $this->count() === 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class DirectoryCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var Directory[]
     */
    private array $directories;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\DirectoryCollection $directories)
    {
        $this->directories = $directories->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->directories);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\Directory
    {
        return $this->directories[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class File
{
    private string $path;
    public function __construct(string $path)
    {
        $this->path = $path;
    }
    public function path() : string
    {
        return $this->path;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class FileCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var File[]
     */
    private array $files;
    /**
     * @param File[] $files
     */
    public static function fromArray(array $files) : self
    {
        return new self(...$files);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\File ...$files)
    {
        $this->files = $files;
    }
    /**
     * @return File[]
     */
    public function asArray() : array
    {
        return $this->files;
    }
    public function count() : int
    {
        return \count($this->files);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\FileCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\FileCollectionIterator($this);
    }
    public function isEmpty() : bool
    {
        return $this->count() === 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class FileCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var File[]
     */
    private array $files;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\FileCollection $files)
    {
        $this->files = $files->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->files);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->files[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function str_replace;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Generator
{
    /**
     * @var string
     */
    private const TEMPLATE = <<<'EOT'
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/{phpunit_version}/phpunit.xsd"
         bootstrap="{bootstrap_script}"
         cacheDirectory="{cache_directory}"
         executionOrder="depends,defects"
         forceCoversAnnotation="true"
         beStrictAboutCoversAnnotation="true"
         beStrictAboutOutputDuringTests="true"
         beStrictAboutTodoAnnotatedTests="true"
         failOnRisky="true"
         failOnWarning="true"
         verbose="true">
    <testsuites>
        <testsuite name="default">
            <directory>{tests_directory}</directory>
        </testsuite>
    </testsuites>

    <coverage>
        <include>
            <directory suffix=".php">{src_directory}</directory>
        </include>
    </coverage>
</phpunit>

EOT;
    public function generateDefaultConfiguration(string $phpunitVersion, string $bootstrapScript, string $testsDirectory, string $srcDirectory, string $cacheDirectory) : string
    {
        return \str_replace(['{phpunit_version}', '{bootstrap_script}', '{tests_directory}', '{src_directory}', '{cache_directory}'], [$phpunitVersion, $bootstrapScript, $testsDirectory, $srcDirectory, $cacheDirectory], self::TEMPLATE);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Group
{
    private string $name;
    public function __construct(string $name)
    {
        $this->name = $name;
    }
    public function name() : string
    {
        return $this->name;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class GroupCollection implements \IteratorAggregate
{
    /**
     * @var Group[]
     */
    private array $groups;
    /**
     * @param Group[] $groups
     */
    public static function fromArray(array $groups) : self
    {
        return new self(...$groups);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\Group ...$groups)
    {
        $this->groups = $groups;
    }
    /**
     * @return Group[]
     */
    public function asArray() : array
    {
        return $this->groups;
    }
    /**
     * @return string[]
     */
    public function asArrayOfStrings() : array
    {
        $result = [];
        foreach ($this->groups as $group) {
            $result[] = $group->name();
        }
        return $result;
    }
    public function isEmpty() : bool
    {
        return empty($this->groups);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\GroupCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\GroupCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class GroupCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var Group[]
     */
    private array $groups;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\GroupCollection $groups)
    {
        $this->groups = $groups->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->groups);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\Group
    {
        return $this->groups[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Groups
{
    private \PHPUnit\TextUI\XmlConfiguration\GroupCollection $include;
    private \PHPUnit\TextUI\XmlConfiguration\GroupCollection $exclude;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\GroupCollection $include, \PHPUnit\TextUI\XmlConfiguration\GroupCollection $exclude)
    {
        $this->include = $include;
        $this->exclude = $exclude;
    }
    public function hasInclude() : bool
    {
        return !$this->include->isEmpty();
    }
    public function include() : \PHPUnit\TextUI\XmlConfiguration\GroupCollection
    {
        return $this->include;
    }
    public function hasExclude() : bool
    {
        return !$this->exclude->isEmpty();
    }
    public function exclude() : \PHPUnit\TextUI\XmlConfiguration\GroupCollection
    {
        return $this->exclude;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use const DIRECTORY_SEPARATOR;
use const PHP_VERSION;
use function assert;
use function defined;
use function dirname;
use function explode;
use function is_file;
use function is_numeric;
use function preg_match;
use function stream_resolve_include_path;
use function strlen;
use function strpos;
use function strtolower;
use function substr;
use function trim;
use DOMDocument;
use DOMElement;
use DOMNodeList;
use DOMXPath;
use PHPUnit\Runner\TestSuiteSorter;
use PHPUnit\Runner\Version;
use PHPUnit\TextUI\DefaultResultPrinter;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\Directory as FilterDirectory;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection as FilterDirectoryCollection;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html as CodeCoverageHtml;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php as CodeCoveragePhp;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text as CodeCoverageText;
use PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml as CodeCoverageXml;
use PHPUnit\TextUI\XmlConfiguration\Logging\Junit;
use PHPUnit\TextUI\XmlConfiguration\Logging\Logging;
use PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity;
use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html as TestDoxHtml;
use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text as TestDoxText;
use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml as TestDoxXml;
use PHPUnit\TextUI\XmlConfiguration\Logging\Text;
use PHPUnit\TextUI\XmlConfiguration\TestSuite as TestSuiteConfiguration;
use PHPUnit\Util\TestDox\CliTestDoxPrinter;
use PHPUnit\Util\VersionComparisonOperator;
use PHPUnit\Util\Xml;
use PHPUnit\Util\Xml\Exception as XmlException;
use PHPUnit\Util\Xml\Loader as XmlLoader;
use PHPUnit\Util\Xml\SchemaFinder;
use PHPUnit\Util\Xml\Validator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Loader
{
    /**
     * @throws Exception
     */
    public function load(string $filename) : \PHPUnit\TextUI\XmlConfiguration\Configuration
    {
        try {
            $document = (new \PHPUnit\Util\Xml\Loader())->loadFile($filename, \false, \true, \true);
        } catch (\PHPUnit\Util\Xml\Exception $e) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        $xpath = new \DOMXPath($document);
        try {
            $xsdFilename = (new \PHPUnit\Util\Xml\SchemaFinder())->find(\PHPUnit\Runner\Version::series());
        } catch (\PHPUnit\Util\Xml\Exception $e) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        return new \PHPUnit\TextUI\XmlConfiguration\Configuration($filename, (new \PHPUnit\Util\Xml\Validator())->validate($document, $xsdFilename), $this->extensions($filename, $xpath), $this->codeCoverage($filename, $xpath, $document), $this->groups($xpath), $this->testdoxGroups($xpath), $this->logging($filename, $xpath), $this->php($filename, $xpath), $this->phpunit($filename, $document), $this->testSuite($filename, $xpath));
    }
    public function logging(string $filename, \DOMXPath $xpath) : \PHPUnit\TextUI\XmlConfiguration\Logging\Logging
    {
        $junit = null;
        $element = $this->element($xpath, 'logging/junit');
        if ($element) {
            $junit = new \PHPUnit\TextUI\XmlConfiguration\Logging\Junit(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $text = null;
        $element = $this->element($xpath, 'logging/text');
        if ($element) {
            $text = new \PHPUnit\TextUI\XmlConfiguration\Logging\Text(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $teamCity = null;
        $element = $this->element($xpath, 'logging/teamcity');
        if ($element) {
            $teamCity = new \PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $testDoxHtml = null;
        $element = $this->element($xpath, 'logging/testdoxHtml');
        if ($element) {
            $testDoxHtml = new \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $testDoxText = null;
        $element = $this->element($xpath, 'logging/testdoxText');
        if ($element) {
            $testDoxText = new \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $testDoxXml = null;
        $element = $this->element($xpath, 'logging/testdoxXml');
        if ($element) {
            $testDoxXml = new \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        return new \PHPUnit\TextUI\XmlConfiguration\Logging\Logging($junit, $text, $teamCity, $testDoxHtml, $testDoxText, $testDoxXml);
    }
    private function extensions(string $filename, \DOMXPath $xpath) : \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection
    {
        $extensions = [];
        foreach ($xpath->query('extensions/extension') as $extension) {
            \assert($extension instanceof \DOMElement);
            $extensions[] = $this->getElementConfigurationParameters($filename, $extension);
        }
        return \PHPUnit\TextUI\XmlConfiguration\ExtensionCollection::fromArray($extensions);
    }
    private function getElementConfigurationParameters(string $filename, \DOMElement $element) : \PHPUnit\TextUI\XmlConfiguration\Extension
    {
        /** @psalm-var class-string $class */
        $class = (string) $element->getAttribute('class');
        $file = '';
        $arguments = $this->getConfigurationArguments($filename, $element->childNodes);
        if ($element->getAttribute('file')) {
            $file = $this->toAbsolutePath($filename, (string) $element->getAttribute('file'), \true);
        }
        return new \PHPUnit\TextUI\XmlConfiguration\Extension($class, $file, $arguments);
    }
    private function toAbsolutePath(string $filename, string $path, bool $useIncludePath = \false) : string
    {
        $path = \trim($path);
        if (\strpos($path, '/') === 0) {
            return $path;
        }
        // Matches the following on Windows:
        //  - \\NetworkComputer\Path
        //  - \\.\D:
        //  - \\.\c:
        //  - C:\Windows
        //  - C:\windows
        //  - C:/windows
        //  - c:/windows
        if (\defined('PHP_WINDOWS_VERSION_BUILD') && ($path[0] === '\\' || \strlen($path) >= 3 && \preg_match('#^[A-Z]\\:[/\\\\]#i', \substr($path, 0, 3)))) {
            return $path;
        }
        if (\strpos($path, '://') !== \false) {
            return $path;
        }
        $file = \dirname($filename) . \DIRECTORY_SEPARATOR . $path;
        if ($useIncludePath && !\is_file($file)) {
            $includePathFile = \stream_resolve_include_path($path);
            if ($includePathFile) {
                $file = $includePathFile;
            }
        }
        return $file;
    }
    private function getConfigurationArguments(string $filename, \DOMNodeList $nodes) : array
    {
        $arguments = [];
        if ($nodes->length === 0) {
            return $arguments;
        }
        foreach ($nodes as $node) {
            if (!$node instanceof \DOMElement) {
                continue;
            }
            if ($node->tagName !== 'arguments') {
                continue;
            }
            foreach ($node->childNodes as $argument) {
                if (!$argument instanceof \DOMElement) {
                    continue;
                }
                if ($argument->tagName === 'file' || $argument->tagName === 'directory') {
                    $arguments[] = $this->toAbsolutePath($filename, (string) $argument->textContent);
                } else {
                    $arguments[] = \PHPUnit\Util\Xml::xmlToVariable($argument);
                }
            }
        }
        return $arguments;
    }
    private function codeCoverage(string $filename, \DOMXPath $xpath, \DOMDocument $document) : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage
    {
        $cacheDirectory = null;
        $pathCoverage = \false;
        $includeUncoveredFiles = \true;
        $ignoreDeprecatedCodeUnits = \false;
        $disableCodeCoverageIgnore = \false;
        $element = $this->element($xpath, 'coverage');
        if ($element) {
            $cacheDirectory = $this->getStringAttribute($element, 'cacheDirectory');
            if ($cacheDirectory !== null) {
                $cacheDirectory = new \PHPUnit\TextUI\XmlConfiguration\Directory($this->toAbsolutePath($filename, $cacheDirectory));
            }
            $pathCoverage = $this->getBooleanAttribute($element, 'pathCoverage', \false);
            $includeUncoveredFiles = $this->getBooleanAttribute($element, 'includeUncoveredFiles', \true);
            $ignoreDeprecatedCodeUnits = $this->getBooleanAttribute($element, 'ignoreDeprecatedCodeUnits', \false);
            $disableCodeCoverageIgnore = $this->getBooleanAttribute($element, 'disableCodeCoverageIgnore', \false);
        }
        $clover = null;
        $element = $this->element($xpath, 'coverage/report/clover');
        if ($element) {
            $clover = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Clover(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $cobertura = null;
        $element = $this->element($xpath, 'coverage/report/cobertura');
        if ($element) {
            $cobertura = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Cobertura(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $crap4j = null;
        $element = $this->element($xpath, 'coverage/report/crap4j');
        if ($element) {
            $crap4j = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Crap4j(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))), $this->getIntegerAttribute($element, 'threshold', 30));
        }
        $html = null;
        $element = $this->element($xpath, 'coverage/report/html');
        if ($element) {
            $html = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Html(new \PHPUnit\TextUI\XmlConfiguration\Directory($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputDirectory'))), $this->getIntegerAttribute($element, 'lowUpperBound', 50), $this->getIntegerAttribute($element, 'highLowerBound', 90));
        }
        $php = null;
        $element = $this->element($xpath, 'coverage/report/php');
        if ($element) {
            $php = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Php(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))));
        }
        $text = null;
        $element = $this->element($xpath, 'coverage/report/text');
        if ($element) {
            $text = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Text(new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputFile'))), $this->getBooleanAttribute($element, 'showUncoveredFiles', \false), $this->getBooleanAttribute($element, 'showOnlySummary', \false));
        }
        $xml = null;
        $element = $this->element($xpath, 'coverage/report/xml');
        if ($element) {
            $xml = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Report\Xml(new \PHPUnit\TextUI\XmlConfiguration\Directory($this->toAbsolutePath($filename, (string) $this->getStringAttribute($element, 'outputDirectory'))));
        }
        return new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\CodeCoverage($cacheDirectory, $this->readFilterDirectories($filename, $xpath, 'coverage/include/directory'), $this->readFilterFiles($filename, $xpath, 'coverage/include/file'), $this->readFilterDirectories($filename, $xpath, 'coverage/exclude/directory'), $this->readFilterFiles($filename, $xpath, 'coverage/exclude/file'), $pathCoverage, $includeUncoveredFiles, $ignoreDeprecatedCodeUnits, $disableCodeCoverageIgnore, $clover, $cobertura, $crap4j, $html, $php, $text, $xml);
    }
    /**
     * If $value is 'false' or 'true', this returns the value that $value represents.
     * Otherwise, returns $default, which may be a string in rare cases.
     *
     * @see \PHPUnit\TextUI\XmlConfigurationTest::testPHPConfigurationIsReadCorrectly
     *
     * @param bool|string $default
     *
     * @return bool|string
     */
    private function getBoolean(string $value, $default)
    {
        if (\strtolower($value) === 'false') {
            return \false;
        }
        if (\strtolower($value) === 'true') {
            return \true;
        }
        return $default;
    }
    private function readFilterDirectories(string $filename, \DOMXPath $xpath, string $query) : \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection
    {
        $directories = [];
        foreach ($xpath->query($query) as $directoryNode) {
            \assert($directoryNode instanceof \DOMElement);
            $directoryPath = (string) $directoryNode->textContent;
            if (!$directoryPath) {
                continue;
            }
            $directories[] = new \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\Directory($this->toAbsolutePath($filename, $directoryPath), $directoryNode->hasAttribute('prefix') ? (string) $directoryNode->getAttribute('prefix') : '', $directoryNode->hasAttribute('suffix') ? (string) $directoryNode->getAttribute('suffix') : '.php', $directoryNode->hasAttribute('group') ? (string) $directoryNode->getAttribute('group') : 'DEFAULT');
        }
        return \PHPUnit\TextUI\XmlConfiguration\CodeCoverage\Filter\DirectoryCollection::fromArray($directories);
    }
    private function readFilterFiles(string $filename, \DOMXPath $xpath, string $query) : \PHPUnit\TextUI\XmlConfiguration\FileCollection
    {
        $files = [];
        foreach ($xpath->query($query) as $file) {
            $filePath = (string) $file->textContent;
            if ($filePath) {
                $files[] = new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, $filePath));
            }
        }
        return \PHPUnit\TextUI\XmlConfiguration\FileCollection::fromArray($files);
    }
    private function groups(\DOMXPath $xpath) : \PHPUnit\TextUI\XmlConfiguration\Groups
    {
        return $this->parseGroupConfiguration($xpath, 'groups');
    }
    private function testdoxGroups(\DOMXPath $xpath) : \PHPUnit\TextUI\XmlConfiguration\Groups
    {
        return $this->parseGroupConfiguration($xpath, 'testdoxGroups');
    }
    private function parseGroupConfiguration(\DOMXPath $xpath, string $root) : \PHPUnit\TextUI\XmlConfiguration\Groups
    {
        $include = [];
        $exclude = [];
        foreach ($xpath->query($root . '/include/group') as $group) {
            $include[] = new \PHPUnit\TextUI\XmlConfiguration\Group((string) $group->textContent);
        }
        foreach ($xpath->query($root . '/exclude/group') as $group) {
            $exclude[] = new \PHPUnit\TextUI\XmlConfiguration\Group((string) $group->textContent);
        }
        return new \PHPUnit\TextUI\XmlConfiguration\Groups(\PHPUnit\TextUI\XmlConfiguration\GroupCollection::fromArray($include), \PHPUnit\TextUI\XmlConfiguration\GroupCollection::fromArray($exclude));
    }
    private function getBooleanAttribute(\DOMElement $element, string $attribute, bool $default) : bool
    {
        if (!$element->hasAttribute($attribute)) {
            return $default;
        }
        return (bool) $this->getBoolean((string) $element->getAttribute($attribute), \false);
    }
    private function getIntegerAttribute(\DOMElement $element, string $attribute, int $default) : int
    {
        if (!$element->hasAttribute($attribute)) {
            return $default;
        }
        return $this->getInteger((string) $element->getAttribute($attribute), $default);
    }
    private function getStringAttribute(\DOMElement $element, string $attribute) : ?string
    {
        if (!$element->hasAttribute($attribute)) {
            return null;
        }
        return (string) $element->getAttribute($attribute);
    }
    private function getInteger(string $value, int $default) : int
    {
        if (\is_numeric($value)) {
            return (int) $value;
        }
        return $default;
    }
    private function php(string $filename, \DOMXPath $xpath) : \PHPUnit\TextUI\XmlConfiguration\Php
    {
        $includePaths = [];
        foreach ($xpath->query('php/includePath') as $includePath) {
            $path = (string) $includePath->textContent;
            if ($path) {
                $includePaths[] = new \PHPUnit\TextUI\XmlConfiguration\Directory($this->toAbsolutePath($filename, $path));
            }
        }
        $iniSettings = [];
        foreach ($xpath->query('php/ini') as $ini) {
            \assert($ini instanceof \DOMElement);
            $iniSettings[] = new \PHPUnit\TextUI\XmlConfiguration\IniSetting((string) $ini->getAttribute('name'), (string) $ini->getAttribute('value'));
        }
        $constants = [];
        foreach ($xpath->query('php/const') as $const) {
            \assert($const instanceof \DOMElement);
            $value = (string) $const->getAttribute('value');
            $constants[] = new \PHPUnit\TextUI\XmlConfiguration\Constant((string) $const->getAttribute('name'), $this->getBoolean($value, $value));
        }
        $variables = ['var' => [], 'env' => [], 'post' => [], 'get' => [], 'cookie' => [], 'server' => [], 'files' => [], 'request' => []];
        foreach (['var', 'env', 'post', 'get', 'cookie', 'server', 'files', 'request'] as $array) {
            foreach ($xpath->query('php/' . $array) as $var) {
                \assert($var instanceof \DOMElement);
                $name = (string) $var->getAttribute('name');
                $value = (string) $var->getAttribute('value');
                $force = \false;
                $verbatim = \false;
                if ($var->hasAttribute('force')) {
                    $force = (bool) $this->getBoolean($var->getAttribute('force'), \false);
                }
                if ($var->hasAttribute('verbatim')) {
                    $verbatim = $this->getBoolean($var->getAttribute('verbatim'), \false);
                }
                if (!$verbatim) {
                    $value = $this->getBoolean($value, $value);
                }
                $variables[$array][] = new \PHPUnit\TextUI\XmlConfiguration\Variable($name, $value, $force);
            }
        }
        return new \PHPUnit\TextUI\XmlConfiguration\Php(\PHPUnit\TextUI\XmlConfiguration\DirectoryCollection::fromArray($includePaths), \PHPUnit\TextUI\XmlConfiguration\IniSettingCollection::fromArray($iniSettings), \PHPUnit\TextUI\XmlConfiguration\ConstantCollection::fromArray($constants), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['var']), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['env']), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['post']), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['get']), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['cookie']), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['server']), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['files']), \PHPUnit\TextUI\XmlConfiguration\VariableCollection::fromArray($variables['request']));
    }
    private function phpunit(string $filename, \DOMDocument $document) : \PHPUnit\TextUI\XmlConfiguration\PHPUnit
    {
        $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT;
        $defectsFirst = \false;
        $resolveDependencies = $this->getBooleanAttribute($document->documentElement, 'resolveDependencies', \true);
        if ($document->documentElement->hasAttribute('executionOrder')) {
            foreach (\explode(',', $document->documentElement->getAttribute('executionOrder')) as $order) {
                switch ($order) {
                    case 'default':
                        $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_DEFAULT;
                        $defectsFirst = \false;
                        $resolveDependencies = \true;
                        break;
                    case 'depends':
                        $resolveDependencies = \true;
                        break;
                    case 'no-depends':
                        $resolveDependencies = \false;
                        break;
                    case 'defects':
                        $defectsFirst = \true;
                        break;
                    case 'duration':
                        $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_DURATION;
                        break;
                    case 'random':
                        $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_RANDOMIZED;
                        break;
                    case 'reverse':
                        $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_REVERSED;
                        break;
                    case 'size':
                        $executionOrder = \PHPUnit\Runner\TestSuiteSorter::ORDER_SIZE;
                        break;
                }
            }
        }
        $printerClass = $this->getStringAttribute($document->documentElement, 'printerClass');
        $testdox = $this->getBooleanAttribute($document->documentElement, 'testdox', \false);
        $conflictBetweenPrinterClassAndTestdox = \false;
        if ($testdox) {
            if ($printerClass !== null) {
                $conflictBetweenPrinterClassAndTestdox = \true;
            }
            $printerClass = \PHPUnit\Util\TestDox\CliTestDoxPrinter::class;
        }
        $cacheDirectory = $this->getStringAttribute($document->documentElement, 'cacheDirectory');
        if ($cacheDirectory !== null) {
            $cacheDirectory = $this->toAbsolutePath($filename, $cacheDirectory);
        }
        $cacheResultFile = $this->getStringAttribute($document->documentElement, 'cacheResultFile');
        if ($cacheResultFile !== null) {
            $cacheResultFile = $this->toAbsolutePath($filename, $cacheResultFile);
        }
        $bootstrap = $this->getStringAttribute($document->documentElement, 'bootstrap');
        if ($bootstrap !== null) {
            $bootstrap = $this->toAbsolutePath($filename, $bootstrap);
        }
        $extensionsDirectory = $this->getStringAttribute($document->documentElement, 'extensionsDirectory');
        if ($extensionsDirectory !== null) {
            $extensionsDirectory = $this->toAbsolutePath($filename, $extensionsDirectory);
        }
        $printerFile = $this->getStringAttribute($document->documentElement, 'printerFile');
        if ($printerFile !== null) {
            $printerFile = $this->toAbsolutePath($filename, $printerFile);
        }
        $backupStaticProperties = \false;
        if ($document->documentElement->hasAttribute('backupStaticProperties')) {
            $backupStaticProperties = $this->getBooleanAttribute($document->documentElement, 'backupStaticProperties', \false);
        } elseif ($document->documentElement->hasAttribute('backupStaticAttributes')) {
            $backupStaticProperties = $this->getBooleanAttribute($document->documentElement, 'backupStaticAttributes', \false);
        }
        return new \PHPUnit\TextUI\XmlConfiguration\PHPUnit($cacheDirectory, $this->getBooleanAttribute($document->documentElement, 'cacheResult', \true), $cacheResultFile, $this->getColumns($document), $this->getColors($document), $this->getBooleanAttribute($document->documentElement, 'stderr', \false), $this->getBooleanAttribute($document->documentElement, 'noInteraction', \false), $this->getBooleanAttribute($document->documentElement, 'verbose', \false), $this->getBooleanAttribute($document->documentElement, 'reverseDefectList', \false), $this->getBooleanAttribute($document->documentElement, 'convertDeprecationsToExceptions', \true), $this->getBooleanAttribute($document->documentElement, 'convertErrorsToExceptions', \true), $this->getBooleanAttribute($document->documentElement, 'convertNoticesToExceptions', \true), $this->getBooleanAttribute($document->documentElement, 'convertWarningsToExceptions', \true), $this->getBooleanAttribute($document->documentElement, 'forceCoversAnnotation', \false), $bootstrap, $this->getBooleanAttribute($document->documentElement, 'processIsolation', \false), $this->getBooleanAttribute($document->documentElement, 'failOnEmptyTestSuite', \false), $this->getBooleanAttribute($document->documentElement, 'failOnIncomplete', \false), $this->getBooleanAttribute($document->documentElement, 'failOnRisky', \false), $this->getBooleanAttribute($document->documentElement, 'failOnSkipped', \false), $this->getBooleanAttribute($document->documentElement, 'failOnWarning', \false), $this->getBooleanAttribute($document->documentElement, 'stopOnDefect', \false), $this->getBooleanAttribute($document->documentElement, 'stopOnError', \false), $this->getBooleanAttribute($document->documentElement, 'stopOnFailure', \false), $this->getBooleanAttribute($document->documentElement, 'stopOnWarning', \false), $this->getBooleanAttribute($document->documentElement, 'stopOnIncomplete', \false), $this->getBooleanAttribute($document->documentElement, 'stopOnRisky', \false), $this->getBooleanAttribute($document->documentElement, 'stopOnSkipped', \false), $extensionsDirectory, $printerClass, $printerFile, $this->getBooleanAttribute($document->documentElement, 'beStrictAboutChangesToGlobalState', \false), $this->getBooleanAttribute($document->documentElement, 'beStrictAboutOutputDuringTests', \false), $this->getBooleanAttribute($document->documentElement, 'beStrictAboutResourceUsageDuringSmallTests', \false), $this->getBooleanAttribute($document->documentElement, 'beStrictAboutTestsThatDoNotTestAnything', \true), $this->getBooleanAttribute($document->documentElement, 'beStrictAboutTodoAnnotatedTests', \false), $this->getBooleanAttribute($document->documentElement, 'beStrictAboutCoversAnnotation', \false), $this->getBooleanAttribute($document->documentElement, 'enforceTimeLimit', \false), $this->getIntegerAttribute($document->documentElement, 'defaultTimeLimit', 1), $this->getIntegerAttribute($document->documentElement, 'timeoutForSmallTests', 1), $this->getIntegerAttribute($document->documentElement, 'timeoutForMediumTests', 10), $this->getIntegerAttribute($document->documentElement, 'timeoutForLargeTests', 60), $this->getStringAttribute($document->documentElement, 'defaultTestSuite'), $executionOrder, $resolveDependencies, $defectsFirst, $this->getBooleanAttribute($document->documentElement, 'backupGlobals', \false), $backupStaticProperties, $this->getBooleanAttribute($document->documentElement, 'registerMockObjectsFromTestArgumentsRecursively', \false), $conflictBetweenPrinterClassAndTestdox);
    }
    private function getColors(\DOMDocument $document) : string
    {
        $colors = \PHPUnit\TextUI\DefaultResultPrinter::COLOR_DEFAULT;
        if ($document->documentElement->hasAttribute('colors')) {
            /* only allow boolean for compatibility with previous versions
               'always' only allowed from command line */
            if ($this->getBoolean($document->documentElement->getAttribute('colors'), \false)) {
                $colors = \PHPUnit\TextUI\DefaultResultPrinter::COLOR_AUTO;
            } else {
                $colors = \PHPUnit\TextUI\DefaultResultPrinter::COLOR_NEVER;
            }
        }
        return $colors;
    }
    /**
     * @return int|string
     */
    private function getColumns(\DOMDocument $document)
    {
        $columns = 80;
        if ($document->documentElement->hasAttribute('columns')) {
            $columns = (string) $document->documentElement->getAttribute('columns');
            if ($columns !== 'max') {
                $columns = $this->getInteger($columns, 80);
            }
        }
        return $columns;
    }
    private function testSuite(string $filename, \DOMXPath $xpath) : \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection
    {
        $testSuites = [];
        foreach ($this->getTestSuiteElements($xpath) as $element) {
            $exclude = [];
            foreach ($element->getElementsByTagName('exclude') as $excludeNode) {
                $excludeFile = (string) $excludeNode->textContent;
                if ($excludeFile) {
                    $exclude[] = new \PHPUnit\TextUI\XmlConfiguration\File($this->toAbsolutePath($filename, $excludeFile));
                }
            }
            $directories = [];
            foreach ($element->getElementsByTagName('directory') as $directoryNode) {
                \assert($directoryNode instanceof \DOMElement);
                $directory = (string) $directoryNode->textContent;
                if (empty($directory)) {
                    continue;
                }
                $prefix = '';
                if ($directoryNode->hasAttribute('prefix')) {
                    $prefix = (string) $directoryNode->getAttribute('prefix');
                }
                $suffix = 'Test.php';
                if ($directoryNode->hasAttribute('suffix')) {
                    $suffix = (string) $directoryNode->getAttribute('suffix');
                }
                $phpVersion = \PHP_VERSION;
                if ($directoryNode->hasAttribute('phpVersion')) {
                    $phpVersion = (string) $directoryNode->getAttribute('phpVersion');
                }
                $phpVersionOperator = new \PHPUnit\Util\VersionComparisonOperator('>=');
                if ($directoryNode->hasAttribute('phpVersionOperator')) {
                    $phpVersionOperator = new \PHPUnit\Util\VersionComparisonOperator((string) $directoryNode->getAttribute('phpVersionOperator'));
                }
                $directories[] = new \PHPUnit\TextUI\XmlConfiguration\TestDirectory($this->toAbsolutePath($filename, $directory), $prefix, $suffix, $phpVersion, $phpVersionOperator);
            }
            $files = [];
            foreach ($element->getElementsByTagName('file') as $fileNode) {
                \assert($fileNode instanceof \DOMElement);
                $file = (string) $fileNode->textContent;
                if (empty($file)) {
                    continue;
                }
                $phpVersion = \PHP_VERSION;
                if ($fileNode->hasAttribute('phpVersion')) {
                    $phpVersion = (string) $fileNode->getAttribute('phpVersion');
                }
                $phpVersionOperator = new \PHPUnit\Util\VersionComparisonOperator('>=');
                if ($fileNode->hasAttribute('phpVersionOperator')) {
                    $phpVersionOperator = new \PHPUnit\Util\VersionComparisonOperator((string) $fileNode->getAttribute('phpVersionOperator'));
                }
                $files[] = new \PHPUnit\TextUI\XmlConfiguration\TestFile($this->toAbsolutePath($filename, $file), $phpVersion, $phpVersionOperator);
            }
            $testSuites[] = new \PHPUnit\TextUI\XmlConfiguration\TestSuite((string) $element->getAttribute('name'), \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection::fromArray($directories), \PHPUnit\TextUI\XmlConfiguration\TestFileCollection::fromArray($files), \PHPUnit\TextUI\XmlConfiguration\FileCollection::fromArray($exclude));
        }
        return \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection::fromArray($testSuites);
    }
    /**
     * @return DOMElement[]
     */
    private function getTestSuiteElements(\DOMXPath $xpath) : array
    {
        /** @var DOMElement[] $elements */
        $elements = [];
        $testSuiteNodes = $xpath->query('testsuites/testsuite');
        if ($testSuiteNodes->length === 0) {
            $testSuiteNodes = $xpath->query('testsuite');
        }
        if ($testSuiteNodes->length === 1) {
            $element = $testSuiteNodes->item(0);
            \assert($element instanceof \DOMElement);
            $elements[] = $element;
        } else {
            foreach ($testSuiteNodes as $testSuiteNode) {
                \assert($testSuiteNode instanceof \DOMElement);
                $elements[] = $testSuiteNode;
            }
        }
        return $elements;
    }
    private function element(\DOMXPath $xpath, string $element) : ?\DOMElement
    {
        $nodes = $xpath->query($element);
        if ($nodes->length === 1) {
            $node = $nodes->item(0);
            \assert($node instanceof \DOMElement);
            return $node;
        }
        return null;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\Logging;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Junit
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\Logging;

use PHPUnit\TextUI\XmlConfiguration\Exception;
use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html as TestDoxHtml;
use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text as TestDoxText;
use PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml as TestDoxXml;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Logging
{
    private ?\PHPUnit\TextUI\XmlConfiguration\Logging\Junit $junit;
    private ?\PHPUnit\TextUI\XmlConfiguration\Logging\Text $text;
    private ?\PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity $teamCity;
    private ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html $testDoxHtml;
    private ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text $testDoxText;
    private ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml $testDoxXml;
    public function __construct(?\PHPUnit\TextUI\XmlConfiguration\Logging\Junit $junit, ?\PHPUnit\TextUI\XmlConfiguration\Logging\Text $text, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity $teamCity, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html $testDoxHtml, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text $testDoxText, ?\PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml $testDoxXml)
    {
        $this->junit = $junit;
        $this->text = $text;
        $this->teamCity = $teamCity;
        $this->testDoxHtml = $testDoxHtml;
        $this->testDoxText = $testDoxText;
        $this->testDoxXml = $testDoxXml;
    }
    public function hasJunit() : bool
    {
        return $this->junit !== null;
    }
    public function junit() : \PHPUnit\TextUI\XmlConfiguration\Logging\Junit
    {
        if ($this->junit === null) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Logger "JUnit XML" is not configured');
        }
        return $this->junit;
    }
    public function hasText() : bool
    {
        return $this->text !== null;
    }
    public function text() : \PHPUnit\TextUI\XmlConfiguration\Logging\Text
    {
        if ($this->text === null) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Logger "Text" is not configured');
        }
        return $this->text;
    }
    public function hasTeamCity() : bool
    {
        return $this->teamCity !== null;
    }
    public function teamCity() : \PHPUnit\TextUI\XmlConfiguration\Logging\TeamCity
    {
        if ($this->teamCity === null) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Logger "Team City" is not configured');
        }
        return $this->teamCity;
    }
    public function hasTestDoxHtml() : bool
    {
        return $this->testDoxHtml !== null;
    }
    public function testDoxHtml() : \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Html
    {
        if ($this->testDoxHtml === null) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Logger "TestDox HTML" is not configured');
        }
        return $this->testDoxHtml;
    }
    public function hasTestDoxText() : bool
    {
        return $this->testDoxText !== null;
    }
    public function testDoxText() : \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Text
    {
        if ($this->testDoxText === null) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Logger "TestDox Text" is not configured');
        }
        return $this->testDoxText;
    }
    public function hasTestDoxXml() : bool
    {
        return $this->testDoxXml !== null;
    }
    public function testDoxXml() : \PHPUnit\TextUI\XmlConfiguration\Logging\TestDox\Xml
    {
        if ($this->testDoxXml === null) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Logger "TestDox XML" is not configured');
        }
        return $this->testDoxXml;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\Logging;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TeamCity
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\Logging\TestDox;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Html
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\Logging\TestDox;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Text
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\Logging\TestDox;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Xml
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration\Logging;

use PHPUnit\TextUI\XmlConfiguration\File;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Text
{
    private \PHPUnit\TextUI\XmlConfiguration\File $target;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\File $target)
    {
        $this->target = $target;
    }
    public function target() : \PHPUnit\TextUI\XmlConfiguration\File
    {
        return $this->target;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function array_key_exists;
use function sprintf;
use function version_compare;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MigrationBuilder
{
    private const AVAILABLE_MIGRATIONS = ['8.5' => [\PHPUnit\TextUI\XmlConfiguration\RemoveLogTypes::class], '9.2' => [\PHPUnit\TextUI\XmlConfiguration\RemoveCacheTokensAttribute::class, \PHPUnit\TextUI\XmlConfiguration\IntroduceCoverageElement::class, \PHPUnit\TextUI\XmlConfiguration\MoveAttributesFromRootToCoverage::class, \PHPUnit\TextUI\XmlConfiguration\MoveAttributesFromFilterWhitelistToCoverage::class, \PHPUnit\TextUI\XmlConfiguration\MoveWhitelistDirectoriesToCoverage::class, \PHPUnit\TextUI\XmlConfiguration\MoveWhitelistExcludesToCoverage::class, \PHPUnit\TextUI\XmlConfiguration\RemoveEmptyFilter::class, \PHPUnit\TextUI\XmlConfiguration\CoverageCloverToReport::class, \PHPUnit\TextUI\XmlConfiguration\CoverageCrap4jToReport::class, \PHPUnit\TextUI\XmlConfiguration\CoverageHtmlToReport::class, \PHPUnit\TextUI\XmlConfiguration\CoveragePhpToReport::class, \PHPUnit\TextUI\XmlConfiguration\CoverageTextToReport::class, \PHPUnit\TextUI\XmlConfiguration\CoverageXmlToReport::class, \PHPUnit\TextUI\XmlConfiguration\ConvertLogTypes::class], '9.5' => [\PHPUnit\TextUI\XmlConfiguration\RemoveListeners::class, \PHPUnit\TextUI\XmlConfiguration\RemoveTestSuiteLoaderAttributes::class, \PHPUnit\TextUI\XmlConfiguration\RemoveCacheResultFileAttribute::class, \PHPUnit\TextUI\XmlConfiguration\RemoveCoverageElementCacheDirectoryAttribute::class, \PHPUnit\TextUI\XmlConfiguration\RemoveCoverageElementProcessUncoveredFilesAttribute::class, \PHPUnit\TextUI\XmlConfiguration\IntroduceCacheDirectoryAttribute::class, \PHPUnit\TextUI\XmlConfiguration\RenameBackupStaticAttributesAttribute::class]];
    /**
     * @throws MigrationBuilderException
     */
    public function build(string $fromVersion) : array
    {
        if (!\array_key_exists($fromVersion, self::AVAILABLE_MIGRATIONS)) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationBuilderException(\sprintf('Migration from schema version %s is not supported', $fromVersion));
        }
        $stack = [new \PHPUnit\TextUI\XmlConfiguration\UpdateSchemaLocation()];
        foreach (self::AVAILABLE_MIGRATIONS as $version => $migrations) {
            if (\version_compare($version, $fromVersion, '<')) {
                continue;
            }
            foreach ($migrations as $migration) {
                $stack[] = new $migration();
            }
        }
        return $stack;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MigrationBuilderException extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MigrationException extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ConvertLogTypes implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $logging = $document->getElementsByTagName('logging')->item(0);
        if (!$logging instanceof \DOMElement) {
            return;
        }
        $types = ['junit' => 'junit', 'teamcity' => 'teamcity', 'testdox-html' => 'testdoxHtml', 'testdox-text' => 'testdoxText', 'testdox-xml' => 'testdoxXml', 'plain' => 'text'];
        $logNodes = [];
        foreach ($logging->getElementsByTagName('log') as $logNode) {
            if (!isset($types[$logNode->getAttribute('type')])) {
                continue;
            }
            $logNodes[] = $logNode;
        }
        foreach ($logNodes as $oldNode) {
            $newLogNode = $document->createElement($types[$oldNode->getAttribute('type')]);
            $newLogNode->setAttribute('outputFile', $oldNode->getAttribute('target'));
            $logging->replaceChild($newLogNode, $oldNode);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CoverageCloverToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
{
    protected function forType() : string
    {
        return 'coverage-clover';
    }
    protected function toReportFormat(\DOMElement $logNode) : \DOMElement
    {
        $clover = $logNode->ownerDocument->createElement('clover');
        $clover->setAttribute('outputFile', $logNode->getAttribute('target'));
        return $clover;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CoverageCrap4jToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
{
    protected function forType() : string
    {
        return 'coverage-crap4j';
    }
    protected function toReportFormat(\DOMElement $logNode) : \DOMElement
    {
        $crap4j = $logNode->ownerDocument->createElement('crap4j');
        $crap4j->setAttribute('outputFile', $logNode->getAttribute('target'));
        $this->migrateAttributes($logNode, $crap4j, ['threshold']);
        return $crap4j;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CoverageHtmlToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
{
    protected function forType() : string
    {
        return 'coverage-html';
    }
    protected function toReportFormat(\DOMElement $logNode) : \DOMElement
    {
        $html = $logNode->ownerDocument->createElement('html');
        $html->setAttribute('outputDirectory', $logNode->getAttribute('target'));
        $this->migrateAttributes($logNode, $html, ['lowUpperBound', 'highLowerBound']);
        return $html;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CoveragePhpToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
{
    protected function forType() : string
    {
        return 'coverage-php';
    }
    protected function toReportFormat(\DOMElement $logNode) : \DOMElement
    {
        $php = $logNode->ownerDocument->createElement('php');
        $php->setAttribute('outputFile', $logNode->getAttribute('target'));
        return $php;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CoverageTextToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
{
    protected function forType() : string
    {
        return 'coverage-text';
    }
    protected function toReportFormat(\DOMElement $logNode) : \DOMElement
    {
        $text = $logNode->ownerDocument->createElement('text');
        $text->setAttribute('outputFile', $logNode->getAttribute('target'));
        $this->migrateAttributes($logNode, $text, ['showUncoveredFiles', 'showOnlySummary']);
        return $text;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class CoverageXmlToReport extends \PHPUnit\TextUI\XmlConfiguration\LogToReportMigration
{
    protected function forType() : string
    {
        return 'coverage-xml';
    }
    protected function toReportFormat(\DOMElement $logNode) : \DOMElement
    {
        $xml = $logNode->ownerDocument->createElement('xml');
        $xml->setAttribute('outputDirectory', $logNode->getAttribute('target'));
        return $xml;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class IntroduceCacheDirectoryAttribute implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $root = $document->documentElement;
        if ($root->hasAttribute('cacheDirectory')) {
            return;
        }
        $root->setAttribute('cacheDirectory', '.phpunit.cache');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class IntroduceCoverageElement implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $coverage = $document->createElement('coverage');
        $document->documentElement->insertBefore($coverage, $document->documentElement->firstChild);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function sprintf;
use DOMDocument;
use DOMElement;
use DOMXPath;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
abstract class LogToReportMigration implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    /**
     * @throws MigrationException
     */
    public function migrate(\DOMDocument $document) : void
    {
        $coverage = $document->getElementsByTagName('coverage')->item(0);
        if (!$coverage instanceof \DOMElement) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException('Unexpected state - No coverage element');
        }
        $logNode = $this->findLogNode($document);
        if ($logNode === null) {
            return;
        }
        $reportChild = $this->toReportFormat($logNode);
        $report = $coverage->getElementsByTagName('report')->item(0);
        if ($report === null) {
            $report = $coverage->appendChild($document->createElement('report'));
        }
        $report->appendChild($reportChild);
        $logNode->parentNode->removeChild($logNode);
    }
    protected function migrateAttributes(\DOMElement $src, \DOMElement $dest, array $attributes) : void
    {
        foreach ($attributes as $attr) {
            if (!$src->hasAttribute($attr)) {
                continue;
            }
            $dest->setAttribute($attr, $src->getAttribute($attr));
            $src->removeAttribute($attr);
        }
    }
    protected abstract function forType() : string;
    protected abstract function toReportFormat(\DOMElement $logNode) : \DOMElement;
    private function findLogNode(\DOMDocument $document) : ?\DOMElement
    {
        $logNode = (new \DOMXPath($document))->query(\sprintf('//logging/log[@type="%s"]', $this->forType()))->item(0);
        if (!$logNode instanceof \DOMElement) {
            return null;
        }
        return $logNode;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
interface Migration
{
    public function migrate(\DOMDocument $document) : void;
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MoveAttributesFromFilterWhitelistToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    /**
     * @throws MigrationException
     */
    public function migrate(\DOMDocument $document) : void
    {
        $whitelist = $document->getElementsByTagName('whitelist')->item(0);
        if (!$whitelist) {
            return;
        }
        $coverage = $document->getElementsByTagName('coverage')->item(0);
        if (!$coverage instanceof \DOMElement) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException('Unexpected state - No coverage element');
        }
        $map = ['addUncoveredFilesFromWhitelist' => 'includeUncoveredFiles', 'processUncoveredFilesFromWhitelist' => 'processUncoveredFiles'];
        foreach ($map as $old => $new) {
            if (!$whitelist->hasAttribute($old)) {
                continue;
            }
            $coverage->setAttribute($new, $whitelist->getAttribute($old));
            $whitelist->removeAttribute($old);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MoveAttributesFromRootToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    /**
     * @throws MigrationException
     */
    public function migrate(\DOMDocument $document) : void
    {
        $map = ['disableCodeCoverageIgnore' => 'disableCodeCoverageIgnore', 'ignoreDeprecatedCodeUnitsFromCodeCoverage' => 'ignoreDeprecatedCodeUnits'];
        $root = $document->documentElement;
        $coverage = $document->getElementsByTagName('coverage')->item(0);
        if (!$coverage instanceof \DOMElement) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException('Unexpected state - No coverage element');
        }
        foreach ($map as $old => $new) {
            if (!$root->hasAttribute($old)) {
                continue;
            }
            $coverage->setAttribute($new, $root->getAttribute($old));
            $root->removeAttribute($old);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
use PHPUnit\Util\Xml\SnapshotNodeList;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MoveWhitelistDirectoriesToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    /**
     * @throws MigrationException
     */
    public function migrate(\DOMDocument $document) : void
    {
        $whitelist = $document->getElementsByTagName('whitelist')->item(0);
        if ($whitelist === null) {
            return;
        }
        $coverage = $document->getElementsByTagName('coverage')->item(0);
        if (!$coverage instanceof \DOMElement) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException('Unexpected state - No coverage element');
        }
        $include = $document->createElement('include');
        $coverage->appendChild($include);
        foreach (\PHPUnit\Util\Xml\SnapshotNodeList::fromNodeList($whitelist->childNodes) as $child) {
            if (!$child instanceof \DOMElement || $child->nodeName !== 'directory') {
                continue;
            }
            $include->appendChild($child);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
use PHPUnit\Util\Xml\SnapshotNodeList;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class MoveWhitelistExcludesToCoverage implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    /**
     * @throws MigrationException
     */
    public function migrate(\DOMDocument $document) : void
    {
        $whitelist = $document->getElementsByTagName('whitelist')->item(0);
        if ($whitelist === null) {
            return;
        }
        $excludeNodes = \PHPUnit\Util\Xml\SnapshotNodeList::fromNodeList($whitelist->getElementsByTagName('exclude'));
        if ($excludeNodes->count() === 0) {
            return;
        }
        $coverage = $document->getElementsByTagName('coverage')->item(0);
        if (!$coverage instanceof \DOMElement) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException('Unexpected state - No coverage element');
        }
        $targetExclude = $coverage->getElementsByTagName('exclude')->item(0);
        if ($targetExclude === null) {
            $targetExclude = $coverage->appendChild($document->createElement('exclude'));
        }
        foreach ($excludeNodes as $excludeNode) {
            \assert($excludeNode instanceof \DOMElement);
            foreach (\PHPUnit\Util\Xml\SnapshotNodeList::fromNodeList($excludeNode->childNodes) as $child) {
                if (!$child instanceof \DOMElement || !\in_array($child->nodeName, ['directory', 'file'], \true)) {
                    continue;
                }
                $targetExclude->appendChild($child);
            }
            if ($excludeNode->getElementsByTagName('*')->count() !== 0) {
                throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException('Dangling child elements in exclude found.');
            }
            $whitelist->removeChild($excludeNode);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveCacheResultFileAttribute implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $root = $document->documentElement;
        if ($root->hasAttribute('cacheResultFile')) {
            $root->removeAttribute('cacheResultFile');
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveCacheTokensAttribute implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $root = $document->documentElement;
        if ($root->hasAttribute('cacheTokens')) {
            $root->removeAttribute('cacheTokens');
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveCoverageElementCacheDirectoryAttribute implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $node = $document->getElementsByTagName('coverage')->item(0);
        if (!$node instanceof \DOMElement || $node->parentNode === null) {
            return;
        }
        if ($node->hasAttribute('cacheDirectory')) {
            $node->removeAttribute('cacheDirectory');
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveCoverageElementProcessUncoveredFilesAttribute implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $node = $document->getElementsByTagName('coverage')->item(0);
        if (!$node instanceof \DOMElement || $node->parentNode === null) {
            return;
        }
        if ($node->hasAttribute('processUncoveredFiles')) {
            $node->removeAttribute('processUncoveredFiles');
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function sprintf;
use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveEmptyFilter implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    /**
     * @throws MigrationException
     */
    public function migrate(\DOMDocument $document) : void
    {
        $whitelist = $document->getElementsByTagName('whitelist')->item(0);
        if ($whitelist instanceof \DOMElement) {
            $this->ensureEmpty($whitelist);
            $whitelist->parentNode->removeChild($whitelist);
        }
        $filter = $document->getElementsByTagName('filter')->item(0);
        if ($filter instanceof \DOMElement) {
            $this->ensureEmpty($filter);
            $filter->parentNode->removeChild($filter);
        }
    }
    /**
     * @throws MigrationException
     */
    private function ensureEmpty(\DOMElement $element) : void
    {
        if ($element->attributes->length > 0) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException(\sprintf('%s element has unexpected attributes', $element->nodeName));
        }
        if ($element->getElementsByTagName('*')->length > 0) {
            throw new \PHPUnit\TextUI\XmlConfiguration\MigrationException(\sprintf('%s element has unexpected children', $element->nodeName));
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveListeners implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $node = $document->getElementsByTagName('listeners')->item(0);
        if (!$node instanceof \DOMElement || $node->parentNode === null) {
            return;
        }
        $node->parentNode->removeChild($node);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use DOMElement;
use PHPUnit\Util\Xml\SnapshotNodeList;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveLogTypes implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $logging = $document->getElementsByTagName('logging')->item(0);
        if (!$logging instanceof \DOMElement) {
            return;
        }
        foreach (\PHPUnit\Util\Xml\SnapshotNodeList::fromNodeList($logging->getElementsByTagName('log')) as $logNode) {
            switch ($logNode->getAttribute('type')) {
                case 'json':
                case 'tap':
                    $logging->removeChild($logNode);
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RemoveTestSuiteLoaderAttributes implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $root = $document->documentElement;
        if ($root->hasAttribute('testSuiteLoaderClass')) {
            $root->removeAttribute('testSuiteLoaderClass');
        }
        if ($root->hasAttribute('testSuiteLoaderFile')) {
            $root->removeAttribute('testSuiteLoaderFile');
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RenameBackupStaticAttributesAttribute implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $root = $document->documentElement;
        if ($root->hasAttribute('backupStaticProperties')) {
            return;
        }
        if (!$root->hasAttribute('backupStaticAttributes')) {
            return;
        }
        $root->setAttribute('backupStaticProperties', $root->getAttribute('backupStaticAttributes'));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use DOMDocument;
use PHPUnit\Runner\Version;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class UpdateSchemaLocation implements \PHPUnit\TextUI\XmlConfiguration\Migration
{
    public function migrate(\DOMDocument $document) : void
    {
        $document->documentElement->setAttributeNS('http://www.w3.org/2001/XMLSchema-instance', 'xsi:noNamespaceSchemaLocation', 'https://schema.phpunit.de/' . \PHPUnit\Runner\Version::series() . '/phpunit.xsd');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function sprintf;
use PHPUnit\Util\Xml\Exception as XmlException;
use PHPUnit\Util\Xml\Loader as XmlLoader;
use PHPUnit\Util\Xml\SchemaDetector;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Migrator
{
    /**
     * @throws Exception
     * @throws MigrationBuilderException
     * @throws MigrationException
     * @throws XmlException
     */
    public function migrate(string $filename) : string
    {
        $origin = (new \PHPUnit\Util\Xml\SchemaDetector())->detect($filename);
        if (!$origin->detected()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception(\sprintf('"%s" is not a valid PHPUnit XML configuration file that can be migrated', $filename));
        }
        $configurationDocument = (new \PHPUnit\Util\Xml\Loader())->loadFile($filename, \false, \true, \true);
        foreach ((new \PHPUnit\TextUI\XmlConfiguration\MigrationBuilder())->build($origin->version()) as $migration) {
            $migration->migrate($configurationDocument);
        }
        $configurationDocument->formatOutput = \true;
        $configurationDocument->preserveWhiteSpace = \false;
        return $configurationDocument->saveXML();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Constant
{
    private string $name;
    /**
     * @var mixed
     */
    private $value;
    public function __construct(string $name, $value)
    {
        $this->name = $name;
        $this->value = $value;
    }
    public function name() : string
    {
        return $this->name;
    }
    public function value()
    {
        return $this->value;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class ConstantCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var Constant[]
     */
    private array $constants;
    /**
     * @param Constant[] $constants
     */
    public static function fromArray(array $constants) : self
    {
        return new self(...$constants);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\Constant ...$constants)
    {
        $this->constants = $constants;
    }
    /**
     * @return Constant[]
     */
    public function asArray() : array
    {
        return $this->constants;
    }
    public function count() : int
    {
        return \count($this->constants);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\ConstantCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\ConstantCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ConstantCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var Constant[]
     */
    private array $constants;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\ConstantCollection $constants)
    {
        $this->constants = $constants->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->constants);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\Constant
    {
        return $this->constants[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class IniSetting
{
    private string $name;
    private string $value;
    public function __construct(string $name, string $value)
    {
        $this->name = $name;
        $this->value = $value;
    }
    public function name() : string
    {
        return $this->name;
    }
    public function value() : string
    {
        return $this->value;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class IniSettingCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var IniSetting[]
     */
    private array $iniSettings;
    /**
     * @param IniSetting[] $iniSettings
     */
    public static function fromArray(array $iniSettings) : self
    {
        return new self(...$iniSettings);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\IniSetting ...$iniSettings)
    {
        $this->iniSettings = $iniSettings;
    }
    /**
     * @return IniSetting[]
     */
    public function asArray() : array
    {
        return $this->iniSettings;
    }
    public function count() : int
    {
        return \count($this->iniSettings);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\IniSettingCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\IniSettingCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class IniSettingCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var IniSetting[]
     */
    private array $iniSettings;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\IniSettingCollection $iniSettings)
    {
        $this->iniSettings = $iniSettings->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->iniSettings);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\IniSetting
    {
        return $this->iniSettings[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Php
{
    private \PHPUnit\TextUI\XmlConfiguration\DirectoryCollection $includePaths;
    private \PHPUnit\TextUI\XmlConfiguration\IniSettingCollection $iniSettings;
    private \PHPUnit\TextUI\XmlConfiguration\ConstantCollection $constants;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $globalVariables;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $envVariables;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $postVariables;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $getVariables;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $cookieVariables;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $serverVariables;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $filesVariables;
    private \PHPUnit\TextUI\XmlConfiguration\VariableCollection $requestVariables;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\DirectoryCollection $includePaths, \PHPUnit\TextUI\XmlConfiguration\IniSettingCollection $iniSettings, \PHPUnit\TextUI\XmlConfiguration\ConstantCollection $constants, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $globalVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $envVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $postVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $getVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $cookieVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $serverVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $filesVariables, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $requestVariables)
    {
        $this->includePaths = $includePaths;
        $this->iniSettings = $iniSettings;
        $this->constants = $constants;
        $this->globalVariables = $globalVariables;
        $this->envVariables = $envVariables;
        $this->postVariables = $postVariables;
        $this->getVariables = $getVariables;
        $this->cookieVariables = $cookieVariables;
        $this->serverVariables = $serverVariables;
        $this->filesVariables = $filesVariables;
        $this->requestVariables = $requestVariables;
    }
    public function includePaths() : \PHPUnit\TextUI\XmlConfiguration\DirectoryCollection
    {
        return $this->includePaths;
    }
    public function iniSettings() : \PHPUnit\TextUI\XmlConfiguration\IniSettingCollection
    {
        return $this->iniSettings;
    }
    public function constants() : \PHPUnit\TextUI\XmlConfiguration\ConstantCollection
    {
        return $this->constants;
    }
    public function globalVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->globalVariables;
    }
    public function envVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->envVariables;
    }
    public function postVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->postVariables;
    }
    public function getVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->getVariables;
    }
    public function cookieVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->cookieVariables;
    }
    public function serverVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->serverVariables;
    }
    public function filesVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->filesVariables;
    }
    public function requestVariables() : \PHPUnit\TextUI\XmlConfiguration\VariableCollection
    {
        return $this->requestVariables;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use const PATH_SEPARATOR;
use function constant;
use function define;
use function defined;
use function getenv;
use function implode;
use function ini_get;
use function ini_set;
use function putenv;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class PhpHandler
{
    public function handle(\PHPUnit\TextUI\XmlConfiguration\Php $configuration) : void
    {
        $this->handleIncludePaths($configuration->includePaths());
        $this->handleIniSettings($configuration->iniSettings());
        $this->handleConstants($configuration->constants());
        $this->handleGlobalVariables($configuration->globalVariables());
        $this->handleServerVariables($configuration->serverVariables());
        $this->handleEnvVariables($configuration->envVariables());
        $this->handleVariables('_POST', $configuration->postVariables());
        $this->handleVariables('_GET', $configuration->getVariables());
        $this->handleVariables('_COOKIE', $configuration->cookieVariables());
        $this->handleVariables('_FILES', $configuration->filesVariables());
        $this->handleVariables('_REQUEST', $configuration->requestVariables());
    }
    private function handleIncludePaths(\PHPUnit\TextUI\XmlConfiguration\DirectoryCollection $includePaths) : void
    {
        if (!$includePaths->isEmpty()) {
            $includePathsAsStrings = [];
            foreach ($includePaths as $includePath) {
                $includePathsAsStrings[] = $includePath->path();
            }
            \ini_set('include_path', \implode(\PATH_SEPARATOR, $includePathsAsStrings) . \PATH_SEPARATOR . \ini_get('include_path'));
        }
    }
    private function handleIniSettings(\PHPUnit\TextUI\XmlConfiguration\IniSettingCollection $iniSettings) : void
    {
        foreach ($iniSettings as $iniSetting) {
            $value = $iniSetting->value();
            if (\defined($value)) {
                $value = (string) \constant($value);
            }
            \ini_set($iniSetting->name(), $value);
        }
    }
    private function handleConstants(\PHPUnit\TextUI\XmlConfiguration\ConstantCollection $constants) : void
    {
        foreach ($constants as $constant) {
            if (!\defined($constant->name())) {
                \define($constant->name(), $constant->value());
            }
        }
    }
    private function handleGlobalVariables(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables) : void
    {
        foreach ($variables as $variable) {
            $GLOBALS[$variable->name()] = $variable->value();
        }
    }
    private function handleServerVariables(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables) : void
    {
        foreach ($variables as $variable) {
            $_SERVER[$variable->name()] = $variable->value();
        }
    }
    private function handleVariables(string $target, \PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables) : void
    {
        foreach ($variables as $variable) {
            $GLOBALS[$target][$variable->name()] = $variable->value();
        }
    }
    private function handleEnvVariables(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables) : void
    {
        foreach ($variables as $variable) {
            $name = $variable->name();
            $value = $variable->value();
            $force = $variable->force();
            if ($force || \getenv($name) === \false) {
                \putenv("{$name}={$value}");
            }
            $value = \getenv($name);
            if ($force || !isset($_ENV[$name])) {
                $_ENV[$name] = $value;
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Variable
{
    private string $name;
    /**
     * @var mixed
     */
    private $value;
    private bool $force;
    public function __construct(string $name, $value, bool $force)
    {
        $this->name = $name;
        $this->value = $value;
        $this->force = $force;
    }
    public function name() : string
    {
        return $this->name;
    }
    public function value()
    {
        return $this->value;
    }
    public function force() : bool
    {
        return $this->force;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class VariableCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var Variable[]
     */
    private array $variables;
    /**
     * @param Variable[] $variables
     */
    public static function fromArray(array $variables) : self
    {
        return new self(...$variables);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\Variable ...$variables)
    {
        $this->variables = $variables;
    }
    /**
     * @return Variable[]
     */
    public function asArray() : array
    {
        return $this->variables;
    }
    public function count() : int
    {
        return \count($this->variables);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\VariableCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\VariableCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class VariableCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var Variable[]
     */
    private array $variables;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\VariableCollection $variables)
    {
        $this->variables = $variables->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->variables);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\Variable
    {
        return $this->variables[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class Extension
{
    /**
     * @psalm-var class-string
     */
    private string $className;
    private string $sourceFile;
    private array $arguments;
    /**
     * @psalm-param class-string $className
     */
    public function __construct(string $className, string $sourceFile, array $arguments)
    {
        $this->className = $className;
        $this->sourceFile = $sourceFile;
        $this->arguments = $arguments;
    }
    /**
     * @psalm-return class-string
     */
    public function className() : string
    {
        return $this->className;
    }
    public function hasSourceFile() : bool
    {
        return $this->sourceFile !== '';
    }
    public function sourceFile() : string
    {
        return $this->sourceFile;
    }
    public function hasArguments() : bool
    {
        return !empty($this->arguments);
    }
    public function arguments() : array
    {
        return $this->arguments;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class ExtensionCollection implements \IteratorAggregate
{
    /**
     * @var Extension[]
     */
    private array $extensions;
    /**
     * @param Extension[] $extensions
     */
    public static function fromArray(array $extensions) : self
    {
        return new self(...$extensions);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\Extension ...$extensions)
    {
        $this->extensions = $extensions;
    }
    /**
     * @return Extension[]
     */
    public function asArray() : array
    {
        return $this->extensions;
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\ExtensionCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\ExtensionCollectionIterator($this);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class ExtensionCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var Extension[]
     */
    private array $extensions;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\ExtensionCollection $extensions)
    {
        $this->extensions = $extensions->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->extensions);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\Extension
    {
        return $this->extensions[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class PHPUnit
{
    private ?string $cacheDirectory = null;
    private bool $cacheResult;
    private ?string $cacheResultFile = null;
    /**
     * @var int|string
     */
    private $columns;
    private string $colors;
    private bool $stderr;
    private bool $noInteraction;
    private bool $verbose;
    private bool $reverseDefectList;
    private bool $convertDeprecationsToExceptions;
    private bool $convertErrorsToExceptions;
    private bool $convertNoticesToExceptions;
    private bool $convertWarningsToExceptions;
    private bool $forceCoversAnnotation;
    private ?string $bootstrap = null;
    private bool $processIsolation;
    private bool $failOnEmptyTestSuite;
    private bool $failOnIncomplete;
    private bool $failOnRisky;
    private bool $failOnSkipped;
    private bool $failOnWarning;
    private bool $stopOnDefect;
    private bool $stopOnError;
    private bool $stopOnFailure;
    private bool $stopOnWarning;
    private bool $stopOnIncomplete;
    private bool $stopOnRisky;
    private bool $stopOnSkipped;
    private ?string $extensionsDirectory = null;
    private ?string $printerClass = null;
    private ?string $printerFile = null;
    private bool $beStrictAboutChangesToGlobalState;
    private bool $beStrictAboutOutputDuringTests;
    private bool $beStrictAboutResourceUsageDuringSmallTests;
    private bool $beStrictAboutTestsThatDoNotTestAnything;
    private bool $beStrictAboutTodoAnnotatedTests;
    private bool $beStrictAboutCoversAnnotation;
    private bool $enforceTimeLimit;
    private int $defaultTimeLimit;
    private int $timeoutForSmallTests;
    private int $timeoutForMediumTests;
    private int $timeoutForLargeTests;
    private ?string $defaultTestSuite = null;
    private int $executionOrder;
    private bool $resolveDependencies;
    private bool $defectsFirst;
    private bool $backupGlobals;
    private bool $backupStaticProperties;
    private bool $registerMockObjectsFromTestArgumentsRecursively;
    private bool $conflictBetweenPrinterClassAndTestdox;
    public function __construct(?string $cacheDirectory, bool $cacheResult, ?string $cacheResultFile, $columns, string $colors, bool $stderr, bool $noInteraction, bool $verbose, bool $reverseDefectList, bool $convertDeprecationsToExceptions, bool $convertErrorsToExceptions, bool $convertNoticesToExceptions, bool $convertWarningsToExceptions, bool $forceCoversAnnotation, ?string $bootstrap, bool $processIsolation, bool $failOnEmptyTestSuite, bool $failOnIncomplete, bool $failOnRisky, bool $failOnSkipped, bool $failOnWarning, bool $stopOnDefect, bool $stopOnError, bool $stopOnFailure, bool $stopOnWarning, bool $stopOnIncomplete, bool $stopOnRisky, bool $stopOnSkipped, ?string $extensionsDirectory, ?string $printerClass, ?string $printerFile, bool $beStrictAboutChangesToGlobalState, bool $beStrictAboutOutputDuringTests, bool $beStrictAboutResourceUsageDuringSmallTests, bool $beStrictAboutTestsThatDoNotTestAnything, bool $beStrictAboutTodoAnnotatedTests, bool $beStrictAboutCoversAnnotation, bool $enforceTimeLimit, int $defaultTimeLimit, int $timeoutForSmallTests, int $timeoutForMediumTests, int $timeoutForLargeTests, ?string $defaultTestSuite, int $executionOrder, bool $resolveDependencies, bool $defectsFirst, bool $backupGlobals, bool $backupStaticProperties, bool $registerMockObjectsFromTestArgumentsRecursively, bool $conflictBetweenPrinterClassAndTestdox)
    {
        $this->cacheDirectory = $cacheDirectory;
        $this->cacheResult = $cacheResult;
        $this->cacheResultFile = $cacheResultFile;
        $this->columns = $columns;
        $this->colors = $colors;
        $this->stderr = $stderr;
        $this->noInteraction = $noInteraction;
        $this->verbose = $verbose;
        $this->reverseDefectList = $reverseDefectList;
        $this->convertDeprecationsToExceptions = $convertDeprecationsToExceptions;
        $this->convertErrorsToExceptions = $convertErrorsToExceptions;
        $this->convertNoticesToExceptions = $convertNoticesToExceptions;
        $this->convertWarningsToExceptions = $convertWarningsToExceptions;
        $this->forceCoversAnnotation = $forceCoversAnnotation;
        $this->bootstrap = $bootstrap;
        $this->processIsolation = $processIsolation;
        $this->failOnEmptyTestSuite = $failOnEmptyTestSuite;
        $this->failOnIncomplete = $failOnIncomplete;
        $this->failOnRisky = $failOnRisky;
        $this->failOnSkipped = $failOnSkipped;
        $this->failOnWarning = $failOnWarning;
        $this->stopOnDefect = $stopOnDefect;
        $this->stopOnError = $stopOnError;
        $this->stopOnFailure = $stopOnFailure;
        $this->stopOnWarning = $stopOnWarning;
        $this->stopOnIncomplete = $stopOnIncomplete;
        $this->stopOnRisky = $stopOnRisky;
        $this->stopOnSkipped = $stopOnSkipped;
        $this->extensionsDirectory = $extensionsDirectory;
        $this->printerClass = $printerClass;
        $this->printerFile = $printerFile;
        $this->beStrictAboutChangesToGlobalState = $beStrictAboutChangesToGlobalState;
        $this->beStrictAboutOutputDuringTests = $beStrictAboutOutputDuringTests;
        $this->beStrictAboutResourceUsageDuringSmallTests = $beStrictAboutResourceUsageDuringSmallTests;
        $this->beStrictAboutTestsThatDoNotTestAnything = $beStrictAboutTestsThatDoNotTestAnything;
        $this->beStrictAboutTodoAnnotatedTests = $beStrictAboutTodoAnnotatedTests;
        $this->beStrictAboutCoversAnnotation = $beStrictAboutCoversAnnotation;
        $this->enforceTimeLimit = $enforceTimeLimit;
        $this->defaultTimeLimit = $defaultTimeLimit;
        $this->timeoutForSmallTests = $timeoutForSmallTests;
        $this->timeoutForMediumTests = $timeoutForMediumTests;
        $this->timeoutForLargeTests = $timeoutForLargeTests;
        $this->defaultTestSuite = $defaultTestSuite;
        $this->executionOrder = $executionOrder;
        $this->resolveDependencies = $resolveDependencies;
        $this->defectsFirst = $defectsFirst;
        $this->backupGlobals = $backupGlobals;
        $this->backupStaticProperties = $backupStaticProperties;
        $this->registerMockObjectsFromTestArgumentsRecursively = $registerMockObjectsFromTestArgumentsRecursively;
        $this->conflictBetweenPrinterClassAndTestdox = $conflictBetweenPrinterClassAndTestdox;
    }
    /**
     * @psalm-assert-if-true !null $this->cacheDirectory
     */
    public function hasCacheDirectory() : bool
    {
        return $this->cacheDirectory !== null;
    }
    /**
     * @throws Exception
     */
    public function cacheDirectory() : string
    {
        if (!$this->hasCacheDirectory()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Cache directory is not configured');
        }
        return $this->cacheDirectory;
    }
    public function cacheResult() : bool
    {
        return $this->cacheResult;
    }
    /**
     * @psalm-assert-if-true !null $this->cacheResultFile
     *
     * @deprecated
     */
    public function hasCacheResultFile() : bool
    {
        return $this->cacheResultFile !== null;
    }
    /**
     * @throws Exception
     *
     * @deprecated
     */
    public function cacheResultFile() : string
    {
        if (!$this->hasCacheResultFile()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Cache result file is not configured');
        }
        return $this->cacheResultFile;
    }
    public function columns()
    {
        return $this->columns;
    }
    public function colors() : string
    {
        return $this->colors;
    }
    public function stderr() : bool
    {
        return $this->stderr;
    }
    public function noInteraction() : bool
    {
        return $this->noInteraction;
    }
    public function verbose() : bool
    {
        return $this->verbose;
    }
    public function reverseDefectList() : bool
    {
        return $this->reverseDefectList;
    }
    public function convertDeprecationsToExceptions() : bool
    {
        return $this->convertDeprecationsToExceptions;
    }
    public function convertErrorsToExceptions() : bool
    {
        return $this->convertErrorsToExceptions;
    }
    public function convertNoticesToExceptions() : bool
    {
        return $this->convertNoticesToExceptions;
    }
    public function convertWarningsToExceptions() : bool
    {
        return $this->convertWarningsToExceptions;
    }
    public function forceCoversAnnotation() : bool
    {
        return $this->forceCoversAnnotation;
    }
    /**
     * @psalm-assert-if-true !null $this->bootstrap
     */
    public function hasBootstrap() : bool
    {
        return $this->bootstrap !== null;
    }
    /**
     * @throws Exception
     */
    public function bootstrap() : string
    {
        if (!$this->hasBootstrap()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Bootstrap script is not configured');
        }
        return $this->bootstrap;
    }
    public function processIsolation() : bool
    {
        return $this->processIsolation;
    }
    public function failOnEmptyTestSuite() : bool
    {
        return $this->failOnEmptyTestSuite;
    }
    public function failOnIncomplete() : bool
    {
        return $this->failOnIncomplete;
    }
    public function failOnRisky() : bool
    {
        return $this->failOnRisky;
    }
    public function failOnSkipped() : bool
    {
        return $this->failOnSkipped;
    }
    public function failOnWarning() : bool
    {
        return $this->failOnWarning;
    }
    public function stopOnDefect() : bool
    {
        return $this->stopOnDefect;
    }
    public function stopOnError() : bool
    {
        return $this->stopOnError;
    }
    public function stopOnFailure() : bool
    {
        return $this->stopOnFailure;
    }
    public function stopOnWarning() : bool
    {
        return $this->stopOnWarning;
    }
    public function stopOnIncomplete() : bool
    {
        return $this->stopOnIncomplete;
    }
    public function stopOnRisky() : bool
    {
        return $this->stopOnRisky;
    }
    public function stopOnSkipped() : bool
    {
        return $this->stopOnSkipped;
    }
    /**
     * @psalm-assert-if-true !null $this->extensionsDirectory
     */
    public function hasExtensionsDirectory() : bool
    {
        return $this->extensionsDirectory !== null;
    }
    /**
     * @throws Exception
     */
    public function extensionsDirectory() : string
    {
        if (!$this->hasExtensionsDirectory()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Extensions directory is not configured');
        }
        return $this->extensionsDirectory;
    }
    /**
     * @psalm-assert-if-true !null $this->printerClass
     */
    public function hasPrinterClass() : bool
    {
        return $this->printerClass !== null;
    }
    /**
     * @throws Exception
     */
    public function printerClass() : string
    {
        if (!$this->hasPrinterClass()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('ResultPrinter class is not configured');
        }
        return $this->printerClass;
    }
    /**
     * @psalm-assert-if-true !null $this->printerFile
     */
    public function hasPrinterFile() : bool
    {
        return $this->printerFile !== null;
    }
    /**
     * @throws Exception
     */
    public function printerFile() : string
    {
        if (!$this->hasPrinterFile()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('ResultPrinter sourcecode file is not configured');
        }
        return $this->printerFile;
    }
    public function beStrictAboutChangesToGlobalState() : bool
    {
        return $this->beStrictAboutChangesToGlobalState;
    }
    public function beStrictAboutOutputDuringTests() : bool
    {
        return $this->beStrictAboutOutputDuringTests;
    }
    public function beStrictAboutResourceUsageDuringSmallTests() : bool
    {
        return $this->beStrictAboutResourceUsageDuringSmallTests;
    }
    public function beStrictAboutTestsThatDoNotTestAnything() : bool
    {
        return $this->beStrictAboutTestsThatDoNotTestAnything;
    }
    public function beStrictAboutTodoAnnotatedTests() : bool
    {
        return $this->beStrictAboutTodoAnnotatedTests;
    }
    public function beStrictAboutCoversAnnotation() : bool
    {
        return $this->beStrictAboutCoversAnnotation;
    }
    public function enforceTimeLimit() : bool
    {
        return $this->enforceTimeLimit;
    }
    public function defaultTimeLimit() : int
    {
        return $this->defaultTimeLimit;
    }
    public function timeoutForSmallTests() : int
    {
        return $this->timeoutForSmallTests;
    }
    public function timeoutForMediumTests() : int
    {
        return $this->timeoutForMediumTests;
    }
    public function timeoutForLargeTests() : int
    {
        return $this->timeoutForLargeTests;
    }
    /**
     * @psalm-assert-if-true !null $this->defaultTestSuite
     */
    public function hasDefaultTestSuite() : bool
    {
        return $this->defaultTestSuite !== null;
    }
    /**
     * @throws Exception
     */
    public function defaultTestSuite() : string
    {
        if (!$this->hasDefaultTestSuite()) {
            throw new \PHPUnit\TextUI\XmlConfiguration\Exception('Default test suite is not configured');
        }
        return $this->defaultTestSuite;
    }
    public function executionOrder() : int
    {
        return $this->executionOrder;
    }
    public function resolveDependencies() : bool
    {
        return $this->resolveDependencies;
    }
    public function defectsFirst() : bool
    {
        return $this->defectsFirst;
    }
    public function backupGlobals() : bool
    {
        return $this->backupGlobals;
    }
    public function backupStaticProperties() : bool
    {
        return $this->backupStaticProperties;
    }
    public function registerMockObjectsFromTestArgumentsRecursively() : bool
    {
        return $this->registerMockObjectsFromTestArgumentsRecursively;
    }
    public function conflictBetweenPrinterClassAndTestdox() : bool
    {
        return $this->conflictBetweenPrinterClassAndTestdox;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use PHPUnit\Util\VersionComparisonOperator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestDirectory
{
    private string $path;
    private string $prefix;
    private string $suffix;
    private string $phpVersion;
    private \PHPUnit\Util\VersionComparisonOperator $phpVersionOperator;
    public function __construct(string $path, string $prefix, string $suffix, string $phpVersion, \PHPUnit\Util\VersionComparisonOperator $phpVersionOperator)
    {
        $this->path = $path;
        $this->prefix = $prefix;
        $this->suffix = $suffix;
        $this->phpVersion = $phpVersion;
        $this->phpVersionOperator = $phpVersionOperator;
    }
    public function path() : string
    {
        return $this->path;
    }
    public function prefix() : string
    {
        return $this->prefix;
    }
    public function suffix() : string
    {
        return $this->suffix;
    }
    public function phpVersion() : string
    {
        return $this->phpVersion;
    }
    public function phpVersionOperator() : \PHPUnit\Util\VersionComparisonOperator
    {
        return $this->phpVersionOperator;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestDirectoryCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var TestDirectory[]
     */
    private array $directories;
    /**
     * @param TestDirectory[] $directories
     */
    public static function fromArray(array $directories) : self
    {
        return new self(...$directories);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\TestDirectory ...$directories)
    {
        $this->directories = $directories;
    }
    /**
     * @return TestDirectory[]
     */
    public function asArray() : array
    {
        return $this->directories;
    }
    public function count() : int
    {
        return \count($this->directories);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollectionIterator($this);
    }
    public function isEmpty() : bool
    {
        return $this->count() === 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestDirectoryCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var TestDirectory[]
     */
    private array $directories;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection $directories)
    {
        $this->directories = $directories->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->directories);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\TestDirectory
    {
        return $this->directories[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use PHPUnit\Util\VersionComparisonOperator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestFile
{
    private string $path;
    private string $phpVersion;
    private \PHPUnit\Util\VersionComparisonOperator $phpVersionOperator;
    public function __construct(string $path, string $phpVersion, \PHPUnit\Util\VersionComparisonOperator $phpVersionOperator)
    {
        $this->path = $path;
        $this->phpVersion = $phpVersion;
        $this->phpVersionOperator = $phpVersionOperator;
    }
    public function path() : string
    {
        return $this->path;
    }
    public function phpVersion() : string
    {
        return $this->phpVersion;
    }
    public function phpVersionOperator() : \PHPUnit\Util\VersionComparisonOperator
    {
        return $this->phpVersionOperator;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestFileCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var TestFile[]
     */
    private array $files;
    /**
     * @param TestFile[] $files
     */
    public static function fromArray(array $files) : self
    {
        return new self(...$files);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\TestFile ...$files)
    {
        $this->files = $files;
    }
    /**
     * @return TestFile[]
     */
    public function asArray() : array
    {
        return $this->files;
    }
    public function count() : int
    {
        return \count($this->files);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\TestFileCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\TestFileCollectionIterator($this);
    }
    public function isEmpty() : bool
    {
        return $this->count() === 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestFileCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var TestFile[]
     */
    private array $files;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\TestFileCollection $files)
    {
        $this->files = $files->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->files);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\TestFile
    {
        return $this->files[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestSuite
{
    private string $name;
    private \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection $directories;
    private \PHPUnit\TextUI\XmlConfiguration\TestFileCollection $files;
    private \PHPUnit\TextUI\XmlConfiguration\FileCollection $exclude;
    public function __construct(string $name, \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection $directories, \PHPUnit\TextUI\XmlConfiguration\TestFileCollection $files, \PHPUnit\TextUI\XmlConfiguration\FileCollection $exclude)
    {
        $this->name = $name;
        $this->directories = $directories;
        $this->files = $files;
        $this->exclude = $exclude;
    }
    public function name() : string
    {
        return $this->name;
    }
    public function directories() : \PHPUnit\TextUI\XmlConfiguration\TestDirectoryCollection
    {
        return $this->directories;
    }
    public function files() : \PHPUnit\TextUI\XmlConfiguration\TestFileCollection
    {
        return $this->files;
    }
    public function exclude() : \PHPUnit\TextUI\XmlConfiguration\FileCollection
    {
        return $this->exclude;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class TestSuiteCollection implements \Countable, \IteratorAggregate
{
    /**
     * @var TestSuite[]
     */
    private array $testSuites;
    /**
     * @param TestSuite[] $testSuites
     */
    public static function fromArray(array $testSuites) : self
    {
        return new self(...$testSuites);
    }
    private function __construct(\PHPUnit\TextUI\XmlConfiguration\TestSuite ...$testSuites)
    {
        $this->testSuites = $testSuites;
    }
    /**
     * @return TestSuite[]
     */
    public function asArray() : array
    {
        return $this->testSuites;
    }
    public function count() : int
    {
        return \count($this->testSuites);
    }
    public function getIterator() : \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollectionIterator
    {
        return new \PHPUnit\TextUI\XmlConfiguration\TestSuiteCollectionIterator($this);
    }
    public function isEmpty() : bool
    {
        return $this->count() === 0;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\TextUI\XmlConfiguration;

use function count;
use function iterator_count;
use Countable;
use Iterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TestSuiteCollectionIterator implements \Countable, \Iterator
{
    /**
     * @var TestSuite[]
     */
    private array $testSuites;
    private ?int $position = null;
    public function __construct(\PHPUnit\TextUI\XmlConfiguration\TestSuiteCollection $testSuites)
    {
        $this->testSuites = $testSuites->asArray();
    }
    public function count() : int
    {
        return \iterator_count($this);
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return $this->position < \count($this->testSuites);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\TextUI\XmlConfiguration\TestSuite
    {
        return $this->testSuites[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use const DIRECTORY_SEPARATOR;
use function array_keys;
use function array_map;
use function array_values;
use function count;
use function explode;
use function implode;
use function min;
use function preg_replace;
use function preg_replace_callback;
use function sprintf;
use function strtr;
use function trim;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Color
{
    /**
     * @var array<string,string>
     */
    private const WHITESPACE_MAP = [' ' => '', "\t" => ''];
    /**
     * @var array<string,string>
     */
    private const WHITESPACE_EOL_MAP = [' ' => '', "\t" => '', "\n" => '', "\r" => ''];
    /**
     * @var array<string,string>
     */
    private static array $ansiCodes = ['reset' => '0', 'bold' => '1', 'dim' => '2', 'dim-reset' => '22', 'underlined' => '4', 'fg-default' => '39', 'fg-black' => '30', 'fg-red' => '31', 'fg-green' => '32', 'fg-yellow' => '33', 'fg-blue' => '34', 'fg-magenta' => '35', 'fg-cyan' => '36', 'fg-white' => '37', 'bg-default' => '49', 'bg-black' => '40', 'bg-red' => '41', 'bg-green' => '42', 'bg-yellow' => '43', 'bg-blue' => '44', 'bg-magenta' => '45', 'bg-cyan' => '46', 'bg-white' => '47'];
    public static function colorize(string $color, string $buffer) : string
    {
        if (\trim($buffer) === '') {
            return $buffer;
        }
        $codes = \array_map('\\trim', \explode(',', $color));
        $styles = [];
        foreach ($codes as $code) {
            if (isset(self::$ansiCodes[$code])) {
                $styles[] = self::$ansiCodes[$code] ?? '';
            }
        }
        if (empty($styles)) {
            return $buffer;
        }
        return self::optimizeColor(\sprintf("\33[%sm", \implode(';', $styles)) . $buffer . "\33[0m");
    }
    public static function colorizePath(string $path, ?string $prevPath = null, bool $colorizeFilename = \false) : string
    {
        if ($prevPath === null) {
            $prevPath = '';
        }
        $path = \explode(\DIRECTORY_SEPARATOR, $path);
        $prevPath = \explode(\DIRECTORY_SEPARATOR, $prevPath);
        for ($i = 0; $i < \min(\count($path), \count($prevPath)); $i++) {
            if ($path[$i] == $prevPath[$i]) {
                $path[$i] = self::dim($path[$i]);
            }
        }
        if ($colorizeFilename) {
            $last = \count($path) - 1;
            $path[$last] = \preg_replace_callback('/([\\-_\\.]+|phpt$)/', static function ($matches) {
                return self::dim($matches[0]);
            }, $path[$last]);
        }
        return self::optimizeColor(\implode(self::dim(\DIRECTORY_SEPARATOR), $path));
    }
    public static function dim(string $buffer) : string
    {
        if (\trim($buffer) === '') {
            return $buffer;
        }
        return "\33[2m{$buffer}\33[22m";
    }
    public static function visualizeWhitespace(string $buffer, bool $visualizeEOL = \false) : string
    {
        $replaceMap = $visualizeEOL ? self::WHITESPACE_EOL_MAP : self::WHITESPACE_MAP;
        return \preg_replace_callback('/\\s+/', static function ($matches) use($replaceMap) {
            return self::dim(\strtr($matches[0], $replaceMap));
        }, $buffer);
    }
    private static function optimizeColor(string $buffer) : string
    {
        $patterns = ["/\33\\[22m\33\\[2m/" => '', "/\33\\[([^m]*)m\33\\[([1-9][0-9;]*)m/" => "\33[\$1;\$2m", "/(\33\\[[^m]*m)+(\33\\[0m)/" => '$2'];
        return \preg_replace(\array_keys($patterns), \array_values($patterns), $buffer);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Error;

/**
 * @internal
 */
final class Deprecation extends \PHPUnit\Util\Error\Error
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Error;

use PHPUnit\Framework\Exception;
/**
 * @internal
 */
class Error extends \PHPUnit\Framework\Exception
{
    public function __construct(string $message, int $code, string $file, int $line, \Exception $previous = null)
    {
        parent::__construct($message, $code, $previous);
        $this->file = $file;
        $this->line = $line;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Error;

use const E_DEPRECATED;
use const E_NOTICE;
use const E_STRICT;
use const E_USER_DEPRECATED;
use const E_USER_NOTICE;
use const E_USER_WARNING;
use const E_WARNING;
use function error_reporting;
use function restore_error_handler;
use function set_error_handler;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Handler
{
    private bool $convertDeprecationsToExceptions;
    private bool $convertErrorsToExceptions;
    private bool $convertNoticesToExceptions;
    private bool $convertWarningsToExceptions;
    private bool $registered = \false;
    public static function invokeIgnoringWarnings(callable $callable)
    {
        \set_error_handler(static function ($errorNumber, $errorString) {
            if ($errorNumber === \E_WARNING) {
                return;
            }
            return \false;
        });
        $result = $callable();
        \restore_error_handler();
        return $result;
    }
    public function __construct(bool $convertDeprecationsToExceptions, bool $convertErrorsToExceptions, bool $convertNoticesToExceptions, bool $convertWarningsToExceptions)
    {
        $this->convertDeprecationsToExceptions = $convertDeprecationsToExceptions;
        $this->convertErrorsToExceptions = $convertErrorsToExceptions;
        $this->convertNoticesToExceptions = $convertNoticesToExceptions;
        $this->convertWarningsToExceptions = $convertWarningsToExceptions;
    }
    public function __invoke(int $errorNumber, string $errorString, string $errorFile, int $errorLine) : bool
    {
        /*
         * Do not raise an exception when the error suppression operator (@) was used.
         *
         * @see https://github.com/sebastianbergmann/phpunit/issues/3739
         */
        if (!($errorNumber & \error_reporting())) {
            return \false;
        }
        switch ($errorNumber) {
            case \E_NOTICE:
            case \E_USER_NOTICE:
            case \E_STRICT:
                if (!$this->convertNoticesToExceptions) {
                    return \false;
                }
                throw new \PHPUnit\Util\Error\Notice($errorString, $errorNumber, $errorFile, $errorLine);
            case \E_WARNING:
            case \E_USER_WARNING:
                if (!$this->convertWarningsToExceptions) {
                    return \false;
                }
                throw new \PHPUnit\Util\Error\Warning($errorString, $errorNumber, $errorFile, $errorLine);
            case \E_DEPRECATED:
            case \E_USER_DEPRECATED:
                if (!$this->convertDeprecationsToExceptions) {
                    return \false;
                }
                throw new \PHPUnit\Util\Error\Deprecation($errorString, $errorNumber, $errorFile, $errorLine);
            default:
                if (!$this->convertErrorsToExceptions) {
                    return \false;
                }
                throw new \PHPUnit\Util\Error\Error($errorString, $errorNumber, $errorFile, $errorLine);
        }
    }
    public function register() : void
    {
        if ($this->registered) {
            return;
        }
        $oldErrorHandler = \set_error_handler($this);
        if ($oldErrorHandler !== null) {
            \restore_error_handler();
            return;
        }
        $this->registered = \true;
    }
    public function unregister() : void
    {
        if (!$this->registered) {
            return;
        }
        \restore_error_handler();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Error;

/**
 * @internal
 */
final class Notice extends \PHPUnit\Util\Error\Error
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Error;

/**
 * @internal
 */
final class Warning extends \PHPUnit\Util\Error\Error
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Exception extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use const DIRECTORY_SEPARATOR;
use function class_exists;
use function defined;
use function dirname;
use function is_dir;
use function realpath;
use function sprintf;
use function strpos;
use function sys_get_temp_dir;
use PHPUnit\Composer\Autoload\ClassLoader;
use PHPUnit\DeepCopy\DeepCopy;
use PHPUnit\Doctrine\Instantiator\Instantiator;
use PHPUnit\PharIo\Manifest\Manifest;
use PHPUnit\PharIo\Version\Version as PharIoVersion;
use PHPUnit\PhpParser\Parser;
use PHPUnit\Framework\TestCase;
use ReflectionClass;
use ReflectionException;
use PHPUnit\SebastianBergmann\CliParser\Parser as CliParser;
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeUnit\CodeUnit;
use PHPUnit\SebastianBergmann\CodeUnitReverseLookup\Wizard;
use PHPUnit\SebastianBergmann\Comparator\Comparator;
use PHPUnit\SebastianBergmann\Complexity\Calculator;
use PHPUnit\SebastianBergmann\Diff\Diff;
use PHPUnit\SebastianBergmann\Environment\Runtime;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
use PHPUnit\SebastianBergmann\FileIterator\Facade as FileIteratorFacade;
use PHPUnit\SebastianBergmann\GlobalState\Snapshot;
use PHPUnit\SebastianBergmann\Invoker\Invoker;
use PHPUnit\SebastianBergmann\LinesOfCode\Counter;
use PHPUnit\SebastianBergmann\ObjectEnumerator\Enumerator;
use PHPUnit\SebastianBergmann\RecursionContext\Context;
use PHPUnit\SebastianBergmann\ResourceOperations\ResourceOperations;
use PHPUnit\SebastianBergmann\Template\Template;
use PHPUnit\SebastianBergmann\Timer\Timer;
use PHPUnit\SebastianBergmann\Type\TypeName;
use PHPUnit\SebastianBergmann\Version;
use PHPUnit\TheSeer\Tokenizer\Tokenizer;
/**
 * @no-named-arguments Parameter names are not covered by the backward compatibility promise for PHPUnit
 */
final class ExcludeList
{
    /**
     * @var array<string,int>
     */
    private const EXCLUDED_CLASS_NAMES = [
        // composer
        \PHPUnit\Composer\Autoload\ClassLoader::class => 1,
        // doctrine/instantiator
        \PHPUnit\Doctrine\Instantiator\Instantiator::class => 1,
        // myclabs/deepcopy
        \PHPUnit\DeepCopy\DeepCopy::class => 1,
        // nikic/php-parser
        \PHPUnit\PhpParser\Parser::class => 1,
        // phar-io/manifest
        \PHPUnit\PharIo\Manifest\Manifest::class => 1,
        // phar-io/version
        \PHPUnit\PharIo\Version\Version::class => 1,
        // phpunit/phpunit
        \PHPUnit\Framework\TestCase::class => 2,
        // phpunit/php-code-coverage
        \PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage::class => 1,
        // phpunit/php-file-iterator
        \PHPUnit\SebastianBergmann\FileIterator\Facade::class => 1,
        // phpunit/php-invoker
        \PHPUnit\SebastianBergmann\Invoker\Invoker::class => 1,
        // phpunit/php-text-template
        \PHPUnit\SebastianBergmann\Template\Template::class => 1,
        // phpunit/php-timer
        \PHPUnit\SebastianBergmann\Timer\Timer::class => 1,
        // sebastian/cli-parser
        \PHPUnit\SebastianBergmann\CliParser\Parser::class => 1,
        // sebastian/code-unit
        \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::class => 1,
        // sebastian/code-unit-reverse-lookup
        \PHPUnit\SebastianBergmann\CodeUnitReverseLookup\Wizard::class => 1,
        // sebastian/comparator
        \PHPUnit\SebastianBergmann\Comparator\Comparator::class => 1,
        // sebastian/complexity
        \PHPUnit\SebastianBergmann\Complexity\Calculator::class => 1,
        // sebastian/diff
        \PHPUnit\SebastianBergmann\Diff\Diff::class => 1,
        // sebastian/environment
        \PHPUnit\SebastianBergmann\Environment\Runtime::class => 1,
        // sebastian/exporter
        \PHPUnit\SebastianBergmann\Exporter\Exporter::class => 1,
        // sebastian/global-state
        \PHPUnit\SebastianBergmann\GlobalState\Snapshot::class => 1,
        // sebastian/lines-of-code
        \PHPUnit\SebastianBergmann\LinesOfCode\Counter::class => 1,
        // sebastian/object-enumerator
        \PHPUnit\SebastianBergmann\ObjectEnumerator\Enumerator::class => 1,
        // sebastian/recursion-context
        \PHPUnit\SebastianBergmann\RecursionContext\Context::class => 1,
        // sebastian/resource-operations
        \PHPUnit\SebastianBergmann\ResourceOperations\ResourceOperations::class => 1,
        // sebastian/type
        \PHPUnit\SebastianBergmann\Type\TypeName::class => 1,
        // sebastian/version
        \PHPUnit\SebastianBergmann\Version::class => 1,
        // theseer/tokenizer
        \PHPUnit\TheSeer\Tokenizer\Tokenizer::class => 1,
    ];
    /**
     * @var string[]
     */
    private static ?array $directories = null;
    public static function addDirectory(string $directory) : void
    {
        if (!\is_dir($directory)) {
            throw new \PHPUnit\Util\Exception(\sprintf('"%s" is not a directory', $directory));
        }
        self::$directories[] = \realpath($directory);
    }
    /**
     * @throws Exception
     *
     * @return string[]
     */
    public function getExcludedDirectories() : array
    {
        $this->initialize();
        return self::$directories;
    }
    /**
     * @throws Exception
     */
    public function isExcluded(string $file) : bool
    {
        if (\defined('PHPUNIT_TESTSUITE')) {
            return \false;
        }
        $this->initialize();
        foreach (self::$directories as $directory) {
            if (\strpos($file, $directory) === 0) {
                return \true;
            }
        }
        return \false;
    }
    /**
     * @throws Exception
     */
    private function initialize() : void
    {
        if (self::$directories === null) {
            self::$directories = [];
            foreach (self::EXCLUDED_CLASS_NAMES as $className => $parent) {
                if (!\class_exists($className)) {
                    continue;
                }
                try {
                    $directory = (new \ReflectionClass($className))->getFileName();
                    // @codeCoverageIgnoreStart
                } catch (\ReflectionException $e) {
                    throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
                }
                // @codeCoverageIgnoreEnd
                for ($i = 0; $i < $parent; $i++) {
                    $directory = \dirname($directory);
                }
                self::$directories[] = $directory;
            }
            // Hide process isolation workaround on Windows.
            if (\DIRECTORY_SEPARATOR === '\\') {
                // tempnam() prefix is limited to first 3 chars.
                // @see https://php.net/manual/en/function.tempnam.php
                self::$directories[] = \sys_get_temp_dir() . '\\PHP';
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use const DIRECTORY_SEPARATOR;
use function is_dir;
use function mkdir;
use function str_replace;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Filesystem
{
    /**
     * Maps class names to source file names.
     *
     *   - PEAR CS:   Foo_Bar_Baz -> Foo/Bar/Baz.php
     *   - Namespace: Foo\Bar\Baz -> Foo/Bar/Baz.php
     */
    public static function classNameToFilename(string $className) : string
    {
        return \str_replace(['_', '\\'], \DIRECTORY_SEPARATOR, $className) . '.php';
    }
    public static function createDirectory(string $directory) : bool
    {
        return !(!\is_dir($directory) && !@\mkdir($directory, 0777, \true) && !\is_dir($directory));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use function array_unshift;
use function defined;
use function in_array;
use function is_file;
use function realpath;
use function sprintf;
use function strpos;
use PHPUnit\Framework\Exception;
use PHPUnit\Framework\SyntheticError;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Filter
{
    /**
     * @throws Exception
     */
    public static function getFilteredStacktrace(\Throwable $t) : string
    {
        $filteredStacktrace = '';
        if ($t instanceof \PHPUnit\Framework\SyntheticError) {
            $eTrace = $t->getSyntheticTrace();
            $eFile = $t->getSyntheticFile();
            $eLine = $t->getSyntheticLine();
        } elseif ($t instanceof \PHPUnit\Framework\Exception) {
            $eTrace = $t->getSerializableTrace();
            $eFile = $t->getFile();
            $eLine = $t->getLine();
        } else {
            if ($t->getPrevious()) {
                $t = $t->getPrevious();
            }
            $eTrace = $t->getTrace();
            $eFile = $t->getFile();
            $eLine = $t->getLine();
        }
        if (!self::frameExists($eTrace, $eFile, $eLine)) {
            \array_unshift($eTrace, ['file' => $eFile, 'line' => $eLine]);
        }
        $prefix = \defined('__PHPUNIT_PHAR_ROOT__') ? __PHPUNIT_PHAR_ROOT__ : \false;
        $excludeList = new \PHPUnit\Util\ExcludeList();
        foreach ($eTrace as $frame) {
            if (self::shouldPrintFrame($frame, $prefix, $excludeList)) {
                $filteredStacktrace .= \sprintf("%s:%s\n", $frame['file'], $frame['line'] ?? '?');
            }
        }
        return $filteredStacktrace;
    }
    private static function shouldPrintFrame(array $frame, $prefix, \PHPUnit\Util\ExcludeList $excludeList) : bool
    {
        if (!isset($frame['file'])) {
            return \false;
        }
        $file = $frame['file'];
        $fileIsNotPrefixed = $prefix === \false || \strpos($file, $prefix) !== 0;
        // @see https://github.com/sebastianbergmann/phpunit/issues/4033
        if (isset($GLOBALS['_SERVER']['SCRIPT_NAME'])) {
            $script = \realpath($GLOBALS['_SERVER']['SCRIPT_NAME']);
        } else {
            $script = '';
        }
        return \is_file($file) && self::fileIsExcluded($file, $excludeList) && $fileIsNotPrefixed && $file !== $script;
    }
    private static function fileIsExcluded(string $file, \PHPUnit\Util\ExcludeList $excludeList) : bool
    {
        return (empty($GLOBALS['__PHPUNIT_ISOLATION_EXCLUDE_LIST']) || !\in_array($file, $GLOBALS['__PHPUNIT_ISOLATION_EXCLUDE_LIST'], \true)) && !$excludeList->isExcluded($file);
    }
    private static function frameExists(array $trace, string $file, int $line) : bool
    {
        foreach ($trace as $frame) {
            if (isset($frame['file'], $frame['line']) && $frame['file'] === $file && $frame['line'] === $line) {
                return \true;
            }
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use function array_keys;
use function array_reverse;
use function defined;
use function get_defined_constants;
use function get_included_files;
use function in_array;
use function ini_get_all;
use function is_array;
use function is_file;
use function is_scalar;
use function preg_match;
use function serialize;
use function sprintf;
use function strpos;
use function var_export;
use Closure;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class GlobalState
{
    /**
     * @var string[]
     */
    private const SUPER_GLOBAL_ARRAYS = ['_ENV', '_POST', '_GET', '_COOKIE', '_SERVER', '_FILES', '_REQUEST'];
    /**
     * @throws Exception
     */
    public static function getIncludedFilesAsString() : string
    {
        return self::processIncludedFilesAsString(\get_included_files());
    }
    /**
     * @param string[] $files
     *
     * @throws Exception
     */
    public static function processIncludedFilesAsString(array $files) : string
    {
        $excludeList = new \PHPUnit\Util\ExcludeList();
        $prefix = \false;
        $result = '';
        if (\defined('__PHPUNIT_PHAR__')) {
            $prefix = 'phar://' . __PHPUNIT_PHAR__ . '/';
        }
        // Do not process bootstrap script
        unset($files[0]);
        foreach (\array_reverse($files) as $file) {
            if (!empty($GLOBALS['__PHPUNIT_ISOLATION_EXCLUDE_LIST']) && \in_array($file, $GLOBALS['__PHPUNIT_ISOLATION_EXCLUDE_LIST'], \true)) {
                continue;
            }
            if ($prefix !== \false && \strpos($file, $prefix) === 0) {
                continue;
            }
            // Skip virtual file system protocols
            if (\preg_match('/^(vfs|phpvfs[a-z0-9]+):/', $file)) {
                continue;
            }
            if (!$excludeList->isExcluded($file) && \is_file($file)) {
                $result = 'require_once \'' . $file . "';\n" . $result;
            }
        }
        return $result;
    }
    public static function getIniSettingsAsString() : string
    {
        $result = '';
        foreach (\ini_get_all(null, \false) as $key => $value) {
            $result .= \sprintf('@ini_set(%s, %s);' . "\n", self::exportVariable($key), self::exportVariable((string) $value));
        }
        return $result;
    }
    public static function getConstantsAsString() : string
    {
        $constants = \get_defined_constants(\true);
        $result = '';
        if (isset($constants['user'])) {
            foreach ($constants['user'] as $name => $value) {
                $result .= \sprintf('if (!defined(\'%s\')) define(\'%s\', %s);' . "\n", $name, $name, self::exportVariable($value));
            }
        }
        return $result;
    }
    public static function getGlobalsAsString() : string
    {
        $result = '';
        foreach (self::SUPER_GLOBAL_ARRAYS as $superGlobalArray) {
            if (isset($GLOBALS[$superGlobalArray]) && \is_array($GLOBALS[$superGlobalArray])) {
                foreach (\array_keys($GLOBALS[$superGlobalArray]) as $key) {
                    if ($GLOBALS[$superGlobalArray][$key] instanceof \Closure) {
                        continue;
                    }
                    $result .= \sprintf('$GLOBALS[\'%s\'][\'%s\'] = %s;' . "\n", $superGlobalArray, $key, self::exportVariable($GLOBALS[$superGlobalArray][$key]));
                }
            }
        }
        $excludeList = self::SUPER_GLOBAL_ARRAYS;
        $excludeList[] = 'GLOBALS';
        foreach (\array_keys($GLOBALS) as $key) {
            if (!$GLOBALS[$key] instanceof \Closure && !\in_array($key, $excludeList, \true)) {
                $result .= \sprintf('$GLOBALS[\'%s\'] = %s;' . "\n", $key, self::exportVariable($GLOBALS[$key]));
            }
        }
        return $result;
    }
    private static function exportVariable($variable) : string
    {
        if (\is_scalar($variable) || $variable === null || \is_array($variable) && self::arrayOnlyContainsScalars($variable)) {
            return \var_export($variable, \true);
        }
        return 'unserialize(' . \var_export(\serialize($variable), \true) . ')';
    }
    private static function arrayOnlyContainsScalars(array $array) : bool
    {
        $result = \true;
        foreach ($array as $element) {
            if (\is_array($element)) {
                $result = self::arrayOnlyContainsScalars($element);
            } elseif (!\is_scalar($element) && $element !== null) {
                $result = \false;
            }
            if (!$result) {
                break;
            }
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class InvalidDataSetException extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use const JSON_PRETTY_PRINT;
use const JSON_UNESCAPED_SLASHES;
use const JSON_UNESCAPED_UNICODE;
use function count;
use function is_array;
use function is_object;
use function json_decode;
use function json_encode;
use function json_last_error;
use function ksort;
use PHPUnit\Framework\Exception;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Json
{
    /**
     * Prettify json string.
     *
     * @throws \PHPUnit\Framework\Exception
     */
    public static function prettify(string $json) : string
    {
        $decodedJson = \json_decode($json, \false);
        if (\json_last_error()) {
            throw new \PHPUnit\Framework\Exception('Cannot prettify invalid json');
        }
        return \json_encode($decodedJson, \JSON_PRETTY_PRINT | \JSON_UNESCAPED_SLASHES | \JSON_UNESCAPED_UNICODE);
    }
    /**
     * To allow comparison of JSON strings, first process them into a consistent
     * format so that they can be compared as strings.
     *
     * @return array ($error, $canonicalized_json)  The $error parameter is used
     *               to indicate an error decoding the json. This is used to avoid ambiguity
     *               with JSON strings consisting entirely of 'null' or 'false'.
     */
    public static function canonicalize(string $json) : array
    {
        $decodedJson = \json_decode($json);
        if (\json_last_error()) {
            return [\true, null];
        }
        self::recursiveSort($decodedJson);
        $reencodedJson = \json_encode($decodedJson);
        return [\false, $reencodedJson];
    }
    /**
     * JSON object keys are unordered while PHP array keys are ordered.
     *
     * Sort all array keys to ensure both the expected and actual values have
     * their keys in the same order.
     */
    private static function recursiveSort(&$json) : void
    {
        if (!\is_array($json)) {
            // If the object is not empty, change it to an associative array
            // so we can sort the keys (and we will still re-encode it
            // correctly, since PHP encodes associative arrays as JSON objects.)
            // But EMPTY objects MUST remain empty objects. (Otherwise we will
            // re-encode it as a JSON array rather than a JSON object.)
            // See #2919.
            if (\is_object($json) && \count((array) $json) > 0) {
                $json = (array) $json;
            } else {
                return;
            }
        }
        \ksort($json);
        foreach ($json as $key => &$value) {
            self::recursiveSort($value);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Log;

use function class_exists;
use function get_class;
use function method_exists;
use function sprintf;
use function str_replace;
use function trim;
use DOMDocument;
use DOMElement;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\ExceptionWrapper;
use PHPUnit\Framework\SelfDescribing;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestFailure;
use PHPUnit\Framework\TestListener;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\Warning;
use PHPUnit\Util\Exception;
use PHPUnit\Util\Filter;
use PHPUnit\Util\Printer;
use PHPUnit\Util\Xml;
use ReflectionClass;
use ReflectionException;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class JUnit extends \PHPUnit\Util\Printer implements \PHPUnit\Framework\TestListener
{
    private \DOMDocument $document;
    private \DOMElement $root;
    private bool $reportRiskyTests = \false;
    /**
     * @var DOMElement[]
     */
    private array $testSuites = [];
    /**
     * @var int[]
     */
    private array $testSuiteTests = [0];
    /**
     * @var int[]
     */
    private array $testSuiteAssertions = [0];
    /**
     * @var int[]
     */
    private array $testSuiteErrors = [0];
    /**
     * @var int[]
     */
    private array $testSuiteWarnings = [0];
    /**
     * @var int[]
     */
    private array $testSuiteFailures = [0];
    /**
     * @var int[]
     */
    private array $testSuiteSkipped = [0];
    /**
     * @var int[]
     */
    private array $testSuiteTimes = [0];
    private int $testSuiteLevel = 0;
    private ?\DOMElement $currentTestCase = null;
    /**
     * @param null|mixed $out
     */
    public function __construct($out = null, bool $reportRiskyTests = \false)
    {
        $this->document = new \DOMDocument('1.0', 'UTF-8');
        $this->document->formatOutput = \true;
        $this->root = $this->document->createElement('testsuites');
        $this->document->appendChild($this->root);
        parent::__construct($out);
        $this->reportRiskyTests = $reportRiskyTests;
    }
    /**
     * Flush buffer and close output.
     */
    public function flush() : void
    {
        $this->write($this->getXML());
        parent::flush();
    }
    /**
     * An error occurred.
     */
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->doAddFault($test, $t, 'error');
        $this->testSuiteErrors[$this->testSuiteLevel]++;
    }
    /**
     * A warning occurred.
     */
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
        $this->doAddFault($test, $e, 'warning');
        $this->testSuiteWarnings[$this->testSuiteLevel]++;
    }
    /**
     * A failure occurred.
     */
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        $this->doAddFault($test, $e, 'failure');
        $this->testSuiteFailures[$this->testSuiteLevel]++;
    }
    /**
     * Incomplete test.
     */
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->doAddSkipped();
    }
    /**
     * Risky test.
     */
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        if (!$this->reportRiskyTests) {
            return;
        }
        $this->doAddFault($test, $t, 'error');
        $this->testSuiteErrors[$this->testSuiteLevel]++;
    }
    /**
     * Skipped test.
     */
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->doAddSkipped();
    }
    /**
     * A testsuite started.
     */
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
        $testSuite = $this->document->createElement('testsuite');
        $testSuite->setAttribute('name', $suite->getName());
        if (\class_exists($suite->getName(), \false)) {
            try {
                $class = new \ReflectionClass($suite->getName());
                $testSuite->setAttribute('file', $class->getFileName());
            } catch (\ReflectionException $e) {
            }
        }
        if ($this->testSuiteLevel > 0) {
            $this->testSuites[$this->testSuiteLevel]->appendChild($testSuite);
        } else {
            $this->root->appendChild($testSuite);
        }
        $this->testSuiteLevel++;
        $this->testSuites[$this->testSuiteLevel] = $testSuite;
        $this->testSuiteTests[$this->testSuiteLevel] = 0;
        $this->testSuiteAssertions[$this->testSuiteLevel] = 0;
        $this->testSuiteErrors[$this->testSuiteLevel] = 0;
        $this->testSuiteWarnings[$this->testSuiteLevel] = 0;
        $this->testSuiteFailures[$this->testSuiteLevel] = 0;
        $this->testSuiteSkipped[$this->testSuiteLevel] = 0;
        $this->testSuiteTimes[$this->testSuiteLevel] = 0;
    }
    /**
     * A testsuite ended.
     */
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
        $this->testSuites[$this->testSuiteLevel]->setAttribute('tests', (string) $this->testSuiteTests[$this->testSuiteLevel]);
        $this->testSuites[$this->testSuiteLevel]->setAttribute('assertions', (string) $this->testSuiteAssertions[$this->testSuiteLevel]);
        $this->testSuites[$this->testSuiteLevel]->setAttribute('errors', (string) $this->testSuiteErrors[$this->testSuiteLevel]);
        $this->testSuites[$this->testSuiteLevel]->setAttribute('warnings', (string) $this->testSuiteWarnings[$this->testSuiteLevel]);
        $this->testSuites[$this->testSuiteLevel]->setAttribute('failures', (string) $this->testSuiteFailures[$this->testSuiteLevel]);
        $this->testSuites[$this->testSuiteLevel]->setAttribute('skipped', (string) $this->testSuiteSkipped[$this->testSuiteLevel]);
        $this->testSuites[$this->testSuiteLevel]->setAttribute('time', \sprintf('%F', $this->testSuiteTimes[$this->testSuiteLevel]));
        if ($this->testSuiteLevel > 1) {
            $this->testSuiteTests[$this->testSuiteLevel - 1] += $this->testSuiteTests[$this->testSuiteLevel];
            $this->testSuiteAssertions[$this->testSuiteLevel - 1] += $this->testSuiteAssertions[$this->testSuiteLevel];
            $this->testSuiteErrors[$this->testSuiteLevel - 1] += $this->testSuiteErrors[$this->testSuiteLevel];
            $this->testSuiteWarnings[$this->testSuiteLevel - 1] += $this->testSuiteWarnings[$this->testSuiteLevel];
            $this->testSuiteFailures[$this->testSuiteLevel - 1] += $this->testSuiteFailures[$this->testSuiteLevel];
            $this->testSuiteSkipped[$this->testSuiteLevel - 1] += $this->testSuiteSkipped[$this->testSuiteLevel];
            $this->testSuiteTimes[$this->testSuiteLevel - 1] += $this->testSuiteTimes[$this->testSuiteLevel];
        }
        $this->testSuiteLevel--;
    }
    /**
     * A test started.
     */
    public function startTest(\PHPUnit\Framework\Test $test) : void
    {
        $usesDataprovider = \false;
        if (\method_exists($test, 'usesDataProvider')) {
            $usesDataprovider = $test->usesDataProvider();
        }
        $testCase = $this->document->createElement('testcase');
        $testCase->setAttribute('name', $test->getName());
        try {
            $class = new \ReflectionClass($test);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        $methodName = $test->getName(!$usesDataprovider);
        if ($class->hasMethod($methodName)) {
            try {
                $method = $class->getMethod($methodName);
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
            $testCase->setAttribute('class', $class->getName());
            $testCase->setAttribute('classname', \str_replace('\\', '.', $class->getName()));
            $testCase->setAttribute('file', $class->getFileName());
            $testCase->setAttribute('line', (string) $method->getStartLine());
        }
        $this->currentTestCase = $testCase;
    }
    /**
     * A test ended.
     */
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        $numAssertions = 0;
        if (\method_exists($test, 'numberOfAssertionsPerformed')) {
            $numAssertions = $test->numberOfAssertionsPerformed();
        }
        $this->testSuiteAssertions[$this->testSuiteLevel] += $numAssertions;
        $this->currentTestCase->setAttribute('assertions', (string) $numAssertions);
        $this->currentTestCase->setAttribute('time', \sprintf('%F', $time));
        $this->testSuites[$this->testSuiteLevel]->appendChild($this->currentTestCase);
        $this->testSuiteTests[$this->testSuiteLevel]++;
        $this->testSuiteTimes[$this->testSuiteLevel] += $time;
        $testOutput = '';
        if (\method_exists($test, 'hasOutput') && \method_exists($test, 'output')) {
            $testOutput = $test->hasOutput() ? $test->output() : '';
        }
        if (!empty($testOutput)) {
            $systemOut = $this->document->createElement('system-out', \PHPUnit\Util\Xml::prepareString($testOutput));
            $this->currentTestCase->appendChild($systemOut);
        }
        $this->currentTestCase = null;
    }
    /**
     * Returns the XML as a string.
     */
    public function getXML() : string
    {
        return $this->document->saveXML();
    }
    private function doAddFault(\PHPUnit\Framework\Test $test, \Throwable $t, string $type) : void
    {
        if ($this->currentTestCase === null) {
            return;
        }
        if ($test instanceof \PHPUnit\Framework\SelfDescribing) {
            $buffer = $test->toString() . "\n";
        } else {
            $buffer = '';
        }
        $buffer .= \trim(\PHPUnit\Framework\TestFailure::exceptionToString($t) . "\n" . \PHPUnit\Util\Filter::getFilteredStacktrace($t));
        $fault = $this->document->createElement($type, \PHPUnit\Util\Xml::prepareString($buffer));
        if ($t instanceof \PHPUnit\Framework\ExceptionWrapper) {
            $fault->setAttribute('type', $t->getClassName());
        } else {
            $fault->setAttribute('type', \get_class($t));
        }
        $this->currentTestCase->appendChild($fault);
    }
    private function doAddSkipped() : void
    {
        if ($this->currentTestCase === null) {
            return;
        }
        $skipped = $this->document->createElement('skipped');
        $this->currentTestCase->appendChild($skipped);
        $this->testSuiteSkipped[$this->testSuiteLevel]++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Log;

use function class_exists;
use function count;
use function explode;
use function get_class;
use function getmypid;
use function ini_get;
use function is_bool;
use function is_scalar;
use function method_exists;
use function print_r;
use function round;
use function str_replace;
use function stripos;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\ExceptionWrapper;
use PHPUnit\Framework\ExpectationFailedException;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestFailure;
use PHPUnit\Framework\TestResult;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\Warning;
use PHPUnit\TextUI\DefaultResultPrinter;
use PHPUnit\Util\Exception;
use PHPUnit\Util\Filter;
use ReflectionClass;
use ReflectionException;
use PHPUnit\SebastianBergmann\Comparator\ComparisonFailure;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TeamCity extends \PHPUnit\TextUI\DefaultResultPrinter
{
    private bool $isSummaryTestCountPrinted = \false;
    private string $startedTestName;
    /**
     * @var false|int
     */
    private $flowId;
    public function printResult(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printHeader($result);
        $this->printFooter($result);
    }
    /**
     * An error occurred.
     */
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->printEvent('testFailed', ['name' => $test->getName(), 'message' => self::getMessage($t), 'details' => self::getDetails($t), 'duration' => self::toMilliseconds($time)]);
    }
    /**
     * A warning occurred.
     */
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
        $this->write(self::getMessage($e) . \PHP_EOL);
    }
    /**
     * A failure occurred.
     */
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        $parameters = ['name' => $test->getName(), 'message' => self::getMessage($e), 'details' => self::getDetails($e), 'duration' => self::toMilliseconds($time)];
        if ($e instanceof \PHPUnit\Framework\ExpectationFailedException) {
            $comparisonFailure = $e->getComparisonFailure();
            if ($comparisonFailure instanceof \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure) {
                $expectedString = $comparisonFailure->getExpectedAsString();
                if ($expectedString === null || empty($expectedString)) {
                    $expectedString = self::getPrimitiveValueAsString($comparisonFailure->getExpected());
                }
                $actualString = $comparisonFailure->getActualAsString();
                if ($actualString === null || empty($actualString)) {
                    $actualString = self::getPrimitiveValueAsString($comparisonFailure->getActual());
                }
                if ($actualString !== null && $expectedString !== null) {
                    $parameters['type'] = 'comparisonFailure';
                    $parameters['actual'] = $actualString;
                    $parameters['expected'] = $expectedString;
                }
            }
        }
        $this->printEvent('testFailed', $parameters);
    }
    /**
     * Incomplete test.
     */
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->printIgnoredTest($test->getName(), $t, $time);
    }
    /**
     * Risky test.
     */
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->addError($test, $t, $time);
    }
    /**
     * Skipped test.
     */
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $testName = $test->getName();
        if ($this->startedTestName !== $testName) {
            $this->startTest($test);
            $this->printIgnoredTest($testName, $t, $time);
            $this->endTest($test, $time);
        } else {
            $this->printIgnoredTest($testName, $t, $time);
        }
    }
    public function printIgnoredTest(string $testName, \Throwable $t, float $time) : void
    {
        $this->printEvent('testIgnored', ['name' => $testName, 'message' => self::getMessage($t), 'details' => self::getDetails($t), 'duration' => self::toMilliseconds($time)]);
    }
    /**
     * A testsuite started.
     */
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
        if (\stripos(\ini_get('disable_functions'), 'getmypid') === \false) {
            $this->flowId = \getmypid();
        } else {
            $this->flowId = \false;
        }
        if (!$this->isSummaryTestCountPrinted) {
            $this->isSummaryTestCountPrinted = \true;
            $this->printEvent('testCount', ['count' => \count($suite)]);
        }
        $suiteName = $suite->getName();
        if (empty($suiteName)) {
            return;
        }
        $parameters = ['name' => $suiteName];
        if (\class_exists($suiteName, \false)) {
            $fileName = self::getFileName($suiteName);
            $parameters['locationHint'] = "php_qn://{$fileName}::\\{$suiteName}";
        } else {
            $split = \explode('::', $suiteName);
            if (\count($split) === 2 && \class_exists($split[0]) && \method_exists($split[0], $split[1])) {
                $fileName = self::getFileName($split[0]);
                $parameters['locationHint'] = "php_qn://{$fileName}::\\{$suiteName}";
                $parameters['name'] = $split[1];
            }
        }
        $this->printEvent('testSuiteStarted', $parameters);
    }
    /**
     * A testsuite ended.
     */
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
        $suiteName = $suite->getName();
        if (empty($suiteName)) {
            return;
        }
        $parameters = ['name' => $suiteName];
        if (!\class_exists($suiteName, \false)) {
            $split = \explode('::', $suiteName);
            if (\count($split) === 2 && \class_exists($split[0]) && \method_exists($split[0], $split[1])) {
                $parameters['name'] = $split[1];
            }
        }
        $this->printEvent('testSuiteFinished', $parameters);
    }
    /**
     * A test started.
     */
    public function startTest(\PHPUnit\Framework\Test $test) : void
    {
        $testName = $test->getName();
        $this->startedTestName = $testName;
        $params = ['name' => $testName];
        if ($test instanceof \PHPUnit\Framework\TestCase) {
            $className = \get_class($test);
            $fileName = self::getFileName($className);
            $params['locationHint'] = "php_qn://{$fileName}::\\{$className}::{$testName}";
        }
        $this->printEvent('testStarted', $params);
    }
    /**
     * A test ended.
     */
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        parent::endTest($test, $time);
        $this->printEvent('testFinished', ['name' => $test->getName(), 'duration' => self::toMilliseconds($time)]);
    }
    protected function writeProgress(string $progress) : void
    {
    }
    private function printEvent(string $eventName, array $params = []) : void
    {
        $this->write("\n##teamcity[{$eventName}");
        if ($this->flowId) {
            $params['flowId'] = $this->flowId;
        }
        foreach ($params as $key => $value) {
            $escapedValue = self::escapeValue((string) $value);
            $this->write(" {$key}='{$escapedValue}'");
        }
        $this->write("]\n");
    }
    private static function getMessage(\Throwable $t) : string
    {
        $message = '';
        if ($t instanceof \PHPUnit\Framework\ExceptionWrapper) {
            if ($t->getClassName() !== '') {
                $message .= $t->getClassName();
            }
            if ($message !== '' && $t->getMessage() !== '') {
                $message .= ' : ';
            }
        }
        return $message . $t->getMessage();
    }
    private static function getDetails(\Throwable $t) : string
    {
        $stackTrace = \PHPUnit\Util\Filter::getFilteredStacktrace($t);
        $previous = $t instanceof \PHPUnit\Framework\ExceptionWrapper ? $t->getPreviousWrapped() : $t->getPrevious();
        while ($previous) {
            $stackTrace .= "\nCaused by\n" . \PHPUnit\Framework\TestFailure::exceptionToString($previous) . "\n" . \PHPUnit\Util\Filter::getFilteredStacktrace($previous);
            $previous = $previous instanceof \PHPUnit\Framework\ExceptionWrapper ? $previous->getPreviousWrapped() : $previous->getPrevious();
        }
        return ' ' . \str_replace("\n", "\n ", $stackTrace);
    }
    private static function getPrimitiveValueAsString($value) : ?string
    {
        if ($value === null) {
            return 'null';
        }
        if (\is_bool($value)) {
            return $value ? 'true' : 'false';
        }
        if (\is_scalar($value)) {
            return \print_r($value, \true);
        }
        return null;
    }
    private static function escapeValue(string $text) : string
    {
        return \str_replace(['|', "'", "\n", "\r", ']', '['], ['||', "|'", '|n', '|r', '|]', '|['], $text);
    }
    /**
     * @param string $className
     */
    private static function getFileName($className) : string
    {
        try {
            return (new \ReflectionClass($className))->getFileName();
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @param float $time microseconds
     */
    private static function toMilliseconds(float $time) : int
    {
        return (int) \round($time * 1000);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\PHP;

use const DIRECTORY_SEPARATOR;
use const PHP_SAPI;
use function array_keys;
use function array_merge;
use function assert;
use function escapeshellarg;
use function ini_get_all;
use function restore_error_handler;
use function set_error_handler;
use function sprintf;
use function str_replace;
use function strpos;
use function strrpos;
use function substr;
use function trim;
use function unserialize;
use __PHP_Incomplete_Class;
use ErrorException;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\Exception;
use PHPUnit\Framework\SyntheticError;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestFailure;
use PHPUnit\Framework\TestResult;
use PHPUnit\Runner\CodeCoverage;
use PHPUnit\SebastianBergmann\Environment\Runtime;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
abstract class AbstractPhpProcess
{
    protected \PHPUnit\SebastianBergmann\Environment\Runtime $runtime;
    protected bool $stderrRedirection = \false;
    protected string $stdin = '';
    protected string $args = '';
    /**
     * @var array<string, string>
     */
    protected array $env = [];
    protected int $timeout = 0;
    public static function factory() : self
    {
        if (\DIRECTORY_SEPARATOR === '\\') {
            return new \PHPUnit\Util\PHP\WindowsPhpProcess();
        }
        return new \PHPUnit\Util\PHP\DefaultPhpProcess();
    }
    public function __construct()
    {
        $this->runtime = new \PHPUnit\SebastianBergmann\Environment\Runtime();
    }
    /**
     * Defines if should use STDERR redirection or not.
     *
     * Then $stderrRedirection is TRUE, STDERR is redirected to STDOUT.
     */
    public function setUseStderrRedirection(bool $stderrRedirection) : void
    {
        $this->stderrRedirection = $stderrRedirection;
    }
    /**
     * Returns TRUE if uses STDERR redirection or FALSE if not.
     */
    public function useStderrRedirection() : bool
    {
        return $this->stderrRedirection;
    }
    /**
     * Sets the input string to be sent via STDIN.
     */
    public function setStdin(string $stdin) : void
    {
        $this->stdin = $stdin;
    }
    /**
     * Returns the input string to be sent via STDIN.
     */
    public function getStdin() : string
    {
        return $this->stdin;
    }
    /**
     * Sets the string of arguments to pass to the php job.
     */
    public function setArgs(string $args) : void
    {
        $this->args = $args;
    }
    /**
     * Returns the string of arguments to pass to the php job.
     */
    public function getArgs() : string
    {
        return $this->args;
    }
    /**
     * Sets the array of environment variables to start the child process with.
     *
     * @param array<string, string> $env
     */
    public function setEnv(array $env) : void
    {
        $this->env = $env;
    }
    /**
     * Returns the array of environment variables to start the child process with.
     */
    public function getEnv() : array
    {
        return $this->env;
    }
    /**
     * Sets the amount of seconds to wait before timing out.
     */
    public function setTimeout(int $timeout) : void
    {
        $this->timeout = $timeout;
    }
    /**
     * Returns the amount of seconds to wait before timing out.
     */
    public function getTimeout() : int
    {
        return $this->timeout;
    }
    /**
     * Runs a single test in a separate PHP process.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function runTestJob(string $job, \PHPUnit\Framework\Test $test, \PHPUnit\Framework\TestResult $result) : void
    {
        $result->startTest($test);
        $_result = $this->runJob($job);
        $this->processChildResult($test, $result, $_result['stdout'], $_result['stderr']);
    }
    /**
     * Returns the command based into the configurations.
     */
    public function getCommand(array $settings, string $file = null) : string
    {
        $command = $this->runtime->getBinary();
        if ($this->runtime->hasPCOV()) {
            $settings = \array_merge($settings, $this->runtime->getCurrentSettings(\array_keys(\ini_get_all('pcov'))));
        } elseif ($this->runtime->hasXdebug()) {
            $settings = \array_merge($settings, $this->runtime->getCurrentSettings(\array_keys(\ini_get_all('xdebug'))));
        }
        $command .= $this->settingsToParameters($settings);
        if (\PHP_SAPI === 'phpdbg') {
            $command .= ' -qrr';
            if (!$file) {
                $command .= 's=';
            }
        }
        if ($file) {
            $command .= ' ' . \escapeshellarg($file);
        }
        if ($this->args) {
            if (!$file) {
                $command .= ' --';
            }
            $command .= ' ' . $this->args;
        }
        if ($this->stderrRedirection) {
            $command .= ' 2>&1';
        }
        return $command;
    }
    /**
     * Runs a single job (PHP code) using a separate PHP process.
     */
    public abstract function runJob(string $job, array $settings = []) : array;
    protected function settingsToParameters(array $settings) : string
    {
        $buffer = '';
        foreach ($settings as $setting) {
            $buffer .= ' -d ' . \escapeshellarg($setting);
        }
        return $buffer;
    }
    /**
     * Processes the TestResult object from an isolated process.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function processChildResult(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\TestResult $result, string $stdout, string $stderr) : void
    {
        $time = 0;
        if (!empty($stderr)) {
            $result->addError($test, new \PHPUnit\Framework\Exception(\trim($stderr)), $time);
        } else {
            \set_error_handler(
                /**
                 * @throws ErrorException
                 */
                static function ($errno, $errstr, $errfile, $errline) : void {
                    throw new \ErrorException($errstr, $errno, $errno, $errfile, $errline);
                }
            );
            try {
                if (\strpos($stdout, "#!/usr/bin/env php\n") === 0) {
                    $stdout = \substr($stdout, 19);
                }
                $childResult = \unserialize(\str_replace("#!/usr/bin/env php\n", '', $stdout));
                \restore_error_handler();
                if ($childResult === \false) {
                    $result->addFailure($test, new \PHPUnit\Framework\AssertionFailedError('Test was run in child process and ended unexpectedly'), $time);
                }
            } catch (\ErrorException $e) {
                \restore_error_handler();
                $childResult = \false;
                $result->addError($test, new \PHPUnit\Framework\Exception(\trim($stdout), 0, $e), $time);
            }
            if ($childResult !== \false) {
                if (!empty($childResult['output'])) {
                    $output = $childResult['output'];
                }
                /* @var TestCase $test */
                $test->setResult($childResult['testResult']);
                $test->addToAssertionCount($childResult['numAssertions']);
                if (\PHPUnit\Runner\CodeCoverage::isActive() && $childResult['codeCoverage'] instanceof \PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage) {
                    \PHPUnit\Runner\CodeCoverage::instance()->merge($childResult['codeCoverage']);
                }
                \assert($childResult['result'] instanceof \PHPUnit\Framework\TestResult);
                $time = $childResult['result']->time();
                $notImplemented = $childResult['result']->notImplemented();
                $risky = $childResult['result']->risky();
                $skipped = $childResult['result']->skipped();
                $errors = $childResult['result']->errors();
                $warnings = $childResult['result']->warnings();
                $failures = $childResult['result']->failures();
                if (!empty($notImplemented)) {
                    $result->addFailure($test, $this->getException($notImplemented[0]), $time);
                } elseif (!empty($risky)) {
                    $result->addFailure($test, $this->getException($risky[0]), $time);
                } elseif (!empty($skipped)) {
                    $result->addFailure($test, $this->getException($skipped[0]), $time);
                } elseif (!empty($errors)) {
                    $result->addError($test, $this->getException($errors[0]), $time);
                } elseif (!empty($warnings)) {
                    $result->addWarning($test, $this->getException($warnings[0]), $time);
                } elseif (!empty($failures)) {
                    $result->addFailure($test, $this->getException($failures[0]), $time);
                }
            }
        }
        $result->endTest($test, $time);
        if (!empty($output)) {
            print $output;
        }
    }
    /**
     * Gets the thrown exception from a PHPUnit\Framework\TestFailure.
     *
     * @see https://github.com/sebastianbergmann/phpunit/issues/74
     */
    private function getException(\PHPUnit\Framework\TestFailure $error) : \PHPUnit\Framework\Exception
    {
        $exception = $error->thrownException();
        if ($exception instanceof \__PHP_Incomplete_Class) {
            $exceptionArray = [];
            foreach ((array) $exception as $key => $value) {
                $key = \substr($key, \strrpos($key, "\0") + 1);
                $exceptionArray[$key] = $value;
            }
            $exception = new \PHPUnit\Framework\SyntheticError(\sprintf('%s: %s', $exceptionArray['_PHP_Incomplete_Class_Name'], $exceptionArray['message']), $exceptionArray['code'], $exceptionArray['file'], $exceptionArray['line'], $exceptionArray['trace']);
        }
        return $exception;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\PHP;

use function array_merge;
use function fclose;
use function file_put_contents;
use function fread;
use function fwrite;
use function is_array;
use function is_resource;
use function proc_close;
use function proc_open;
use function proc_terminate;
use function rewind;
use function sprintf;
use function stream_get_contents;
use function stream_select;
use function sys_get_temp_dir;
use function tempnam;
use function unlink;
use PHPUnit\Framework\Exception;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class DefaultPhpProcess extends \PHPUnit\Util\PHP\AbstractPhpProcess
{
    private ?string $tempFile = null;
    /**
     * Runs a single job (PHP code) using a separate PHP process.
     *
     * @throws Exception
     */
    public function runJob(string $job, array $settings = []) : array
    {
        if ($this->stdin || $this->useTemporaryFile()) {
            if (!($this->tempFile = \tempnam(\sys_get_temp_dir(), 'PHPUnit')) || \file_put_contents($this->tempFile, $job) === \false) {
                throw new \PHPUnit\Framework\Exception('Unable to write temporary file');
            }
            $job = $this->stdin;
        }
        return $this->runProcess($job, $settings);
    }
    /**
     * Returns an array of file handles to be used in place of pipes.
     */
    protected function getHandles() : array
    {
        return [];
    }
    /**
     * Handles creating the child process and returning the STDOUT and STDERR.
     *
     * @throws Exception
     */
    protected function runProcess(string $job, array $settings) : array
    {
        $handles = $this->getHandles();
        $env = null;
        if ($this->env) {
            $env = $_SERVER ?? [];
            unset($env['argv'], $env['argc']);
            $env = \array_merge($env, $this->env);
            foreach ($env as $envKey => $envVar) {
                if (\is_array($envVar)) {
                    unset($env[$envKey]);
                }
            }
        }
        $pipeSpec = [0 => $handles[0] ?? ['pipe', 'r'], 1 => $handles[1] ?? ['pipe', 'w'], 2 => $handles[2] ?? ['pipe', 'w']];
        $process = \proc_open($this->getCommand($settings, $this->tempFile), $pipeSpec, $pipes, null, $env);
        if (!\is_resource($process)) {
            throw new \PHPUnit\Framework\Exception('Unable to spawn worker process');
        }
        if ($job) {
            $this->process($pipes[0], $job);
        }
        \fclose($pipes[0]);
        $stderr = $stdout = '';
        if ($this->timeout) {
            unset($pipes[0]);
            while (\true) {
                $r = $pipes;
                $w = null;
                $e = null;
                $n = @\stream_select($r, $w, $e, $this->timeout);
                if ($n === \false) {
                    break;
                }
                if ($n === 0) {
                    \proc_terminate($process, 9);
                    throw new \PHPUnit\Framework\Exception(\sprintf('Job execution aborted after %d seconds', $this->timeout));
                }
                if ($n > 0) {
                    foreach ($r as $pipe) {
                        $pipeOffset = 0;
                        foreach ($pipes as $i => $origPipe) {
                            if ($pipe === $origPipe) {
                                $pipeOffset = $i;
                                break;
                            }
                        }
                        if (!$pipeOffset) {
                            break;
                        }
                        $line = \fread($pipe, 8192);
                        if ($line === '' || $line === \false) {
                            \fclose($pipes[$pipeOffset]);
                            unset($pipes[$pipeOffset]);
                        } elseif ($pipeOffset === 1) {
                            $stdout .= $line;
                        } else {
                            $stderr .= $line;
                        }
                    }
                    if (empty($pipes)) {
                        break;
                    }
                }
            }
        } else {
            if (isset($pipes[1])) {
                $stdout = \stream_get_contents($pipes[1]);
                \fclose($pipes[1]);
            }
            if (isset($pipes[2])) {
                $stderr = \stream_get_contents($pipes[2]);
                \fclose($pipes[2]);
            }
        }
        if (isset($handles[1])) {
            \rewind($handles[1]);
            $stdout = \stream_get_contents($handles[1]);
            \fclose($handles[1]);
        }
        if (isset($handles[2])) {
            \rewind($handles[2]);
            $stderr = \stream_get_contents($handles[2]);
            \fclose($handles[2]);
        }
        \proc_close($process);
        $this->cleanup();
        return ['stdout' => $stdout, 'stderr' => $stderr];
    }
    /**
     * @param resource $pipe
     */
    protected function process($pipe, string $job) : void
    {
        \fwrite($pipe, $job);
    }
    protected function cleanup() : void
    {
        if ($this->tempFile) {
            \unlink($this->tempFile);
        }
    }
    protected function useTemporaryFile() : bool
    {
        return \false;
    }
}
<?php
use PHPUnit\Runner\CodeCoverage;
use PHPUnit\TextUI\XmlConfiguration\Loader;
use PHPUnit\TextUI\XmlConfiguration\PhpHandler;

if (!defined('STDOUT')) {
    // php://stdout does not obey output buffering. Any output would break
    // unserialization of child process results in the parent process.
    define('STDOUT', fopen('php://temp', 'w+b'));
    define('STDERR', fopen('php://stderr', 'wb'));
}

{iniSettings}
ini_set('display_errors', 'stderr');
set_include_path('{include_path}');

$composerAutoload = {composerAutoload};
$phar             = {phar};

ob_start();

if ($composerAutoload) {
    require_once $composerAutoload;
    define('PHPUNIT_COMPOSER_INSTALL', $composerAutoload);
} else if ($phar) {
    require $phar;
}

function __phpunit_run_isolated_test()
{
    if (!class_exists('{className}')) {
        require_once '{filename}';
    }

    $result = new PHPUnit\Framework\TestResult;

    if ({collectCodeCoverageInformation}) {
        CodeCoverage::activate(
            unserialize('{codeCoverageFilter}'),
            {pathCoverage}
        );

        if ({cachesStaticAnalysis}) {
            CodeCoverage::instance()->cacheStaticAnalysis(unserialize('{codeCoverageCacheDirectory}'));
        }
    }

    $result->beStrictAboutTestsThatDoNotTestAnything({isStrictAboutTestsThatDoNotTestAnything});
    $result->beStrictAboutOutputDuringTests({isStrictAboutOutputDuringTests});
    $result->enforceTimeLimit({enforcesTimeLimit});
    $result->beStrictAboutTodoAnnotatedTests({isStrictAboutTodoAnnotatedTests});
    $result->beStrictAboutResourceUsageDuringSmallTests({isStrictAboutResourceUsageDuringSmallTests});

    $test = new {className}('{name}');
    $test->setData('{dataName}', unserialize('{data}'));
    $test->setDependencyInput(unserialize('{dependencyInput}'));
    $test->setInIsolation(TRUE);

    ob_end_clean();
    $test->run($result);
    $output = '';
    if (!$test->hasExpectationOnOutput()) {
        $output = $test->output();
    }

    ini_set('xdebug.scream', '0');
    @rewind(STDOUT); /* @ as not every STDOUT target stream is rewindable */
    if ($stdout = @stream_get_contents(STDOUT)) {
        $output = $stdout . $output;
        $streamMetaData = stream_get_meta_data(STDOUT);
        if (!empty($streamMetaData['stream_type']) && 'STDIO' === $streamMetaData['stream_type']) {
            @ftruncate(STDOUT, 0);
            @rewind(STDOUT);
        }
    }

    print serialize(
      [
        'testResult'    => $test->result(),
        'codeCoverage'  => {collectCodeCoverageInformation} ? CodeCoverage::instance() : null,
        'numAssertions' => $test->numberOfAssertionsPerformed(),
        'result'        => $result,
        'output'        => $output
      ]
    );
}

$configurationFilePath = '{configurationFilePath}';

if ('' !== $configurationFilePath) {
    $configuration = (new Loader)->load($configurationFilePath);

    (new PhpHandler)->handle($configuration->php());

    unset($configuration);
}

function __phpunit_error_handler($errno, $errstr, $errfile, $errline)
{
   return true;
}

set_error_handler('__phpunit_error_handler');

{constants}
{included_files}
{globals}

restore_error_handler();

if (isset($GLOBALS['__PHPUNIT_BOOTSTRAP'])) {
    require_once $GLOBALS['__PHPUNIT_BOOTSTRAP'];
    unset($GLOBALS['__PHPUNIT_BOOTSTRAP']);
}

__phpunit_run_isolated_test();
<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\Runner\CodeCoverage;
use PHPUnit\TextUI\XmlConfiguration\Loader;
use PHPUnit\TextUI\XmlConfiguration\PhpHandler;

if (!defined('STDOUT')) {
    // php://stdout does not obey output buffering. Any output would break
    // unserialization of child process results in the parent process.
    define('STDOUT', fopen('php://temp', 'w+b'));
    define('STDERR', fopen('php://stderr', 'wb'));
}

{iniSettings}
ini_set('display_errors', 'stderr');
set_include_path('{include_path}');

$composerAutoload = {composerAutoload};
$phar             = {phar};

ob_start();

if ($composerAutoload) {
    require_once $composerAutoload;
    define('PHPUNIT_COMPOSER_INSTALL', $composerAutoload);
} else if ($phar) {
    require $phar;
}

function __phpunit_run_isolated_test()
{
    if (!class_exists('{className}')) {
        require_once '{filename}';
    }

    $result = new PHPUnit\Framework\TestResult;

    if ({collectCodeCoverageInformation}) {
        CodeCoverage::activate(
            unserialize('{codeCoverageFilter}'),
            {pathCoverage}
        );

        if ({cachesStaticAnalysis}) {
            CodeCoverage::instance()->cacheStaticAnalysis(unserialize('{codeCoverageCacheDirectory}'));
        }
    }

    $result->beStrictAboutTestsThatDoNotTestAnything({isStrictAboutTestsThatDoNotTestAnything});
    $result->beStrictAboutOutputDuringTests({isStrictAboutOutputDuringTests});
    $result->enforceTimeLimit({enforcesTimeLimit});
    $result->beStrictAboutTodoAnnotatedTests({isStrictAboutTodoAnnotatedTests});
    $result->beStrictAboutResourceUsageDuringSmallTests({isStrictAboutResourceUsageDuringSmallTests});

    $test = new {className}('{methodName}');
    \assert($test instanceof TestCase);

    $test->setData('{dataName}', unserialize('{data}'));
    $test->setDependencyInput(unserialize('{dependencyInput}'));
    $test->setInIsolation(true);

    ob_end_clean();
    $test->run($result);
    $output = '';
    if (!$test->hasExpectationOnOutput()) {
        $output = $test->output();
    }

    ini_set('xdebug.scream', '0');
    @rewind(STDOUT); /* @ as not every STDOUT target stream is rewindable */
    if ($stdout = @stream_get_contents(STDOUT)) {
        $output = $stdout . $output;
        $streamMetaData = stream_get_meta_data(STDOUT);
        if (!empty($streamMetaData['stream_type']) && 'STDIO' === $streamMetaData['stream_type']) {
            @ftruncate(STDOUT, 0);
            @rewind(STDOUT);
        }
    }

    print serialize(
      [
        'testResult'    => $test->result(),
        'codeCoverage'  => {collectCodeCoverageInformation} ? CodeCoverage::instance() : null,
        'numAssertions' => $test->numberOfAssertionsPerformed(),
        'result'        => $result,
        'output'        => $output
      ]
    );
}

$configurationFilePath = '{configurationFilePath}';

if ('' !== $configurationFilePath) {
    $configuration = (new Loader)->load($configurationFilePath);

    (new PhpHandler)->handle($configuration->php());

    unset($configuration);
}

function __phpunit_error_handler($errno, $errstr, $errfile, $errline)
{
   return true;
}

set_error_handler('__phpunit_error_handler');

{constants}
{included_files}
{globals}

restore_error_handler();

if (isset($GLOBALS['__PHPUNIT_BOOTSTRAP'])) {
    require_once $GLOBALS['__PHPUNIT_BOOTSTRAP'];
    unset($GLOBALS['__PHPUNIT_BOOTSTRAP']);
}

__phpunit_run_isolated_test();
<?php
use PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage;
use PHPUnit\SebastianBergmann\CodeCoverage\Driver\Selector;
use SebastianBergmann\CodeCoverage\Filter;

$composerAutoload = {composerAutoload};
$phar             = {phar};

ob_start();

$GLOBALS['__PHPUNIT_ISOLATION_EXCLUDE_LIST'][] = '{job}';

if ($composerAutoload) {
    require_once $composerAutoload;

    define('PHPUNIT_COMPOSER_INSTALL', $composerAutoload);
} else if ($phar) {
    require $phar;
}

{globals}
$coverage = null;

if (isset($GLOBALS['__PHPUNIT_BOOTSTRAP'])) {
    require_once $GLOBALS['__PHPUNIT_BOOTSTRAP'];
}

if (class_exists('PHPUnit\SebastianBergmann\CodeCoverage\CodeCoverage')) {
    $filter = new Filter;

    $coverage = new CodeCoverage(
        (new Selector)->{driverMethod}($filter),
        $filter
    );

    if ({codeCoverageCacheDirectory}) {
        $coverage->cacheStaticAnalysis({codeCoverageCacheDirectory});
    }

    $coverage->start(__FILE__);
}

register_shutdown_function(
    function() use ($coverage) {
        $output = null;

        if ($coverage) {
            $output = $coverage->stop();
        }

        file_put_contents('{coverageFile}', serialize($output));
    }
);

ob_end_clean();

require '{job}';
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\PHP;

use const PHP_MAJOR_VERSION;
use function tmpfile;
use PHPUnit\Framework\Exception;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 *
 * @see https://bugs.php.net/bug.php?id=51800
 */
final class WindowsPhpProcess extends \PHPUnit\Util\PHP\DefaultPhpProcess
{
    public function getCommand(array $settings, string $file = null) : string
    {
        if (\PHP_MAJOR_VERSION < 8) {
            return '"' . parent::getCommand($settings, $file) . '"';
        }
        return parent::getCommand($settings, $file);
    }
    /**
     * @throws Exception
     */
    protected function getHandles() : array
    {
        if (\false === ($stdout_handle = \tmpfile())) {
            throw new \PHPUnit\Framework\Exception('A temporary file could not be created; verify that your TEMP environment variable is writable');
        }
        return [1 => $stdout_handle];
    }
    protected function useTemporaryFile() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use const ENT_COMPAT;
use const ENT_SUBSTITUTE;
use const PHP_SAPI;
use function assert;
use function count;
use function dirname;
use function explode;
use function fclose;
use function fopen;
use function fsockopen;
use function fwrite;
use function htmlspecialchars;
use function is_resource;
use function is_string;
use function sprintf;
use function str_replace;
use function strncmp;
use function strpos;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class Printer
{
    /**
     * @psalm-var closed-resource|resource
     */
    private $stream;
    private bool $isPhpStream;
    /**
     * @param null|resource|string $out
     *
     * @throws Exception
     */
    public function __construct($out = null)
    {
        if (\is_resource($out)) {
            $this->stream = $out;
            return;
        }
        if (!\is_string($out)) {
            return;
        }
        if (\strpos($out, 'socket://') === 0) {
            $tmp = \explode(':', \str_replace('socket://', '', $out));
            if (\count($tmp) !== 2) {
                throw new \PHPUnit\Util\Exception(\sprintf('"%s" does not match "socket://hostname:port" format', $out));
            }
            $this->stream = \fsockopen($tmp[0], (int) $tmp[1]);
            return;
        }
        if (\strpos($out, 'php://') === \false && !\PHPUnit\Util\Filesystem::createDirectory(\dirname($out))) {
            throw new \PHPUnit\Util\Exception(\sprintf('Directory "%s" was not created', \dirname($out)));
        }
        $this->stream = \fopen($out, 'wb');
        $this->isPhpStream = \strncmp($out, 'php://', 6) !== 0;
    }
    public function write(string $buffer) : void
    {
        if ($this->stream) {
            \assert(\is_resource($this->stream));
            \fwrite($this->stream, $buffer);
        } else {
            if (\PHP_SAPI !== 'cli' && \PHP_SAPI !== 'phpdbg') {
                $buffer = \htmlspecialchars($buffer, \ENT_COMPAT | \ENT_SUBSTITUTE);
            }
            print $buffer;
        }
    }
    public function flush() : void
    {
        if ($this->stream && $this->isPhpStream) {
            \assert(\is_resource($this->stream));
            \fclose($this->stream);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use function preg_match;
use PHPUnit\Util\Error\Handler;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class RegularExpression
{
    /**
     * @return false|int
     */
    public static function safeMatch(string $pattern, string $subject)
    {
        return \PHPUnit\Util\Error\Handler::invokeIgnoringWarnings(static function () use($pattern, $subject) {
            return \preg_match($pattern, $subject);
        });
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use function array_merge;
use function array_unique;
use function strpos;
use PHPUnit\Framework\ExecutionOrderDependency;
use PHPUnit\Metadata\Annotation\Registry as AnnotationRegistry;
use PHPUnit\Metadata\Registry as MetadataRegistry;
use ReflectionMethod;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Test
{
    /**
     * @psalm-param class-string $className
     */
    public static function parseTestMethodAnnotations(string $className, ?string $methodName = '') : array
    {
        $registry = \PHPUnit\Metadata\Annotation\Registry::getInstance();
        if ($methodName !== null) {
            try {
                return ['method' => $registry->forMethod($className, $methodName)->symbolAnnotations(), 'class' => $registry->forClassName($className)->symbolAnnotations()];
            } catch (\PHPUnit\Util\Exception $methodNotFound) {
                // ignored
            }
        }
        return ['method' => null, 'class' => $registry->forClassName($className)->symbolAnnotations()];
    }
    /**
     * @psalm-param class-string $className
     *
     * @return ExecutionOrderDependency[]
     */
    public static function getDependencies(string $className, string $methodName) : array
    {
        $annotations = self::parseTestMethodAnnotations($className, $methodName);
        $dependsAnnotations = $annotations['class']['depends'] ?? [];
        if (isset($annotations['method']['depends'])) {
            $dependsAnnotations = \array_merge($dependsAnnotations, $annotations['method']['depends']);
        }
        // Normalize dependency name to className::methodName
        $dependencies = [];
        foreach ($dependsAnnotations as $value) {
            $dependencies[] = \PHPUnit\Framework\ExecutionOrderDependency::fromDependsAnnotation($className, $value);
        }
        return \array_unique($dependencies);
    }
    public static function isTestMethod(\ReflectionMethod $method) : bool
    {
        if (!$method->isPublic()) {
            return \false;
        }
        if (\strpos($method->getName(), 'test') === 0) {
            return \true;
        }
        $metadata = \PHPUnit\Metadata\Registry::parser()->forMethod($method->getDeclaringClass()->getName(), $method->getName());
        return $metadata->isTest()->isNotEmpty();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\TestDox;

use const PHP_EOL;
use function array_map;
use function ceil;
use function count;
use function explode;
use function get_class;
use function implode;
use function preg_match;
use function sprintf;
use function strlen;
use function strpos;
use function trim;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestFailure;
use PHPUnit\Framework\TestResult;
use PHPUnit\Framework\TestStatus\TestStatus;
use PHPUnit\Runner\PhptTestCase;
use PHPUnit\Util\Color;
use PHPUnit\SebastianBergmann\Timer\ResourceUsageFormatter;
use PHPUnit\SebastianBergmann\Timer\Timer;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class CliTestDoxPrinter extends \PHPUnit\Util\TestDox\TestDoxPrinter
{
    /**
     * The default Testdox left margin for messages is a vertical line.
     */
    private const PREFIX_SIMPLE = ['default' => '', 'start' => '', 'message' => '', 'diff' => '', 'trace' => '', 'last' => ''];
    /**
     * Colored Testdox use box-drawing for a more textured map of the message.
     */
    private const PREFIX_DECORATED = ['default' => '', 'start' => '', 'message' => '', 'diff' => '', 'trace' => '', 'last' => ''];
    private const SPINNER_ICONS = [" \33[36m\33[0m running tests", " \33[36m\33[0m running tests", " \33[36m\33[0m running tests", " \33[36m\33[0m running tests"];
    private const STATUS_STYLES = ['success' => ['symbol' => '', 'color' => 'fg-green'], 'error' => ['symbol' => '', 'color' => 'fg-yellow', 'message' => 'bg-yellow,fg-black'], 'failure' => ['symbol' => '', 'color' => 'fg-red', 'message' => 'bg-red,fg-white'], 'skipped' => ['symbol' => '', 'color' => 'fg-cyan', 'message' => 'fg-cyan'], 'risky' => ['symbol' => '', 'color' => 'fg-yellow', 'message' => 'fg-yellow'], 'incomplete' => ['symbol' => '', 'color' => 'fg-yellow', 'message' => 'fg-yellow'], 'warning' => ['symbol' => '', 'color' => 'fg-yellow', 'message' => 'fg-yellow'], 'unknown' => ['symbol' => '?', 'color' => 'fg-blue', 'message' => 'fg-white,bg-blue']];
    /**
     * @var int[]
     */
    private array $nonSuccessfulTestResults = [];
    private \PHPUnit\SebastianBergmann\Timer\Timer $timer;
    /**
     * @param null|resource|string $out
     * @param int|string           $numberOfColumns
     *
     * @throws \PHPUnit\Framework\Exception
     */
    public function __construct($out = null, bool $verbose = \false, string $colors = self::COLOR_DEFAULT, bool $debug = \false, $numberOfColumns = 80, bool $reverse = \false)
    {
        parent::__construct($out, $verbose, $colors, $debug, $numberOfColumns, $reverse);
        $this->timer = new \PHPUnit\SebastianBergmann\Timer\Timer();
        $this->timer->start();
    }
    public function printResult(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->printHeader($result);
        $this->printNonSuccessfulTestsSummary($result->count());
        $this->printFooter($result);
    }
    protected function printHeader(\PHPUnit\Framework\TestResult $result) : void
    {
        $this->write("\n" . (new \PHPUnit\SebastianBergmann\Timer\ResourceUsageFormatter())->resourceUsage($this->timer->stop()) . "\n\n");
    }
    protected function formatClassName(\PHPUnit\Framework\Test $test) : string
    {
        if ($test instanceof \PHPUnit\Framework\TestCase) {
            return $this->prettifier->prettifyTestClass(\get_class($test));
        }
        return \get_class($test);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function registerTestResult(\PHPUnit\Framework\Test $test, ?\Throwable $t, \PHPUnit\Framework\TestStatus\TestStatus $status, float $time, bool $verbose) : void
    {
        if (!$status->isSuccess()) {
            $this->nonSuccessfulTestResults[] = $this->testIndex;
        }
        parent::registerTestResult($test, $t, $status, $time, $verbose);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function formatTestName(\PHPUnit\Framework\Test $test) : string
    {
        if ($test instanceof \PHPUnit\Framework\TestCase) {
            return $this->prettifier->prettifyTestCase($test);
        }
        return parent::formatTestName($test);
    }
    protected function writeTestResult(array $prevResult, array $result) : void
    {
        // spacer line for new suite headers and after verbose messages
        if ($prevResult['testName'] !== '' && (!empty($prevResult['message']) || $prevResult['className'] !== $result['className'])) {
            $this->write(\PHP_EOL);
        }
        // suite header
        if ($prevResult['className'] !== $result['className']) {
            $this->write($this->colorizeTextBox('underlined', $result['className']) . \PHP_EOL);
        }
        // test result line
        if ($this->colors && $result['className'] === \PHPUnit\Runner\PhptTestCase::class) {
            $testName = \PHPUnit\Util\Color::colorizePath($result['testName'], $prevResult['testName'], \true);
        } else {
            $testName = $result['testMethod'];
        }
        $style = self::STATUS_STYLES[$result['status']->asString()];
        $line = \sprintf(' %s %s%s' . \PHP_EOL, $this->colorizeTextBox($style['color'], $style['symbol']), $testName, $this->verbose ? ' ' . $this->formatRuntime($result['time'], $style['color']) : '');
        $this->write($line);
        // additional information when verbose
        $this->write($result['message']);
    }
    protected function formatThrowable(\Throwable $t) : string
    {
        return \trim(\PHPUnit\Framework\TestFailure::exceptionToString($t));
    }
    protected function colorizeMessageAndDiff(string $style, string $buffer) : array
    {
        $lines = $buffer ? \array_map('\\rtrim', \explode(\PHP_EOL, $buffer)) : [];
        $message = [];
        $diff = [];
        $insideDiff = \false;
        foreach ($lines as $line) {
            if ($line === '--- Expected') {
                $insideDiff = \true;
            }
            if (!$insideDiff) {
                $message[] = $line;
            } else {
                if (\strpos($line, '-') === 0) {
                    $line = \PHPUnit\Util\Color::colorize('fg-red', \PHPUnit\Util\Color::visualizeWhitespace($line, \true));
                } elseif (\strpos($line, '+') === 0) {
                    $line = \PHPUnit\Util\Color::colorize('fg-green', \PHPUnit\Util\Color::visualizeWhitespace($line, \true));
                } elseif ($line === '@@ @@') {
                    $line = \PHPUnit\Util\Color::colorize('fg-cyan', $line);
                }
                $diff[] = $line;
            }
        }
        $diff = \implode(\PHP_EOL, $diff);
        if (!empty($message)) {
            $message = $this->colorizeTextBox($style, \implode(\PHP_EOL, $message));
        }
        return [$message, $diff];
    }
    protected function formatStacktrace(\Throwable $t) : string
    {
        $trace = \PHPUnit\Util\Filter::getFilteredStacktrace($t);
        if (!$this->colors) {
            return $trace;
        }
        $lines = [];
        $prevPath = '';
        foreach (\explode(\PHP_EOL, $trace) as $line) {
            if (\preg_match('/^(.*):(\\d+)$/', $line, $matches)) {
                $lines[] = \PHPUnit\Util\Color::colorizePath($matches[1], $prevPath) . \PHPUnit\Util\Color::dim(':') . \PHPUnit\Util\Color::colorize('fg-blue', $matches[2]) . "\n";
                $prevPath = $matches[1];
            } else {
                $lines[] = $line;
                $prevPath = '';
            }
        }
        return \implode('', $lines);
    }
    protected function formatTestResultMessage(\Throwable $t, array $result, ?string $prefix = null) : string
    {
        $message = $this->formatThrowable($t);
        $diff = '';
        if (!($this->verbose || $result['verbose'])) {
            return '';
        }
        if ($message && $this->colors) {
            $style = self::STATUS_STYLES[$result['status']->asString()]['message'] ?? '';
            [$message, $diff] = $this->colorizeMessageAndDiff($style, $message);
        }
        if ($prefix === null || !$this->colors) {
            $prefix = self::PREFIX_SIMPLE;
        }
        if ($this->colors) {
            $color = self::STATUS_STYLES[$result['status']->asString()]['color'] ?? '';
            $prefix = \array_map(static function ($p) use($color) {
                return \PHPUnit\Util\Color::colorize($color, $p);
            }, self::PREFIX_DECORATED);
        }
        $trace = $this->formatStacktrace($t);
        $out = $this->prefixLines($prefix['start'], \PHP_EOL) . \PHP_EOL;
        if ($message) {
            $out .= $this->prefixLines($prefix['message'], $message . \PHP_EOL) . \PHP_EOL;
        }
        if ($diff) {
            $out .= $this->prefixLines($prefix['diff'], $diff . \PHP_EOL) . \PHP_EOL;
        }
        if ($trace) {
            if ($message || $diff) {
                $out .= $this->prefixLines($prefix['default'], \PHP_EOL) . \PHP_EOL;
            }
            $out .= $this->prefixLines($prefix['trace'], $trace . \PHP_EOL) . \PHP_EOL;
        }
        $out .= $this->prefixLines($prefix['last'], \PHP_EOL) . \PHP_EOL;
        return $out;
    }
    protected function drawSpinner() : void
    {
        if ($this->colors) {
            $id = $this->spinState % \count(self::SPINNER_ICONS);
            $this->write(self::SPINNER_ICONS[$id]);
        }
    }
    protected function undrawSpinner() : void
    {
        if ($this->colors) {
            $id = $this->spinState % \count(self::SPINNER_ICONS);
            $this->write("\33[1K\33[" . \strlen(self::SPINNER_ICONS[$id]) . 'D');
        }
    }
    private function formatRuntime(float $time, string $color = '') : string
    {
        if (!$this->colors) {
            return \sprintf('[%.2f ms]', $time * 1000);
        }
        if ($time > 1) {
            $color = 'fg-magenta';
        }
        return \PHPUnit\Util\Color::colorize($color, ' ' . (int) \ceil($time * 1000) . ' ' . \PHPUnit\Util\Color::dim('ms'));
    }
    private function printNonSuccessfulTestsSummary(int $numberOfExecutedTests) : void
    {
        if (empty($this->nonSuccessfulTestResults)) {
            return;
        }
        if (\count($this->nonSuccessfulTestResults) / $numberOfExecutedTests >= 0.7) {
            return;
        }
        $this->write("Summary of non-successful tests:\n\n");
        $prevResult = $this->getEmptyTestResult();
        foreach ($this->nonSuccessfulTestResults as $testIndex) {
            $result = $this->testResults[$testIndex];
            $this->writeTestResult($prevResult, $result);
            $prevResult = $result;
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\TestDox;

use function sprintf;
use PHPUnit\Framework\TestResult;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class HtmlResultPrinter extends \PHPUnit\Util\TestDox\ResultPrinter
{
    /**
     * @var string
     */
    private const PAGE_HEADER = <<<'EOT'
<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>Test Documentation</title>
        <style>
            body {
                text-rendering: optimizeLegibility;
                font-variant-ligatures: common-ligatures;
                font-kerning: normal;
                margin-left: 2em;
            }

            body > ul > li {
                font-family: Source Serif Pro, PT Sans, Trebuchet MS, Helvetica, Arial;
                font-size: 2em;
            }

            h2 {
                font-family: Tahoma, Helvetica, Arial;
                font-size: 3em;
            }

            ul {
                list-style: none;
                margin-bottom: 1em;
            }
        </style>
    </head>
    <body>
EOT;
    /**
     * @var string
     */
    private const CLASS_HEADER = <<<'EOT'

        <h2 id="%s">%s</h2>
        <ul>

EOT;
    /**
     * @var string
     */
    private const CLASS_FOOTER = <<<'EOT'
        </ul>
EOT;
    /**
     * @var string
     */
    private const PAGE_FOOTER = <<<'EOT'

    </body>
</html>
EOT;
    public function printResult(\PHPUnit\Framework\TestResult $result) : void
    {
    }
    /**
     * Handler for 'start run' event.
     */
    protected function startRun() : void
    {
        $this->write(self::PAGE_HEADER);
    }
    /**
     * Handler for 'start class' event.
     */
    protected function startClass(string $name) : void
    {
        $this->write(\sprintf(self::CLASS_HEADER, $name, $this->currentTestClassPrettified));
    }
    /**
     * Handler for 'on test' event.
     */
    protected function onTest(string $name, bool $success = \true) : void
    {
        $this->write(\sprintf("            <li style=\"color: %s;\">%s %s</li>\n", $success ? '#555753' : '#ef2929', $success ? '' : '', $name));
    }
    /**
     * Handler for 'end class' event.
     */
    protected function endClass(string $name) : void
    {
        $this->write(self::CLASS_FOOTER);
    }
    /**
     * Handler for 'end run' event.
     */
    protected function endRun() : void
    {
        $this->write(self::PAGE_FOOTER);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\TestDox;

use function array_key_exists;
use function array_keys;
use function array_map;
use function array_pop;
use function array_values;
use function class_exists;
use function explode;
use function get_class;
use function gettype;
use function implode;
use function in_array;
use function is_bool;
use function is_float;
use function is_int;
use function is_numeric;
use function is_object;
use function is_scalar;
use function is_string;
use function mb_strtolower;
use function ord;
use function preg_quote;
use function preg_replace;
use function range;
use function sprintf;
use function str_replace;
use function strlen;
use function strpos;
use function strtolower;
use function strtoupper;
use function substr;
use function trim;
use PHPUnit\Framework\TestCase;
use PHPUnit\Metadata\Registry as MetadataRegistry;
use PHPUnit\Util\Color;
use PHPUnit\Util\Exception as UtilException;
use ReflectionException;
use ReflectionMethod;
use ReflectionObject;
use PHPUnit\SebastianBergmann\Exporter\Exporter;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class NamePrettifier
{
    /**
     * @var string[]
     */
    private array $strings = [];
    private bool $useColor;
    public function __construct(bool $useColor = \false)
    {
        $this->useColor = $useColor;
    }
    /**
     * Prettifies the name of a test class.
     *
     * @psalm-param class-string $className
     */
    public function prettifyTestClass(string $className) : string
    {
        if (\class_exists($className)) {
            $metadata = \PHPUnit\Metadata\Registry::parser()->forClass($className);
            if ($metadata->isTestDox()->isNotEmpty()) {
                return $metadata->isTestDox()->asArray()[0]->text();
            }
        }
        $parts = \explode('\\', $className);
        $className = \array_pop($parts);
        if (\substr($className, -1 * \strlen('Test')) === 'Test') {
            $className = \substr($className, 0, \strlen($className) - \strlen('Test'));
        }
        if (\strpos($className, 'Tests') === 0) {
            $className = \substr($className, \strlen('Tests'));
        } elseif (\strpos($className, 'Test') === 0) {
            $className = \substr($className, \strlen('Test'));
        }
        if (empty($className)) {
            $className = 'UnnamedTests';
        }
        if (!empty($parts)) {
            $parts[] = $className;
            $fullyQualifiedName = \implode('\\', $parts);
        } else {
            $fullyQualifiedName = $className;
        }
        $result = '';
        $wasLowerCase = \false;
        foreach (\range(0, \strlen($className) - 1) as $i) {
            $isLowerCase = \mb_strtolower($className[$i], 'UTF-8') === $className[$i];
            if ($wasLowerCase && !$isLowerCase) {
                $result .= ' ';
            }
            $result .= $className[$i];
            if ($isLowerCase) {
                $wasLowerCase = \true;
            } else {
                $wasLowerCase = \false;
            }
        }
        if ($fullyQualifiedName !== $className) {
            return $result . ' (' . $fullyQualifiedName . ')';
        }
        return $result;
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function prettifyTestCase(\PHPUnit\Framework\TestCase $test) : string
    {
        $annotationWithPlaceholders = \false;
        $metadata = \PHPUnit\Metadata\Registry::parser()->forMethod(\get_class($test), $test->getName(\false));
        if ($metadata->isTestDox()->isNotEmpty()) {
            $result = $metadata->isTestDox()->asArray()[0]->text();
            if (\strpos($result, '$') !== \false) {
                $annotation = $result;
                $providedData = $this->mapTestMethodParameterNamesToProvidedDataValues($test);
                $variables = \array_map(static function (string $variable) : string {
                    return \sprintf('/%s(?=\\b)/', \preg_quote($variable, '/'));
                }, \array_keys($providedData));
                $result = \trim(\preg_replace($variables, $providedData, $annotation));
                $annotationWithPlaceholders = \true;
            }
        } else {
            $result = $this->prettifyTestMethod($test->getName(\false));
        }
        if (!$annotationWithPlaceholders && $test->usesDataProvider()) {
            $result .= $this->prettifyDataSet($test);
        }
        return $result;
    }
    public function prettifyDataSet(\PHPUnit\Framework\TestCase $test) : string
    {
        if (!$this->useColor) {
            return $test->getDataSetAsString();
        }
        if (\is_int($test->dataName())) {
            $data = \PHPUnit\Util\Color::dim(' with data set ') . \PHPUnit\Util\Color::colorize('fg-cyan', (string) $test->dataName());
        } else {
            $data = \PHPUnit\Util\Color::dim(' with ') . \PHPUnit\Util\Color::colorize('fg-cyan', \PHPUnit\Util\Color::visualizeWhitespace((string) $test->dataName()));
        }
        return $data;
    }
    /**
     * Prettifies the name of a test method.
     */
    public function prettifyTestMethod(string $name) : string
    {
        $buffer = '';
        if ($name === '') {
            return $buffer;
        }
        $string = (string) \preg_replace('#\\d+$#', '', $name, -1, $count);
        if (\in_array($string, $this->strings, \true)) {
            $name = $string;
        } elseif ($count === 0) {
            $this->strings[] = $string;
        }
        if (\strpos($name, 'test_') === 0) {
            $name = \substr($name, 5);
        } elseif (\strpos($name, 'test') === 0) {
            $name = \substr($name, 4);
        }
        if ($name === '') {
            return $buffer;
        }
        $name[0] = \strtoupper($name[0]);
        if (\strpos($name, '_') !== \false) {
            return \trim(\str_replace('_', ' ', $name));
        }
        $wasNumeric = \false;
        foreach (\range(0, \strlen($name) - 1) as $i) {
            if ($i > 0 && \ord($name[$i]) >= 65 && \ord($name[$i]) <= 90) {
                $buffer .= ' ' . \strtolower($name[$i]);
            } else {
                $isNumeric = \is_numeric($name[$i]);
                if (!$wasNumeric && $isNumeric) {
                    $buffer .= ' ';
                    $wasNumeric = \true;
                }
                if ($wasNumeric && !$isNumeric) {
                    $wasNumeric = \false;
                }
                $buffer .= $name[$i];
            }
        }
        return $buffer;
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    private function mapTestMethodParameterNamesToProvidedDataValues(\PHPUnit\Framework\TestCase $test) : array
    {
        try {
            $reflector = new \ReflectionMethod(\get_class($test), $test->getName(\false));
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
        $providedData = [];
        $providedDataValues = \array_values($test->getProvidedData());
        $i = 0;
        $providedData['$_dataName'] = $test->dataName();
        foreach ($reflector->getParameters() as $parameter) {
            if (!\array_key_exists($i, $providedDataValues) && $parameter->isDefaultValueAvailable()) {
                try {
                    $providedDataValues[$i] = $parameter->getDefaultValue();
                    // @codeCoverageIgnoreStart
                } catch (\ReflectionException $e) {
                    throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
                }
                // @codeCoverageIgnoreEnd
            }
            $value = $providedDataValues[$i++] ?? null;
            if (\is_object($value)) {
                $reflector = new \ReflectionObject($value);
                if ($reflector->hasMethod('__toString')) {
                    $value = (string) $value;
                } else {
                    $value = \get_class($value);
                }
            }
            if (!\is_scalar($value)) {
                $value = \gettype($value);
            }
            if (\is_bool($value) || \is_int($value) || \is_float($value)) {
                $value = (new \PHPUnit\SebastianBergmann\Exporter\Exporter())->export($value);
            }
            if (\is_string($value) && $value === '') {
                if ($this->useColor) {
                    $value = \PHPUnit\Util\Color::colorize('dim,underlined', 'empty');
                } else {
                    $value = "''";
                }
            }
            $providedData['$' . $parameter->getName()] = $value;
        }
        if ($this->useColor) {
            $providedData = \array_map(static function ($value) {
                return \PHPUnit\Util\Color::colorize('fg-cyan', \PHPUnit\Util\Color::visualizeWhitespace((string) $value, \true));
            }, $providedData);
        }
        return $providedData;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\TestDox;

use function get_class;
use function in_array;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\ErrorTestCase;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestStatus\TestStatus;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\Warning;
use PHPUnit\Framework\WarningTestCase;
use PHPUnit\TextUI\ResultPrinter as ResultPrinterInterface;
use PHPUnit\Util\Printer;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
abstract class ResultPrinter extends \PHPUnit\Util\Printer implements \PHPUnit\TextUI\ResultPrinter
{
    protected \PHPUnit\Util\TestDox\NamePrettifier $prettifier;
    /**
     * @psalm-var class-string
     */
    protected ?string $testClass = null;
    protected ?\PHPUnit\Framework\TestStatus\TestStatus $testStatus = null;
    protected array $tests = [];
    protected int $successful = 0;
    protected int $warned = 0;
    protected int $failed = 0;
    protected int $risky = 0;
    protected int $skipped = 0;
    protected int $incomplete = 0;
    protected ?string $currentTestClassPrettified = null;
    protected ?string $currentTestMethodPrettified = null;
    private array $groups;
    private array $excludeGroups;
    /**
     * @param resource $out
     *
     * @throws \PHPUnit\Framework\Exception
     */
    public function __construct($out = null, array $groups = [], array $excludeGroups = [])
    {
        parent::__construct($out);
        $this->groups = $groups;
        $this->excludeGroups = $excludeGroups;
        $this->prettifier = new \PHPUnit\Util\TestDox\NamePrettifier();
        $this->startRun();
    }
    /**
     * Flush buffer and close output.
     */
    public function flush() : void
    {
        $this->doEndClass();
        $this->endRun();
        parent::flush();
    }
    /**
     * An error occurred.
     */
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $this->testStatus = \PHPUnit\Framework\TestStatus\TestStatus::error();
        $this->failed++;
    }
    /**
     * A warning occurred.
     */
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $this->testStatus = \PHPUnit\Framework\TestStatus\TestStatus::warning();
        $this->warned++;
    }
    /**
     * A failure occurred.
     */
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $this->testStatus = \PHPUnit\Framework\TestStatus\TestStatus::failure();
        $this->failed++;
    }
    /**
     * Incomplete test.
     */
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $this->testStatus = \PHPUnit\Framework\TestStatus\TestStatus::incomplete();
        $this->incomplete++;
    }
    /**
     * Risky test.
     */
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $this->testStatus = \PHPUnit\Framework\TestStatus\TestStatus::risky();
        $this->risky++;
    }
    /**
     * Skipped test.
     */
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $this->testStatus = \PHPUnit\Framework\TestStatus\TestStatus::skipped();
        $this->skipped++;
    }
    /**
     * A testsuite started.
     */
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
    }
    /**
     * A testsuite ended.
     */
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
    }
    /**
     * A test started.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function startTest(\PHPUnit\Framework\Test $test) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $class = \get_class($test);
        if ($this->testClass !== $class) {
            if ($this->testClass !== null) {
                $this->doEndClass();
            }
            $this->currentTestClassPrettified = $this->prettifier->prettifyTestClass($class);
            $this->testClass = $class;
            $this->tests = [];
            $this->startClass($class);
        }
        if ($test instanceof \PHPUnit\Framework\TestCase) {
            $this->currentTestMethodPrettified = $this->prettifier->prettifyTestCase($test);
        }
        $this->testStatus = \PHPUnit\Framework\TestStatus\TestStatus::success();
    }
    /**
     * A test ended.
     */
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        if (!$this->isOfInterest($test)) {
            return;
        }
        $this->tests[] = [$this->currentTestMethodPrettified, $this->testStatus];
        $this->currentTestClassPrettified = null;
        $this->currentTestMethodPrettified = null;
    }
    protected function doEndClass() : void
    {
        foreach ($this->tests as $test) {
            $this->onTest($test[0], $test[1]->isSuccess());
        }
        $this->endClass((string) $this->testClass);
    }
    /**
     * Handler for 'start run' event.
     */
    protected function startRun() : void
    {
    }
    /**
     * Handler for 'start class' event.
     */
    protected function startClass(string $name) : void
    {
    }
    /**
     * Handler for 'on test' event.
     */
    protected function onTest(string $name, bool $success = \true) : void
    {
    }
    /**
     * Handler for 'end class' event.
     */
    protected function endClass(string $name) : void
    {
    }
    /**
     * Handler for 'end run' event.
     */
    protected function endRun() : void
    {
    }
    private function isOfInterest(\PHPUnit\Framework\Test $test) : bool
    {
        if (!$test instanceof \PHPUnit\Framework\TestCase) {
            return \false;
        }
        if ($test instanceof \PHPUnit\Framework\ErrorTestCase || $test instanceof \PHPUnit\Framework\WarningTestCase) {
            return \false;
        }
        if (!empty($this->groups)) {
            foreach ($test->groups() as $group) {
                if (\in_array($group, $this->groups, \true)) {
                    return \true;
                }
            }
            return \false;
        }
        if (!empty($this->excludeGroups)) {
            foreach ($test->groups() as $group) {
                if (\in_array($group, $this->excludeGroups, \true)) {
                    return \false;
                }
            }
            return \true;
        }
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\TestDox;

use const PHP_EOL;
use function array_map;
use function get_class;
use function implode;
use function method_exists;
use function preg_split;
use function trim;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\Reorderable;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestFailure;
use PHPUnit\Framework\TestResult;
use PHPUnit\Framework\TestStatus\TestStatus;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\Warning;
use PHPUnit\Runner\PhptTestCase;
use PHPUnit\TextUI\DefaultResultPrinter;
use PHPUnit\Util\Filter;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
class TestDoxPrinter extends \PHPUnit\TextUI\DefaultResultPrinter
{
    protected \PHPUnit\Util\TestDox\NamePrettifier $prettifier;
    /**
     * @var int The number of test results received from the TestRunner
     */
    protected int $testIndex = 0;
    /**
     * @var int The number of test results already sent to the output
     */
    protected int $testFlushIndex = 0;
    /**
     * @var array<int, array> Buffer for test results
     */
    protected array $testResults = [];
    /**
     * @var array<string, int> Lookup table for testname to testResults[index]
     */
    protected array $testNameResultIndex = [];
    protected bool $enableOutputBuffer = \false;
    /**
     * @var array array<string>
     */
    protected array $originalExecutionOrder = [];
    protected int $spinState = 0;
    protected bool $showProgress = \true;
    /**
     * @param null|resource|string $out
     * @param int|string           $numberOfColumns
     *
     * @throws \PHPUnit\Framework\Exception
     */
    public function __construct($out = null, bool $verbose = \false, string $colors = self::COLOR_DEFAULT, bool $debug = \false, $numberOfColumns = 80, bool $reverse = \false)
    {
        parent::__construct($out, $verbose, $colors, $debug, $numberOfColumns, $reverse);
        $this->prettifier = new \PHPUnit\Util\TestDox\NamePrettifier($this->colors);
    }
    public function setOriginalExecutionOrder(array $order) : void
    {
        $this->originalExecutionOrder = $order;
        $this->enableOutputBuffer = !empty($order);
    }
    public function setShowProgressAnimation(bool $showProgress) : void
    {
        $this->showProgress = $showProgress;
    }
    public function printResult(\PHPUnit\Framework\TestResult $result) : void
    {
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        if (!$test instanceof \PHPUnit\Framework\TestCase && !$test instanceof \PHPUnit\Runner\PhptTestCase && !$test instanceof \PHPUnit\Framework\TestSuite) {
            return;
        }
        if ($this->testHasPassed()) {
            $this->registerTestResult($test, null, \PHPUnit\Framework\TestStatus\TestStatus::success(), $time, \false);
        }
        if ($test instanceof \PHPUnit\Framework\TestCase || $test instanceof \PHPUnit\Runner\PhptTestCase) {
            $this->testIndex++;
        }
        parent::endTest($test, $time);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->registerTestResult($test, $t, \PHPUnit\Framework\TestStatus\TestStatus::error(), $time, \true);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
        $this->registerTestResult($test, $e, \PHPUnit\Framework\TestStatus\TestStatus::warning(), $time, \true);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        $this->registerTestResult($test, $e, \PHPUnit\Framework\TestStatus\TestStatus::failure(), $time, \true);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->registerTestResult($test, $t, \PHPUnit\Framework\TestStatus\TestStatus::incomplete(), $time, \false);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->registerTestResult($test, $t, \PHPUnit\Framework\TestStatus\TestStatus::risky(), $time, \false);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->registerTestResult($test, $t, \PHPUnit\Framework\TestStatus\TestStatus::skipped(), $time, \false);
    }
    public function writeProgress(string $progress) : void
    {
        $this->flushOutputBuffer();
    }
    public function flush() : void
    {
        $this->flushOutputBuffer(\true);
    }
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    protected function registerTestResult(\PHPUnit\Framework\Test $test, ?\Throwable $t, \PHPUnit\Framework\TestStatus\TestStatus $status, float $time, bool $verbose) : void
    {
        $testName = $test instanceof \PHPUnit\Framework\Reorderable ? $test->sortId() : $test->getName();
        $result = ['className' => $this->formatClassName($test), 'testName' => $testName, 'testMethod' => $this->formatTestName($test), 'message' => '', 'status' => $status, 'time' => $time, 'verbose' => $verbose];
        if ($t !== null) {
            $result['message'] = $this->formatTestResultMessage($t, $result);
        }
        $this->testResults[$this->testIndex] = $result;
        $this->testNameResultIndex[$testName] = $this->testIndex;
    }
    protected function formatTestName(\PHPUnit\Framework\Test $test) : string
    {
        return \method_exists($test, 'getName') ? $test->getName() : '';
    }
    protected function formatClassName(\PHPUnit\Framework\Test $test) : string
    {
        return \get_class($test);
    }
    protected function testHasPassed() : bool
    {
        if (!isset($this->testResults[$this->testIndex]['status'])) {
            return \true;
        }
        if ($this->testResults[$this->testIndex]['status']->isSuccess()) {
            return \true;
        }
        return \false;
    }
    protected function flushOutputBuffer(bool $forceFlush = \false) : void
    {
        if ($this->testFlushIndex === $this->testIndex) {
            return;
        }
        if ($this->testFlushIndex > 0) {
            if ($this->enableOutputBuffer && isset($this->originalExecutionOrder[$this->testFlushIndex - 1])) {
                $prevResult = $this->getTestResultByName($this->originalExecutionOrder[$this->testFlushIndex - 1]);
            } else {
                $prevResult = $this->testResults[$this->testFlushIndex - 1];
            }
        } else {
            $prevResult = $this->getEmptyTestResult();
        }
        if (!$this->enableOutputBuffer) {
            $this->writeTestResult($prevResult, $this->testResults[$this->testFlushIndex++]);
        } else {
            do {
                $flushed = \false;
                if (!$forceFlush && isset($this->originalExecutionOrder[$this->testFlushIndex])) {
                    $result = $this->getTestResultByName($this->originalExecutionOrder[$this->testFlushIndex]);
                } else {
                    // This test(name) cannot found in original execution order,
                    // flush result to output stream right away
                    $result = $this->testResults[$this->testFlushIndex];
                }
                if (!empty($result)) {
                    $this->hideSpinner();
                    $this->writeTestResult($prevResult, $result);
                    $this->testFlushIndex++;
                    $prevResult = $result;
                    $flushed = \true;
                } else {
                    $this->showSpinner();
                }
            } while ($flushed && $this->testFlushIndex < $this->testIndex);
        }
    }
    protected function showSpinner() : void
    {
        if (!$this->showProgress) {
            return;
        }
        if ($this->spinState) {
            $this->undrawSpinner();
        }
        $this->spinState++;
        $this->drawSpinner();
    }
    protected function hideSpinner() : void
    {
        if (!$this->showProgress) {
            return;
        }
        if ($this->spinState) {
            $this->undrawSpinner();
        }
        $this->spinState = 0;
    }
    protected function drawSpinner() : void
    {
        // optional for CLI printers: show the user a 'buffering output' spinner
    }
    protected function undrawSpinner() : void
    {
        // remove the spinner from the current line
    }
    protected function writeTestResult(array $prevResult, array $result) : void
    {
    }
    protected function getEmptyTestResult() : array
    {
        return ['className' => '', 'testName' => '', 'message' => '', 'failed' => '', 'verbose' => ''];
    }
    protected function getTestResultByName(?string $testName) : array
    {
        if (isset($this->testNameResultIndex[$testName])) {
            return $this->testResults[$this->testNameResultIndex[$testName]];
        }
        return [];
    }
    protected function formatThrowable(\Throwable $t) : string
    {
        $message = \trim(\PHPUnit\Framework\TestFailure::exceptionToString($t));
        if ($message) {
            $message .= \PHP_EOL . \PHP_EOL . $this->formatStacktrace($t);
        } else {
            $message = $this->formatStacktrace($t);
        }
        return $message;
    }
    protected function formatStacktrace(\Throwable $t) : string
    {
        return \PHPUnit\Util\Filter::getFilteredStacktrace($t);
    }
    protected function formatTestResultMessage(\Throwable $t, array $result, string $prefix = '') : string
    {
        $message = $this->formatThrowable($t);
        if ($message === '') {
            return '';
        }
        if (!($this->verbose || $result['verbose'])) {
            return '';
        }
        return $this->prefixLines($prefix, $message);
    }
    protected function prefixLines(string $prefix, string $message) : string
    {
        $message = \trim($message);
        return \implode(\PHP_EOL, \array_map(static function (string $text) use($prefix) {
            return '   ' . $prefix . ($text ? ' ' . $text : '');
        }, \preg_split('/\\r\\n|\\r|\\n/', $message)));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\TestDox;

use PHPUnit\Framework\TestResult;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TextResultPrinter extends \PHPUnit\Util\TestDox\ResultPrinter
{
    public function printResult(\PHPUnit\Framework\TestResult $result) : void
    {
    }
    /**
     * Handler for 'start class' event.
     */
    protected function startClass(string $name) : void
    {
        $this->write($this->currentTestClassPrettified . "\n");
    }
    /**
     * Handler for 'on test' event.
     */
    protected function onTest(string $name, bool $success = \true) : void
    {
        if ($success) {
            $this->write(' [x] ');
        } else {
            $this->write(' [ ] ');
        }
        $this->write($name . "\n");
    }
    /**
     * Handler for 'end class' event.
     */
    protected function endClass(string $name) : void
    {
        $this->write("\n");
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\TestDox;

use function array_filter;
use function assert;
use function get_class;
use function strpos;
use DOMDocument;
use DOMElement;
use PHPUnit\Framework\AssertionFailedError;
use PHPUnit\Framework\Exception;
use PHPUnit\Framework\Test;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestListener;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Framework\Warning;
use PHPUnit\Framework\WarningTestCase;
use PHPUnit\Metadata\Covers;
use PHPUnit\Metadata\CoversClass;
use PHPUnit\Metadata\CoversFunction;
use PHPUnit\Metadata\CoversMethod;
use PHPUnit\Metadata\InlineAnnotationParser;
use PHPUnit\Metadata\Registry as MetadataRegistry;
use PHPUnit\Metadata\Uses;
use PHPUnit\Metadata\UsesClass;
use PHPUnit\Metadata\UsesFunction;
use PHPUnit\Metadata\UsesMethod;
use PHPUnit\Util\Printer;
use ReflectionClass;
use ReflectionException;
use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class XmlResultPrinter extends \PHPUnit\Util\Printer implements \PHPUnit\Framework\TestListener
{
    private \DOMDocument $document;
    private \DOMElement $root;
    private \PHPUnit\Util\TestDox\NamePrettifier $prettifier;
    private ?\Throwable $exception = null;
    /**
     * @param resource|string $out
     *
     * @throws Exception
     */
    public function __construct($out = null)
    {
        $this->document = new \DOMDocument('1.0', 'UTF-8');
        $this->document->formatOutput = \true;
        $this->root = $this->document->createElement('tests');
        $this->document->appendChild($this->root);
        $this->prettifier = new \PHPUnit\Util\TestDox\NamePrettifier();
        parent::__construct($out);
    }
    /**
     * Flush buffer and close output.
     */
    public function flush() : void
    {
        $this->write($this->document->saveXML());
        parent::flush();
    }
    /**
     * An error occurred.
     */
    public function addError(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
        $this->exception = $t;
    }
    /**
     * A warning occurred.
     */
    public function addWarning(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\Warning $e, float $time) : void
    {
    }
    /**
     * A failure occurred.
     */
    public function addFailure(\PHPUnit\Framework\Test $test, \PHPUnit\Framework\AssertionFailedError $e, float $time) : void
    {
        $this->exception = $e;
    }
    /**
     * Incomplete test.
     */
    public function addIncompleteTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
    }
    /**
     * Risky test.
     */
    public function addRiskyTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
    }
    /**
     * Skipped test.
     */
    public function addSkippedTest(\PHPUnit\Framework\Test $test, \Throwable $t, float $time) : void
    {
    }
    /**
     * A test suite started.
     */
    public function startTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
    }
    /**
     * A test suite ended.
     */
    public function endTestSuite(\PHPUnit\Framework\TestSuite $suite) : void
    {
    }
    /**
     * A test started.
     */
    public function startTest(\PHPUnit\Framework\Test $test) : void
    {
        $this->exception = null;
    }
    /**
     * A test ended.
     *
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function endTest(\PHPUnit\Framework\Test $test, float $time) : void
    {
        if (!$test instanceof \PHPUnit\Framework\TestCase || $test instanceof \PHPUnit\Framework\WarningTestCase) {
            return;
        }
        $groups = \array_filter($test->groups(), static function ($group) {
            return !($group === 'small' || $group === 'medium' || $group === 'large' || \strpos($group, '__phpunit_') === 0);
        });
        $testNode = $this->document->createElement('test');
        $testNode->setAttribute('className', \get_class($test));
        $testNode->setAttribute('methodName', $test->getName());
        $testNode->setAttribute('prettifiedClassName', $this->prettifier->prettifyTestClass(\get_class($test)));
        $testNode->setAttribute('prettifiedMethodName', $this->prettifier->prettifyTestCase($test));
        $testNode->setAttribute('status', $test->status()->asString());
        $testNode->setAttribute('time', (string) $time);
        $testNode->setAttribute('size', $test->size()->asString());
        foreach ($groups as $group) {
            $groupNode = $this->document->createElement('group');
            $groupNode->setAttribute('name', $group);
            $testNode->appendChild($groupNode);
        }
        foreach (\PHPUnit\Metadata\Registry::parser()->forClassAndMethod(\get_class($test), $test->getName(\false)) as $metadata) {
            if ($metadata->isCovers()) {
                \assert($metadata instanceof \PHPUnit\Metadata\Covers);
                $coversNode = $this->document->createElement('covers');
                $coversNode->setAttribute('target', $metadata->target());
                $testNode->appendChild($coversNode);
            }
            if ($metadata->isCoversClass()) {
                \assert($metadata instanceof \PHPUnit\Metadata\CoversClass);
                $coversNode = $this->document->createElement('covers');
                $coversNode->setAttribute('target', $metadata->className());
                $testNode->appendChild($coversNode);
            }
            if ($metadata->isCoversMethod()) {
                \assert($metadata instanceof \PHPUnit\Metadata\CoversMethod);
                $coversNode = $this->document->createElement('covers');
                $coversNode->setAttribute('target', $metadata->className() . '::' . $metadata->methodName());
                $testNode->appendChild($coversNode);
            }
            if ($metadata->isCoversFunction()) {
                \assert($metadata instanceof \PHPUnit\Metadata\CoversFunction);
                $coversNode = $this->document->createElement('covers');
                $coversNode->setAttribute('target', $metadata->functionName());
                $testNode->appendChild($coversNode);
            }
            if ($metadata->isUses()) {
                \assert($metadata instanceof \PHPUnit\Metadata\Uses);
                $coversNode = $this->document->createElement('uses');
                $coversNode->setAttribute('target', $metadata->target());
                $testNode->appendChild($coversNode);
            }
            if ($metadata->isUsesClass()) {
                \assert($metadata instanceof \PHPUnit\Metadata\UsesClass);
                $coversNode = $this->document->createElement('uses');
                $coversNode->setAttribute('target', $metadata->className());
                $testNode->appendChild($coversNode);
            }
            if ($metadata->isUsesMethod()) {
                \assert($metadata instanceof \PHPUnit\Metadata\UsesMethod);
                $coversNode = $this->document->createElement('uses');
                $coversNode->setAttribute('target', $metadata->className() . '::' . $metadata->methodName());
                $testNode->appendChild($coversNode);
            }
            if ($metadata->isUsesFunction()) {
                \assert($metadata instanceof \PHPUnit\Metadata\UsesFunction);
                $coversNode = $this->document->createElement('uses');
                $coversNode->setAttribute('target', $metadata->functionName());
                $testNode->appendChild($coversNode);
            }
        }
        foreach ($test->doubledTypes() as $doubledType) {
            $testDoubleNode = $this->document->createElement('testDouble');
            $testDoubleNode->setAttribute('type', $doubledType);
            $testNode->appendChild($testDoubleNode);
        }
        $inlineAnnotations = (new \PHPUnit\Metadata\InlineAnnotationParser())->parse(\get_class($test), $test->getName(\false));
        if (isset($inlineAnnotations['given'], $inlineAnnotations['when'], $inlineAnnotations['then'])) {
            $testNode->setAttribute('given', $inlineAnnotations['given']['value']);
            $testNode->setAttribute('givenStartLine', (string) $inlineAnnotations['given']['line']);
            $testNode->setAttribute('when', $inlineAnnotations['when']['value']);
            $testNode->setAttribute('whenStartLine', (string) $inlineAnnotations['when']['line']);
            $testNode->setAttribute('then', $inlineAnnotations['then']['value']);
            $testNode->setAttribute('thenStartLine', (string) $inlineAnnotations['then']['line']);
        }
        if ($this->exception !== null) {
            if ($this->exception instanceof \PHPUnit\Framework\Exception) {
                $steps = $this->exception->getSerializableTrace();
            } else {
                $steps = $this->exception->getTrace();
            }
            try {
                $file = (new \ReflectionClass($test))->getFileName();
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\Framework\Exception($e->getMessage(), (int) $e->getCode(), $e);
            }
            // @codeCoverageIgnoreEnd
            foreach ($steps as $step) {
                if (isset($step['file']) && $step['file'] === $file) {
                    $testNode->setAttribute('exceptionLine', (string) $step['line']);
                    break;
                }
            }
            $testNode->setAttribute('exceptionMessage', $this->exception->getMessage());
        }
        $this->root->appendChild($testNode);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use const PHP_EOL;
use function get_class;
use function sprintf;
use function str_replace;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Runner\PhptTestCase;
use RecursiveIteratorIterator;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class TextTestListRenderer
{
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function render(\PHPUnit\Framework\TestSuite $suite) : string
    {
        $buffer = 'Available test(s):' . \PHP_EOL;
        foreach (new \RecursiveIteratorIterator($suite->getIterator()) as $test) {
            if ($test instanceof \PHPUnit\Framework\TestCase) {
                $name = \sprintf('%s::%s', \get_class($test), \str_replace(' with data set ', '', $test->getName()));
            } elseif ($test instanceof \PHPUnit\Runner\PhptTestCase) {
                $name = $test->getName();
            } else {
                continue;
            }
            $buffer .= \sprintf(' - %s' . \PHP_EOL, $name);
        }
        return $buffer;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use Throwable;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Type
{
    public static function isType(string $type) : bool
    {
        switch ($type) {
            case 'numeric':
            case 'integer':
            case 'int':
            case 'iterable':
            case 'float':
            case 'string':
            case 'boolean':
            case 'bool':
            case 'null':
            case 'array':
            case 'object':
            case 'resource':
            case 'scalar':
                return \true;
            default:
                return \false;
        }
    }
    public static function isCloneable(object $object) : bool
    {
        try {
            $clone = clone $object;
        } catch (\Throwable $t) {
            return \false;
        }
        return $clone instanceof $object;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use function in_array;
use function sprintf;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 * @psalm-immutable
 */
final class VersionComparisonOperator
{
    /**
     * @psalm-var '<'|'lt'|'<='|'le'|'>'|'gt'|'>='|'ge'|'=='|'='|'eq'|'!='|'<>'|'ne'
     */
    private string $operator;
    public function __construct(string $operator)
    {
        $this->ensureOperatorIsValid($operator);
        $this->operator = $operator;
    }
    /**
     * @return '<'|'lt'|'<='|'le'|'>'|'gt'|'>='|'ge'|'=='|'='|'eq'|'!='|'<>'|'ne'
     */
    public function asString() : string
    {
        return $this->operator;
    }
    /**
     * @throws Exception
     *
     * @psalm-assert '<'|'lt'|'<='|'le'|'>'|'gt'|'>='|'ge'|'=='|'='|'eq'|'!='|'<>'|'ne' $operator
     */
    private function ensureOperatorIsValid(string $operator) : void
    {
        if (!\in_array($operator, ['<', 'lt', '<=', 'le', '>', 'gt', '>=', 'ge', '==', '=', 'eq', '!=', '<>', 'ne'], \true)) {
            throw new \PHPUnit\Util\Exception(\sprintf('"%s" is not a valid version_compare() operator', $operator));
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use PHPUnit\Framework\TestCase;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 *
 * @codeCoverageIgnore
 */
final class Warning
{
    public function createForTestCaseObjectOnCallStack(string $warning) : void
    {
        foreach (\debug_backtrace() as $step) {
            if (isset($step['object']) && $step['object'] instanceof \PHPUnit\Framework\TestCase) {
                \assert($step['object'] instanceof \PHPUnit\Framework\TestCase);
                $step['object']->addWarning($warning);
                break;
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use const ENT_QUOTES;
use function assert;
use function class_exists;
use function htmlspecialchars;
use function mb_convert_encoding;
use function ord;
use function preg_replace;
use function settype;
use function strlen;
use DOMElement;
use DOMText;
use ReflectionClass;
use ReflectionException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Xml
{
    /**
     * Escapes a string for the use in XML documents.
     *
     * Any Unicode character is allowed, excluding the surrogate blocks, FFFE,
     * and FFFF (not even as character reference).
     *
     * @see https://www.w3.org/TR/xml/#charsets
     */
    public static function prepareString(string $string) : string
    {
        return \preg_replace('/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]/', '', \htmlspecialchars(self::convertToUtf8($string), \ENT_QUOTES));
    }
    /**
     * "Convert" a DOMElement object into a PHP variable.
     */
    public static function xmlToVariable(\DOMElement $element)
    {
        $variable = null;
        switch ($element->tagName) {
            case 'array':
                $variable = [];
                foreach ($element->childNodes as $entry) {
                    if (!$entry instanceof \DOMElement || $entry->tagName !== 'element') {
                        continue;
                    }
                    $item = $entry->childNodes->item(0);
                    if ($item instanceof \DOMText) {
                        $item = $entry->childNodes->item(1);
                    }
                    $value = self::xmlToVariable($item);
                    if ($entry->hasAttribute('key')) {
                        $variable[(string) $entry->getAttribute('key')] = $value;
                    } else {
                        $variable[] = $value;
                    }
                }
                break;
            case 'object':
                $className = $element->getAttribute('class');
                if ($element->hasChildNodes()) {
                    $arguments = $element->childNodes->item(0)->childNodes;
                    $constructorArgs = [];
                    foreach ($arguments as $argument) {
                        if ($argument instanceof \DOMElement) {
                            $constructorArgs[] = self::xmlToVariable($argument);
                        }
                    }
                    try {
                        \assert(\class_exists($className));
                        $variable = (new \ReflectionClass($className))->newInstanceArgs($constructorArgs);
                        // @codeCoverageIgnoreStart
                    } catch (\ReflectionException $e) {
                        throw new \PHPUnit\Util\Exception($e->getMessage(), (int) $e->getCode(), $e);
                    }
                    // @codeCoverageIgnoreEnd
                } else {
                    $variable = new $className();
                }
                break;
            case 'boolean':
                $variable = $element->textContent === 'true';
                break;
            case 'integer':
            case 'double':
            case 'string':
                $variable = $element->textContent;
                \settype($variable, $element->tagName);
                break;
        }
        return $variable;
    }
    private static function convertToUtf8(string $string) : string
    {
        if (!self::isUtf8($string)) {
            $string = \mb_convert_encoding($string, 'UTF-8');
        }
        return $string;
    }
    private static function isUtf8(string $string) : bool
    {
        $length = \strlen($string);
        for ($i = 0; $i < $length; $i++) {
            if (\ord($string[$i]) < 0x80) {
                $n = 0;
            } elseif ((\ord($string[$i]) & 0xe0) === 0xc0) {
                $n = 1;
            } elseif ((\ord($string[$i]) & 0xf0) === 0xe0) {
                $n = 2;
            } elseif ((\ord($string[$i]) & 0xf0) === 0xf0) {
                $n = 3;
            } else {
                return \false;
            }
            for ($j = 0; $j < $n; $j++) {
                if (++$i === $length || (\ord($string[$i]) & 0xc0) !== 0x80) {
                    return \false;
                }
            }
        }
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

use RuntimeException;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Exception extends \RuntimeException implements \PHPUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 *
 * @psalm-immutable
 */
final class FailedSchemaDetectionResult extends \PHPUnit\Util\Xml\SchemaDetectionResult
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

use function chdir;
use function dirname;
use function error_reporting;
use function file_get_contents;
use function getcwd;
use function libxml_get_errors;
use function libxml_use_internal_errors;
use function sprintf;
use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Loader
{
    /**
     * @throws Exception
     */
    public function loadFile(string $filename, bool $isHtml = \false, bool $xinclude = \false, bool $strict = \false) : \DOMDocument
    {
        $reporting = \error_reporting(0);
        $contents = \file_get_contents($filename);
        \error_reporting($reporting);
        if ($contents === \false) {
            throw new \PHPUnit\Util\Xml\Exception(\sprintf('Could not read "%s".', $filename));
        }
        return $this->load($contents, $isHtml, $filename, $xinclude, $strict);
    }
    /**
     * @throws Exception
     */
    public function load(string $actual, bool $isHtml = \false, string $filename = '', bool $xinclude = \false, bool $strict = \false) : \DOMDocument
    {
        if ($actual === '') {
            throw new \PHPUnit\Util\Xml\Exception('Could not load XML from empty string');
        }
        // Required for XInclude on Windows.
        if ($xinclude) {
            $cwd = \getcwd();
            @\chdir(\dirname($filename));
        }
        $document = new \DOMDocument();
        $document->preserveWhiteSpace = \false;
        $internal = \libxml_use_internal_errors(\true);
        $message = '';
        $reporting = \error_reporting(0);
        if ($filename !== '') {
            // Required for XInclude
            $document->documentURI = $filename;
        }
        if ($isHtml) {
            $loaded = $document->loadHTML($actual);
        } else {
            $loaded = $document->loadXML($actual);
        }
        if (!$isHtml && $xinclude) {
            $document->xinclude();
        }
        foreach (\libxml_get_errors() as $error) {
            $message .= "\n" . $error->message;
        }
        \libxml_use_internal_errors($internal);
        \error_reporting($reporting);
        if (isset($cwd)) {
            @\chdir($cwd);
        }
        if ($loaded === \false || $strict && $message !== '') {
            if ($filename !== '') {
                throw new \PHPUnit\Util\Xml\Exception(\sprintf('Could not load "%s".%s', $filename, $message !== '' ? "\n" . $message : ''));
            }
            if ($message === '') {
                $message = 'Could not load XML for unknown reason';
            }
            throw new \PHPUnit\Util\Xml\Exception($message);
        }
        return $document;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 *
 * @psalm-immutable
 */
abstract class SchemaDetectionResult
{
    public function detected() : bool
    {
        return \false;
    }
    /**
     * @throws Exception
     */
    public function version() : string
    {
        throw new \PHPUnit\Util\Xml\Exception('No supported schema was detected');
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SchemaDetector
{
    /**
     * @throws Exception
     */
    public function detect(string $filename) : \PHPUnit\Util\Xml\SchemaDetectionResult
    {
        $document = (new \PHPUnit\Util\Xml\Loader())->loadFile($filename, \false, \true, \true);
        foreach (['9.5', '9.2', '8.5'] as $candidate) {
            $schema = (new \PHPUnit\Util\Xml\SchemaFinder())->find($candidate);
            if (!(new \PHPUnit\Util\Xml\Validator())->validate($document, $schema)->hasValidationErrors()) {
                return new \PHPUnit\Util\Xml\SuccessfulSchemaDetectionResult($candidate);
            }
        }
        return new \PHPUnit\Util\Xml\FailedSchemaDetectionResult();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

use function defined;
use function is_file;
use function sprintf;
use PHPUnit\Runner\Version;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SchemaFinder
{
    /**
     * @throws Exception
     */
    public function find(string $version) : string
    {
        if ($version === \PHPUnit\Runner\Version::series()) {
            $filename = $this->path() . 'phpunit.xsd';
        } else {
            $filename = $this->path() . 'schema/' . $version . '.xsd';
        }
        if (!\is_file($filename)) {
            throw new \PHPUnit\Util\Xml\Exception(\sprintf('Schema for PHPUnit %s is not available', $version));
        }
        return $filename;
    }
    private function path() : string
    {
        if (\defined('__PHPUNIT_PHAR_ROOT__')) {
            return __PHPUNIT_PHAR_ROOT__ . '/';
        }
        return __DIR__ . '/../../../';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

use ArrayIterator;
use Countable;
use DOMNode;
use DOMNodeList;
use IteratorAggregate;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class SnapshotNodeList implements \Countable, \IteratorAggregate
{
    /**
     * @var DOMNode[]
     */
    private array $nodes = [];
    public static function fromNodeList(\DOMNodeList $list) : self
    {
        $snapshot = new self();
        foreach ($list as $node) {
            $snapshot->nodes[] = $node;
        }
        return $snapshot;
    }
    public function count() : int
    {
        return \count($this->nodes);
    }
    public function getIterator() : \ArrayIterator
    {
        return new \ArrayIterator($this->nodes);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 *
 * @psalm-immutable
 */
final class SuccessfulSchemaDetectionResult extends \PHPUnit\Util\Xml\SchemaDetectionResult
{
    private string $version;
    public function __construct(string $version)
    {
        $this->version = $version;
    }
    public function detected() : bool
    {
        return \true;
    }
    public function version() : string
    {
        return $this->version;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

use function sprintf;
use function trim;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 *
 * @psalm-immutable
 */
final class ValidationResult
{
    /**
     * @psalm-var array<int,list<string>>
     */
    private array $validationErrors = [];
    /**
     * @psalm-param array<int,\LibXMLError> $errors
     */
    public static function fromArray(array $errors) : self
    {
        $validationErrors = [];
        foreach ($errors as $error) {
            if (!isset($validationErrors[$error->line])) {
                $validationErrors[$error->line] = [];
            }
            $validationErrors[$error->line][] = \trim($error->message);
        }
        return new self($validationErrors);
    }
    private function __construct(array $validationErrors)
    {
        $this->validationErrors = $validationErrors;
    }
    public function hasValidationErrors() : bool
    {
        return !empty($this->validationErrors);
    }
    public function asString() : string
    {
        $buffer = '';
        foreach ($this->validationErrors as $line => $validationErrorsOnLine) {
            $buffer .= \sprintf(\PHP_EOL . '  Line %d:' . \PHP_EOL, $line);
            foreach ($validationErrorsOnLine as $validationError) {
                $buffer .= \sprintf('  - %s' . \PHP_EOL, $validationError);
            }
        }
        return $buffer;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util\Xml;

use function file_get_contents;
use function libxml_clear_errors;
use function libxml_get_errors;
use function libxml_use_internal_errors;
use DOMDocument;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class Validator
{
    public function validate(\DOMDocument $document, string $xsdFilename) : \PHPUnit\Util\Xml\ValidationResult
    {
        $originalErrorHandling = \libxml_use_internal_errors(\true);
        $document->schemaValidateSource(\file_get_contents($xsdFilename));
        $errors = \libxml_get_errors();
        \libxml_clear_errors();
        \libxml_use_internal_errors($originalErrorHandling);
        return \PHPUnit\Util\Xml\ValidationResult::fromArray($errors);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of PHPUnit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\Util;

use function get_class;
use function implode;
use function str_replace;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\TestSuite;
use PHPUnit\Runner\PhptTestCase;
use RecursiveIteratorIterator;
use XMLWriter;
/**
 * @internal This class is not covered by the backward compatibility promise for PHPUnit
 */
final class XmlTestListRenderer
{
    /**
     * @throws \SebastianBergmann\RecursionContext\InvalidArgumentException
     */
    public function render(\PHPUnit\Framework\TestSuite $suite) : string
    {
        $writer = new \XMLWriter();
        $writer->openMemory();
        $writer->setIndent(\true);
        $writer->startDocument();
        $writer->startElement('tests');
        $currentTestCase = null;
        foreach (new \RecursiveIteratorIterator($suite->getIterator()) as $test) {
            if ($test instanceof \PHPUnit\Framework\TestCase) {
                if (\get_class($test) !== $currentTestCase) {
                    if ($currentTestCase !== null) {
                        $writer->endElement();
                    }
                    $writer->startElement('testCaseClass');
                    $writer->writeAttribute('name', \get_class($test));
                    $currentTestCase = \get_class($test);
                }
                $writer->startElement('testCaseMethod');
                $writer->writeAttribute('name', $test->getName(\false));
                $writer->writeAttribute('groups', \implode(',', $test->groups()));
                if (!empty($test->getDataSetAsString())) {
                    $writer->writeAttribute('dataSet', \str_replace(' with data set ', '', $test->getDataSetAsString()));
                }
                $writer->endElement();
            } elseif ($test instanceof \PHPUnit\Runner\PhptTestCase) {
                if ($currentTestCase !== null) {
                    $writer->endElement();
                    $currentTestCase = null;
                }
                $writer->startElement('phptFile');
                $writer->writeAttribute('path', $test->getName());
                $writer->endElement();
            }
        }
        if ($currentTestCase !== null) {
            $writer->endElement();
        }
        $writer->endElement();
        return $writer->outputMemory();
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:annotation>
        <xs:documentation source="https://phpunit.de/documentation.html">
            This Schema file defines the rules by which the XML configuration file of PHPUnit 8.5 may be structured.
        </xs:documentation>
        <xs:appinfo source="https://phpunit.de/documentation.html"/>
    </xs:annotation>
    <xs:element name="phpunit" type="phpUnitType">
        <xs:annotation>
            <xs:documentation>Root Element</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="filtersType">
        <xs:sequence>
            <xs:element name="whitelist" type="whiteListType" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="filterType">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:group ref="pathGroup"/>
                <xs:element name="exclude">
                    <xs:complexType>
                        <xs:group ref="pathGroup"/>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="whiteListType">
        <xs:complexContent>
            <xs:extension base="filterType">
                <xs:attribute name="addUncoveredFilesFromWhitelist" default="true" type="xs:boolean"/>
                <xs:attribute name="processUncoveredFilesFromWhitelist" default="false" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="groupsType">
        <xs:choice>
            <xs:sequence>
                <xs:element name="include" type="groupType"/>
                <xs:element name="exclude" type="groupType" minOccurs="0"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element name="exclude" type="groupType"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="groupType">
        <xs:sequence>
            <xs:element name="group" type="xs:string" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="extensionsType">
        <xs:sequence>
            <xs:element name="extension" type="objectType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="listenersType">
        <xs:sequence>
            <xs:element name="listener" type="objectType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="objectType">
        <xs:sequence>
            <xs:element name="arguments" minOccurs="0">
                <xs:complexType>
                    <xs:group ref="argumentsGroup"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="class" type="xs:string" use="required"/>
        <xs:attribute name="file" type="xs:anyURI"/>
    </xs:complexType>
    <xs:complexType name="arrayType">
        <xs:sequence>
            <xs:element name="element" type="argumentType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="argumentType">
        <xs:group ref="argumentChoice"/>
        <xs:attribute name="key" use="required"/>
    </xs:complexType>
    <xs:group name="argumentsGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="array" type="arrayType" />
                <xs:element name="integer" type="xs:integer" />
                <xs:element name="string" type="xs:string" />
                <xs:element name="double" type="xs:double" />
                <xs:element name="null" />
                <xs:element name="object" type="objectType" />
                <xs:element name="file" type="xs:anyURI" />
                <xs:element name="directory" type="xs:anyURI" />
                <xs:element name="boolean" type="xs:boolean" />
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:group name="argumentChoice">
        <xs:choice>
            <xs:element name="array" type="arrayType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="integer" type="xs:integer" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="string" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="double" type="xs:double" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="null" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="object" type="objectType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="file" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="directory" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="boolean" type="xs:boolean" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
    </xs:group>
    <xs:simpleType name="columnsType">
        <xs:union>
            <xs:simpleType>
                <xs:restriction base="xs:integer"/>
            </xs:simpleType>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="max"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    <xs:complexType name="loggersType">
        <xs:sequence>
            <xs:element name="log" type="loggerType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="loggerType">
        <xs:attribute name="type">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="coverage-html"/>
                    <xs:enumeration value="coverage-text"/>
                    <xs:enumeration value="coverage-clover"/>
                    <xs:enumeration value="coverage-crap4j"/>
                    <xs:enumeration value="coverage-xml"/>
                    <xs:enumeration value="coverage-php"/>
                    <xs:enumeration value="json"/>
                    <xs:enumeration value="plain"/>
                    <xs:enumeration value="tap"/>
                    <xs:enumeration value="teamcity"/>
                    <xs:enumeration value="junit"/>
                    <xs:enumeration value="testdox-html"/>
                    <xs:enumeration value="testdox-text"/>
                    <xs:enumeration value="testdox-xml"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="target" type="xs:anyURI"/>
        <xs:attribute name="lowUpperBound" type="xs:nonNegativeInteger" default="50"/>
        <xs:attribute name="highLowerBound" type="xs:nonNegativeInteger" default="90"/>
        <xs:attribute name="showUncoveredFiles" type="xs:boolean" default="false"/>
        <xs:attribute name="showOnlySummary" type="xs:boolean" default="false"/>
        <xs:attribute name="threshold" type="xs:nonNegativeInteger" default="30"/>
    </xs:complexType>
    <xs:group name="pathGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="directory" type="directoryFilterType"/>
                <xs:element name="file" type="fileFilterType"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="directoryFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attribute type="xs:string" name="prefix" default=""/>
                <xs:attribute type="xs:string" name="suffix" default="Test.php"/>
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:simpleType name="executionOrderType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default"/>
            <xs:enumeration value="defects"/>
            <xs:enumeration value="depends"/>
            <xs:enumeration value="depends,defects"/>
            <xs:enumeration value="depends,duration"/>
            <xs:enumeration value="depends,random"/>
            <xs:enumeration value="depends,reverse"/>
            <xs:enumeration value="depends,size"/>
            <xs:enumeration value="duration"/>
            <xs:enumeration value="no-depends"/>
            <xs:enumeration value="no-depends,defects"/>
            <xs:enumeration value="no-depends,duration"/>
            <xs:enumeration value="no-depends,random"/>
            <xs:enumeration value="no-depends,reverse"/>
            <xs:enumeration value="no-depends,size"/>
            <xs:enumeration value="random"/>
            <xs:enumeration value="reverse"/>
            <xs:enumeration value="size"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="fileFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="phpVersionGroup">
        <xs:attribute name="phpVersion" type="xs:string" default="5.3.0"/>
        <xs:attribute name="phpVersionOperator" type="xs:string" default="&gt;="/>
    </xs:attributeGroup>
    <xs:complexType name="phpType">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="includePath" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="ini" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="const" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="var" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="env" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="post" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="get" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="cookie" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="server" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="files" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="request" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="namedValueType">
        <xs:attribute name="name" use="required" type="xs:string"/>
        <xs:attribute name="value" use="required" type="xs:anySimpleType"/>
        <xs:attribute name="verbatim" use="optional" type="xs:boolean"/>
        <xs:attribute name="force" use="optional" type="xs:boolean"/>
    </xs:complexType>
    <xs:complexType name="phpUnitType">
        <xs:annotation>
            <xs:documentation>The main type specifying the document structure</xs:documentation>
        </xs:annotation>
        <xs:group ref="configGroup"/>
        <xs:attributeGroup ref="configAttributeGroup"/>
    </xs:complexType>
    <xs:attributeGroup name="configAttributeGroup">
        <xs:attribute name="backupGlobals" type="xs:boolean" default="false"/>
        <xs:attribute name="backupStaticAttributes" type="xs:boolean" default="false"/>
        <xs:attribute name="bootstrap" type="xs:anyURI"/>
        <xs:attribute name="cacheResult" type="xs:boolean" default="true"/>
        <xs:attribute name="cacheResultFile" type="xs:anyURI"/>
        <xs:attribute name="cacheTokens" type="xs:boolean" default="false"/>
        <xs:attribute name="colors" type="xs:boolean" default="false"/>
        <xs:attribute name="columns" type="columnsType" default="80"/>
        <xs:attribute name="convertDeprecationsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertErrorsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertNoticesToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertWarningsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="disableCodeCoverageIgnore" type="xs:boolean" default="false"/>
        <xs:attribute name="forceCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="printerClass" type="xs:string" default="PHPUnit\TextUI\ResultPrinter"/>
        <xs:attribute name="printerFile" type="xs:anyURI"/>
        <xs:attribute name="processIsolation" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnDefect" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnError" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnFailure" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnIncomplete" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnSkipped" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutChangesToGlobalState" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutOutputDuringTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutResourceUsageDuringSmallTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutTestsThatDoNotTestAnything" type="xs:boolean" default="true"/>
        <xs:attribute name="beStrictAboutTodoAnnotatedTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="defaultTimeLimit" type="xs:integer" default="0"/>
        <xs:attribute name="enforceTimeLimit" type="xs:boolean" default="false"/>
        <xs:attribute name="ignoreDeprecatedCodeUnitsFromCodeCoverage" type="xs:boolean" default="false"/>
        <xs:attribute name="timeoutForSmallTests" type="xs:integer" default="1"/>
        <xs:attribute name="timeoutForMediumTests" type="xs:integer" default="10"/>
        <xs:attribute name="timeoutForLargeTests" type="xs:integer" default="60"/>
        <xs:attribute name="testSuiteLoaderClass" type="xs:string" default="PHPUnit\Runner\StandardTestSuiteLoader"/>
        <xs:attribute name="testSuiteLoaderFile" type="xs:anyURI"/>
        <xs:attribute name="defaultTestSuite" type="xs:string" default=""/>
        <xs:attribute name="verbose" type="xs:boolean" default="false"/>
        <xs:attribute name="testdox" type="xs:boolean" default="false"/>
        <xs:attribute name="stderr" type="xs:boolean" default="false"/>
        <xs:attribute name="reverseDefectList" type="xs:boolean" default="false"/>
        <xs:attribute name="registerMockObjectsFromTestArgumentsRecursively" type="xs:boolean" default="false"/>
        <xs:attribute name="extensionsDirectory" type="xs:string"/>
        <xs:attribute name="executionOrder" type="executionOrderType" default="default"/>
        <xs:attribute name="resolveDependencies" type="xs:boolean" default="true"/>
        <xs:attribute name="noInteraction" type="xs:boolean" default="false"/>
    </xs:attributeGroup>
    <xs:group name="configGroup">
        <xs:all>
            <xs:element ref="testSuiteFacet" minOccurs="0"/>
            <xs:element name="groups" type="groupsType" minOccurs="0"/>
            <xs:element name="testdoxGroups" type="groupsType" minOccurs="0"/>
            <xs:element name="filter" type="filtersType" minOccurs="0"/>
            <xs:element name="logging" type="loggersType" minOccurs="0"/>
            <xs:element name="extensions" type="extensionsType" minOccurs="0"/>
            <xs:element name="listeners" type="listenersType" minOccurs="0"/>
            <xs:element name="php" type="phpType" minOccurs="0"/>
        </xs:all>
    </xs:group>
    <xs:element name="testSuiteFacet" abstract="true"/>
    <xs:element name="testsuite" type="testSuiteType" substitutionGroup="testSuiteFacet"/>
    <xs:element name="testsuites" type="testSuitesType" substitutionGroup="testSuiteFacet"/>
    <xs:complexType name="testSuitesType">
        <xs:sequence>
            <xs:element name="testsuite" type="testSuiteType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="testSuiteType">
        <xs:sequence>
            <xs:group ref="pathGroup"/>
            <xs:element name="exclude" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required"/>
    </xs:complexType>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:annotation>
        <xs:documentation source="https://phpunit.de/documentation.html">
            This Schema file defines the rules by which the XML configuration file of PHPUnit 9.2 may be structured.
        </xs:documentation>
        <xs:appinfo source="https://phpunit.de/documentation.html"/>
    </xs:annotation>
    <xs:element name="phpunit" type="phpUnitType">
        <xs:annotation>
            <xs:documentation>Root Element</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="filtersType">
        <xs:sequence>
            <xs:element name="whitelist" type="whiteListType" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="filterType">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:group ref="pathGroup"/>
                <xs:element name="exclude">
                    <xs:complexType>
                        <xs:group ref="pathGroup"/>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="whiteListType">
        <xs:complexContent>
            <xs:extension base="filterType">
                <xs:attribute name="addUncoveredFilesFromWhitelist" default="true" type="xs:boolean"/>
                <xs:attribute name="processUncoveredFilesFromWhitelist" default="false" type="xs:boolean"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:complexType name="groupsType">
        <xs:choice>
            <xs:sequence>
                <xs:element name="include" type="groupType"/>
                <xs:element name="exclude" type="groupType" minOccurs="0"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element name="exclude" type="groupType"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="groupType">
        <xs:sequence>
            <xs:element name="group" type="xs:string" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="extensionsType">
        <xs:sequence>
            <xs:element name="extension" type="objectType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="listenersType">
        <xs:sequence>
            <xs:element name="listener" type="objectType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="objectType">
        <xs:sequence>
            <xs:element name="arguments" minOccurs="0">
                <xs:complexType>
                    <xs:group ref="argumentsGroup"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="class" type="xs:string" use="required"/>
        <xs:attribute name="file" type="xs:anyURI"/>
    </xs:complexType>
    <xs:complexType name="arrayType">
        <xs:sequence>
            <xs:element name="element" type="argumentType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="argumentType">
        <xs:group ref="argumentChoice"/>
        <xs:attribute name="key" use="required"/>
    </xs:complexType>
    <xs:group name="argumentsGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="array" type="arrayType" />
                <xs:element name="integer" type="xs:integer" />
                <xs:element name="string" type="xs:string" />
                <xs:element name="double" type="xs:double" />
                <xs:element name="null" />
                <xs:element name="object" type="objectType" />
                <xs:element name="file" type="xs:anyURI" />
                <xs:element name="directory" type="xs:anyURI" />
                <xs:element name="boolean" type="xs:boolean" />
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:group name="argumentChoice">
        <xs:choice>
            <xs:element name="array" type="arrayType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="integer" type="xs:integer" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="string" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="double" type="xs:double" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="null" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="object" type="objectType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="file" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="directory" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="boolean" type="xs:boolean" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
    </xs:group>
    <xs:simpleType name="columnsType">
        <xs:union>
            <xs:simpleType>
                <xs:restriction base="xs:integer"/>
            </xs:simpleType>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="max"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    <xs:complexType name="loggersType">
        <xs:sequence>
            <xs:element name="log" type="loggerType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="loggerType">
        <xs:attribute name="type">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="coverage-html"/>
                    <xs:enumeration value="coverage-text"/>
                    <xs:enumeration value="coverage-clover"/>
                    <xs:enumeration value="coverage-crap4j"/>
                    <xs:enumeration value="coverage-xml"/>
                    <xs:enumeration value="coverage-php"/>
                    <xs:enumeration value="plain"/>
                    <xs:enumeration value="teamcity"/>
                    <xs:enumeration value="junit"/>
                    <xs:enumeration value="testdox-html"/>
                    <xs:enumeration value="testdox-text"/>
                    <xs:enumeration value="testdox-xml"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="target" type="xs:anyURI"/>
        <xs:attribute name="lowUpperBound" type="xs:nonNegativeInteger" default="50"/>
        <xs:attribute name="highLowerBound" type="xs:nonNegativeInteger" default="90"/>
        <xs:attribute name="showUncoveredFiles" type="xs:boolean" default="false"/>
        <xs:attribute name="showOnlySummary" type="xs:boolean" default="false"/>
        <xs:attribute name="threshold" type="xs:nonNegativeInteger" default="30"/>
    </xs:complexType>
    <xs:group name="pathGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="directory" type="directoryFilterType"/>
                <xs:element name="file" type="fileFilterType"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="directoryFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attribute type="xs:string" name="prefix" default=""/>
                <xs:attribute type="xs:string" name="suffix" default="Test.php"/>
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:simpleType name="executionOrderType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default"/>
            <xs:enumeration value="defects"/>
            <xs:enumeration value="depends"/>
            <xs:enumeration value="depends,defects"/>
            <xs:enumeration value="depends,duration"/>
            <xs:enumeration value="depends,random"/>
            <xs:enumeration value="depends,reverse"/>
            <xs:enumeration value="depends,size"/>
            <xs:enumeration value="duration"/>
            <xs:enumeration value="no-depends"/>
            <xs:enumeration value="no-depends,defects"/>
            <xs:enumeration value="no-depends,duration"/>
            <xs:enumeration value="no-depends,random"/>
            <xs:enumeration value="no-depends,reverse"/>
            <xs:enumeration value="no-depends,size"/>
            <xs:enumeration value="random"/>
            <xs:enumeration value="reverse"/>
            <xs:enumeration value="size"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="fileFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="phpVersionGroup">
        <xs:attribute name="phpVersion" type="xs:string" default="5.3.0"/>
        <xs:attribute name="phpVersionOperator" type="xs:string" default="&gt;="/>
    </xs:attributeGroup>
    <xs:complexType name="phpType">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="includePath" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="ini" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="const" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="var" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="env" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="post" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="get" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="cookie" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="server" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="files" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="request" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="namedValueType">
        <xs:attribute name="name" use="required" type="xs:string"/>
        <xs:attribute name="value" use="required" type="xs:anySimpleType"/>
        <xs:attribute name="verbatim" use="optional" type="xs:boolean"/>
        <xs:attribute name="force" use="optional" type="xs:boolean"/>
    </xs:complexType>
    <xs:complexType name="phpUnitType">
        <xs:annotation>
            <xs:documentation>The main type specifying the document structure</xs:documentation>
        </xs:annotation>
        <xs:group ref="configGroup"/>
        <xs:attributeGroup ref="configAttributeGroup"/>
    </xs:complexType>
    <xs:attributeGroup name="configAttributeGroup">
        <xs:attribute name="backupGlobals" type="xs:boolean" default="false"/>
        <xs:attribute name="backupStaticAttributes" type="xs:boolean" default="false"/>
        <xs:attribute name="bootstrap" type="xs:anyURI"/>
        <xs:attribute name="cacheResult" type="xs:boolean" default="true"/>
        <xs:attribute name="cacheResultFile" type="xs:anyURI"/>
        <xs:attribute name="cacheTokens" type="xs:boolean" default="false"/>
        <xs:attribute name="colors" type="xs:boolean" default="false"/>
        <xs:attribute name="columns" type="columnsType" default="80"/>
        <xs:attribute name="convertDeprecationsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertErrorsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertNoticesToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertWarningsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="disableCodeCoverageIgnore" type="xs:boolean" default="false"/>
        <xs:attribute name="forceCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="printerClass" type="xs:string" default="PHPUnit\TextUI\ResultPrinter"/>
        <xs:attribute name="printerFile" type="xs:anyURI"/>
        <xs:attribute name="processIsolation" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnDefect" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnError" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnFailure" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnIncomplete" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnSkipped" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnIncomplete" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnSkipped" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutChangesToGlobalState" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutOutputDuringTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutResourceUsageDuringSmallTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutTestsThatDoNotTestAnything" type="xs:boolean" default="true"/>
        <xs:attribute name="beStrictAboutTodoAnnotatedTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="defaultTimeLimit" type="xs:integer" default="0"/>
        <xs:attribute name="enforceTimeLimit" type="xs:boolean" default="false"/>
        <xs:attribute name="ignoreDeprecatedCodeUnitsFromCodeCoverage" type="xs:boolean" default="false"/>
        <xs:attribute name="timeoutForSmallTests" type="xs:integer" default="1"/>
        <xs:attribute name="timeoutForMediumTests" type="xs:integer" default="10"/>
        <xs:attribute name="timeoutForLargeTests" type="xs:integer" default="60"/>
        <xs:attribute name="testSuiteLoaderClass" type="xs:string" default="PHPUnit\Runner\StandardTestSuiteLoader"/>
        <xs:attribute name="testSuiteLoaderFile" type="xs:anyURI"/>
        <xs:attribute name="defaultTestSuite" type="xs:string" default=""/>
        <xs:attribute name="verbose" type="xs:boolean" default="false"/>
        <xs:attribute name="testdox" type="xs:boolean" default="false"/>
        <xs:attribute name="stderr" type="xs:boolean" default="false"/>
        <xs:attribute name="reverseDefectList" type="xs:boolean" default="false"/>
        <xs:attribute name="registerMockObjectsFromTestArgumentsRecursively" type="xs:boolean" default="false"/>
        <xs:attribute name="extensionsDirectory" type="xs:string"/>
        <xs:attribute name="executionOrder" type="executionOrderType" default="default"/>
        <xs:attribute name="resolveDependencies" type="xs:boolean" default="true"/>
        <xs:attribute name="noInteraction" type="xs:boolean" default="false"/>
    </xs:attributeGroup>
    <xs:group name="configGroup">
        <xs:all>
            <xs:element ref="testSuiteFacet" minOccurs="0"/>
            <xs:element name="groups" type="groupsType" minOccurs="0"/>
            <xs:element name="testdoxGroups" type="groupsType" minOccurs="0"/>
            <xs:element name="filter" type="filtersType" minOccurs="0"/>
            <xs:element name="logging" type="loggersType" minOccurs="0"/>
            <xs:element name="extensions" type="extensionsType" minOccurs="0"/>
            <xs:element name="listeners" type="listenersType" minOccurs="0"/>
            <xs:element name="php" type="phpType" minOccurs="0"/>
        </xs:all>
    </xs:group>
    <xs:element name="testSuiteFacet" abstract="true"/>
    <xs:element name="testsuite" type="testSuiteType" substitutionGroup="testSuiteFacet"/>
    <xs:element name="testsuites" type="testSuitesType" substitutionGroup="testSuiteFacet"/>
    <xs:complexType name="testSuitesType">
        <xs:sequence>
            <xs:element name="testsuite" type="testSuiteType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="testSuiteType">
        <xs:sequence>
            <xs:group ref="pathGroup"/>
            <xs:element name="exclude" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required"/>
    </xs:complexType>
</xs:schema>
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:annotation>
        <xs:documentation source="https://phpunit.de/documentation.html">
            This Schema file defines the rules by which the XML configuration file of PHPUnit 9.5 may be structured.
        </xs:documentation>
        <xs:appinfo source="https://phpunit.de/documentation.html"/>
    </xs:annotation>
    <xs:element name="phpunit" type="phpUnitType">
        <xs:annotation>
            <xs:documentation>Root Element</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="coverageType">
        <xs:all>
            <xs:element name="include" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:group ref="pathGroup"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="exclude" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:group ref="pathGroup"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="report" minOccurs="0" maxOccurs="1">
                <xs:complexType>
                    <xs:group ref="coverageReportGroup"/>
                </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute name="cacheDirectory" type="xs:anyURI"/>
        <xs:attribute name="pathCoverage" type="xs:boolean" default="false"/>
        <xs:attribute name="includeUncoveredFiles" type="xs:boolean" default="true"/>
        <xs:attribute name="processUncoveredFiles" type="xs:boolean" default="false"/>
        <xs:attribute name="ignoreDeprecatedCodeUnits" type="xs:boolean" default="false"/>
        <xs:attribute name="disableCodeCoverageIgnore" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:complexType name="loggingType">
        <xs:group ref="loggingGroup"/>
    </xs:complexType>
    <xs:complexType name="groupsType">
        <xs:choice>
            <xs:sequence>
                <xs:element name="include" type="groupType"/>
                <xs:element name="exclude" type="groupType" minOccurs="0"/>
            </xs:sequence>
            <xs:sequence>
                <xs:element name="exclude" type="groupType"/>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>
    <xs:complexType name="groupType">
        <xs:sequence>
            <xs:element name="group" type="xs:string" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="extensionsType">
        <xs:sequence>
            <xs:element name="extension" type="objectType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="listenersType">
        <xs:sequence>
            <xs:element name="listener" type="objectType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="objectType">
        <xs:sequence>
            <xs:element name="arguments" minOccurs="0">
                <xs:complexType>
                    <xs:group ref="argumentsGroup"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="class" type="xs:string" use="required"/>
        <xs:attribute name="file" type="xs:anyURI"/>
    </xs:complexType>
    <xs:complexType name="arrayType">
        <xs:sequence>
            <xs:element name="element" type="argumentType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="argumentType">
        <xs:group ref="argumentChoice"/>
        <xs:attribute name="key" use="required"/>
    </xs:complexType>
    <xs:group name="argumentsGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="array" type="arrayType" />
                <xs:element name="integer" type="xs:integer" />
                <xs:element name="string" type="xs:string" />
                <xs:element name="double" type="xs:double" />
                <xs:element name="null" />
                <xs:element name="object" type="objectType" />
                <xs:element name="file" type="xs:anyURI" />
                <xs:element name="directory" type="xs:anyURI" />
                <xs:element name="boolean" type="xs:boolean" />
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:group name="argumentChoice">
        <xs:choice>
            <xs:element name="array" type="arrayType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="integer" type="xs:integer" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="string" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="double" type="xs:double" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="null" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="object" type="objectType" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="file" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="directory" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="boolean" type="xs:boolean" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
    </xs:group>
    <xs:simpleType name="columnsType">
        <xs:union>
            <xs:simpleType>
                <xs:restriction base="xs:integer"/>
            </xs:simpleType>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="max"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>
    <xs:group name="pathGroup">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="directory" type="directoryFilterType"/>
                <xs:element name="file" type="fileFilterType"/>
            </xs:choice>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="directoryFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attribute type="xs:string" name="prefix" default=""/>
                <xs:attribute type="xs:string" name="suffix" default="Test.php"/>
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:simpleType name="executionOrderType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default"/>
            <xs:enumeration value="defects"/>
            <xs:enumeration value="depends"/>
            <xs:enumeration value="depends,defects"/>
            <xs:enumeration value="depends,duration"/>
            <xs:enumeration value="depends,random"/>
            <xs:enumeration value="depends,reverse"/>
            <xs:enumeration value="depends,size"/>
            <xs:enumeration value="duration"/>
            <xs:enumeration value="no-depends"/>
            <xs:enumeration value="no-depends,defects"/>
            <xs:enumeration value="no-depends,duration"/>
            <xs:enumeration value="no-depends,random"/>
            <xs:enumeration value="no-depends,reverse"/>
            <xs:enumeration value="no-depends,size"/>
            <xs:enumeration value="random"/>
            <xs:enumeration value="reverse"/>
            <xs:enumeration value="size"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="fileFilterType">
        <xs:simpleContent>
            <xs:extension base="xs:anyURI">
                <xs:attributeGroup ref="phpVersionGroup"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:attributeGroup name="phpVersionGroup">
        <xs:attribute name="phpVersion" type="xs:string" default="5.3.0"/>
        <xs:attribute name="phpVersionOperator" type="xs:string" default="&gt;="/>
    </xs:attributeGroup>
    <xs:complexType name="phpType">
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="includePath" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="ini" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="const" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="var" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="env" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="post" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="get" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="cookie" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="server" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="files" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="request" type="namedValueType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="namedValueType">
        <xs:attribute name="name" use="required" type="xs:string"/>
        <xs:attribute name="value" use="required" type="xs:anySimpleType"/>
        <xs:attribute name="verbatim" use="optional" type="xs:boolean"/>
        <xs:attribute name="force" use="optional" type="xs:boolean"/>
    </xs:complexType>
    <xs:complexType name="phpUnitType">
        <xs:annotation>
            <xs:documentation>The main type specifying the document structure</xs:documentation>
        </xs:annotation>
        <xs:group ref="configGroup"/>
        <xs:attributeGroup ref="configAttributeGroup"/>
    </xs:complexType>
    <xs:attributeGroup name="configAttributeGroup">
        <xs:attribute name="backupGlobals" type="xs:boolean" default="false"/>
        <xs:attribute name="backupStaticAttributes" type="xs:boolean" default="false"/>
        <xs:attribute name="bootstrap" type="xs:anyURI"/>
        <xs:attribute name="cacheResult" type="xs:boolean" default="true"/>
        <xs:attribute name="cacheResultFile" type="xs:anyURI"/>
        <xs:attribute name="colors" type="xs:boolean" default="false"/>
        <xs:attribute name="columns" type="columnsType" default="80"/>
        <xs:attribute name="convertDeprecationsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertErrorsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertNoticesToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="convertWarningsToExceptions" type="xs:boolean" default="true"/>
        <xs:attribute name="forceCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="printerClass" type="xs:string" default="PHPUnit\TextUI\DefaultResultPrinter"/>
        <xs:attribute name="printerFile" type="xs:anyURI"/>
        <xs:attribute name="processIsolation" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnDefect" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnError" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnFailure" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnIncomplete" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="stopOnSkipped" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnEmptyTestSuite" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnIncomplete" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnRisky" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnSkipped" type="xs:boolean" default="false"/>
        <xs:attribute name="failOnWarning" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutChangesToGlobalState" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutOutputDuringTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutResourceUsageDuringSmallTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutTestsThatDoNotTestAnything" type="xs:boolean" default="true"/>
        <xs:attribute name="beStrictAboutTodoAnnotatedTests" type="xs:boolean" default="false"/>
        <xs:attribute name="beStrictAboutCoversAnnotation" type="xs:boolean" default="false"/>
        <xs:attribute name="defaultTimeLimit" type="xs:integer" default="0"/>
        <xs:attribute name="enforceTimeLimit" type="xs:boolean" default="false"/>
        <xs:attribute name="timeoutForSmallTests" type="xs:integer" default="1"/>
        <xs:attribute name="timeoutForMediumTests" type="xs:integer" default="10"/>
        <xs:attribute name="timeoutForLargeTests" type="xs:integer" default="60"/>
        <xs:attribute name="testSuiteLoaderClass" type="xs:string" default="PHPUnit\Runner\StandardTestSuiteLoader"/>
        <xs:attribute name="testSuiteLoaderFile" type="xs:anyURI"/>
        <xs:attribute name="defaultTestSuite" type="xs:string" default=""/>
        <xs:attribute name="verbose" type="xs:boolean" default="false"/>
        <xs:attribute name="testdox" type="xs:boolean" default="false"/>
        <xs:attribute name="stderr" type="xs:boolean" default="false"/>
        <xs:attribute name="reverseDefectList" type="xs:boolean" default="false"/>
        <xs:attribute name="registerMockObjectsFromTestArgumentsRecursively" type="xs:boolean" default="false"/>
        <xs:attribute name="extensionsDirectory" type="xs:string"/>
        <xs:attribute name="executionOrder" type="executionOrderType" default="default"/>
        <xs:attribute name="resolveDependencies" type="xs:boolean" default="true"/>
        <xs:attribute name="noInteraction" type="xs:boolean" default="false"/>
    </xs:attributeGroup>
    <xs:group name="configGroup">
        <xs:all>
            <xs:element ref="testSuiteFacet" minOccurs="0"/>
            <xs:element name="groups" type="groupsType" minOccurs="0"/>
            <xs:element name="testdoxGroups" type="groupsType" minOccurs="0"/>
            <xs:element name="coverage" type="coverageType" minOccurs="0"/>
            <xs:element name="logging" type="loggingType" minOccurs="0"/>
            <xs:element name="extensions" type="extensionsType" minOccurs="0"/>
            <xs:element name="listeners" type="listenersType" minOccurs="0"/>
            <xs:element name="php" type="phpType" minOccurs="0"/>
        </xs:all>
    </xs:group>
    <xs:element name="testSuiteFacet" abstract="true"/>
    <xs:element name="testsuite" type="testSuiteType" substitutionGroup="testSuiteFacet"/>
    <xs:element name="testsuites" type="testSuitesType" substitutionGroup="testSuiteFacet"/>
    <xs:complexType name="testSuitesType">
        <xs:sequence>
            <xs:element name="testsuite" type="testSuiteType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="testSuiteType">
        <xs:sequence>
            <xs:group ref="pathGroup"/>
            <xs:element name="exclude" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required"/>
    </xs:complexType>
    <xs:group name="coverageReportGroup">
        <xs:all>
            <xs:element name="clover" type="logToFileType" minOccurs="0"/>
            <xs:element name="cobertura" type="logToFileType" minOccurs="0"/>
            <xs:element name="crap4j" type="coverageReportCrap4JType" minOccurs="0" />
            <xs:element name="html" type="coverageReportHtmlType" minOccurs="0" />
            <xs:element name="php" type="logToFileType" minOccurs="0" />
            <xs:element name="text" type="coverageReportTextType" minOccurs="0" />
            <xs:element name="xml" type="logToDirectoryType" minOccurs="0" />
        </xs:all>
    </xs:group>
    <xs:group name="loggingGroup">
        <xs:all>
            <xs:element name="junit" type="logToFileType" minOccurs="0" />
            <xs:element name="teamcity" type="logToFileType" minOccurs="0" />
            <xs:element name="testdoxHtml" type="logToFileType" minOccurs="0" />
            <xs:element name="testdoxText" type="logToFileType" minOccurs="0" />
            <xs:element name="testdoxXml" type="logToFileType" minOccurs="0" />
            <xs:element name="text" type="logToFileType" minOccurs="0"/>
        </xs:all>
    </xs:group>
    <xs:complexType name="logToFileType">
        <xs:attribute name="outputFile" type="xs:anyURI" use="required"/>
    </xs:complexType>
    <xs:complexType name="logToDirectoryType">
        <xs:attribute name="outputDirectory" type="xs:anyURI" use="required"/>
    </xs:complexType>
    <xs:complexType name="coverageReportCrap4JType">
        <xs:attribute name="outputFile" type="xs:anyURI" use="required"/>
        <xs:attribute name="threshold" type="xs:integer"/>
    </xs:complexType>
    <xs:complexType name="coverageReportHtmlType">
        <xs:attribute name="outputDirectory" type="xs:anyURI" use="required"/>
        <xs:attribute name="lowUpperBound" type="xs:integer" default="50"/>
        <xs:attribute name="highLowerBound" type="xs:integer" default="90"/>
    </xs:complexType>
    <xs:complexType name="coverageReportTextType">
        <xs:attribute name="outputFile" type="xs:anyURI" use="required"/>
        <xs:attribute name="showUncoveredFiles" type="xs:boolean" default="false"/>
        <xs:attribute name="showOnlySummary" type="xs:boolean" default="false"/>
    </xs:complexType>
</xs:schema>
sebastian/cli-parser

Copyright (c) 2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/cli-parser.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CliParser;

use function array_map;
use function array_merge;
use function array_shift;
use function array_slice;
use function assert;
use function count;
use function current;
use function explode;
use function is_array;
use function is_int;
use function is_string;
use function key;
use function next;
use function preg_replace;
use function reset;
use function sort;
use function strlen;
use function strpos;
use function strstr;
use function substr;
final class Parser
{
    /**
     * @psalm-param list<string> $argv
     * @psalm-param list<string> $longOptions
     *
     * @throws AmbiguousOptionException
     * @throws RequiredOptionArgumentMissingException
     * @throws OptionDoesNotAllowArgumentException
     * @throws UnknownOptionException
     */
    public function parse(array $argv, string $shortOptions, array $longOptions = null) : array
    {
        if (empty($argv)) {
            return [[], []];
        }
        $options = [];
        $nonOptions = [];
        if ($longOptions) {
            \sort($longOptions);
        }
        if (isset($argv[0][0]) && $argv[0][0] !== '-') {
            \array_shift($argv);
        }
        \reset($argv);
        $argv = \array_map('trim', $argv);
        while (\false !== ($arg = \current($argv))) {
            $i = \key($argv);
            \assert(\is_int($i));
            \next($argv);
            if ($arg === '') {
                continue;
            }
            if ($arg === '--') {
                $nonOptions = \array_merge($nonOptions, \array_slice($argv, $i + 1));
                break;
            }
            if ($arg[0] !== '-' || \strlen($arg) > 1 && $arg[1] === '-' && !$longOptions) {
                $nonOptions[] = $arg;
                continue;
            }
            if (\strlen($arg) > 1 && $arg[1] === '-' && \is_array($longOptions)) {
                $this->parseLongOption(\substr($arg, 2), $longOptions, $options, $argv);
            } else {
                $this->parseShortOption(\substr($arg, 1), $shortOptions, $options, $argv);
            }
        }
        return [$options, $nonOptions];
    }
    /**
     * @throws RequiredOptionArgumentMissingException
     */
    private function parseShortOption(string $arg, string $shortOptions, array &$opts, array &$args) : void
    {
        $argLength = \strlen($arg);
        for ($i = 0; $i < $argLength; $i++) {
            $option = $arg[$i];
            $optionArgument = null;
            if ($arg[$i] === ':' || ($spec = \strstr($shortOptions, $option)) === \false) {
                throw new \PHPUnit\SebastianBergmann\CliParser\UnknownOptionException('-' . $option);
            }
            \assert(\is_string($spec));
            if (\strlen($spec) > 1 && $spec[1] === ':') {
                if ($i + 1 < $argLength) {
                    $opts[] = [$option, \substr($arg, $i + 1)];
                    break;
                }
                if (!(\strlen($spec) > 2 && $spec[2] === ':')) {
                    $optionArgument = \current($args);
                    if (!$optionArgument) {
                        throw new \PHPUnit\SebastianBergmann\CliParser\RequiredOptionArgumentMissingException('-' . $option);
                    }
                    \assert(\is_string($optionArgument));
                    \next($args);
                }
            }
            $opts[] = [$option, $optionArgument];
        }
    }
    /**
     * @psalm-param list<string> $longOptions
     *
     * @throws AmbiguousOptionException
     * @throws RequiredOptionArgumentMissingException
     * @throws OptionDoesNotAllowArgumentException
     * @throws UnknownOptionException
     */
    private function parseLongOption(string $arg, array $longOptions, array &$opts, array &$args) : void
    {
        $count = \count($longOptions);
        $list = \explode('=', $arg);
        $option = $list[0];
        $optionArgument = null;
        if (\count($list) > 1) {
            $optionArgument = $list[1];
        }
        $optionLength = \strlen($option);
        foreach ($longOptions as $i => $longOption) {
            $opt_start = \substr($longOption, 0, $optionLength);
            if ($opt_start !== $option) {
                continue;
            }
            $opt_rest = \substr($longOption, $optionLength);
            if ($opt_rest !== '' && $i + 1 < $count && $option[0] !== '=' && \strpos($longOptions[$i + 1], $option) === 0) {
                throw new \PHPUnit\SebastianBergmann\CliParser\AmbiguousOptionException('--' . $option);
            }
            if (\substr($longOption, -1) === '=') {
                /* @noinspection StrlenInEmptyStringCheckContextInspection */
                if (\substr($longOption, -2) !== '==' && !\strlen((string) $optionArgument)) {
                    if (\false === ($optionArgument = \current($args))) {
                        throw new \PHPUnit\SebastianBergmann\CliParser\RequiredOptionArgumentMissingException('--' . $option);
                    }
                    \next($args);
                }
            } elseif ($optionArgument) {
                throw new \PHPUnit\SebastianBergmann\CliParser\OptionDoesNotAllowArgumentException('--' . $option);
            }
            $fullOption = '--' . \preg_replace('/={1,2}$/', '', $longOption);
            $opts[] = [$fullOption, $optionArgument];
            return;
        }
        throw new \PHPUnit\SebastianBergmann\CliParser\UnknownOptionException('--' . $option);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/cli-parser.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CliParser;

use function sprintf;
use RuntimeException;
final class AmbiguousOptionException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CliParser\Exception
{
    public function __construct(string $option)
    {
        parent::__construct(\sprintf('Option "%s" is ambiguous', $option));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/cli-parser.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CliParser;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/cli-parser.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CliParser;

use function sprintf;
use RuntimeException;
final class OptionDoesNotAllowArgumentException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CliParser\Exception
{
    public function __construct(string $option)
    {
        parent::__construct(\sprintf('Option "%s" does not allow an argument', $option));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/cli-parser.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CliParser;

use function sprintf;
use RuntimeException;
final class RequiredOptionArgumentMissingException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CliParser\Exception
{
    public function __construct(string $option)
    {
        parent::__construct(\sprintf('Required argument for option "%s" is missing', $option));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/cli-parser.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CliParser;

use function sprintf;
use RuntimeException;
final class UnknownOptionException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CliParser\Exception
{
    public function __construct(string $option)
    {
        parent::__construct(\sprintf('Unknown option "%s"', $option));
    }
}
code-unit-reverse-lookup

Copyright (c) 2016-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit-reverse-lookup.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnitReverseLookup;

use function array_merge;
use function assert;
use function get_declared_classes;
use function get_declared_traits;
use function get_defined_functions;
use function is_array;
use function range;
use ReflectionClass;
use ReflectionFunction;
use ReflectionFunctionAbstract;
use ReflectionMethod;
/**
 * @since Class available since Release 1.0.0
 */
class Wizard
{
    /**
     * @var array
     */
    private $lookupTable = [];
    /**
     * @var array
     */
    private $processedClasses = [];
    /**
     * @var array
     */
    private $processedFunctions = [];
    /**
     * @param string $filename
     * @param int    $lineNumber
     *
     * @return string
     */
    public function lookup($filename, $lineNumber)
    {
        if (!isset($this->lookupTable[$filename][$lineNumber])) {
            $this->updateLookupTable();
        }
        if (isset($this->lookupTable[$filename][$lineNumber])) {
            return $this->lookupTable[$filename][$lineNumber];
        }
        return $filename . ':' . $lineNumber;
    }
    private function updateLookupTable() : void
    {
        $this->processClassesAndTraits();
        $this->processFunctions();
    }
    private function processClassesAndTraits() : void
    {
        $classes = \get_declared_classes();
        $traits = \get_declared_traits();
        \assert(\is_array($classes));
        \assert(\is_array($traits));
        foreach (\array_merge($classes, $traits) as $classOrTrait) {
            if (isset($this->processedClasses[$classOrTrait])) {
                continue;
            }
            $reflector = new \ReflectionClass($classOrTrait);
            foreach ($reflector->getMethods() as $method) {
                $this->processFunctionOrMethod($method);
            }
            $this->processedClasses[$classOrTrait] = \true;
        }
    }
    private function processFunctions() : void
    {
        foreach (\get_defined_functions()['user'] as $function) {
            if (isset($this->processedFunctions[$function])) {
                continue;
            }
            $this->processFunctionOrMethod(new \ReflectionFunction($function));
            $this->processedFunctions[$function] = \true;
        }
    }
    private function processFunctionOrMethod(\ReflectionFunctionAbstract $functionOrMethod) : void
    {
        if ($functionOrMethod->isInternal()) {
            return;
        }
        $name = $functionOrMethod->getName();
        if ($functionOrMethod instanceof \ReflectionMethod) {
            $name = $functionOrMethod->getDeclaringClass()->getName() . '::' . $name;
        }
        if (!isset($this->lookupTable[$functionOrMethod->getFileName()])) {
            $this->lookupTable[$functionOrMethod->getFileName()] = [];
        }
        foreach (\range($functionOrMethod->getStartLine(), $functionOrMethod->getEndLine()) as $line) {
            $this->lookupTable[$functionOrMethod->getFileName()][$line] = $name;
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class ClassMethodUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true ClassMethodUnit $this
     */
    public function isClassMethod() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class ClassUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true ClassUnit $this
     */
    public function isClass() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use function range;
use function sprintf;
use ReflectionClass;
use ReflectionFunction;
use ReflectionMethod;
/**
 * @psalm-immutable
 */
abstract class CodeUnit
{
    private string $name;
    private string $sourceFileName;
    /**
     * @psalm-var list<int>
     */
    private array $sourceLines;
    /**
     * @psalm-param class-string $className
     *
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public static function forClass(string $className) : \PHPUnit\SebastianBergmann\CodeUnit\ClassUnit
    {
        self::ensureUserDefinedClass($className);
        $reflector = self::reflectorForClass($className);
        return new \PHPUnit\SebastianBergmann\CodeUnit\ClassUnit($className, $reflector->getFileName(), \range($reflector->getStartLine(), $reflector->getEndLine()));
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public static function forClassMethod(string $className, string $methodName) : \PHPUnit\SebastianBergmann\CodeUnit\ClassMethodUnit
    {
        self::ensureUserDefinedClass($className);
        $reflector = self::reflectorForClassMethod($className, $methodName);
        return new \PHPUnit\SebastianBergmann\CodeUnit\ClassMethodUnit($className . '::' . $methodName, $reflector->getFileName(), \range($reflector->getStartLine(), $reflector->getEndLine()));
    }
    /**
     * @throws InvalidCodeUnitException
     */
    public static function forFileWithAbsolutePath(string $path) : \PHPUnit\SebastianBergmann\CodeUnit\FileUnit
    {
        self::ensureFileExistsAndIsReadable($path);
        return new \PHPUnit\SebastianBergmann\CodeUnit\FileUnit($path, $path, \range(1, \count(\file($path))));
    }
    /**
     * @psalm-param class-string $interfaceName
     *
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public static function forInterface(string $interfaceName) : \PHPUnit\SebastianBergmann\CodeUnit\InterfaceUnit
    {
        self::ensureUserDefinedInterface($interfaceName);
        $reflector = self::reflectorForClass($interfaceName);
        return new \PHPUnit\SebastianBergmann\CodeUnit\InterfaceUnit($interfaceName, $reflector->getFileName(), \range($reflector->getStartLine(), $reflector->getEndLine()));
    }
    /**
     * @psalm-param class-string $interfaceName
     *
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public static function forInterfaceMethod(string $interfaceName, string $methodName) : \PHPUnit\SebastianBergmann\CodeUnit\InterfaceMethodUnit
    {
        self::ensureUserDefinedInterface($interfaceName);
        $reflector = self::reflectorForClassMethod($interfaceName, $methodName);
        return new \PHPUnit\SebastianBergmann\CodeUnit\InterfaceMethodUnit($interfaceName . '::' . $methodName, $reflector->getFileName(), \range($reflector->getStartLine(), $reflector->getEndLine()));
    }
    /**
     * @psalm-param class-string $traitName
     *
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public static function forTrait(string $traitName) : \PHPUnit\SebastianBergmann\CodeUnit\TraitUnit
    {
        self::ensureUserDefinedTrait($traitName);
        $reflector = self::reflectorForClass($traitName);
        return new \PHPUnit\SebastianBergmann\CodeUnit\TraitUnit($traitName, $reflector->getFileName(), \range($reflector->getStartLine(), $reflector->getEndLine()));
    }
    /**
     * @psalm-param class-string $traitName
     *
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public static function forTraitMethod(string $traitName, string $methodName) : \PHPUnit\SebastianBergmann\CodeUnit\TraitMethodUnit
    {
        self::ensureUserDefinedTrait($traitName);
        $reflector = self::reflectorForClassMethod($traitName, $methodName);
        return new \PHPUnit\SebastianBergmann\CodeUnit\TraitMethodUnit($traitName . '::' . $methodName, $reflector->getFileName(), \range($reflector->getStartLine(), $reflector->getEndLine()));
    }
    /**
     * @psalm-param callable-string $functionName
     *
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public static function forFunction(string $functionName) : \PHPUnit\SebastianBergmann\CodeUnit\FunctionUnit
    {
        $reflector = self::reflectorForFunction($functionName);
        if (!$reflector->isUserDefined()) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is not a user-defined function', $functionName));
        }
        return new \PHPUnit\SebastianBergmann\CodeUnit\FunctionUnit($functionName, $reflector->getFileName(), \range($reflector->getStartLine(), $reflector->getEndLine()));
    }
    /**
     * @psalm-param list<int> $sourceLines
     */
    private function __construct(string $name, string $sourceFileName, array $sourceLines)
    {
        $this->name = $name;
        $this->sourceFileName = $sourceFileName;
        $this->sourceLines = $sourceLines;
    }
    public function name() : string
    {
        return $this->name;
    }
    public function sourceFileName() : string
    {
        return $this->sourceFileName;
    }
    /**
     * @psalm-return list<int>
     */
    public function sourceLines() : array
    {
        return $this->sourceLines;
    }
    public function isClass() : bool
    {
        return \false;
    }
    public function isClassMethod() : bool
    {
        return \false;
    }
    public function isInterface() : bool
    {
        return \false;
    }
    public function isInterfaceMethod() : bool
    {
        return \false;
    }
    public function isTrait() : bool
    {
        return \false;
    }
    public function isTraitMethod() : bool
    {
        return \false;
    }
    public function isFunction() : bool
    {
        return \false;
    }
    public function isFile() : bool
    {
        return \false;
    }
    /**
     * @throws InvalidCodeUnitException
     */
    private static function ensureFileExistsAndIsReadable(string $path) : void
    {
        if (!(\file_exists($path) && \is_readable($path))) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('File "%s" does not exist or is not readable', $path));
        }
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws InvalidCodeUnitException
     */
    private static function ensureUserDefinedClass(string $className) : void
    {
        try {
            $reflector = new \ReflectionClass($className);
            if ($reflector->isInterface()) {
                throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is an interface and not a class', $className));
            }
            if ($reflector->isTrait()) {
                throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is a trait and not a class', $className));
            }
            if (!$reflector->isUserDefined()) {
                throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is not a user-defined class', $className));
            }
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @psalm-param class-string $interfaceName
     *
     * @throws InvalidCodeUnitException
     */
    private static function ensureUserDefinedInterface(string $interfaceName) : void
    {
        try {
            $reflector = new \ReflectionClass($interfaceName);
            if (!$reflector->isInterface()) {
                throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is not an interface', $interfaceName));
            }
            if (!$reflector->isUserDefined()) {
                throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is not a user-defined interface', $interfaceName));
            }
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @psalm-param class-string $traitName
     *
     * @throws InvalidCodeUnitException
     */
    private static function ensureUserDefinedTrait(string $traitName) : void
    {
        try {
            $reflector = new \ReflectionClass($traitName);
            if (!$reflector->isTrait()) {
                throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is not a trait', $traitName));
            }
            // @codeCoverageIgnoreStart
            if (!$reflector->isUserDefined()) {
                throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is not a user-defined trait', $traitName));
            }
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws ReflectionException
     */
    private static function reflectorForClass(string $className) : \ReflectionClass
    {
        try {
            return new \ReflectionClass($className);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws ReflectionException
     */
    private static function reflectorForClassMethod(string $className, string $methodName) : \ReflectionMethod
    {
        try {
            return new \ReflectionMethod($className, $methodName);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @psalm-param callable-string $functionName
     *
     * @throws ReflectionException
     */
    private static function reflectorForFunction(string $functionName) : \ReflectionFunction
    {
        try {
            return new \ReflectionFunction($functionName);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use function array_merge;
use function count;
use Countable;
use IteratorAggregate;
final class CodeUnitCollection implements \Countable, \IteratorAggregate
{
    /**
     * @psalm-var list<CodeUnit>
     */
    private array $codeUnits = [];
    /**
     * @psalm-param list<CodeUnit> $items
     */
    public static function fromArray(array $items) : self
    {
        $collection = new self();
        foreach ($items as $item) {
            $collection->add($item);
        }
        return $collection;
    }
    public static function fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit ...$items) : self
    {
        return self::fromArray($items);
    }
    private function __construct()
    {
    }
    /**
     * @psalm-return list<CodeUnit>
     */
    public function asArray() : array
    {
        return $this->codeUnits;
    }
    public function getIterator() : \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollectionIterator
    {
        return new \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollectionIterator($this);
    }
    public function count() : int
    {
        return \count($this->codeUnits);
    }
    public function isEmpty() : bool
    {
        return empty($this->codeUnits);
    }
    public function mergeWith(self $other) : self
    {
        return self::fromArray(\array_merge($this->asArray(), $other->asArray()));
    }
    private function add(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit $item) : void
    {
        $this->codeUnits[] = $item;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use Iterator;
final class CodeUnitCollectionIterator implements \Iterator
{
    /**
     * @psalm-var list<CodeUnit>
     */
    private array $codeUnits;
    private int $position = 0;
    public function __construct(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection $collection)
    {
        $this->codeUnits = $collection->asArray();
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return isset($this->codeUnits[$this->position]);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
    {
        return $this->codeUnits[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class FileUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true FileUnit $this
     */
    public function isFile() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class FunctionUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true FunctionUnit $this
     */
    public function isFunction() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class InterfaceMethodUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true InterfaceMethod $this
     */
    public function isInterfaceMethod() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class InterfaceUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true InterfaceUnit $this
     */
    public function isInterface() : bool
    {
        return \true;
    }
}
sebastian/code-unit

Copyright (c) 2020-2021, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use function array_keys;
use function array_merge;
use function array_unique;
use function array_values;
use function class_exists;
use function explode;
use function function_exists;
use function interface_exists;
use function ksort;
use function method_exists;
use function sort;
use function sprintf;
use function strpos;
use function trait_exists;
use ReflectionClass;
use ReflectionFunction;
use ReflectionMethod;
final class Mapper
{
    /**
     * @psalm-return array<string,list<int>>
     */
    public function codeUnitsToSourceLines(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection $codeUnits) : array
    {
        $result = [];
        foreach ($codeUnits as $codeUnit) {
            $sourceFileName = $codeUnit->sourceFileName();
            if (!isset($result[$sourceFileName])) {
                $result[$sourceFileName] = [];
            }
            $result[$sourceFileName] = \array_merge($result[$sourceFileName], $codeUnit->sourceLines());
        }
        foreach (\array_keys($result) as $sourceFileName) {
            $result[$sourceFileName] = \array_values(\array_unique($result[$sourceFileName]));
            \sort($result[$sourceFileName]);
        }
        \ksort($result);
        return $result;
    }
    /**
     * @throws InvalidCodeUnitException
     * @throws ReflectionException
     */
    public function stringToCodeUnits(string $unit) : \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection
    {
        if (\strpos($unit, '::') !== \false) {
            [$firstPart, $secondPart] = \explode('::', $unit);
            if ($this->isUserDefinedFunction($secondPart)) {
                return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forFunction($secondPart));
            }
            if ($this->isUserDefinedClass($firstPart)) {
                if ($this->isUserDefinedMethod($firstPart, $secondPart)) {
                    return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forClassMethod($firstPart, $secondPart));
                }
            }
            if ($this->isUserDefinedInterface($firstPart)) {
                return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forInterfaceMethod($firstPart, $secondPart));
            }
            if ($this->isUserDefinedTrait($firstPart)) {
                return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forTraitMethod($firstPart, $secondPart));
            }
        } else {
            if ($this->isUserDefinedClass($unit)) {
                $units = [\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forClass($unit)];
                foreach ($this->reflectorForClass($unit)->getTraits() as $trait) {
                    if (!$trait->isUserDefined()) {
                        // @codeCoverageIgnoreStart
                        continue;
                        // @codeCoverageIgnoreEnd
                    }
                    $units[] = \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forTrait($trait->getName());
                }
                return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromArray($units);
            }
            if ($this->isUserDefinedInterface($unit)) {
                return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forInterface($unit));
            }
            if ($this->isUserDefinedTrait($unit)) {
                return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forTrait($unit));
            }
            if ($this->isUserDefinedFunction($unit)) {
                return \PHPUnit\SebastianBergmann\CodeUnit\CodeUnitCollection::fromList(\PHPUnit\SebastianBergmann\CodeUnit\CodeUnit::forFunction($unit));
            }
        }
        throw new \PHPUnit\SebastianBergmann\CodeUnit\InvalidCodeUnitException(\sprintf('"%s" is not a valid code unit', $unit));
    }
    /**
     * @psalm-param class-string $className
     *
     * @throws ReflectionException
     */
    private function reflectorForClass(string $className) : \ReflectionClass
    {
        try {
            return new \ReflectionClass($className);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @throws ReflectionException
     */
    private function isUserDefinedFunction(string $functionName) : bool
    {
        if (!\function_exists($functionName)) {
            return \false;
        }
        try {
            return (new \ReflectionFunction($functionName))->isUserDefined();
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @throws ReflectionException
     */
    private function isUserDefinedClass(string $className) : bool
    {
        if (!\class_exists($className)) {
            return \false;
        }
        try {
            return (new \ReflectionClass($className))->isUserDefined();
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @throws ReflectionException
     */
    private function isUserDefinedInterface(string $interfaceName) : bool
    {
        if (!\interface_exists($interfaceName)) {
            return \false;
        }
        try {
            return (new \ReflectionClass($interfaceName))->isUserDefined();
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @throws ReflectionException
     */
    private function isUserDefinedTrait(string $traitName) : bool
    {
        if (!\trait_exists($traitName)) {
            return \false;
        }
        try {
            return (new \ReflectionClass($traitName))->isUserDefined();
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @throws ReflectionException
     */
    private function isUserDefinedMethod(string $className, string $methodName) : bool
    {
        if (!\class_exists($className)) {
            // @codeCoverageIgnoreStart
            return \false;
            // @codeCoverageIgnoreEnd
        }
        if (!\method_exists($className, $methodName)) {
            // @codeCoverageIgnoreStart
            return \false;
            // @codeCoverageIgnoreEnd
        }
        try {
            return (new \ReflectionMethod($className, $methodName))->isUserDefined();
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\CodeUnit\ReflectionException($e->getMessage(), (int) $e->getCode(), $e);
        }
        // @codeCoverageIgnoreEnd
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class TraitMethodUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true TraitMethodUnit $this
     */
    public function isTraitMethod() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

/**
 * @psalm-immutable
 */
final class TraitUnit extends \PHPUnit\SebastianBergmann\CodeUnit\CodeUnit
{
    /**
     * @psalm-assert-if-true TraitUnit $this
     */
    public function isTrait() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use RuntimeException;
final class InvalidCodeUnitException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use RuntimeException;
final class NoTraitException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/code-unit.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\CodeUnit;

use RuntimeException;
final class ReflectionException extends \RuntimeException implements \PHPUnit\SebastianBergmann\CodeUnit\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function array_key_exists;
use function is_array;
use function sort;
use function sprintf;
use function str_replace;
use function trim;
/**
 * Compares arrays for equality.
 *
 * Arrays are equal if they contain the same key-value pairs.
 * The order of the keys does not matter.
 * The types of key-value pairs do not matter.
 */
class ArrayComparator extends \PHPUnit\SebastianBergmann\Comparator\Comparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return \is_array($expected) && \is_array($actual);
    }
    /**
     * Asserts that two arrays are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     * @param array $processed    List of already processed elements (used to prevent infinite recursion)
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false, array &$processed = [])
    {
        if ($canonicalize) {
            \sort($expected);
            \sort($actual);
        }
        $remaining = $actual;
        $actualAsString = "Array (\n";
        $expectedAsString = "Array (\n";
        $equal = \true;
        foreach ($expected as $key => $value) {
            unset($remaining[$key]);
            if (!\array_key_exists($key, $actual)) {
                $expectedAsString .= \sprintf("    %s => %s\n", $this->exporter->export($key), $this->exporter->shortenedExport($value));
                $equal = \false;
                continue;
            }
            try {
                $comparator = $this->factory->getComparatorFor($value, $actual[$key]);
                $comparator->assertEquals($value, $actual[$key], $delta, $canonicalize, $ignoreCase, $processed);
                $expectedAsString .= \sprintf("    %s => %s\n", $this->exporter->export($key), $this->exporter->shortenedExport($value));
                $actualAsString .= \sprintf("    %s => %s\n", $this->exporter->export($key), $this->exporter->shortenedExport($actual[$key]));
            } catch (\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $e) {
                $expectedAsString .= \sprintf("    %s => %s\n", $this->exporter->export($key), $e->getExpectedAsString() ? $this->indent($e->getExpectedAsString()) : $this->exporter->shortenedExport($e->getExpected()));
                $actualAsString .= \sprintf("    %s => %s\n", $this->exporter->export($key), $e->getActualAsString() ? $this->indent($e->getActualAsString()) : $this->exporter->shortenedExport($e->getActual()));
                $equal = \false;
            }
        }
        foreach ($remaining as $key => $value) {
            $actualAsString .= \sprintf("    %s => %s\n", $this->exporter->export($key), $this->exporter->shortenedExport($value));
            $equal = \false;
        }
        $expectedAsString .= ')';
        $actualAsString .= ')';
        if (!$equal) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $expectedAsString, $actualAsString, \false, 'Failed asserting that two arrays are equal.');
        }
    }
    protected function indent($lines)
    {
        return \trim(\str_replace("\n", "\n    ", $lines));
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use PHPUnit\SebastianBergmann\Exporter\Exporter;
/**
 * Abstract base class for comparators which compare values for equality.
 */
abstract class Comparator
{
    /**
     * @var Factory
     */
    protected $factory;
    /**
     * @var Exporter
     */
    protected $exporter;
    public function __construct()
    {
        $this->exporter = new \PHPUnit\SebastianBergmann\Exporter\Exporter();
    }
    public function setFactory(\PHPUnit\SebastianBergmann\Comparator\Factory $factory)
    {
        $this->factory = $factory;
    }
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public abstract function accepts($expected, $actual);
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     *
     * @throws ComparisonFailure
     */
    public abstract function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false);
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use RuntimeException;
use PHPUnit\SebastianBergmann\Diff\Differ;
use PHPUnit\SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder;
/**
 * Thrown when an assertion for string equality failed.
 */
class ComparisonFailure extends \RuntimeException
{
    /**
     * Expected value of the retrieval which does not match $actual.
     *
     * @var mixed
     */
    protected $expected;
    /**
     * Actually retrieved value which does not match $expected.
     *
     * @var mixed
     */
    protected $actual;
    /**
     * The string representation of the expected value.
     *
     * @var string
     */
    protected $expectedAsString;
    /**
     * The string representation of the actual value.
     *
     * @var string
     */
    protected $actualAsString;
    /**
     * @var bool
     */
    protected $identical;
    /**
     * Optional message which is placed in front of the first line
     * returned by toString().
     *
     * @var string
     */
    protected $message;
    /**
     * Initialises with the expected value and the actual value.
     *
     * @param mixed  $expected         expected value retrieved
     * @param mixed  $actual           actual value retrieved
     * @param string $expectedAsString
     * @param string $actualAsString
     * @param bool   $identical
     * @param string $message          a string which is prefixed on all returned lines
     *                                 in the difference output
     */
    public function __construct($expected, $actual, $expectedAsString, $actualAsString, $identical = \false, $message = '')
    {
        $this->expected = $expected;
        $this->actual = $actual;
        $this->expectedAsString = $expectedAsString;
        $this->actualAsString = $actualAsString;
        $this->message = $message;
    }
    public function getActual()
    {
        return $this->actual;
    }
    public function getExpected()
    {
        return $this->expected;
    }
    /**
     * @return string
     */
    public function getActualAsString()
    {
        return $this->actualAsString;
    }
    /**
     * @return string
     */
    public function getExpectedAsString()
    {
        return $this->expectedAsString;
    }
    /**
     * @return string
     */
    public function getDiff()
    {
        if (!$this->actualAsString && !$this->expectedAsString) {
            return '';
        }
        $differ = new \PHPUnit\SebastianBergmann\Diff\Differ(new \PHPUnit\SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder("\n--- Expected\n+++ Actual\n"));
        return $differ->diff($this->expectedAsString, $this->actualAsString);
    }
    /**
     * @return string
     */
    public function toString()
    {
        return $this->message . $this->getDiff();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function sprintf;
use function strtolower;
use DOMDocument;
use DOMNode;
use ValueError;
/**
 * Compares DOMNode instances for equality.
 */
class DOMNodeComparator extends \PHPUnit\SebastianBergmann\Comparator\ObjectComparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return $expected instanceof \DOMNode && $actual instanceof \DOMNode;
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     * @param array $processed    List of already processed elements (used to prevent infinite recursion)
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false, array &$processed = [])
    {
        $expectedAsString = $this->nodeToText($expected, \true, $ignoreCase);
        $actualAsString = $this->nodeToText($actual, \true, $ignoreCase);
        if ($expectedAsString !== $actualAsString) {
            $type = $expected instanceof \DOMDocument ? 'documents' : 'nodes';
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $expectedAsString, $actualAsString, \false, \sprintf("Failed asserting that two DOM %s are equal.\n", $type));
        }
    }
    /**
     * Returns the normalized, whitespace-cleaned, and indented textual
     * representation of a DOMNode.
     */
    private function nodeToText(\DOMNode $node, bool $canonicalize, bool $ignoreCase) : string
    {
        if ($canonicalize) {
            $document = new \DOMDocument();
            try {
                @$document->loadXML($node->C14N());
            } catch (\ValueError $e) {
            }
            $node = $document;
        }
        $document = $node instanceof \DOMDocument ? $node : $node->ownerDocument;
        $document->formatOutput = \true;
        $document->normalizeDocument();
        $text = $node instanceof \DOMDocument ? $node->saveXML() : $document->saveXML($node);
        return $ignoreCase ? \strtolower($text) : $text;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function abs;
use function floor;
use function sprintf;
use DateInterval;
use DateTime;
use DateTimeInterface;
use DateTimeZone;
use Exception;
/**
 * Compares DateTimeInterface instances for equality.
 */
class DateTimeComparator extends \PHPUnit\SebastianBergmann\Comparator\ObjectComparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return ($expected instanceof \DateTime || $expected instanceof \DateTimeInterface) && ($actual instanceof \DateTime || $actual instanceof \DateTimeInterface);
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     * @param array $processed    List of already processed elements (used to prevent infinite recursion)
     *
     * @throws Exception
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false, array &$processed = [])
    {
        /** @var DateTimeInterface $expected */
        /** @var DateTimeInterface $actual */
        $absDelta = \abs($delta);
        $delta = new \DateInterval(\sprintf('PT%dS', $absDelta));
        $delta->f = $absDelta - \floor($absDelta);
        $actualClone = (clone $actual)->setTimezone(new \DateTimeZone('UTC'));
        $expectedLower = (clone $expected)->setTimezone(new \DateTimeZone('UTC'))->sub($delta);
        $expectedUpper = (clone $expected)->setTimezone(new \DateTimeZone('UTC'))->add($delta);
        if ($actualClone < $expectedLower || $actualClone > $expectedUpper) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $this->dateTimeToString($expected), $this->dateTimeToString($actual), \false, 'Failed asserting that two DateTime objects are equal.');
        }
    }
    /**
     * Returns an ISO 8601 formatted string representation of a datetime or
     * 'Invalid DateTimeInterface object' if the provided DateTimeInterface was not properly
     * initialized.
     */
    private function dateTimeToString(\DateTimeInterface $datetime) : string
    {
        $string = $datetime->format('Y-m-d\\TH:i:s.uO');
        return $string ?: 'Invalid DateTimeInterface object';
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function is_float;
use function is_numeric;
/**
 * Compares doubles for equality.
 */
class DoubleComparator extends \PHPUnit\SebastianBergmann\Comparator\NumericComparator
{
    /**
     * Smallest value available in PHP.
     *
     * @var float
     */
    public const EPSILON = 1.0E-10;
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return (\is_float($expected) || \is_float($actual)) && \is_numeric($expected) && \is_numeric($actual);
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false)
    {
        if ($delta == 0) {
            $delta = self::EPSILON;
        }
        parent::assertEquals($expected, $actual, $delta, $canonicalize, $ignoreCase);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use Exception;
/**
 * Compares Exception instances for equality.
 */
class ExceptionComparator extends \PHPUnit\SebastianBergmann\Comparator\ObjectComparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return $expected instanceof \Exception && $actual instanceof \Exception;
    }
    /**
     * Converts an object to an array containing all of its private, protected
     * and public properties.
     *
     * @param object $object
     *
     * @return array
     */
    protected function toArray($object)
    {
        $array = parent::toArray($object);
        unset($array['file'], $array['line'], $array['trace'], $array['string'], $array['xdebug_message']);
        return $array;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function array_unshift;
/**
 * Factory for comparators which compare values for equality.
 */
class Factory
{
    /**
     * @var Factory
     */
    private static $instance;
    /**
     * @var Comparator[]
     */
    private $customComparators = [];
    /**
     * @var Comparator[]
     */
    private $defaultComparators = [];
    /**
     * @return Factory
     */
    public static function getInstance()
    {
        if (self::$instance === null) {
            self::$instance = new self();
            // @codeCoverageIgnore
        }
        return self::$instance;
    }
    /**
     * Constructs a new factory.
     */
    public function __construct()
    {
        $this->registerDefaultComparators();
    }
    /**
     * Returns the correct comparator for comparing two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return Comparator
     */
    public function getComparatorFor($expected, $actual)
    {
        foreach ($this->customComparators as $comparator) {
            if ($comparator->accepts($expected, $actual)) {
                return $comparator;
            }
        }
        foreach ($this->defaultComparators as $comparator) {
            if ($comparator->accepts($expected, $actual)) {
                return $comparator;
            }
        }
        throw new \PHPUnit\SebastianBergmann\Comparator\RuntimeException('No suitable Comparator implementation found');
    }
    /**
     * Registers a new comparator.
     *
     * This comparator will be returned by getComparatorFor() if its accept() method
     * returns TRUE for the compared values. It has higher priority than the
     * existing comparators, meaning that its accept() method will be invoked
     * before those of the other comparators.
     *
     * @param Comparator $comparator The comparator to be registered
     */
    public function register(\PHPUnit\SebastianBergmann\Comparator\Comparator $comparator)
    {
        \array_unshift($this->customComparators, $comparator);
        $comparator->setFactory($this);
    }
    /**
     * Unregisters a comparator.
     *
     * This comparator will no longer be considered by getComparatorFor().
     *
     * @param Comparator $comparator The comparator to be unregistered
     */
    public function unregister(\PHPUnit\SebastianBergmann\Comparator\Comparator $comparator)
    {
        foreach ($this->customComparators as $key => $_comparator) {
            if ($comparator === $_comparator) {
                unset($this->customComparators[$key]);
            }
        }
    }
    /**
     * Unregisters all non-default comparators.
     */
    public function reset()
    {
        $this->customComparators = [];
    }
    private function registerDefaultComparators() : void
    {
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\MockObjectComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\DateTimeComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\DOMNodeComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\SplObjectStorageComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\ExceptionComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\ObjectComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\ResourceComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\ArrayComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\DoubleComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\NumericComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\ScalarComparator());
        $this->registerDefaultComparator(new \PHPUnit\SebastianBergmann\Comparator\TypeComparator());
    }
    private function registerDefaultComparator(\PHPUnit\SebastianBergmann\Comparator\Comparator $comparator) : void
    {
        $this->defaultComparators[] = $comparator;
        $comparator->setFactory($this);
    }
}
Comparator

Copyright (c) 2002-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use PHPUnit\Framework\MockObject\MockObject;
/**
 * Compares PHPUnit\Framework\MockObject\MockObject instances for equality.
 */
class MockObjectComparator extends \PHPUnit\SebastianBergmann\Comparator\ObjectComparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return $expected instanceof \PHPUnit\Framework\MockObject\MockObject && $actual instanceof \PHPUnit\Framework\MockObject\MockObject;
    }
    /**
     * Converts an object to an array containing all of its private, protected
     * and public properties.
     *
     * @param object $object
     *
     * @return array
     */
    protected function toArray($object)
    {
        $array = parent::toArray($object);
        unset($array['__phpunit_invocationMocker']);
        return $array;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function abs;
use function is_float;
use function is_infinite;
use function is_nan;
use function is_numeric;
use function is_string;
use function sprintf;
/**
 * Compares numerical values for equality.
 */
class NumericComparator extends \PHPUnit\SebastianBergmann\Comparator\ScalarComparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        // all numerical values, but not if one of them is a double
        // or both of them are strings
        return \is_numeric($expected) && \is_numeric($actual) && !(\is_float($expected) || \is_float($actual)) && !(\is_string($expected) && \is_string($actual));
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false)
    {
        if ($this->isInfinite($actual) && $this->isInfinite($expected)) {
            return;
        }
        if (($this->isInfinite($actual) xor $this->isInfinite($expected)) || ($this->isNan($actual) || $this->isNan($expected)) || \abs($actual - $expected) > $delta) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, '', '', \false, \sprintf('Failed asserting that %s matches expected %s.', $this->exporter->export($actual), $this->exporter->export($expected)));
        }
    }
    private function isInfinite($value) : bool
    {
        return \is_float($value) && \is_infinite($value);
    }
    private function isNan($value) : bool
    {
        return \is_float($value) && \is_nan($value);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function get_class;
use function in_array;
use function is_object;
use function sprintf;
use function substr_replace;
/**
 * Compares objects for equality.
 */
class ObjectComparator extends \PHPUnit\SebastianBergmann\Comparator\ArrayComparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return \is_object($expected) && \is_object($actual);
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     * @param array $processed    List of already processed elements (used to prevent infinite recursion)
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false, array &$processed = [])
    {
        if (\get_class($actual) !== \get_class($expected)) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $this->exporter->export($expected), $this->exporter->export($actual), \false, \sprintf('%s is not instance of expected class "%s".', $this->exporter->export($actual), \get_class($expected)));
        }
        // don't compare twice to allow for cyclic dependencies
        if (\in_array([$actual, $expected], $processed, \true) || \in_array([$expected, $actual], $processed, \true)) {
            return;
        }
        $processed[] = [$actual, $expected];
        // don't compare objects if they are identical
        // this helps to avoid the error "maximum function nesting level reached"
        // CAUTION: this conditional clause is not tested
        if ($actual !== $expected) {
            try {
                parent::assertEquals($this->toArray($expected), $this->toArray($actual), $delta, $canonicalize, $ignoreCase, $processed);
            } catch (\PHPUnit\SebastianBergmann\Comparator\ComparisonFailure $e) {
                throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure(
                    $expected,
                    $actual,
                    // replace "Array" with "MyClass object"
                    \substr_replace($e->getExpectedAsString(), \get_class($expected) . ' Object', 0, 5),
                    \substr_replace($e->getActualAsString(), \get_class($actual) . ' Object', 0, 5),
                    \false,
                    'Failed asserting that two objects are equal.'
                );
            }
        }
    }
    /**
     * Converts an object to an array containing all of its private, protected
     * and public properties.
     *
     * @param object $object
     *
     * @return array
     */
    protected function toArray($object)
    {
        return $this->exporter->toArray($object);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function is_resource;
/**
 * Compares resources for equality.
 */
class ResourceComparator extends \PHPUnit\SebastianBergmann\Comparator\Comparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return \is_resource($expected) && \is_resource($actual);
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false)
    {
        if ($actual != $expected) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $this->exporter->export($expected), $this->exporter->export($actual));
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function is_object;
use function is_scalar;
use function is_string;
use function method_exists;
use function sprintf;
use function strtolower;
/**
 * Compares scalar or NULL values for equality.
 */
class ScalarComparator extends \PHPUnit\SebastianBergmann\Comparator\Comparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     *
     * @since  Method available since Release 3.6.0
     */
    public function accepts($expected, $actual)
    {
        return (\is_scalar($expected) xor null === $expected) && (\is_scalar($actual) xor null === $actual) || \is_string($expected) && \is_object($actual) && \method_exists($actual, '__toString') || \is_object($expected) && \method_exists($expected, '__toString') && \is_string($actual);
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false)
    {
        $expectedToCompare = $expected;
        $actualToCompare = $actual;
        // always compare as strings to avoid strange behaviour
        // otherwise 0 == 'Foobar'
        if (\is_string($expected) || \is_string($actual)) {
            $expectedToCompare = (string) $expectedToCompare;
            $actualToCompare = (string) $actualToCompare;
            if ($ignoreCase) {
                $expectedToCompare = \strtolower($expectedToCompare);
                $actualToCompare = \strtolower($actualToCompare);
            }
        }
        if ($expectedToCompare !== $actualToCompare && \is_string($expected) && \is_string($actual)) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $this->exporter->export($expected), $this->exporter->export($actual), \false, 'Failed asserting that two strings are equal.');
        }
        if ($expectedToCompare != $actualToCompare) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure(
                $expected,
                $actual,
                // no diff is required
                '',
                '',
                \false,
                \sprintf('Failed asserting that %s matches expected %s.', $this->exporter->export($actual), $this->exporter->export($expected))
            );
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use SplObjectStorage;
/**
 * Compares \SplObjectStorage instances for equality.
 */
class SplObjectStorageComparator extends \PHPUnit\SebastianBergmann\Comparator\Comparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return $expected instanceof \SplObjectStorage && $actual instanceof \SplObjectStorage;
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false)
    {
        foreach ($actual as $object) {
            if (!$expected->contains($object)) {
                throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $this->exporter->export($expected), $this->exporter->export($actual), \false, 'Failed asserting that two objects are equal.');
            }
        }
        foreach ($expected as $object) {
            if (!$actual->contains($object)) {
                throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure($expected, $actual, $this->exporter->export($expected), $this->exporter->export($actual), \false, 'Failed asserting that two objects are equal.');
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use function gettype;
use function sprintf;
/**
 * Compares values for type equality.
 */
class TypeComparator extends \PHPUnit\SebastianBergmann\Comparator\Comparator
{
    /**
     * Returns whether the comparator can compare two values.
     *
     * @param mixed $expected The first value to compare
     * @param mixed $actual   The second value to compare
     *
     * @return bool
     */
    public function accepts($expected, $actual)
    {
        return \true;
    }
    /**
     * Asserts that two values are equal.
     *
     * @param mixed $expected     First value to compare
     * @param mixed $actual       Second value to compare
     * @param float $delta        Allowed numerical distance between two values to consider them equal
     * @param bool  $canonicalize Arrays are sorted before comparison when set to true
     * @param bool  $ignoreCase   Case is ignored when set to true
     *
     * @throws ComparisonFailure
     */
    public function assertEquals($expected, $actual, $delta = 0.0, $canonicalize = \false, $ignoreCase = \false)
    {
        if (\gettype($expected) != \gettype($actual)) {
            throw new \PHPUnit\SebastianBergmann\Comparator\ComparisonFailure(
                $expected,
                $actual,
                // we don't need a diff
                '',
                '',
                \false,
                \sprintf('%s does not match expected type "%s".', $this->exporter->shortenedExport($actual), \gettype($expected))
            );
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/comparator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Comparator;

final class RuntimeException extends \RuntimeException implements \PHPUnit\SebastianBergmann\Comparator\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Lexer;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\NodeVisitor\NameResolver;
use PHPUnit\PhpParser\NodeVisitor\ParentConnectingVisitor;
use PHPUnit\PhpParser\Parser;
use PHPUnit\PhpParser\ParserFactory;
final class Calculator
{
    /**
     * @throws RuntimeException
     */
    public function calculateForSourceFile(string $sourceFile) : \PHPUnit\SebastianBergmann\Complexity\ComplexityCollection
    {
        return $this->calculateForSourceString(\file_get_contents($sourceFile));
    }
    /**
     * @throws RuntimeException
     */
    public function calculateForSourceString(string $source) : \PHPUnit\SebastianBergmann\Complexity\ComplexityCollection
    {
        try {
            $nodes = $this->parser()->parse($source);
            \assert($nodes !== null);
            return $this->calculateForAbstractSyntaxTree($nodes);
            // @codeCoverageIgnoreStart
        } catch (\PHPUnit\PhpParser\Error $error) {
            throw new \PHPUnit\SebastianBergmann\Complexity\RuntimeException($error->getMessage(), (int) $error->getCode(), $error);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @param Node[] $nodes
     *
     * @throws RuntimeException
     */
    public function calculateForAbstractSyntaxTree(array $nodes) : \PHPUnit\SebastianBergmann\Complexity\ComplexityCollection
    {
        $traverser = new \PHPUnit\PhpParser\NodeTraverser();
        $complexityCalculatingVisitor = new \PHPUnit\SebastianBergmann\Complexity\ComplexityCalculatingVisitor(\true);
        $traverser->addVisitor(new \PHPUnit\PhpParser\NodeVisitor\NameResolver());
        $traverser->addVisitor(new \PHPUnit\PhpParser\NodeVisitor\ParentConnectingVisitor());
        $traverser->addVisitor($complexityCalculatingVisitor);
        try {
            /* @noinspection UnusedFunctionResultInspection */
            $traverser->traverse($nodes);
            // @codeCoverageIgnoreStart
        } catch (\PHPUnit\PhpParser\Error $error) {
            throw new \PHPUnit\SebastianBergmann\Complexity\RuntimeException($error->getMessage(), (int) $error->getCode(), $error);
        }
        // @codeCoverageIgnoreEnd
        return $complexityCalculatingVisitor->result();
    }
    private function parser() : \PHPUnit\PhpParser\Parser
    {
        return (new \PHPUnit\PhpParser\ParserFactory())->create(\PHPUnit\PhpParser\ParserFactory::PREFER_PHP7, new \PHPUnit\PhpParser\Lexer());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

/**
 * @psalm-immutable
 */
final class Complexity
{
    private string $name;
    private int $cyclomaticComplexity;
    public function __construct(string $name, int $cyclomaticComplexity)
    {
        $this->name = $name;
        $this->cyclomaticComplexity = $cyclomaticComplexity;
    }
    public function name() : string
    {
        return $this->name;
    }
    public function cyclomaticComplexity() : int
    {
        return $this->cyclomaticComplexity;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

use function count;
use Countable;
use IteratorAggregate;
/**
 * @psalm-immutable
 */
final class ComplexityCollection implements \Countable, \IteratorAggregate
{
    /**
     * @psalm-var list<Complexity>
     */
    private array $items = [];
    public static function fromList(\PHPUnit\SebastianBergmann\Complexity\Complexity ...$items) : self
    {
        return new self($items);
    }
    /**
     * @psalm-param list<Complexity> $items
     */
    private function __construct(array $items)
    {
        $this->items = $items;
    }
    /**
     * @psalm-return list<Complexity>
     */
    public function asArray() : array
    {
        return $this->items;
    }
    public function getIterator() : \PHPUnit\SebastianBergmann\Complexity\ComplexityCollectionIterator
    {
        return new \PHPUnit\SebastianBergmann\Complexity\ComplexityCollectionIterator($this);
    }
    public function count() : int
    {
        return \count($this->items);
    }
    public function isEmpty() : bool
    {
        return empty($this->items);
    }
    public function cyclomaticComplexity() : int
    {
        $cyclomaticComplexity = 0;
        foreach ($this as $item) {
            $cyclomaticComplexity += $item->cyclomaticComplexity();
        }
        return $cyclomaticComplexity;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

use Iterator;
final class ComplexityCollectionIterator implements \Iterator
{
    /**
     * @psalm-var list<Complexity>
     */
    private array $items;
    private int $position = 0;
    public function __construct(\PHPUnit\SebastianBergmann\Complexity\ComplexityCollection $items)
    {
        $this->items = $items->asArray();
    }
    public function rewind() : void
    {
        $this->position = 0;
    }
    public function valid() : bool
    {
        return isset($this->items[$this->position]);
    }
    public function key() : int
    {
        return $this->position;
    }
    public function current() : \PHPUnit\SebastianBergmann\Complexity\Complexity
    {
        return $this->items[$this->position];
    }
    public function next() : void
    {
        $this->position++;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

final class RuntimeException extends \RuntimeException implements \PHPUnit\SebastianBergmann\Complexity\Exception
{
}
sebastian/complexity

Copyright (c) 2020-2021, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

use function assert;
use function is_array;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Name;
use PHPUnit\PhpParser\Node\Stmt;
use PHPUnit\PhpParser\Node\Stmt\Class_;
use PHPUnit\PhpParser\Node\Stmt\ClassMethod;
use PHPUnit\PhpParser\Node\Stmt\Function_;
use PHPUnit\PhpParser\Node\Stmt\Trait_;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\NodeVisitorAbstract;
final class ComplexityCalculatingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    /**
     * @psalm-var list<Complexity>
     */
    private array $result = [];
    private bool $shortCircuitTraversal;
    public function __construct(bool $shortCircuitTraversal)
    {
        $this->shortCircuitTraversal = $shortCircuitTraversal;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node) : ?int
    {
        if (!$node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod && !$node instanceof \PHPUnit\PhpParser\Node\Stmt\Function_) {
            return null;
        }
        if ($node instanceof \PHPUnit\PhpParser\Node\Stmt\ClassMethod) {
            $name = $this->classMethodName($node);
        } else {
            $name = $this->functionName($node);
        }
        $statements = $node->getStmts();
        \assert(\is_array($statements));
        $this->result[] = new \PHPUnit\SebastianBergmann\Complexity\Complexity($name, $this->cyclomaticComplexity($statements));
        if ($this->shortCircuitTraversal) {
            return \PHPUnit\PhpParser\NodeTraverser::DONT_TRAVERSE_CHILDREN;
        }
        return null;
    }
    public function result() : \PHPUnit\SebastianBergmann\Complexity\ComplexityCollection
    {
        return \PHPUnit\SebastianBergmann\Complexity\ComplexityCollection::fromList(...$this->result);
    }
    /**
     * @param Stmt[] $statements
     */
    private function cyclomaticComplexity(array $statements) : int
    {
        $traverser = new \PHPUnit\PhpParser\NodeTraverser();
        $cyclomaticComplexityCalculatingVisitor = new \PHPUnit\SebastianBergmann\Complexity\CyclomaticComplexityCalculatingVisitor();
        $traverser->addVisitor($cyclomaticComplexityCalculatingVisitor);
        /* @noinspection UnusedFunctionResultInspection */
        $traverser->traverse($statements);
        return $cyclomaticComplexityCalculatingVisitor->cyclomaticComplexity();
    }
    private function classMethodName(\PHPUnit\PhpParser\Node\Stmt\ClassMethod $node) : string
    {
        $parent = $node->getAttribute('parent');
        \assert($parent instanceof \PHPUnit\PhpParser\Node\Stmt\Class_ || $parent instanceof \PHPUnit\PhpParser\Node\Stmt\Trait_);
        \assert(isset($parent->namespacedName));
        \assert($parent->namespacedName instanceof \PHPUnit\PhpParser\Node\Name);
        return $parent->namespacedName->toString() . '::' . $node->name->toString();
    }
    private function functionName(\PHPUnit\PhpParser\Node\Stmt\Function_ $node) : string
    {
        \assert(isset($node->namespacedName));
        \assert($node->namespacedName instanceof \PHPUnit\PhpParser\Node\Name);
        return $node->namespacedName->toString();
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/complexity.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Complexity;

use function get_class;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd;
use PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr;
use PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd;
use PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr;
use PHPUnit\PhpParser\Node\Expr\Ternary;
use PHPUnit\PhpParser\Node\Stmt\Case_;
use PHPUnit\PhpParser\Node\Stmt\Catch_;
use PHPUnit\PhpParser\Node\Stmt\ElseIf_;
use PHPUnit\PhpParser\Node\Stmt\For_;
use PHPUnit\PhpParser\Node\Stmt\Foreach_;
use PHPUnit\PhpParser\Node\Stmt\If_;
use PHPUnit\PhpParser\Node\Stmt\While_;
use PHPUnit\PhpParser\NodeVisitorAbstract;
final class CyclomaticComplexityCalculatingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    private int $cyclomaticComplexity = 1;
    public function enterNode(\PHPUnit\PhpParser\Node $node) : void
    {
        /* @noinspection GetClassMissUseInspection */
        switch (\get_class($node)) {
            case \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanAnd::class:
            case \PHPUnit\PhpParser\Node\Expr\BinaryOp\BooleanOr::class:
            case \PHPUnit\PhpParser\Node\Stmt\Case_::class:
            case \PHPUnit\PhpParser\Node\Stmt\Catch_::class:
            case \PHPUnit\PhpParser\Node\Stmt\ElseIf_::class:
            case \PHPUnit\PhpParser\Node\Stmt\For_::class:
            case \PHPUnit\PhpParser\Node\Stmt\Foreach_::class:
            case \PHPUnit\PhpParser\Node\Stmt\If_::class:
            case \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalAnd::class:
            case \PHPUnit\PhpParser\Node\Expr\BinaryOp\LogicalOr::class:
            case \PHPUnit\PhpParser\Node\Expr\Ternary::class:
            case \PHPUnit\PhpParser\Node\Stmt\While_::class:
                $this->cyclomaticComplexity++;
        }
    }
    public function cyclomaticComplexity() : int
    {
        return $this->cyclomaticComplexity;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

final class Chunk
{
    /**
     * @var int
     */
    private $start;
    /**
     * @var int
     */
    private $startRange;
    /**
     * @var int
     */
    private $end;
    /**
     * @var int
     */
    private $endRange;
    /**
     * @var Line[]
     */
    private $lines;
    public function __construct(int $start = 0, int $startRange = 1, int $end = 0, int $endRange = 1, array $lines = [])
    {
        $this->start = $start;
        $this->startRange = $startRange;
        $this->end = $end;
        $this->endRange = $endRange;
        $this->lines = $lines;
    }
    public function getStart() : int
    {
        return $this->start;
    }
    public function getStartRange() : int
    {
        return $this->startRange;
    }
    public function getEnd() : int
    {
        return $this->end;
    }
    public function getEndRange() : int
    {
        return $this->endRange;
    }
    /**
     * @return Line[]
     */
    public function getLines() : array
    {
        return $this->lines;
    }
    /**
     * @param Line[] $lines
     */
    public function setLines(array $lines) : void
    {
        foreach ($lines as $line) {
            if (!$line instanceof \PHPUnit\SebastianBergmann\Diff\Line) {
                throw new \PHPUnit\SebastianBergmann\Diff\InvalidArgumentException();
            }
        }
        $this->lines = $lines;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

final class Diff
{
    /**
     * @var string
     */
    private $from;
    /**
     * @var string
     */
    private $to;
    /**
     * @var Chunk[]
     */
    private $chunks;
    /**
     * @param Chunk[] $chunks
     */
    public function __construct(string $from, string $to, array $chunks = [])
    {
        $this->from = $from;
        $this->to = $to;
        $this->chunks = $chunks;
    }
    public function getFrom() : string
    {
        return $this->from;
    }
    public function getTo() : string
    {
        return $this->to;
    }
    /**
     * @return Chunk[]
     */
    public function getChunks() : array
    {
        return $this->chunks;
    }
    /**
     * @param Chunk[] $chunks
     */
    public function setChunks(array $chunks) : void
    {
        $this->chunks = $chunks;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

use const PHP_INT_SIZE;
use const PREG_SPLIT_DELIM_CAPTURE;
use const PREG_SPLIT_NO_EMPTY;
use function array_shift;
use function array_unshift;
use function array_values;
use function count;
use function current;
use function end;
use function get_class;
use function gettype;
use function is_array;
use function is_object;
use function is_string;
use function key;
use function min;
use function preg_split;
use function prev;
use function reset;
use function sprintf;
use function substr;
use PHPUnit\SebastianBergmann\Diff\Output\DiffOutputBuilderInterface;
use PHPUnit\SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder;
final class Differ
{
    public const OLD = 0;
    public const ADDED = 1;
    public const REMOVED = 2;
    public const DIFF_LINE_END_WARNING = 3;
    public const NO_LINE_END_EOF_WARNING = 4;
    /**
     * @var DiffOutputBuilderInterface
     */
    private $outputBuilder;
    /**
     * @param DiffOutputBuilderInterface $outputBuilder
     *
     * @throws InvalidArgumentException
     */
    public function __construct($outputBuilder = null)
    {
        if ($outputBuilder instanceof \PHPUnit\SebastianBergmann\Diff\Output\DiffOutputBuilderInterface) {
            $this->outputBuilder = $outputBuilder;
        } elseif (null === $outputBuilder) {
            $this->outputBuilder = new \PHPUnit\SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder();
        } elseif (\is_string($outputBuilder)) {
            // PHPUnit 6.1.4, 6.2.0, 6.2.1, 6.2.2, and 6.2.3 support
            // @see https://github.com/sebastianbergmann/phpunit/issues/2734#issuecomment-314514056
            // @deprecated
            $this->outputBuilder = new \PHPUnit\SebastianBergmann\Diff\Output\UnifiedDiffOutputBuilder($outputBuilder);
        } else {
            throw new \PHPUnit\SebastianBergmann\Diff\InvalidArgumentException(\sprintf('Expected builder to be an instance of DiffOutputBuilderInterface, <null> or a string, got %s.', \is_object($outputBuilder) ? 'instance of "' . \get_class($outputBuilder) . '"' : \gettype($outputBuilder) . ' "' . $outputBuilder . '"'));
        }
    }
    /**
     * Returns the diff between two arrays or strings as string.
     *
     * @param array|string $from
     * @param array|string $to
     */
    public function diff($from, $to, \PHPUnit\SebastianBergmann\Diff\LongestCommonSubsequenceCalculator $lcs = null) : string
    {
        $diff = $this->diffToArray($this->normalizeDiffInput($from), $this->normalizeDiffInput($to), $lcs);
        return $this->outputBuilder->getDiff($diff);
    }
    /**
     * Returns the diff between two arrays or strings as array.
     *
     * Each array element contains two elements:
     *   - [0] => mixed $token
     *   - [1] => 2|1|0
     *
     * - 2: REMOVED: $token was removed from $from
     * - 1: ADDED: $token was added to $from
     * - 0: OLD: $token is not changed in $to
     *
     * @param array|string                       $from
     * @param array|string                       $to
     * @param LongestCommonSubsequenceCalculator $lcs
     */
    public function diffToArray($from, $to, \PHPUnit\SebastianBergmann\Diff\LongestCommonSubsequenceCalculator $lcs = null) : array
    {
        if (\is_string($from)) {
            $from = $this->splitStringByLines($from);
        } elseif (!\is_array($from)) {
            throw new \PHPUnit\SebastianBergmann\Diff\InvalidArgumentException('"from" must be an array or string.');
        }
        if (\is_string($to)) {
            $to = $this->splitStringByLines($to);
        } elseif (!\is_array($to)) {
            throw new \PHPUnit\SebastianBergmann\Diff\InvalidArgumentException('"to" must be an array or string.');
        }
        [$from, $to, $start, $end] = self::getArrayDiffParted($from, $to);
        if ($lcs === null) {
            $lcs = $this->selectLcsImplementation($from, $to);
        }
        $common = $lcs->calculate(\array_values($from), \array_values($to));
        $diff = [];
        foreach ($start as $token) {
            $diff[] = [$token, self::OLD];
        }
        \reset($from);
        \reset($to);
        foreach ($common as $token) {
            while (($fromToken = \reset($from)) !== $token) {
                $diff[] = [\array_shift($from), self::REMOVED];
            }
            while (($toToken = \reset($to)) !== $token) {
                $diff[] = [\array_shift($to), self::ADDED];
            }
            $diff[] = [$token, self::OLD];
            \array_shift($from);
            \array_shift($to);
        }
        while (($token = \array_shift($from)) !== null) {
            $diff[] = [$token, self::REMOVED];
        }
        while (($token = \array_shift($to)) !== null) {
            $diff[] = [$token, self::ADDED];
        }
        foreach ($end as $token) {
            $diff[] = [$token, self::OLD];
        }
        if ($this->detectUnmatchedLineEndings($diff)) {
            \array_unshift($diff, ["#Warning: Strings contain different line endings!\n", self::DIFF_LINE_END_WARNING]);
        }
        return $diff;
    }
    /**
     * Casts variable to string if it is not a string or array.
     *
     * @return array|string
     */
    private function normalizeDiffInput($input)
    {
        if (!\is_array($input) && !\is_string($input)) {
            return (string) $input;
        }
        return $input;
    }
    /**
     * Checks if input is string, if so it will split it line-by-line.
     */
    private function splitStringByLines(string $input) : array
    {
        return \preg_split('/(.*\\R)/', $input, -1, \PREG_SPLIT_DELIM_CAPTURE | \PREG_SPLIT_NO_EMPTY);
    }
    private function selectLcsImplementation(array $from, array $to) : \PHPUnit\SebastianBergmann\Diff\LongestCommonSubsequenceCalculator
    {
        // We do not want to use the time-efficient implementation if its memory
        // footprint will probably exceed this value. Note that the footprint
        // calculation is only an estimation for the matrix and the LCS method
        // will typically allocate a bit more memory than this.
        $memoryLimit = 100 * 1024 * 1024;
        if ($this->calculateEstimatedFootprint($from, $to) > $memoryLimit) {
            return new \PHPUnit\SebastianBergmann\Diff\MemoryEfficientLongestCommonSubsequenceCalculator();
        }
        return new \PHPUnit\SebastianBergmann\Diff\TimeEfficientLongestCommonSubsequenceCalculator();
    }
    /**
     * Calculates the estimated memory footprint for the DP-based method.
     *
     * @return float|int
     */
    private function calculateEstimatedFootprint(array $from, array $to)
    {
        $itemSize = \PHP_INT_SIZE === 4 ? 76 : 144;
        return $itemSize * \min(\count($from), \count($to)) ** 2;
    }
    /**
     * Returns true if line ends don't match in a diff.
     */
    private function detectUnmatchedLineEndings(array $diff) : bool
    {
        $newLineBreaks = ['' => \true];
        $oldLineBreaks = ['' => \true];
        foreach ($diff as $entry) {
            if (self::OLD === $entry[1]) {
                $ln = $this->getLinebreak($entry[0]);
                $oldLineBreaks[$ln] = \true;
                $newLineBreaks[$ln] = \true;
            } elseif (self::ADDED === $entry[1]) {
                $newLineBreaks[$this->getLinebreak($entry[0])] = \true;
            } elseif (self::REMOVED === $entry[1]) {
                $oldLineBreaks[$this->getLinebreak($entry[0])] = \true;
            }
        }
        // if either input or output is a single line without breaks than no warning should be raised
        if (['' => \true] === $newLineBreaks || ['' => \true] === $oldLineBreaks) {
            return \false;
        }
        // two way compare
        foreach ($newLineBreaks as $break => $set) {
            if (!isset($oldLineBreaks[$break])) {
                return \true;
            }
        }
        foreach ($oldLineBreaks as $break => $set) {
            if (!isset($newLineBreaks[$break])) {
                return \true;
            }
        }
        return \false;
    }
    private function getLinebreak($line) : string
    {
        if (!\is_string($line)) {
            return '';
        }
        $lc = \substr($line, -1);
        if ("\r" === $lc) {
            return "\r";
        }
        if ("\n" !== $lc) {
            return '';
        }
        if ("\r\n" === \substr($line, -2)) {
            return "\r\n";
        }
        return "\n";
    }
    private static function getArrayDiffParted(array &$from, array &$to) : array
    {
        $start = [];
        $end = [];
        \reset($to);
        foreach ($from as $k => $v) {
            $toK = \key($to);
            if ($toK === $k && $v === $to[$k]) {
                $start[$k] = $v;
                unset($from[$k], $to[$k]);
            } else {
                break;
            }
        }
        \end($from);
        \end($to);
        do {
            $fromK = \key($from);
            $toK = \key($to);
            if (null === $fromK || null === $toK || \current($from) !== \current($to)) {
                break;
            }
            \prev($from);
            \prev($to);
            $end = [$fromK => $from[$fromK]] + $end;
            unset($from[$fromK], $to[$toK]);
        } while (\true);
        return [$from, $to, $start, $end];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

use function get_class;
use function gettype;
use function is_object;
use function sprintf;
use Exception;
final class ConfigurationException extends \PHPUnit\SebastianBergmann\Diff\InvalidArgumentException
{
    public function __construct(string $option, string $expected, $value, int $code = 0, \Exception $previous = null)
    {
        parent::__construct(\sprintf('Option "%s" must be %s, got "%s".', $option, $expected, \is_object($value) ? \get_class($value) : (null === $value ? '<null>' : \gettype($value) . '#' . $value)), $code, $previous);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

class InvalidArgumentException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\Diff\Exception
{
}
sebastian/diff

Copyright (c) 2002-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

final class Line
{
    public const ADDED = 1;
    public const REMOVED = 2;
    public const UNCHANGED = 3;
    /**
     * @var int
     */
    private $type;
    /**
     * @var string
     */
    private $content;
    public function __construct(int $type = self::UNCHANGED, string $content = '')
    {
        $this->type = $type;
        $this->content = $content;
    }
    public function getContent() : string
    {
        return $this->content;
    }
    public function getType() : int
    {
        return $this->type;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

interface LongestCommonSubsequenceCalculator
{
    /**
     * Calculates the longest common subsequence of two arrays.
     */
    public function calculate(array $from, array $to) : array;
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

use function array_fill;
use function array_merge;
use function array_reverse;
use function array_slice;
use function count;
use function in_array;
use function max;
final class MemoryEfficientLongestCommonSubsequenceCalculator implements \PHPUnit\SebastianBergmann\Diff\LongestCommonSubsequenceCalculator
{
    /**
     * {@inheritdoc}
     */
    public function calculate(array $from, array $to) : array
    {
        $cFrom = \count($from);
        $cTo = \count($to);
        if ($cFrom === 0) {
            return [];
        }
        if ($cFrom === 1) {
            if (\in_array($from[0], $to, \true)) {
                return [$from[0]];
            }
            return [];
        }
        $i = (int) ($cFrom / 2);
        $fromStart = \array_slice($from, 0, $i);
        $fromEnd = \array_slice($from, $i);
        $llB = $this->length($fromStart, $to);
        $llE = $this->length(\array_reverse($fromEnd), \array_reverse($to));
        $jMax = 0;
        $max = 0;
        for ($j = 0; $j <= $cTo; $j++) {
            $m = $llB[$j] + $llE[$cTo - $j];
            if ($m >= $max) {
                $max = $m;
                $jMax = $j;
            }
        }
        $toStart = \array_slice($to, 0, $jMax);
        $toEnd = \array_slice($to, $jMax);
        return \array_merge($this->calculate($fromStart, $toStart), $this->calculate($fromEnd, $toEnd));
    }
    private function length(array $from, array $to) : array
    {
        $current = \array_fill(0, \count($to) + 1, 0);
        $cFrom = \count($from);
        $cTo = \count($to);
        for ($i = 0; $i < $cFrom; $i++) {
            $prev = $current;
            for ($j = 0; $j < $cTo; $j++) {
                if ($from[$i] === $to[$j]) {
                    $current[$j + 1] = $prev[$j] + 1;
                } else {
                    $current[$j + 1] = \max($current[$j], $prev[$j + 1]);
                }
            }
        }
        return $current;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff\Output;

use function count;
abstract class AbstractChunkOutputBuilder implements \PHPUnit\SebastianBergmann\Diff\Output\DiffOutputBuilderInterface
{
    /**
     * Takes input of the diff array and returns the common parts.
     * Iterates through diff line by line.
     */
    protected function getCommonChunks(array $diff, int $lineThreshold = 5) : array
    {
        $diffSize = \count($diff);
        $capturing = \false;
        $chunkStart = 0;
        $chunkSize = 0;
        $commonChunks = [];
        for ($i = 0; $i < $diffSize; ++$i) {
            if ($diff[$i][1] === 0) {
                if ($capturing === \false) {
                    $capturing = \true;
                    $chunkStart = $i;
                    $chunkSize = 0;
                } else {
                    ++$chunkSize;
                }
            } elseif ($capturing !== \false) {
                if ($chunkSize >= $lineThreshold) {
                    $commonChunks[$chunkStart] = $chunkStart + $chunkSize;
                }
                $capturing = \false;
            }
        }
        if ($capturing !== \false && $chunkSize >= $lineThreshold) {
            $commonChunks[$chunkStart] = $chunkStart + $chunkSize;
        }
        return $commonChunks;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff\Output;

use function fclose;
use function fopen;
use function fwrite;
use function stream_get_contents;
use function substr;
use PHPUnit\SebastianBergmann\Diff\Differ;
/**
 * Builds a diff string representation in a loose unified diff format
 * listing only changes lines. Does not include line numbers.
 */
final class DiffOnlyOutputBuilder implements \PHPUnit\SebastianBergmann\Diff\Output\DiffOutputBuilderInterface
{
    /**
     * @var string
     */
    private $header;
    public function __construct(string $header = "--- Original\n+++ New\n")
    {
        $this->header = $header;
    }
    public function getDiff(array $diff) : string
    {
        $buffer = \fopen('php://memory', 'r+b');
        if ('' !== $this->header) {
            \fwrite($buffer, $this->header);
            if ("\n" !== \substr($this->header, -1, 1)) {
                \fwrite($buffer, "\n");
            }
        }
        foreach ($diff as $diffEntry) {
            if ($diffEntry[1] === \PHPUnit\SebastianBergmann\Diff\Differ::ADDED) {
                \fwrite($buffer, '+' . $diffEntry[0]);
            } elseif ($diffEntry[1] === \PHPUnit\SebastianBergmann\Diff\Differ::REMOVED) {
                \fwrite($buffer, '-' . $diffEntry[0]);
            } elseif ($diffEntry[1] === \PHPUnit\SebastianBergmann\Diff\Differ::DIFF_LINE_END_WARNING) {
                \fwrite($buffer, ' ' . $diffEntry[0]);
                continue;
                // Warnings should not be tested for line break, it will always be there
            } else {
                /* Not changed (old) 0 */
                continue;
                // we didn't write the non changs line, so do not add a line break either
            }
            $lc = \substr($diffEntry[0], -1);
            if ($lc !== "\n" && $lc !== "\r") {
                \fwrite($buffer, "\n");
                // \No newline at end of file
            }
        }
        $diff = \stream_get_contents($buffer, -1, 0);
        \fclose($buffer);
        return $diff;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff\Output;

/**
 * Defines how an output builder should take a generated
 * diff array and return a string representation of that diff.
 */
interface DiffOutputBuilderInterface
{
    public function getDiff(array $diff) : string;
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff\Output;

use function array_merge;
use function array_splice;
use function count;
use function fclose;
use function fopen;
use function fwrite;
use function is_bool;
use function is_int;
use function is_string;
use function max;
use function min;
use function sprintf;
use function stream_get_contents;
use function substr;
use PHPUnit\SebastianBergmann\Diff\ConfigurationException;
use PHPUnit\SebastianBergmann\Diff\Differ;
/**
 * Strict Unified diff output builder.
 *
 * Generates (strict) Unified diff's (unidiffs) with hunks.
 */
final class StrictUnifiedDiffOutputBuilder implements \PHPUnit\SebastianBergmann\Diff\Output\DiffOutputBuilderInterface
{
    private static $default = [
        'collapseRanges' => \true,
        // ranges of length one are rendered with the trailing `,1`
        'commonLineThreshold' => 6,
        // number of same lines before ending a new hunk and creating a new one (if needed)
        'contextLines' => 3,
        // like `diff:  -u, -U NUM, --unified[=NUM]`, for patch/git apply compatibility best to keep at least @ 3
        'fromFile' => null,
        'fromFileDate' => null,
        'toFile' => null,
        'toFileDate' => null,
    ];
    /**
     * @var bool
     */
    private $changed;
    /**
     * @var bool
     */
    private $collapseRanges;
    /**
     * @var int >= 0
     */
    private $commonLineThreshold;
    /**
     * @var string
     */
    private $header;
    /**
     * @var int >= 0
     */
    private $contextLines;
    public function __construct(array $options = [])
    {
        $options = \array_merge(self::$default, $options);
        if (!\is_bool($options['collapseRanges'])) {
            throw new \PHPUnit\SebastianBergmann\Diff\ConfigurationException('collapseRanges', 'a bool', $options['collapseRanges']);
        }
        if (!\is_int($options['contextLines']) || $options['contextLines'] < 0) {
            throw new \PHPUnit\SebastianBergmann\Diff\ConfigurationException('contextLines', 'an int >= 0', $options['contextLines']);
        }
        if (!\is_int($options['commonLineThreshold']) || $options['commonLineThreshold'] <= 0) {
            throw new \PHPUnit\SebastianBergmann\Diff\ConfigurationException('commonLineThreshold', 'an int > 0', $options['commonLineThreshold']);
        }
        $this->assertString($options, 'fromFile');
        $this->assertString($options, 'toFile');
        $this->assertStringOrNull($options, 'fromFileDate');
        $this->assertStringOrNull($options, 'toFileDate');
        $this->header = \sprintf("--- %s%s\n+++ %s%s\n", $options['fromFile'], null === $options['fromFileDate'] ? '' : "\t" . $options['fromFileDate'], $options['toFile'], null === $options['toFileDate'] ? '' : "\t" . $options['toFileDate']);
        $this->collapseRanges = $options['collapseRanges'];
        $this->commonLineThreshold = $options['commonLineThreshold'];
        $this->contextLines = $options['contextLines'];
    }
    public function getDiff(array $diff) : string
    {
        if (0 === \count($diff)) {
            return '';
        }
        $this->changed = \false;
        $buffer = \fopen('php://memory', 'r+b');
        \fwrite($buffer, $this->header);
        $this->writeDiffHunks($buffer, $diff);
        if (!$this->changed) {
            \fclose($buffer);
            return '';
        }
        $diff = \stream_get_contents($buffer, -1, 0);
        \fclose($buffer);
        // If the last char is not a linebreak: add it.
        // This might happen when both the `from` and `to` do not have a trailing linebreak
        $last = \substr($diff, -1);
        return "\n" !== $last && "\r" !== $last ? $diff . "\n" : $diff;
    }
    private function writeDiffHunks($output, array $diff) : void
    {
        // detect "No newline at end of file" and insert into `$diff` if needed
        $upperLimit = \count($diff);
        if (0 === $diff[$upperLimit - 1][1]) {
            $lc = \substr($diff[$upperLimit - 1][0], -1);
            if ("\n" !== $lc) {
                \array_splice($diff, $upperLimit, 0, [["\n\\ No newline at end of file\n", \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING]]);
            }
        } else {
            // search back for the last `+` and `-` line,
            // check if has trailing linebreak, else add under it warning under it
            $toFind = [1 => \true, 2 => \true];
            for ($i = $upperLimit - 1; $i >= 0; --$i) {
                if (isset($toFind[$diff[$i][1]])) {
                    unset($toFind[$diff[$i][1]]);
                    $lc = \substr($diff[$i][0], -1);
                    if ("\n" !== $lc) {
                        \array_splice($diff, $i + 1, 0, [["\n\\ No newline at end of file\n", \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING]]);
                    }
                    if (!\count($toFind)) {
                        break;
                    }
                }
            }
        }
        // write hunks to output buffer
        $cutOff = \max($this->commonLineThreshold, $this->contextLines);
        $hunkCapture = \false;
        $sameCount = $toRange = $fromRange = 0;
        $toStart = $fromStart = 1;
        $i = 0;
        /** @var int $i */
        foreach ($diff as $i => $entry) {
            if (0 === $entry[1]) {
                // same
                if (\false === $hunkCapture) {
                    ++$fromStart;
                    ++$toStart;
                    continue;
                }
                ++$sameCount;
                ++$toRange;
                ++$fromRange;
                if ($sameCount === $cutOff) {
                    $contextStartOffset = $hunkCapture - $this->contextLines < 0 ? $hunkCapture : $this->contextLines;
                    // note: $contextEndOffset = $this->contextLines;
                    //
                    // because we never go beyond the end of the diff.
                    // with the cutoff/contextlines here the follow is never true;
                    //
                    // if ($i - $cutOff + $this->contextLines + 1 > \count($diff)) {
                    //    $contextEndOffset = count($diff) - 1;
                    // }
                    //
                    // ; that would be true for a trailing incomplete hunk case which is dealt with after this loop
                    $this->writeHunk($diff, $hunkCapture - $contextStartOffset, $i - $cutOff + $this->contextLines + 1, $fromStart - $contextStartOffset, $fromRange - $cutOff + $contextStartOffset + $this->contextLines, $toStart - $contextStartOffset, $toRange - $cutOff + $contextStartOffset + $this->contextLines, $output);
                    $fromStart += $fromRange;
                    $toStart += $toRange;
                    $hunkCapture = \false;
                    $sameCount = $toRange = $fromRange = 0;
                }
                continue;
            }
            $sameCount = 0;
            if ($entry[1] === \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING) {
                continue;
            }
            $this->changed = \true;
            if (\false === $hunkCapture) {
                $hunkCapture = $i;
            }
            if (\PHPUnit\SebastianBergmann\Diff\Differ::ADDED === $entry[1]) {
                // added
                ++$toRange;
            }
            if (\PHPUnit\SebastianBergmann\Diff\Differ::REMOVED === $entry[1]) {
                // removed
                ++$fromRange;
            }
        }
        if (\false === $hunkCapture) {
            return;
        }
        // we end here when cutoff (commonLineThreshold) was not reached, but we where capturing a hunk,
        // do not render hunk till end automatically because the number of context lines might be less than the commonLineThreshold
        $contextStartOffset = $hunkCapture - $this->contextLines < 0 ? $hunkCapture : $this->contextLines;
        // prevent trying to write out more common lines than there are in the diff _and_
        // do not write more than configured through the context lines
        $contextEndOffset = \min($sameCount, $this->contextLines);
        $fromRange -= $sameCount;
        $toRange -= $sameCount;
        $this->writeHunk($diff, $hunkCapture - $contextStartOffset, $i - $sameCount + $contextEndOffset + 1, $fromStart - $contextStartOffset, $fromRange + $contextStartOffset + $contextEndOffset, $toStart - $contextStartOffset, $toRange + $contextStartOffset + $contextEndOffset, $output);
    }
    private function writeHunk(array $diff, int $diffStartIndex, int $diffEndIndex, int $fromStart, int $fromRange, int $toStart, int $toRange, $output) : void
    {
        \fwrite($output, '@@ -' . $fromStart);
        if (!$this->collapseRanges || 1 !== $fromRange) {
            \fwrite($output, ',' . $fromRange);
        }
        \fwrite($output, ' +' . $toStart);
        if (!$this->collapseRanges || 1 !== $toRange) {
            \fwrite($output, ',' . $toRange);
        }
        \fwrite($output, " @@\n");
        for ($i = $diffStartIndex; $i < $diffEndIndex; ++$i) {
            if ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::ADDED) {
                $this->changed = \true;
                \fwrite($output, '+' . $diff[$i][0]);
            } elseif ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::REMOVED) {
                $this->changed = \true;
                \fwrite($output, '-' . $diff[$i][0]);
            } elseif ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::OLD) {
                \fwrite($output, ' ' . $diff[$i][0]);
            } elseif ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING) {
                $this->changed = \true;
                \fwrite($output, $diff[$i][0]);
            }
            //} elseif ($diff[$i][1] === Differ::DIFF_LINE_END_WARNING) { // custom comment inserted by PHPUnit/diff package
            //  skip
            //} else {
            //  unknown/invalid
            //}
        }
    }
    private function assertString(array $options, string $option) : void
    {
        if (!\is_string($options[$option])) {
            throw new \PHPUnit\SebastianBergmann\Diff\ConfigurationException($option, 'a string', $options[$option]);
        }
    }
    private function assertStringOrNull(array $options, string $option) : void
    {
        if (null !== $options[$option] && !\is_string($options[$option])) {
            throw new \PHPUnit\SebastianBergmann\Diff\ConfigurationException($option, 'a string or <null>', $options[$option]);
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff\Output;

use function array_splice;
use function count;
use function fclose;
use function fopen;
use function fwrite;
use function max;
use function min;
use function stream_get_contents;
use function strlen;
use function substr;
use PHPUnit\SebastianBergmann\Diff\Differ;
/**
 * Builds a diff string representation in unified diff format in chunks.
 */
final class UnifiedDiffOutputBuilder extends \PHPUnit\SebastianBergmann\Diff\Output\AbstractChunkOutputBuilder
{
    /**
     * @var bool
     */
    private $collapseRanges = \true;
    /**
     * @var int >= 0
     */
    private $commonLineThreshold = 6;
    /**
     * @var int >= 0
     */
    private $contextLines = 3;
    /**
     * @var string
     */
    private $header;
    /**
     * @var bool
     */
    private $addLineNumbers;
    public function __construct(string $header = "--- Original\n+++ New\n", bool $addLineNumbers = \false)
    {
        $this->header = $header;
        $this->addLineNumbers = $addLineNumbers;
    }
    public function getDiff(array $diff) : string
    {
        $buffer = \fopen('php://memory', 'r+b');
        if ('' !== $this->header) {
            \fwrite($buffer, $this->header);
            if ("\n" !== \substr($this->header, -1, 1)) {
                \fwrite($buffer, "\n");
            }
        }
        if (0 !== \count($diff)) {
            $this->writeDiffHunks($buffer, $diff);
        }
        $diff = \stream_get_contents($buffer, -1, 0);
        \fclose($buffer);
        // If the diff is non-empty and last char is not a linebreak: add it.
        // This might happen when both the `from` and `to` do not have a trailing linebreak
        $last = \substr($diff, -1);
        return 0 !== \strlen($diff) && "\n" !== $last && "\r" !== $last ? $diff . "\n" : $diff;
    }
    private function writeDiffHunks($output, array $diff) : void
    {
        // detect "No newline at end of file" and insert into `$diff` if needed
        $upperLimit = \count($diff);
        if (0 === $diff[$upperLimit - 1][1]) {
            $lc = \substr($diff[$upperLimit - 1][0], -1);
            if ("\n" !== $lc) {
                \array_splice($diff, $upperLimit, 0, [["\n\\ No newline at end of file\n", \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING]]);
            }
        } else {
            // search back for the last `+` and `-` line,
            // check if has trailing linebreak, else add under it warning under it
            $toFind = [1 => \true, 2 => \true];
            for ($i = $upperLimit - 1; $i >= 0; --$i) {
                if (isset($toFind[$diff[$i][1]])) {
                    unset($toFind[$diff[$i][1]]);
                    $lc = \substr($diff[$i][0], -1);
                    if ("\n" !== $lc) {
                        \array_splice($diff, $i + 1, 0, [["\n\\ No newline at end of file\n", \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING]]);
                    }
                    if (!\count($toFind)) {
                        break;
                    }
                }
            }
        }
        // write hunks to output buffer
        $cutOff = \max($this->commonLineThreshold, $this->contextLines);
        $hunkCapture = \false;
        $sameCount = $toRange = $fromRange = 0;
        $toStart = $fromStart = 1;
        $i = 0;
        /** @var int $i */
        foreach ($diff as $i => $entry) {
            if (0 === $entry[1]) {
                // same
                if (\false === $hunkCapture) {
                    ++$fromStart;
                    ++$toStart;
                    continue;
                }
                ++$sameCount;
                ++$toRange;
                ++$fromRange;
                if ($sameCount === $cutOff) {
                    $contextStartOffset = $hunkCapture - $this->contextLines < 0 ? $hunkCapture : $this->contextLines;
                    // note: $contextEndOffset = $this->contextLines;
                    //
                    // because we never go beyond the end of the diff.
                    // with the cutoff/contextlines here the follow is never true;
                    //
                    // if ($i - $cutOff + $this->contextLines + 1 > \count($diff)) {
                    //    $contextEndOffset = count($diff) - 1;
                    // }
                    //
                    // ; that would be true for a trailing incomplete hunk case which is dealt with after this loop
                    $this->writeHunk($diff, $hunkCapture - $contextStartOffset, $i - $cutOff + $this->contextLines + 1, $fromStart - $contextStartOffset, $fromRange - $cutOff + $contextStartOffset + $this->contextLines, $toStart - $contextStartOffset, $toRange - $cutOff + $contextStartOffset + $this->contextLines, $output);
                    $fromStart += $fromRange;
                    $toStart += $toRange;
                    $hunkCapture = \false;
                    $sameCount = $toRange = $fromRange = 0;
                }
                continue;
            }
            $sameCount = 0;
            if ($entry[1] === \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING) {
                continue;
            }
            if (\false === $hunkCapture) {
                $hunkCapture = $i;
            }
            if (\PHPUnit\SebastianBergmann\Diff\Differ::ADDED === $entry[1]) {
                ++$toRange;
            }
            if (\PHPUnit\SebastianBergmann\Diff\Differ::REMOVED === $entry[1]) {
                ++$fromRange;
            }
        }
        if (\false === $hunkCapture) {
            return;
        }
        // we end here when cutoff (commonLineThreshold) was not reached, but we where capturing a hunk,
        // do not render hunk till end automatically because the number of context lines might be less than the commonLineThreshold
        $contextStartOffset = $hunkCapture - $this->contextLines < 0 ? $hunkCapture : $this->contextLines;
        // prevent trying to write out more common lines than there are in the diff _and_
        // do not write more than configured through the context lines
        $contextEndOffset = \min($sameCount, $this->contextLines);
        $fromRange -= $sameCount;
        $toRange -= $sameCount;
        $this->writeHunk($diff, $hunkCapture - $contextStartOffset, $i - $sameCount + $contextEndOffset + 1, $fromStart - $contextStartOffset, $fromRange + $contextStartOffset + $contextEndOffset, $toStart - $contextStartOffset, $toRange + $contextStartOffset + $contextEndOffset, $output);
    }
    private function writeHunk(array $diff, int $diffStartIndex, int $diffEndIndex, int $fromStart, int $fromRange, int $toStart, int $toRange, $output) : void
    {
        if ($this->addLineNumbers) {
            \fwrite($output, '@@ -' . $fromStart);
            if (!$this->collapseRanges || 1 !== $fromRange) {
                \fwrite($output, ',' . $fromRange);
            }
            \fwrite($output, ' +' . $toStart);
            if (!$this->collapseRanges || 1 !== $toRange) {
                \fwrite($output, ',' . $toRange);
            }
            \fwrite($output, " @@\n");
        } else {
            \fwrite($output, "@@ @@\n");
        }
        for ($i = $diffStartIndex; $i < $diffEndIndex; ++$i) {
            if ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::ADDED) {
                \fwrite($output, '+' . $diff[$i][0]);
            } elseif ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::REMOVED) {
                \fwrite($output, '-' . $diff[$i][0]);
            } elseif ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::OLD) {
                \fwrite($output, ' ' . $diff[$i][0]);
            } elseif ($diff[$i][1] === \PHPUnit\SebastianBergmann\Diff\Differ::NO_LINE_END_EOF_WARNING) {
                \fwrite($output, "\n");
                // $diff[$i][0]
            } else {
                /* Not changed (old) Differ::OLD or Warning Differ::DIFF_LINE_END_WARNING */
                \fwrite($output, ' ' . $diff[$i][0]);
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

use function array_pop;
use function count;
use function max;
use function preg_match;
use function preg_split;
/**
 * Unified diff parser.
 */
final class Parser
{
    /**
     * @return Diff[]
     */
    public function parse(string $string) : array
    {
        $lines = \preg_split('(\\r\\n|\\r|\\n)', $string);
        if (!empty($lines) && $lines[\count($lines) - 1] === '') {
            \array_pop($lines);
        }
        $lineCount = \count($lines);
        $diffs = [];
        $diff = null;
        $collected = [];
        for ($i = 0; $i < $lineCount; ++$i) {
            if (\preg_match('#^---\\h+"?(?P<file>[^\\v\\t"]+)#', $lines[$i], $fromMatch) && \preg_match('#^\\+\\+\\+\\h+"?(?P<file>[^\\v\\t"]+)#', $lines[$i + 1], $toMatch)) {
                if ($diff !== null) {
                    $this->parseFileDiff($diff, $collected);
                    $diffs[] = $diff;
                    $collected = [];
                }
                $diff = new \PHPUnit\SebastianBergmann\Diff\Diff($fromMatch['file'], $toMatch['file']);
                ++$i;
            } else {
                if (\preg_match('/^(?:diff --git |index [\\da-f\\.]+|[+-]{3} [ab])/', $lines[$i])) {
                    continue;
                }
                $collected[] = $lines[$i];
            }
        }
        if ($diff !== null && \count($collected)) {
            $this->parseFileDiff($diff, $collected);
            $diffs[] = $diff;
        }
        return $diffs;
    }
    private function parseFileDiff(\PHPUnit\SebastianBergmann\Diff\Diff $diff, array $lines) : void
    {
        $chunks = [];
        $chunk = null;
        $diffLines = [];
        foreach ($lines as $line) {
            if (\preg_match('/^@@\\s+-(?P<start>\\d+)(?:,\\s*(?P<startrange>\\d+))?\\s+\\+(?P<end>\\d+)(?:,\\s*(?P<endrange>\\d+))?\\s+@@/', $line, $match)) {
                $chunk = new \PHPUnit\SebastianBergmann\Diff\Chunk((int) $match['start'], isset($match['startrange']) ? \max(1, (int) $match['startrange']) : 1, (int) $match['end'], isset($match['endrange']) ? \max(1, (int) $match['endrange']) : 1);
                $chunks[] = $chunk;
                $diffLines = [];
                continue;
            }
            if (\preg_match('/^(?P<type>[+ -])?(?P<line>.*)/', $line, $match)) {
                $type = \PHPUnit\SebastianBergmann\Diff\Line::UNCHANGED;
                if ($match['type'] === '+') {
                    $type = \PHPUnit\SebastianBergmann\Diff\Line::ADDED;
                } elseif ($match['type'] === '-') {
                    $type = \PHPUnit\SebastianBergmann\Diff\Line::REMOVED;
                }
                $diffLines[] = new \PHPUnit\SebastianBergmann\Diff\Line($type, $match['line']);
                if (null !== $chunk) {
                    $chunk->setLines($diffLines);
                }
            }
        }
        $diff->setChunks($chunks);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/diff.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Diff;

use function array_reverse;
use function count;
use function max;
use SplFixedArray;
final class TimeEfficientLongestCommonSubsequenceCalculator implements \PHPUnit\SebastianBergmann\Diff\LongestCommonSubsequenceCalculator
{
    /**
     * {@inheritdoc}
     */
    public function calculate(array $from, array $to) : array
    {
        $common = [];
        $fromLength = \count($from);
        $toLength = \count($to);
        $width = $fromLength + 1;
        $matrix = new \SplFixedArray($width * ($toLength + 1));
        for ($i = 0; $i <= $fromLength; ++$i) {
            $matrix[$i] = 0;
        }
        for ($j = 0; $j <= $toLength; ++$j) {
            $matrix[$j * $width] = 0;
        }
        for ($i = 1; $i <= $fromLength; ++$i) {
            for ($j = 1; $j <= $toLength; ++$j) {
                $o = $j * $width + $i;
                $matrix[$o] = \max($matrix[$o - 1], $matrix[$o - $width], $from[$i - 1] === $to[$j - 1] ? $matrix[$o - $width - 1] + 1 : 0);
            }
        }
        $i = $fromLength;
        $j = $toLength;
        while ($i > 0 && $j > 0) {
            if ($from[$i - 1] === $to[$j - 1]) {
                $common[] = $from[$i - 1];
                --$i;
                --$j;
            } else {
                $o = $j * $width + $i;
                if ($matrix[$o - $width] > $matrix[$o - 1]) {
                    --$j;
                } else {
                    --$i;
                }
            }
        }
        return \array_reverse($common);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/environment.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Environment;

use const DIRECTORY_SEPARATOR;
use const STDIN;
use const STDOUT;
use function defined;
use function fclose;
use function fstat;
use function function_exists;
use function getenv;
use function is_resource;
use function is_string;
use function posix_isatty;
use function preg_match;
use function proc_close;
use function proc_open;
use function sapi_windows_vt100_support;
use function shell_exec;
use function stream_get_contents;
use function stream_isatty;
use function trim;
final class Console
{
    /**
     * @var int
     */
    public const STDIN = 0;
    /**
     * @var int
     */
    public const STDOUT = 1;
    /**
     * @var int
     */
    public const STDERR = 2;
    /**
     * Returns true if STDOUT supports colorization.
     *
     * This code has been copied and adapted from
     * Symfony\Component\Console\Output\StreamOutput.
     */
    public function hasColorSupport() : bool
    {
        if ('Hyper' === \getenv('TERM_PROGRAM')) {
            return \true;
        }
        if ($this->isWindows()) {
            // @codeCoverageIgnoreStart
            return \defined('STDOUT') && \function_exists('sapi_windows_vt100_support') && @\sapi_windows_vt100_support(\STDOUT) || \false !== \getenv('ANSICON') || 'ON' === \getenv('ConEmuANSI') || 'xterm' === \getenv('TERM');
            // @codeCoverageIgnoreEnd
        }
        if (!\defined('STDOUT')) {
            // @codeCoverageIgnoreStart
            return \false;
            // @codeCoverageIgnoreEnd
        }
        return $this->isInteractive(\STDOUT);
    }
    /**
     * Returns the number of columns of the terminal.
     *
     * @codeCoverageIgnore
     */
    public function getNumberOfColumns() : int
    {
        if (!$this->isInteractive(\defined('STDIN') ? \STDIN : self::STDIN)) {
            return 80;
        }
        if ($this->isWindows()) {
            return $this->getNumberOfColumnsWindows();
        }
        return $this->getNumberOfColumnsInteractive();
    }
    /**
     * Returns if the file descriptor is an interactive terminal or not.
     *
     * Normally, we want to use a resource as a parameter, yet sadly it's not always awailable,
     * eg when running code in interactive console (`php -a`), STDIN/STDOUT/STDERR constants are not defined.
     *
     * @param int|resource $fileDescriptor
     */
    public function isInteractive($fileDescriptor = self::STDOUT) : bool
    {
        if (\is_resource($fileDescriptor)) {
            // These functions require a descriptor that is a real resource, not a numeric ID of it
            if (\function_exists('stream_isatty') && @\stream_isatty($fileDescriptor)) {
                return \true;
            }
            // Check if formatted mode is S_IFCHR
            if (\function_exists('fstat') && @\stream_isatty($fileDescriptor)) {
                $stat = @\fstat(\STDOUT);
                return $stat ? 020000 === ($stat['mode'] & 0170000) : \false;
            }
            return \false;
        }
        return \function_exists('posix_isatty') && @\posix_isatty($fileDescriptor);
    }
    private function isWindows() : bool
    {
        return \DIRECTORY_SEPARATOR === '\\';
    }
    /**
     * @codeCoverageIgnore
     */
    private function getNumberOfColumnsInteractive() : int
    {
        if (\function_exists('shell_exec') && \preg_match('#\\d+ (\\d+)#', \shell_exec('stty size') ?: '', $match) === 1) {
            if ((int) $match[1] > 0) {
                return (int) $match[1];
            }
        }
        if (\function_exists('shell_exec') && \preg_match('#columns = (\\d+);#', \shell_exec('stty') ?: '', $match) === 1) {
            if ((int) $match[1] > 0) {
                return (int) $match[1];
            }
        }
        return 80;
    }
    /**
     * @codeCoverageIgnore
     */
    private function getNumberOfColumnsWindows() : int
    {
        $ansicon = \getenv('ANSICON');
        $columns = 80;
        if (\is_string($ansicon) && \preg_match('/^(\\d+)x\\d+ \\(\\d+x(\\d+)\\)$/', \trim($ansicon), $matches)) {
            $columns = (int) $matches[1];
        } elseif (\function_exists('proc_open')) {
            $process = \proc_open('mode CON', [1 => ['pipe', 'w'], 2 => ['pipe', 'w']], $pipes, null, null, ['suppress_errors' => \true]);
            if (\is_resource($process)) {
                $info = \stream_get_contents($pipes[1]);
                \fclose($pipes[1]);
                \fclose($pipes[2]);
                \proc_close($process);
                if (\preg_match('/--------+\\r?\\n.+?(\\d+)\\r?\\n.+?(\\d+)\\r?\\n/', $info, $matches)) {
                    $columns = (int) $matches[2];
                }
            }
        }
        return $columns - 1;
    }
}
sebastian/environment

Copyright (c) 2014-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/environment.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Environment;

use const DIRECTORY_SEPARATOR;
use const PHP_OS;
use const PHP_OS_FAMILY;
use function defined;
final class OperatingSystem
{
    /**
     * Returns PHP_OS_FAMILY (if defined (which it is on PHP >= 7.2)).
     * Returns a string (compatible with PHP_OS_FAMILY) derived from PHP_OS otherwise.
     */
    public function getFamily() : string
    {
        if (\defined('PHP_OS_FAMILY')) {
            return \PHP_OS_FAMILY;
        }
        if (\DIRECTORY_SEPARATOR === '\\') {
            return 'Windows';
        }
        switch (\PHP_OS) {
            case 'Darwin':
                return 'Darwin';
            case 'DragonFly':
            case 'FreeBSD':
            case 'NetBSD':
            case 'OpenBSD':
                return 'BSD';
            case 'Linux':
                return 'Linux';
            case 'SunOS':
                return 'Solaris';
            default:
                return 'Unknown';
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/environment.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Environment;

use const PHP_BINARY;
use const PHP_BINDIR;
use const PHP_MAJOR_VERSION;
use const PHP_SAPI;
use const PHP_VERSION;
use function array_map;
use function array_merge;
use function defined;
use function escapeshellarg;
use function explode;
use function extension_loaded;
use function getenv;
use function ini_get;
use function is_readable;
use function parse_ini_file;
use function php_ini_loaded_file;
use function php_ini_scanned_files;
use function phpversion;
use function sprintf;
use function strpos;
/**
 * Utility class for HHVM/PHP environment handling.
 */
final class Runtime
{
    /**
     * @var string
     */
    private static $binary;
    /**
     * Returns true when Xdebug or PCOV is available or
     * the runtime used is PHPDBG.
     */
    public function canCollectCodeCoverage() : bool
    {
        return $this->hasXdebug() || $this->hasPCOV() || $this->hasPHPDBGCodeCoverage();
    }
    /**
     * Returns true when Zend OPcache is loaded, enabled,
     * and is configured to discard comments.
     */
    public function discardsComments() : bool
    {
        if (!$this->isOpcacheActive()) {
            return \false;
        }
        if (\ini_get('opcache.save_comments') !== '0') {
            return \false;
        }
        return \true;
    }
    /**
     * Returns true when Zend OPcache is loaded, enabled,
     * and is configured to perform just-in-time compilation.
     */
    public function performsJustInTimeCompilation() : bool
    {
        if (\PHP_MAJOR_VERSION < 8) {
            return \false;
        }
        if (!$this->isOpcacheActive()) {
            return \false;
        }
        if (\strpos(\ini_get('opcache.jit'), '0') === 0) {
            return \false;
        }
        return \true;
    }
    /**
     * Returns the path to the binary of the current runtime.
     * Appends ' --php' to the path when the runtime is HHVM.
     */
    public function getBinary() : string
    {
        // HHVM
        if (self::$binary === null && $this->isHHVM()) {
            // @codeCoverageIgnoreStart
            if ((self::$binary = \getenv('PHP_BINARY')) === \false) {
                self::$binary = \PHP_BINARY;
            }
            self::$binary = \escapeshellarg(self::$binary) . ' --php' . ' -d hhvm.php7.all=1';
            // @codeCoverageIgnoreEnd
        }
        if (self::$binary === null && \PHP_BINARY !== '') {
            self::$binary = \escapeshellarg(\PHP_BINARY);
        }
        if (self::$binary === null) {
            // @codeCoverageIgnoreStart
            $possibleBinaryLocations = [\PHP_BINDIR . '/php', \PHP_BINDIR . '/php-cli.exe', \PHP_BINDIR . '/php.exe'];
            foreach ($possibleBinaryLocations as $binary) {
                if (\is_readable($binary)) {
                    self::$binary = \escapeshellarg($binary);
                    break;
                }
            }
            // @codeCoverageIgnoreEnd
        }
        if (self::$binary === null) {
            // @codeCoverageIgnoreStart
            self::$binary = 'php';
            // @codeCoverageIgnoreEnd
        }
        return self::$binary;
    }
    public function getNameWithVersion() : string
    {
        return $this->getName() . ' ' . $this->getVersion();
    }
    public function getNameWithVersionAndCodeCoverageDriver() : string
    {
        if (!$this->canCollectCodeCoverage() || $this->hasPHPDBGCodeCoverage()) {
            return $this->getNameWithVersion();
        }
        if ($this->hasPCOV()) {
            return \sprintf('%s with PCOV %s', $this->getNameWithVersion(), \phpversion('pcov'));
        }
        if ($this->hasXdebug()) {
            return \sprintf('%s with Xdebug %s', $this->getNameWithVersion(), \phpversion('xdebug'));
        }
    }
    public function getName() : string
    {
        if ($this->isHHVM()) {
            // @codeCoverageIgnoreStart
            return 'HHVM';
            // @codeCoverageIgnoreEnd
        }
        if ($this->isPHPDBG()) {
            // @codeCoverageIgnoreStart
            return 'PHPDBG';
            // @codeCoverageIgnoreEnd
        }
        return 'PHP';
    }
    public function getVendorUrl() : string
    {
        if ($this->isHHVM()) {
            // @codeCoverageIgnoreStart
            return 'http://hhvm.com/';
            // @codeCoverageIgnoreEnd
        }
        return 'https://secure.php.net/';
    }
    public function getVersion() : string
    {
        if ($this->isHHVM()) {
            // @codeCoverageIgnoreStart
            return HHVM_VERSION;
            // @codeCoverageIgnoreEnd
        }
        return \PHP_VERSION;
    }
    /**
     * Returns true when the runtime used is PHP and Xdebug is loaded.
     */
    public function hasXdebug() : bool
    {
        return ($this->isPHP() || $this->isHHVM()) && \extension_loaded('xdebug');
    }
    /**
     * Returns true when the runtime used is HHVM.
     */
    public function isHHVM() : bool
    {
        return \defined('HHVM_VERSION');
    }
    /**
     * Returns true when the runtime used is PHP without the PHPDBG SAPI.
     */
    public function isPHP() : bool
    {
        return !$this->isHHVM() && !$this->isPHPDBG();
    }
    /**
     * Returns true when the runtime used is PHP with the PHPDBG SAPI.
     */
    public function isPHPDBG() : bool
    {
        return \PHP_SAPI === 'phpdbg' && !$this->isHHVM();
    }
    /**
     * Returns true when the runtime used is PHP with the PHPDBG SAPI
     * and the phpdbg_*_oplog() functions are available (PHP >= 7.0).
     */
    public function hasPHPDBGCodeCoverage() : bool
    {
        return $this->isPHPDBG();
    }
    /**
     * Returns true when the runtime used is PHP with PCOV loaded and enabled.
     */
    public function hasPCOV() : bool
    {
        return $this->isPHP() && \extension_loaded('pcov') && \ini_get('pcov.enabled');
    }
    /**
     * Parses the loaded php.ini file (if any) as well as all
     * additional php.ini files from the additional ini dir for
     * a list of all configuration settings loaded from files
     * at startup. Then checks for each php.ini setting passed
     * via the `$values` parameter whether this setting has
     * been changed at runtime. Returns an array of strings
     * where each string has the format `key=value` denoting
     * the name of a changed php.ini setting with its new value.
     *
     * @return string[]
     */
    public function getCurrentSettings(array $values) : array
    {
        $diff = [];
        $files = [];
        if ($file = \php_ini_loaded_file()) {
            $files[] = $file;
        }
        if ($scanned = \php_ini_scanned_files()) {
            $files = \array_merge($files, \array_map('trim', \explode(",\n", $scanned)));
        }
        foreach ($files as $ini) {
            $config = \parse_ini_file($ini, \true);
            foreach ($values as $value) {
                $set = \ini_get($value);
                if (isset($config[$value]) && $set != $config[$value]) {
                    $diff[] = \sprintf('%s=%s', $value, $set);
                }
            }
        }
        return $diff;
    }
    private function isOpcacheActive() : bool
    {
        if (!\extension_loaded('Zend OPcache')) {
            return \false;
        }
        if ((\PHP_SAPI === 'cli' || \PHP_SAPI === 'phpdbg') && \ini_get('opcache.enable_cli') === '1') {
            return \true;
        }
        if (\PHP_SAPI !== 'cli' && \PHP_SAPI !== 'phpdbg' && \ini_get('opcache.enable') === '1') {
            return \true;
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/exporter.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Exporter;

use function bin2hex;
use function count;
use function function_exists;
use function get_class;
use function get_resource_type;
use function implode;
use function is_array;
use function is_float;
use function is_object;
use function is_resource;
use function is_string;
use function mb_strlen;
use function mb_substr;
use function preg_match;
use function spl_object_hash;
use function sprintf;
use function str_repeat;
use function str_replace;
use function strlen;
use function substr;
use function var_export;
use PHPUnit\SebastianBergmann\RecursionContext\Context;
use SplObjectStorage;
/**
 * A nifty utility for visualizing PHP variables.
 *
 * <code>
 * <?php
 * use SebastianBergmann\Exporter\Exporter;
 *
 * $exporter = new Exporter;
 * print $exporter->export(new Exception);
 * </code>
 */
class Exporter
{
    /**
     * Exports a value as a string.
     *
     * The output of this method is similar to the output of print_r(), but
     * improved in various aspects:
     *
     *  - NULL is rendered as "null" (instead of "")
     *  - TRUE is rendered as "true" (instead of "1")
     *  - FALSE is rendered as "false" (instead of "")
     *  - Strings are always quoted with single quotes
     *  - Carriage returns and newlines are normalized to \n
     *  - Recursion and repeated rendering is treated properly
     *
     * @param int $indentation The indentation level of the 2nd+ line
     *
     * @return string
     */
    public function export($value, $indentation = 0)
    {
        return $this->recursiveExport($value, $indentation);
    }
    /**
     * @param array<mixed> $data
     * @param Context      $context
     *
     * @return string
     */
    public function shortenedRecursiveExport(&$data, \PHPUnit\SebastianBergmann\RecursionContext\Context $context = null)
    {
        $result = [];
        $exporter = new self();
        if (!$context) {
            $context = new \PHPUnit\SebastianBergmann\RecursionContext\Context();
        }
        $array = $data;
        $context->add($data);
        foreach ($array as $key => $value) {
            if (\is_array($value)) {
                if ($context->contains($data[$key]) !== \false) {
                    $result[] = '*RECURSION*';
                } else {
                    $result[] = \sprintf('array(%s)', $this->shortenedRecursiveExport($data[$key], $context));
                }
            } else {
                $result[] = $exporter->shortenedExport($value);
            }
        }
        return \implode(', ', $result);
    }
    /**
     * Exports a value into a single-line string.
     *
     * The output of this method is similar to the output of
     * SebastianBergmann\Exporter\Exporter::export().
     *
     * Newlines are replaced by the visible string '\n'.
     * Contents of arrays and objects (if any) are replaced by '...'.
     *
     * @return string
     *
     * @see    SebastianBergmann\Exporter\Exporter::export
     */
    public function shortenedExport($value)
    {
        if (\is_string($value)) {
            $string = \str_replace("\n", '', $this->export($value));
            if (\function_exists('mb_strlen')) {
                if (\mb_strlen($string) > 40) {
                    $string = \mb_substr($string, 0, 30) . '...' . \mb_substr($string, -7);
                }
            } else {
                if (\strlen($string) > 40) {
                    $string = \substr($string, 0, 30) . '...' . \substr($string, -7);
                }
            }
            return $string;
        }
        if (\is_object($value)) {
            return \sprintf('%s Object (%s)', \get_class($value), \count($this->toArray($value)) > 0 ? '...' : '');
        }
        if (\is_array($value)) {
            return \sprintf('Array (%s)', \count($value) > 0 ? '...' : '');
        }
        return $this->export($value);
    }
    /**
     * Converts an object to an array containing all of its private, protected
     * and public properties.
     *
     * @return array
     */
    public function toArray($value)
    {
        if (!\is_object($value)) {
            return (array) $value;
        }
        $array = [];
        foreach ((array) $value as $key => $val) {
            // Exception traces commonly reference hundreds to thousands of
            // objects currently loaded in memory. Including them in the result
            // has a severe negative performance impact.
            if ("\0Error\0trace" === $key || "\0Exception\0trace" === $key) {
                continue;
            }
            // properties are transformed to keys in the following way:
            // private   $property => "\0Classname\0property"
            // protected $property => "\0*\0property"
            // public    $property => "property"
            if (\preg_match('/^\\0.+\\0(.+)$/', (string) $key, $matches)) {
                $key = $matches[1];
            }
            // See https://github.com/php/php-src/commit/5721132
            if ($key === "\0gcdata") {
                continue;
            }
            $array[$key] = $val;
        }
        // Some internal classes like SplObjectStorage don't work with the
        // above (fast) mechanism nor with reflection in Zend.
        // Format the output similarly to print_r() in this case
        if ($value instanceof \SplObjectStorage) {
            foreach ($value as $key => $val) {
                $array[\spl_object_hash($val)] = ['obj' => $val, 'inf' => $value->getInfo()];
            }
        }
        return $array;
    }
    /**
     * Recursive implementation of export.
     *
     * @param mixed                                       $value       The value to export
     * @param int                                         $indentation The indentation level of the 2nd+ line
     * @param \SebastianBergmann\RecursionContext\Context $processed   Previously processed objects
     *
     * @return string
     *
     * @see    SebastianBergmann\Exporter\Exporter::export
     */
    protected function recursiveExport(&$value, $indentation, $processed = null)
    {
        if ($value === null) {
            return 'null';
        }
        if ($value === \true) {
            return 'true';
        }
        if ($value === \false) {
            return 'false';
        }
        if (\is_float($value) && (float) (int) $value === $value) {
            return "{$value}.0";
        }
        if (\is_resource($value)) {
            return \sprintf('resource(%d) of type (%s)', $value, \get_resource_type($value));
        }
        if (\is_string($value)) {
            // Match for most non printable chars somewhat taking multibyte chars into account
            if (\preg_match('/[^\\x09-\\x0d\\x1b\\x20-\\xff]/', $value)) {
                return 'Binary String: 0x' . \bin2hex($value);
            }
            return "'" . \str_replace('<lf>', "\n", \str_replace(["\r\n", "\n\r", "\r", "\n"], ['\\r\\n<lf>', '\\n\\r<lf>', '\\r<lf>', '\\n<lf>'], $value)) . "'";
        }
        $whitespace = \str_repeat(' ', (int) (4 * $indentation));
        if (!$processed) {
            $processed = new \PHPUnit\SebastianBergmann\RecursionContext\Context();
        }
        if (\is_array($value)) {
            if (($key = $processed->contains($value)) !== \false) {
                return 'Array &' . $key;
            }
            $array = $value;
            $key = $processed->add($value);
            $values = '';
            if (\count($array) > 0) {
                foreach ($array as $k => $v) {
                    $values .= \sprintf('%s    %s => %s' . "\n", $whitespace, $this->recursiveExport($k, $indentation), $this->recursiveExport($value[$k], $indentation + 1, $processed));
                }
                $values = "\n" . $values . $whitespace;
            }
            return \sprintf('Array &%s (%s)', $key, $values);
        }
        if (\is_object($value)) {
            $class = \get_class($value);
            if ($hash = $processed->contains($value)) {
                return \sprintf('%s Object &%s', $class, $hash);
            }
            $hash = $processed->add($value);
            $values = '';
            $array = $this->toArray($value);
            if (\count($array) > 0) {
                foreach ($array as $k => $v) {
                    $values .= \sprintf('%s    %s => %s' . "\n", $whitespace, $this->recursiveExport($k, $indentation), $this->recursiveExport($v, $indentation + 1, $processed));
                }
                $values = "\n" . $values . $whitespace;
            }
            return \sprintf('%s Object &%s (%s)', $class, $hash, $values);
        }
        return \var_export($value, \true);
    }
}
Exporter

Copyright (c) 2002-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/global-state.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\GlobalState;

use const PHP_EOL;
use function is_array;
use function is_scalar;
use function serialize;
use function sprintf;
use function var_export;
/**
 * Exports parts of a Snapshot as PHP code.
 */
final class CodeExporter
{
    public function constants(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot) : string
    {
        $result = '';
        foreach ($snapshot->constants() as $name => $value) {
            $result .= \sprintf('if (!defined(\'%s\')) define(\'%s\', %s);' . "\n", $name, $name, $this->exportVariable($value));
        }
        return $result;
    }
    public function globalVariables(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot) : string
    {
        $result = '$GLOBALS = [];' . \PHP_EOL;
        foreach ($snapshot->globalVariables() as $name => $value) {
            $result .= \sprintf('$GLOBALS[%s] = %s;' . \PHP_EOL, $this->exportVariable($name), $this->exportVariable($value));
        }
        return $result;
    }
    public function iniSettings(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot) : string
    {
        $result = '';
        foreach ($snapshot->iniSettings() as $key => $value) {
            $result .= \sprintf('@ini_set(%s, %s);' . "\n", $this->exportVariable($key), $this->exportVariable($value));
        }
        return $result;
    }
    private function exportVariable($variable) : string
    {
        if (\is_scalar($variable) || null === $variable || \is_array($variable) && $this->arrayOnlyContainsScalars($variable)) {
            return \var_export($variable, \true);
        }
        return 'unserialize(' . \var_export(\serialize($variable), \true) . ')';
    }
    private function arrayOnlyContainsScalars(array $array) : bool
    {
        $result = \true;
        foreach ($array as $element) {
            if (\is_array($element)) {
                $result = $this->arrayOnlyContainsScalars($element);
            } elseif (!\is_scalar($element) && null !== $element) {
                $result = \false;
            }
            if ($result === \false) {
                break;
            }
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/global-state.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\GlobalState;

use function in_array;
use function strpos;
use ReflectionClass;
final class ExcludeList
{
    /**
     * @var array
     */
    private $globalVariables = [];
    /**
     * @var string[]
     */
    private $classes = [];
    /**
     * @var string[]
     */
    private $classNamePrefixes = [];
    /**
     * @var string[]
     */
    private $parentClasses = [];
    /**
     * @var string[]
     */
    private $interfaces = [];
    /**
     * @var array
     */
    private $staticAttributes = [];
    public function addGlobalVariable(string $variableName) : void
    {
        $this->globalVariables[$variableName] = \true;
    }
    public function addClass(string $className) : void
    {
        $this->classes[] = $className;
    }
    public function addSubclassesOf(string $className) : void
    {
        $this->parentClasses[] = $className;
    }
    public function addImplementorsOf(string $interfaceName) : void
    {
        $this->interfaces[] = $interfaceName;
    }
    public function addClassNamePrefix(string $classNamePrefix) : void
    {
        $this->classNamePrefixes[] = $classNamePrefix;
    }
    public function addStaticAttribute(string $className, string $attributeName) : void
    {
        if (!isset($this->staticAttributes[$className])) {
            $this->staticAttributes[$className] = [];
        }
        $this->staticAttributes[$className][$attributeName] = \true;
    }
    public function isGlobalVariableExcluded(string $variableName) : bool
    {
        return isset($this->globalVariables[$variableName]);
    }
    public function isStaticAttributeExcluded(string $className, string $attributeName) : bool
    {
        if (\in_array($className, $this->classes)) {
            return \true;
        }
        foreach ($this->classNamePrefixes as $prefix) {
            if (\strpos($className, $prefix) === 0) {
                return \true;
            }
        }
        $class = new \ReflectionClass($className);
        foreach ($this->parentClasses as $type) {
            if ($class->isSubclassOf($type)) {
                return \true;
            }
        }
        foreach ($this->interfaces as $type) {
            if ($class->implementsInterface($type)) {
                return \true;
            }
        }
        if (isset($this->staticAttributes[$className][$attributeName])) {
            return \true;
        }
        return \false;
    }
}
sebastian/global-state

Copyright (c) 2001-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/global-state.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\GlobalState;

use function array_diff;
use function array_key_exists;
use function array_keys;
use function array_merge;
use function function_exists;
use function get_defined_functions;
use function in_array;
use function is_array;
use ReflectionClass;
use ReflectionProperty;
/**
 * Restorer of snapshots of global state.
 */
class Restorer
{
    /**
     * Deletes function definitions that are not defined in a snapshot.
     *
     * @throws RuntimeException when the uopz_delete() function is not available
     *
     * @see https://github.com/krakjoe/uopz
     */
    public function restoreFunctions(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot) : void
    {
        if (!\function_exists('PHPUnit\\uopz_delete')) {
            throw new \PHPUnit\SebastianBergmann\GlobalState\RuntimeException('The uopz_delete() function is required for this operation');
        }
        $functions = \get_defined_functions();
        foreach (\array_diff($functions['user'], $snapshot->functions()) as $function) {
            uopz_delete($function);
        }
    }
    /**
     * Restores all global and super-global variables from a snapshot.
     */
    public function restoreGlobalVariables(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot) : void
    {
        $superGlobalArrays = $snapshot->superGlobalArrays();
        foreach ($superGlobalArrays as $superGlobalArray) {
            $this->restoreSuperGlobalArray($snapshot, $superGlobalArray);
        }
        $globalVariables = $snapshot->globalVariables();
        foreach (\array_keys($GLOBALS) as $key) {
            if ($key !== 'GLOBALS' && !\in_array($key, $superGlobalArrays) && !$snapshot->excludeList()->isGlobalVariableExcluded($key)) {
                if (\array_key_exists($key, $globalVariables)) {
                    $GLOBALS[$key] = $globalVariables[$key];
                } else {
                    unset($GLOBALS[$key]);
                }
            }
        }
    }
    /**
     * Restores all static attributes in user-defined classes from this snapshot.
     */
    public function restoreStaticAttributes(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot) : void
    {
        $current = new \PHPUnit\SebastianBergmann\GlobalState\Snapshot($snapshot->excludeList(), \false, \false, \false, \false, \true, \false, \false, \false, \false);
        $newClasses = \array_diff($current->classes(), $snapshot->classes());
        unset($current);
        foreach ($snapshot->staticAttributes() as $className => $staticAttributes) {
            foreach ($staticAttributes as $name => $value) {
                $reflector = new \ReflectionProperty($className, $name);
                $reflector->setAccessible(\true);
                $reflector->setValue($value);
            }
        }
        foreach ($newClasses as $className) {
            $class = new \ReflectionClass($className);
            $defaults = $class->getDefaultProperties();
            foreach ($class->getProperties() as $attribute) {
                if (!$attribute->isStatic()) {
                    continue;
                }
                $name = $attribute->getName();
                if ($snapshot->excludeList()->isStaticAttributeExcluded($className, $name)) {
                    continue;
                }
                if (!isset($defaults[$name])) {
                    continue;
                }
                $attribute->setAccessible(\true);
                $attribute->setValue($defaults[$name]);
            }
        }
    }
    /**
     * Restores a super-global variable array from this snapshot.
     */
    private function restoreSuperGlobalArray(\PHPUnit\SebastianBergmann\GlobalState\Snapshot $snapshot, string $superGlobalArray) : void
    {
        $superGlobalVariables = $snapshot->superGlobalVariables();
        if (isset($GLOBALS[$superGlobalArray]) && \is_array($GLOBALS[$superGlobalArray]) && isset($superGlobalVariables[$superGlobalArray])) {
            $keys = \array_keys(\array_merge($GLOBALS[$superGlobalArray], $superGlobalVariables[$superGlobalArray]));
            foreach ($keys as $key) {
                if (isset($superGlobalVariables[$superGlobalArray][$key])) {
                    $GLOBALS[$superGlobalArray][$key] = $superGlobalVariables[$superGlobalArray][$key];
                } else {
                    unset($GLOBALS[$superGlobalArray][$key]);
                }
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/global-state.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\GlobalState;

use function array_keys;
use function array_merge;
use function array_reverse;
use function func_get_args;
use function get_declared_classes;
use function get_declared_interfaces;
use function get_declared_traits;
use function get_defined_constants;
use function get_defined_functions;
use function get_included_files;
use function in_array;
use function ini_get_all;
use function is_array;
use function is_object;
use function is_resource;
use function is_scalar;
use function serialize;
use function unserialize;
use ReflectionClass;
use PHPUnit\SebastianBergmann\ObjectReflector\ObjectReflector;
use PHPUnit\SebastianBergmann\RecursionContext\Context;
use Throwable;
/**
 * A snapshot of global state.
 */
class Snapshot
{
    /**
     * @var ExcludeList
     */
    private $excludeList;
    /**
     * @var array
     */
    private $globalVariables = [];
    /**
     * @var array
     */
    private $superGlobalArrays = [];
    /**
     * @var array
     */
    private $superGlobalVariables = [];
    /**
     * @var array
     */
    private $staticAttributes = [];
    /**
     * @var array
     */
    private $iniSettings = [];
    /**
     * @var array
     */
    private $includedFiles = [];
    /**
     * @var array
     */
    private $constants = [];
    /**
     * @var array
     */
    private $functions = [];
    /**
     * @var array
     */
    private $interfaces = [];
    /**
     * @var array
     */
    private $classes = [];
    /**
     * @var array
     */
    private $traits = [];
    /**
     * Creates a snapshot of the current global state.
     */
    public function __construct(\PHPUnit\SebastianBergmann\GlobalState\ExcludeList $excludeList = null, bool $includeGlobalVariables = \true, bool $includeStaticAttributes = \true, bool $includeConstants = \true, bool $includeFunctions = \true, bool $includeClasses = \true, bool $includeInterfaces = \true, bool $includeTraits = \true, bool $includeIniSettings = \true, bool $includeIncludedFiles = \true)
    {
        $this->excludeList = $excludeList ?: new \PHPUnit\SebastianBergmann\GlobalState\ExcludeList();
        if ($includeConstants) {
            $this->snapshotConstants();
        }
        if ($includeFunctions) {
            $this->snapshotFunctions();
        }
        if ($includeClasses || $includeStaticAttributes) {
            $this->snapshotClasses();
        }
        if ($includeInterfaces) {
            $this->snapshotInterfaces();
        }
        if ($includeGlobalVariables) {
            $this->setupSuperGlobalArrays();
            $this->snapshotGlobals();
        }
        if ($includeStaticAttributes) {
            $this->snapshotStaticAttributes();
        }
        if ($includeIniSettings) {
            $this->iniSettings = \ini_get_all(null, \false);
        }
        if ($includeIncludedFiles) {
            $this->includedFiles = \get_included_files();
        }
        $this->traits = \get_declared_traits();
    }
    public function excludeList() : \PHPUnit\SebastianBergmann\GlobalState\ExcludeList
    {
        return $this->excludeList;
    }
    public function globalVariables() : array
    {
        return $this->globalVariables;
    }
    public function superGlobalVariables() : array
    {
        return $this->superGlobalVariables;
    }
    public function superGlobalArrays() : array
    {
        return $this->superGlobalArrays;
    }
    public function staticAttributes() : array
    {
        return $this->staticAttributes;
    }
    public function iniSettings() : array
    {
        return $this->iniSettings;
    }
    public function includedFiles() : array
    {
        return $this->includedFiles;
    }
    public function constants() : array
    {
        return $this->constants;
    }
    public function functions() : array
    {
        return $this->functions;
    }
    public function interfaces() : array
    {
        return $this->interfaces;
    }
    public function classes() : array
    {
        return $this->classes;
    }
    public function traits() : array
    {
        return $this->traits;
    }
    /**
     * Creates a snapshot user-defined constants.
     */
    private function snapshotConstants() : void
    {
        $constants = \get_defined_constants(\true);
        if (isset($constants['user'])) {
            $this->constants = $constants['user'];
        }
    }
    /**
     * Creates a snapshot user-defined functions.
     */
    private function snapshotFunctions() : void
    {
        $functions = \get_defined_functions();
        $this->functions = $functions['user'];
    }
    /**
     * Creates a snapshot user-defined classes.
     */
    private function snapshotClasses() : void
    {
        foreach (\array_reverse(\get_declared_classes()) as $className) {
            $class = new \ReflectionClass($className);
            if (!$class->isUserDefined()) {
                break;
            }
            $this->classes[] = $className;
        }
        $this->classes = \array_reverse($this->classes);
    }
    /**
     * Creates a snapshot user-defined interfaces.
     */
    private function snapshotInterfaces() : void
    {
        foreach (\array_reverse(\get_declared_interfaces()) as $interfaceName) {
            $class = new \ReflectionClass($interfaceName);
            if (!$class->isUserDefined()) {
                break;
            }
            $this->interfaces[] = $interfaceName;
        }
        $this->interfaces = \array_reverse($this->interfaces);
    }
    /**
     * Creates a snapshot of all global and super-global variables.
     */
    private function snapshotGlobals() : void
    {
        $superGlobalArrays = $this->superGlobalArrays();
        foreach ($superGlobalArrays as $superGlobalArray) {
            $this->snapshotSuperGlobalArray($superGlobalArray);
        }
        foreach (\array_keys($GLOBALS) as $key) {
            if ($key !== 'GLOBALS' && !\in_array($key, $superGlobalArrays) && $this->canBeSerialized($GLOBALS[$key]) && !$this->excludeList->isGlobalVariableExcluded($key)) {
                /* @noinspection UnserializeExploitsInspection */
                $this->globalVariables[$key] = \unserialize(\serialize($GLOBALS[$key]));
            }
        }
    }
    /**
     * Creates a snapshot a super-global variable array.
     */
    private function snapshotSuperGlobalArray(string $superGlobalArray) : void
    {
        $this->superGlobalVariables[$superGlobalArray] = [];
        if (isset($GLOBALS[$superGlobalArray]) && \is_array($GLOBALS[$superGlobalArray])) {
            foreach ($GLOBALS[$superGlobalArray] as $key => $value) {
                /* @noinspection UnserializeExploitsInspection */
                $this->superGlobalVariables[$superGlobalArray][$key] = \unserialize(\serialize($value));
            }
        }
    }
    /**
     * Creates a snapshot of all static attributes in user-defined classes.
     */
    private function snapshotStaticAttributes() : void
    {
        foreach ($this->classes as $className) {
            $class = new \ReflectionClass($className);
            $snapshot = [];
            foreach ($class->getProperties() as $attribute) {
                if ($attribute->isStatic()) {
                    $name = $attribute->getName();
                    if ($this->excludeList->isStaticAttributeExcluded($className, $name)) {
                        continue;
                    }
                    $attribute->setAccessible(\true);
                    $value = $attribute->getValue();
                    if ($this->canBeSerialized($value)) {
                        /* @noinspection UnserializeExploitsInspection */
                        $snapshot[$name] = \unserialize(\serialize($value));
                    }
                }
            }
            if (!empty($snapshot)) {
                $this->staticAttributes[$className] = $snapshot;
            }
        }
    }
    /**
     * Returns a list of all super-global variable arrays.
     */
    private function setupSuperGlobalArrays() : void
    {
        $this->superGlobalArrays = ['_ENV', '_POST', '_GET', '_COOKIE', '_SERVER', '_FILES', '_REQUEST'];
    }
    private function canBeSerialized($variable) : bool
    {
        if (\is_scalar($variable) || $variable === null) {
            return \true;
        }
        if (\is_resource($variable)) {
            return \false;
        }
        foreach ($this->enumerateObjectsAndResources($variable) as $value) {
            if (\is_resource($value)) {
                return \false;
            }
            if (\is_object($value)) {
                $class = new \ReflectionClass($value);
                if ($class->isAnonymous()) {
                    return \false;
                }
                try {
                    @\serialize($value);
                } catch (\Throwable $t) {
                    return \false;
                }
            }
        }
        return \true;
    }
    private function enumerateObjectsAndResources($variable) : array
    {
        if (isset(\func_get_args()[1])) {
            $processed = \func_get_args()[1];
        } else {
            $processed = new \PHPUnit\SebastianBergmann\RecursionContext\Context();
        }
        $result = [];
        if ($processed->contains($variable)) {
            return $result;
        }
        $array = $variable;
        $processed->add($variable);
        if (\is_array($variable)) {
            foreach ($array as $element) {
                if (!\is_array($element) && !\is_object($element) && !\is_resource($element)) {
                    continue;
                }
                if (!\is_resource($element)) {
                    /** @noinspection SlowArrayOperationsInLoopInspection */
                    $result = \array_merge($result, $this->enumerateObjectsAndResources($element, $processed));
                } else {
                    $result[] = $element;
                }
            }
        } else {
            $result[] = $variable;
            foreach ((new \PHPUnit\SebastianBergmann\ObjectReflector\ObjectReflector())->getAttributes($variable) as $value) {
                if (!\is_array($value) && !\is_object($value) && !\is_resource($value)) {
                    continue;
                }
                if (!\is_resource($value)) {
                    /** @noinspection SlowArrayOperationsInLoopInspection */
                    $result = \array_merge($result, $this->enumerateObjectsAndResources($value, $processed));
                } else {
                    $result[] = $value;
                }
            }
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/global-state.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\GlobalState;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/global-state.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\GlobalState;

final class RuntimeException extends \RuntimeException implements \PHPUnit\SebastianBergmann\GlobalState\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/lines-of-code.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\LinesOfCode;

use function substr_count;
use PHPUnit\PhpParser\Error;
use PHPUnit\PhpParser\Lexer;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\NodeTraverser;
use PHPUnit\PhpParser\Parser;
use PHPUnit\PhpParser\ParserFactory;
final class Counter
{
    /**
     * @throws RuntimeException
     */
    public function countInSourceFile(string $sourceFile) : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        return $this->countInSourceString(\file_get_contents($sourceFile));
    }
    /**
     * @throws RuntimeException
     */
    public function countInSourceString(string $source) : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        $linesOfCode = \substr_count($source, "\n");
        if ($linesOfCode === 0 && !empty($source)) {
            $linesOfCode = 1;
        }
        try {
            $nodes = $this->parser()->parse($source);
            \assert($nodes !== null);
            return $this->countInAbstractSyntaxTree($linesOfCode, $nodes);
            // @codeCoverageIgnoreStart
        } catch (\PHPUnit\PhpParser\Error $error) {
            throw new \PHPUnit\SebastianBergmann\LinesOfCode\RuntimeException($error->getMessage(), (int) $error->getCode(), $error);
        }
        // @codeCoverageIgnoreEnd
    }
    /**
     * @param Node[] $nodes
     *
     * @throws RuntimeException
     */
    public function countInAbstractSyntaxTree(int $linesOfCode, array $nodes) : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        $traverser = new \PHPUnit\PhpParser\NodeTraverser();
        $visitor = new \PHPUnit\SebastianBergmann\LinesOfCode\LineCountingVisitor($linesOfCode);
        $traverser->addVisitor($visitor);
        try {
            /* @noinspection UnusedFunctionResultInspection */
            $traverser->traverse($nodes);
            // @codeCoverageIgnoreStart
        } catch (\PHPUnit\PhpParser\Error $error) {
            throw new \PHPUnit\SebastianBergmann\LinesOfCode\RuntimeException($error->getMessage(), (int) $error->getCode(), $error);
        }
        // @codeCoverageIgnoreEnd
        return $visitor->result();
    }
    private function parser() : \PHPUnit\PhpParser\Parser
    {
        return (new \PHPUnit\PhpParser\ParserFactory())->create(\PHPUnit\PhpParser\ParserFactory::PREFER_PHP7, new \PHPUnit\PhpParser\Lexer());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/lines-of-code.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\LinesOfCode;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/lines-of-code.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\LinesOfCode;

use LogicException;
final class IllogicalValuesException extends \LogicException implements \PHPUnit\SebastianBergmann\LinesOfCode\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/lines-of-code.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\LinesOfCode;

use InvalidArgumentException;
final class NegativeValueException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\LinesOfCode\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/lines-of-code.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\LinesOfCode;

final class RuntimeException extends \RuntimeException implements \PHPUnit\SebastianBergmann\LinesOfCode\Exception
{
}
sebastian/lines-of-code

Copyright (c) 2020-2021, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/lines-of-code.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\LinesOfCode;

use function array_merge;
use function array_unique;
use function count;
use PHPUnit\PhpParser\Comment;
use PHPUnit\PhpParser\Node;
use PHPUnit\PhpParser\Node\Expr;
use PHPUnit\PhpParser\NodeVisitorAbstract;
final class LineCountingVisitor extends \PHPUnit\PhpParser\NodeVisitorAbstract
{
    private int $linesOfCode;
    /**
     * @var Comment[]
     */
    private array $comments = [];
    /**
     * @var int[]
     */
    private array $linesWithStatements = [];
    public function __construct(int $linesOfCode)
    {
        $this->linesOfCode = $linesOfCode;
    }
    public function enterNode(\PHPUnit\PhpParser\Node $node) : void
    {
        $this->comments = \array_merge($this->comments, $node->getComments());
        if (!$node instanceof \PHPUnit\PhpParser\Node\Expr) {
            return;
        }
        $this->linesWithStatements[] = $node->getStartLine();
    }
    public function result() : \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode
    {
        $commentLinesOfCode = 0;
        foreach ($this->comments() as $comment) {
            $commentLinesOfCode += $comment->getEndLine() - $comment->getStartLine() + 1;
        }
        return new \PHPUnit\SebastianBergmann\LinesOfCode\LinesOfCode($this->linesOfCode, $commentLinesOfCode, $this->linesOfCode - $commentLinesOfCode, \count(\array_unique($this->linesWithStatements)));
    }
    /**
     * @return Comment[]
     */
    private function comments() : array
    {
        $comments = [];
        foreach ($this->comments as $comment) {
            $comments[$comment->getStartLine() . '_' . $comment->getStartTokenPos() . '_' . $comment->getEndLine() . '_' . $comment->getEndTokenPos()] = $comment;
        }
        return $comments;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/lines-of-code.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\LinesOfCode;

/**
 * @psalm-immutable
 */
final class LinesOfCode
{
    private int $linesOfCode;
    private int $commentLinesOfCode;
    private int $nonCommentLinesOfCode;
    private int $logicalLinesOfCode;
    /**
     * @throws IllogicalValuesException
     * @throws NegativeValueException
     */
    public function __construct(int $linesOfCode, int $commentLinesOfCode, int $nonCommentLinesOfCode, int $logicalLinesOfCode)
    {
        if ($linesOfCode < 0) {
            throw new \PHPUnit\SebastianBergmann\LinesOfCode\NegativeValueException('$linesOfCode must not be negative');
        }
        if ($commentLinesOfCode < 0) {
            throw new \PHPUnit\SebastianBergmann\LinesOfCode\NegativeValueException('$commentLinesOfCode must not be negative');
        }
        if ($nonCommentLinesOfCode < 0) {
            throw new \PHPUnit\SebastianBergmann\LinesOfCode\NegativeValueException('$nonCommentLinesOfCode must not be negative');
        }
        if ($logicalLinesOfCode < 0) {
            throw new \PHPUnit\SebastianBergmann\LinesOfCode\NegativeValueException('$logicalLinesOfCode must not be negative');
        }
        if ($linesOfCode - $commentLinesOfCode !== $nonCommentLinesOfCode) {
            throw new \PHPUnit\SebastianBergmann\LinesOfCode\IllogicalValuesException('$linesOfCode !== $commentLinesOfCode + $nonCommentLinesOfCode');
        }
        $this->linesOfCode = $linesOfCode;
        $this->commentLinesOfCode = $commentLinesOfCode;
        $this->nonCommentLinesOfCode = $nonCommentLinesOfCode;
        $this->logicalLinesOfCode = $logicalLinesOfCode;
    }
    public function linesOfCode() : int
    {
        return $this->linesOfCode;
    }
    public function commentLinesOfCode() : int
    {
        return $this->commentLinesOfCode;
    }
    public function nonCommentLinesOfCode() : int
    {
        return $this->nonCommentLinesOfCode;
    }
    public function logicalLinesOfCode() : int
    {
        return $this->logicalLinesOfCode;
    }
    public function plus(self $other) : self
    {
        return new self($this->linesOfCode() + $other->linesOfCode(), $this->commentLinesOfCode() + $other->commentLinesOfCode(), $this->nonCommentLinesOfCode() + $other->nonCommentLinesOfCode(), $this->logicalLinesOfCode() + $other->logicalLinesOfCode());
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/object-enumerator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\ObjectEnumerator;

use function array_merge;
use function func_get_args;
use function is_array;
use function is_object;
use PHPUnit\SebastianBergmann\ObjectReflector\ObjectReflector;
use PHPUnit\SebastianBergmann\RecursionContext\Context;
/**
 * Traverses array structures and object graphs
 * to enumerate all referenced objects.
 */
class Enumerator
{
    /**
     * Returns an array of all objects referenced either
     * directly or indirectly by a variable.
     *
     * @param array|object $variable
     *
     * @return object[]
     */
    public function enumerate($variable)
    {
        if (!\is_array($variable) && !\is_object($variable)) {
            throw new \PHPUnit\SebastianBergmann\ObjectEnumerator\InvalidArgumentException();
        }
        if (isset(\func_get_args()[1])) {
            if (!\func_get_args()[1] instanceof \PHPUnit\SebastianBergmann\RecursionContext\Context) {
                throw new \PHPUnit\SebastianBergmann\ObjectEnumerator\InvalidArgumentException();
            }
            $processed = \func_get_args()[1];
        } else {
            $processed = new \PHPUnit\SebastianBergmann\RecursionContext\Context();
        }
        $objects = [];
        if ($processed->contains($variable)) {
            return $objects;
        }
        $array = $variable;
        $processed->add($variable);
        if (\is_array($variable)) {
            foreach ($array as $element) {
                if (!\is_array($element) && !\is_object($element)) {
                    continue;
                }
                $objects = \array_merge($objects, $this->enumerate($element, $processed));
            }
        } else {
            $objects[] = $variable;
            $reflector = new \PHPUnit\SebastianBergmann\ObjectReflector\ObjectReflector();
            foreach ($reflector->getAttributes($variable) as $value) {
                if (!\is_array($value) && !\is_object($value)) {
                    continue;
                }
                $objects = \array_merge($objects, $this->enumerate($value, $processed));
            }
        }
        return $objects;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/object-enumerator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\ObjectEnumerator;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/object-enumerator.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\ObjectEnumerator;

class InvalidArgumentException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\ObjectEnumerator\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/object-reflector.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\ObjectReflector;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/object-reflector.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\ObjectReflector;

class InvalidArgumentException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\ObjectReflector\Exception
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/object-reflector.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\ObjectReflector;

use function count;
use function explode;
use function get_class;
use function is_object;
class ObjectReflector
{
    /**
     * @param object $object
     *
     * @throws InvalidArgumentException
     */
    public function getAttributes($object) : array
    {
        if (!\is_object($object)) {
            throw new \PHPUnit\SebastianBergmann\ObjectReflector\InvalidArgumentException();
        }
        $attributes = [];
        $className = \get_class($object);
        foreach ((array) $object as $name => $value) {
            $name = \explode("\0", (string) $name);
            if (\count($name) === 1) {
                $name = $name[0];
            } else {
                if ($name[1] !== $className) {
                    $name = $name[1] . '::' . $name[2];
                } else {
                    $name = $name[2];
                }
            }
            $attributes[$name] = $value;
        }
        return $attributes;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of the Recursion Context package.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\RecursionContext;

use const PHP_INT_MAX;
use const PHP_INT_MIN;
use function array_pop;
use function array_slice;
use function count;
use function is_array;
use function is_object;
use function random_int;
use function spl_object_hash;
use SplObjectStorage;
/**
 * A context containing previously processed arrays and objects
 * when recursively processing a value.
 */
final class Context
{
    /**
     * @var array[]
     */
    private $arrays;
    /**
     * @var SplObjectStorage
     */
    private $objects;
    /**
     * Initialises the context.
     */
    public function __construct()
    {
        $this->arrays = [];
        $this->objects = new \SplObjectStorage();
    }
    /**
     * @codeCoverageIgnore
     */
    public function __destruct()
    {
        foreach ($this->arrays as &$array) {
            if (\is_array($array)) {
                \array_pop($array);
                \array_pop($array);
            }
        }
    }
    /**
     * Adds a value to the context.
     *
     * @param array|object $value the value to add
     *
     * @throws InvalidArgumentException Thrown if $value is not an array or object
     *
     * @return bool|int|string the ID of the stored value, either as a string or integer
     *
     * @psalm-template T
     * @psalm-param T $value
     * @param-out T $value
     */
    public function add(&$value)
    {
        if (\is_array($value)) {
            return $this->addArray($value);
        }
        if (\is_object($value)) {
            return $this->addObject($value);
        }
        throw new \PHPUnit\SebastianBergmann\RecursionContext\InvalidArgumentException('Only arrays and objects are supported');
    }
    /**
     * Checks if the given value exists within the context.
     *
     * @param array|object $value the value to check
     *
     * @throws InvalidArgumentException Thrown if $value is not an array or object
     *
     * @return false|int|string the string or integer ID of the stored value if it has already been seen, or false if the value is not stored
     *
     * @psalm-template T
     * @psalm-param T $value
     * @param-out T $value
     */
    public function contains(&$value)
    {
        if (\is_array($value)) {
            return $this->containsArray($value);
        }
        if (\is_object($value)) {
            return $this->containsObject($value);
        }
        throw new \PHPUnit\SebastianBergmann\RecursionContext\InvalidArgumentException('Only arrays and objects are supported');
    }
    /**
     * @return bool|int
     */
    private function addArray(array &$array)
    {
        $key = $this->containsArray($array);
        if ($key !== \false) {
            return $key;
        }
        $key = \count($this->arrays);
        $this->arrays[] =& $array;
        if (!isset($array[\PHP_INT_MAX]) && !isset($array[\PHP_INT_MAX - 1])) {
            $array[] = $key;
            $array[] = $this->objects;
        } else {
            /* cover the improbable case too */
            do {
                $key = \random_int(\PHP_INT_MIN, \PHP_INT_MAX);
            } while (isset($array[$key]));
            $array[$key] = $key;
            do {
                $key = \random_int(\PHP_INT_MIN, \PHP_INT_MAX);
            } while (isset($array[$key]));
            $array[$key] = $this->objects;
        }
        return $key;
    }
    /**
     * @param object $object
     */
    private function addObject($object) : string
    {
        if (!$this->objects->contains($object)) {
            $this->objects->attach($object);
        }
        return \spl_object_hash($object);
    }
    /**
     * @return false|int
     */
    private function containsArray(array &$array)
    {
        $end = \array_slice($array, -2);
        return isset($end[1]) && $end[1] === $this->objects ? $end[0] : \false;
    }
    /**
     * @param object $value
     *
     * @return false|string
     */
    private function containsObject($value)
    {
        if ($this->objects->contains($value)) {
            return \spl_object_hash($value);
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of the Recursion Context package.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\RecursionContext;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of the Recursion Context package.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\RecursionContext;

final class InvalidArgumentException extends \InvalidArgumentException implements \PHPUnit\SebastianBergmann\RecursionContext\Exception
{
}
Recursion Context

Copyright (c) 2002-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
Resource Operations

Copyright (c) 2015-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of resource-operations.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\ResourceOperations;

final class ResourceOperations
{
    /**
     * @return string[]
     */
    public static function getFunctions() : array
    {
        return ['Directory::close', 'Directory::read', 'Directory::rewind', 'DirectoryIterator::openFile', 'FilesystemIterator::openFile', 'Gmagick::readimagefile', 'HttpResponse::getRequestBodyStream', 'HttpResponse::getStream', 'HttpResponse::setStream', 'Imagick::pingImageFile', 'Imagick::readImageFile', 'Imagick::writeImageFile', 'Imagick::writeImagesFile', 'MongoGridFSCursor::__construct', 'MongoGridFSFile::getResource', 'MysqlndUhConnection::stmtInit', 'MysqlndUhConnection::storeResult', 'MysqlndUhConnection::useResult', 'PDF_activate_item', 'PDF_add_launchlink', 'PDF_add_locallink', 'PDF_add_nameddest', 'PDF_add_note', 'PDF_add_pdflink', 'PDF_add_table_cell', 'PDF_add_textflow', 'PDF_add_thumbnail', 'PDF_add_weblink', 'PDF_arc', 'PDF_arcn', 'PDF_attach_file', 'PDF_begin_document', 'PDF_begin_font', 'PDF_begin_glyph', 'PDF_begin_item', 'PDF_begin_layer', 'PDF_begin_page', 'PDF_begin_page_ext', 'PDF_begin_pattern', 'PDF_begin_template', 'PDF_begin_template_ext', 'PDF_circle', 'PDF_clip', 'PDF_close', 'PDF_close_image', 'PDF_close_pdi', 'PDF_close_pdi_page', 'PDF_closepath', 'PDF_closepath_fill_stroke', 'PDF_closepath_stroke', 'PDF_concat', 'PDF_continue_text', 'PDF_create_3dview', 'PDF_create_action', 'PDF_create_annotation', 'PDF_create_bookmark', 'PDF_create_field', 'PDF_create_fieldgroup', 'PDF_create_gstate', 'PDF_create_pvf', 'PDF_create_textflow', 'PDF_curveto', 'PDF_define_layer', 'PDF_delete', 'PDF_delete_pvf', 'PDF_delete_table', 'PDF_delete_textflow', 'PDF_encoding_set_char', 'PDF_end_document', 'PDF_end_font', 'PDF_end_glyph', 'PDF_end_item', 'PDF_end_layer', 'PDF_end_page', 'PDF_end_page_ext', 'PDF_end_pattern', 'PDF_end_template', 'PDF_endpath', 'PDF_fill', 'PDF_fill_imageblock', 'PDF_fill_pdfblock', 'PDF_fill_stroke', 'PDF_fill_textblock', 'PDF_findfont', 'PDF_fit_image', 'PDF_fit_pdi_page', 'PDF_fit_table', 'PDF_fit_textflow', 'PDF_fit_textline', 'PDF_get_apiname', 'PDF_get_buffer', 'PDF_get_errmsg', 'PDF_get_errnum', 'PDF_get_parameter', 'PDF_get_pdi_parameter', 'PDF_get_pdi_value', 'PDF_get_value', 'PDF_info_font', 'PDF_info_matchbox', 'PDF_info_table', 'PDF_info_textflow', 'PDF_info_textline', 'PDF_initgraphics', 'PDF_lineto', 'PDF_load_3ddata', 'PDF_load_font', 'PDF_load_iccprofile', 'PDF_load_image', 'PDF_makespotcolor', 'PDF_moveto', 'PDF_new', 'PDF_open_ccitt', 'PDF_open_file', 'PDF_open_image', 'PDF_open_image_file', 'PDF_open_memory_image', 'PDF_open_pdi', 'PDF_open_pdi_document', 'PDF_open_pdi_page', 'PDF_pcos_get_number', 'PDF_pcos_get_stream', 'PDF_pcos_get_string', 'PDF_place_image', 'PDF_place_pdi_page', 'PDF_process_pdi', 'PDF_rect', 'PDF_restore', 'PDF_resume_page', 'PDF_rotate', 'PDF_save', 'PDF_scale', 'PDF_set_border_color', 'PDF_set_border_dash', 'PDF_set_border_style', 'PDF_set_gstate', 'PDF_set_info', 'PDF_set_layer_dependency', 'PDF_set_parameter', 'PDF_set_text_pos', 'PDF_set_value', 'PDF_setcolor', 'PDF_setdash', 'PDF_setdashpattern', 'PDF_setflat', 'PDF_setfont', 'PDF_setgray', 'PDF_setgray_fill', 'PDF_setgray_stroke', 'PDF_setlinecap', 'PDF_setlinejoin', 'PDF_setlinewidth', 'PDF_setmatrix', 'PDF_setmiterlimit', 'PDF_setrgbcolor', 'PDF_setrgbcolor_fill', 'PDF_setrgbcolor_stroke', 'PDF_shading', 'PDF_shading_pattern', 'PDF_shfill', 'PDF_show', 'PDF_show_boxed', 'PDF_show_xy', 'PDF_skew', 'PDF_stringwidth', 'PDF_stroke', 'PDF_suspend_page', 'PDF_translate', 'PDF_utf16_to_utf8', 'PDF_utf32_to_utf16', 'PDF_utf8_to_utf16', 'PDO::pgsqlLOBOpen', 'RarEntry::getStream', 'SQLite3::openBlob', 'SWFMovie::saveToFile', 'SplFileInfo::openFile', 'SplFileObject::openFile', 'SplTempFileObject::openFile', 'V8Js::compileString', 'V8Js::executeScript', 'Vtiful\\Kernel\\Excel::setColumn', 'Vtiful\\Kernel\\Excel::setRow', 'Vtiful\\Kernel\\Format::align', 'Vtiful\\Kernel\\Format::bold', 'Vtiful\\Kernel\\Format::italic', 'Vtiful\\Kernel\\Format::underline', 'XMLWriter::openMemory', 'XMLWriter::openURI', 'ZipArchive::getStream', 'Zookeeper::setLogStream', 'apc_bin_dumpfile', 'apc_bin_loadfile', 'bbcode_add_element', 'bbcode_add_smiley', 'bbcode_create', 'bbcode_destroy', 'bbcode_parse', 'bbcode_set_arg_parser', 'bbcode_set_flags', 'bcompiler_read', 'bcompiler_write_class', 'bcompiler_write_constant', 'bcompiler_write_exe_footer', 'bcompiler_write_file', 'bcompiler_write_footer', 'bcompiler_write_function', 'bcompiler_write_functions_from_file', 'bcompiler_write_header', 'bcompiler_write_included_filename', 'bzclose', 'bzerrno', 'bzerror', 'bzerrstr', 'bzflush', 'bzopen', 'bzread', 'bzwrite', 'cairo_surface_write_to_png', 'closedir', 'copy', 'crack_closedict', 'crack_opendict', 'cubrid_bind', 'cubrid_close_prepare', 'cubrid_close_request', 'cubrid_col_get', 'cubrid_col_size', 'cubrid_column_names', 'cubrid_column_types', 'cubrid_commit', 'cubrid_connect', 'cubrid_connect_with_url', 'cubrid_current_oid', 'cubrid_db_parameter', 'cubrid_disconnect', 'cubrid_drop', 'cubrid_fetch', 'cubrid_free_result', 'cubrid_get', 'cubrid_get_autocommit', 'cubrid_get_charset', 'cubrid_get_class_name', 'cubrid_get_db_parameter', 'cubrid_get_query_timeout', 'cubrid_get_server_info', 'cubrid_insert_id', 'cubrid_is_instance', 'cubrid_lob2_bind', 'cubrid_lob2_close', 'cubrid_lob2_export', 'cubrid_lob2_import', 'cubrid_lob2_new', 'cubrid_lob2_read', 'cubrid_lob2_seek', 'cubrid_lob2_seek64', 'cubrid_lob2_size', 'cubrid_lob2_size64', 'cubrid_lob2_tell', 'cubrid_lob2_tell64', 'cubrid_lob2_write', 'cubrid_lob_export', 'cubrid_lob_get', 'cubrid_lob_send', 'cubrid_lob_size', 'cubrid_lock_read', 'cubrid_lock_write', 'cubrid_move_cursor', 'cubrid_next_result', 'cubrid_num_cols', 'cubrid_num_rows', 'cubrid_pconnect', 'cubrid_pconnect_with_url', 'cubrid_prepare', 'cubrid_put', 'cubrid_query', 'cubrid_rollback', 'cubrid_schema', 'cubrid_seq_add', 'cubrid_seq_drop', 'cubrid_seq_insert', 'cubrid_seq_put', 'cubrid_set_add', 'cubrid_set_autocommit', 'cubrid_set_db_parameter', 'cubrid_set_drop', 'cubrid_set_query_timeout', 'cubrid_unbuffered_query', 'curl_close', 'curl_copy_handle', 'curl_errno', 'curl_error', 'curl_escape', 'curl_exec', 'curl_getinfo', 'curl_multi_add_handle', 'curl_multi_close', 'curl_multi_errno', 'curl_multi_exec', 'curl_multi_getcontent', 'curl_multi_info_read', 'curl_multi_remove_handle', 'curl_multi_select', 'curl_multi_setopt', 'curl_pause', 'curl_reset', 'curl_setopt', 'curl_setopt_array', 'curl_share_close', 'curl_share_errno', 'curl_share_init', 'curl_share_setopt', 'curl_unescape', 'cyrus_authenticate', 'cyrus_bind', 'cyrus_close', 'cyrus_connect', 'cyrus_query', 'cyrus_unbind', 'db2_autocommit', 'db2_bind_param', 'db2_client_info', 'db2_close', 'db2_column_privileges', 'db2_columns', 'db2_commit', 'db2_conn_error', 'db2_conn_errormsg', 'db2_connect', 'db2_cursor_type', 'db2_exec', 'db2_execute', 'db2_fetch_array', 'db2_fetch_assoc', 'db2_fetch_both', 'db2_fetch_object', 'db2_fetch_row', 'db2_field_display_size', 'db2_field_name', 'db2_field_num', 'db2_field_precision', 'db2_field_scale', 'db2_field_type', 'db2_field_width', 'db2_foreign_keys', 'db2_free_result', 'db2_free_stmt', 'db2_get_option', 'db2_last_insert_id', 'db2_lob_read', 'db2_next_result', 'db2_num_fields', 'db2_num_rows', 'db2_pclose', 'db2_pconnect', 'db2_prepare', 'db2_primary_keys', 'db2_procedure_columns', 'db2_procedures', 'db2_result', 'db2_rollback', 'db2_server_info', 'db2_set_option', 'db2_special_columns', 'db2_statistics', 'db2_stmt_error', 'db2_stmt_errormsg', 'db2_table_privileges', 'db2_tables', 'dba_close', 'dba_delete', 'dba_exists', 'dba_fetch', 'dba_firstkey', 'dba_insert', 'dba_nextkey', 'dba_open', 'dba_optimize', 'dba_popen', 'dba_replace', 'dba_sync', 'dbplus_add', 'dbplus_aql', 'dbplus_close', 'dbplus_curr', 'dbplus_find', 'dbplus_first', 'dbplus_flush', 'dbplus_freelock', 'dbplus_freerlocks', 'dbplus_getlock', 'dbplus_getunique', 'dbplus_info', 'dbplus_last', 'dbplus_lockrel', 'dbplus_next', 'dbplus_open', 'dbplus_prev', 'dbplus_rchperm', 'dbplus_rcreate', 'dbplus_rcrtexact', 'dbplus_rcrtlike', 'dbplus_restorepos', 'dbplus_rkeys', 'dbplus_ropen', 'dbplus_rquery', 'dbplus_rrename', 'dbplus_rsecindex', 'dbplus_runlink', 'dbplus_rzap', 'dbplus_savepos', 'dbplus_setindex', 'dbplus_setindexbynumber', 'dbplus_sql', 'dbplus_tremove', 'dbplus_undo', 'dbplus_undoprepare', 'dbplus_unlockrel', 'dbplus_unselect', 'dbplus_update', 'dbplus_xlockrel', 'dbplus_xunlockrel', 'deflate_add', 'dio_close', 'dio_fcntl', 'dio_open', 'dio_read', 'dio_seek', 'dio_stat', 'dio_tcsetattr', 'dio_truncate', 'dio_write', 'dir', 'eio_busy', 'eio_cancel', 'eio_chmod', 'eio_chown', 'eio_close', 'eio_custom', 'eio_dup2', 'eio_fallocate', 'eio_fchmod', 'eio_fchown', 'eio_fdatasync', 'eio_fstat', 'eio_fstatvfs', 'eio_fsync', 'eio_ftruncate', 'eio_futime', 'eio_get_last_error', 'eio_grp', 'eio_grp_add', 'eio_grp_cancel', 'eio_grp_limit', 'eio_link', 'eio_lstat', 'eio_mkdir', 'eio_mknod', 'eio_nop', 'eio_open', 'eio_read', 'eio_readahead', 'eio_readdir', 'eio_readlink', 'eio_realpath', 'eio_rename', 'eio_rmdir', 'eio_seek', 'eio_sendfile', 'eio_stat', 'eio_statvfs', 'eio_symlink', 'eio_sync', 'eio_sync_file_range', 'eio_syncfs', 'eio_truncate', 'eio_unlink', 'eio_utime', 'eio_write', 'enchant_broker_describe', 'enchant_broker_dict_exists', 'enchant_broker_free', 'enchant_broker_free_dict', 'enchant_broker_get_dict_path', 'enchant_broker_get_error', 'enchant_broker_init', 'enchant_broker_list_dicts', 'enchant_broker_request_dict', 'enchant_broker_request_pwl_dict', 'enchant_broker_set_dict_path', 'enchant_broker_set_ordering', 'enchant_dict_add_to_personal', 'enchant_dict_add_to_session', 'enchant_dict_check', 'enchant_dict_describe', 'enchant_dict_get_error', 'enchant_dict_is_in_session', 'enchant_dict_quick_check', 'enchant_dict_store_replacement', 'enchant_dict_suggest', 'event_add', 'event_base_free', 'event_base_loop', 'event_base_loopbreak', 'event_base_loopexit', 'event_base_new', 'event_base_priority_init', 'event_base_reinit', 'event_base_set', 'event_buffer_base_set', 'event_buffer_disable', 'event_buffer_enable', 'event_buffer_fd_set', 'event_buffer_free', 'event_buffer_new', 'event_buffer_priority_set', 'event_buffer_read', 'event_buffer_set_callback', 'event_buffer_timeout_set', 'event_buffer_watermark_set', 'event_buffer_write', 'event_del', 'event_free', 'event_new', 'event_priority_set', 'event_set', 'event_timer_add', 'event_timer_del', 'event_timer_pending', 'event_timer_set', 'expect_expectl', 'expect_popen', 'fam_cancel_monitor', 'fam_close', 'fam_monitor_collection', 'fam_monitor_directory', 'fam_monitor_file', 'fam_next_event', 'fam_open', 'fam_pending', 'fam_resume_monitor', 'fam_suspend_monitor', 'fann_cascadetrain_on_data', 'fann_cascadetrain_on_file', 'fann_clear_scaling_params', 'fann_copy', 'fann_create_from_file', 'fann_create_shortcut_array', 'fann_create_standard', 'fann_create_standard_array', 'fann_create_train', 'fann_create_train_from_callback', 'fann_descale_input', 'fann_descale_output', 'fann_descale_train', 'fann_destroy', 'fann_destroy_train', 'fann_duplicate_train_data', 'fann_get_MSE', 'fann_get_activation_function', 'fann_get_activation_steepness', 'fann_get_bias_array', 'fann_get_bit_fail', 'fann_get_bit_fail_limit', 'fann_get_cascade_activation_functions', 'fann_get_cascade_activation_functions_count', 'fann_get_cascade_activation_steepnesses', 'fann_get_cascade_activation_steepnesses_count', 'fann_get_cascade_candidate_change_fraction', 'fann_get_cascade_candidate_limit', 'fann_get_cascade_candidate_stagnation_epochs', 'fann_get_cascade_max_cand_epochs', 'fann_get_cascade_max_out_epochs', 'fann_get_cascade_min_cand_epochs', 'fann_get_cascade_min_out_epochs', 'fann_get_cascade_num_candidate_groups', 'fann_get_cascade_num_candidates', 'fann_get_cascade_output_change_fraction', 'fann_get_cascade_output_stagnation_epochs', 'fann_get_cascade_weight_multiplier', 'fann_get_connection_array', 'fann_get_connection_rate', 'fann_get_errno', 'fann_get_errstr', 'fann_get_layer_array', 'fann_get_learning_momentum', 'fann_get_learning_rate', 'fann_get_network_type', 'fann_get_num_input', 'fann_get_num_layers', 'fann_get_num_output', 'fann_get_quickprop_decay', 'fann_get_quickprop_mu', 'fann_get_rprop_decrease_factor', 'fann_get_rprop_delta_max', 'fann_get_rprop_delta_min', 'fann_get_rprop_delta_zero', 'fann_get_rprop_increase_factor', 'fann_get_sarprop_step_error_shift', 'fann_get_sarprop_step_error_threshold_factor', 'fann_get_sarprop_temperature', 'fann_get_sarprop_weight_decay_shift', 'fann_get_total_connections', 'fann_get_total_neurons', 'fann_get_train_error_function', 'fann_get_train_stop_function', 'fann_get_training_algorithm', 'fann_init_weights', 'fann_length_train_data', 'fann_merge_train_data', 'fann_num_input_train_data', 'fann_num_output_train_data', 'fann_randomize_weights', 'fann_read_train_from_file', 'fann_reset_errno', 'fann_reset_errstr', 'fann_run', 'fann_save', 'fann_save_train', 'fann_scale_input', 'fann_scale_input_train_data', 'fann_scale_output', 'fann_scale_output_train_data', 'fann_scale_train', 'fann_scale_train_data', 'fann_set_activation_function', 'fann_set_activation_function_hidden', 'fann_set_activation_function_layer', 'fann_set_activation_function_output', 'fann_set_activation_steepness', 'fann_set_activation_steepness_hidden', 'fann_set_activation_steepness_layer', 'fann_set_activation_steepness_output', 'fann_set_bit_fail_limit', 'fann_set_callback', 'fann_set_cascade_activation_functions', 'fann_set_cascade_activation_steepnesses', 'fann_set_cascade_candidate_change_fraction', 'fann_set_cascade_candidate_limit', 'fann_set_cascade_candidate_stagnation_epochs', 'fann_set_cascade_max_cand_epochs', 'fann_set_cascade_max_out_epochs', 'fann_set_cascade_min_cand_epochs', 'fann_set_cascade_min_out_epochs', 'fann_set_cascade_num_candidate_groups', 'fann_set_cascade_output_change_fraction', 'fann_set_cascade_output_stagnation_epochs', 'fann_set_cascade_weight_multiplier', 'fann_set_error_log', 'fann_set_input_scaling_params', 'fann_set_learning_momentum', 'fann_set_learning_rate', 'fann_set_output_scaling_params', 'fann_set_quickprop_decay', 'fann_set_quickprop_mu', 'fann_set_rprop_decrease_factor', 'fann_set_rprop_delta_max', 'fann_set_rprop_delta_min', 'fann_set_rprop_delta_zero', 'fann_set_rprop_increase_factor', 'fann_set_sarprop_step_error_shift', 'fann_set_sarprop_step_error_threshold_factor', 'fann_set_sarprop_temperature', 'fann_set_sarprop_weight_decay_shift', 'fann_set_scaling_params', 'fann_set_train_error_function', 'fann_set_train_stop_function', 'fann_set_training_algorithm', 'fann_set_weight', 'fann_set_weight_array', 'fann_shuffle_train_data', 'fann_subset_train_data', 'fann_test', 'fann_test_data', 'fann_train', 'fann_train_epoch', 'fann_train_on_data', 'fann_train_on_file', 'fbsql_affected_rows', 'fbsql_autocommit', 'fbsql_blob_size', 'fbsql_change_user', 'fbsql_clob_size', 'fbsql_close', 'fbsql_commit', 'fbsql_connect', 'fbsql_create_blob', 'fbsql_create_clob', 'fbsql_create_db', 'fbsql_data_seek', 'fbsql_database', 'fbsql_database_password', 'fbsql_db_query', 'fbsql_db_status', 'fbsql_drop_db', 'fbsql_errno', 'fbsql_error', 'fbsql_fetch_array', 'fbsql_fetch_assoc', 'fbsql_fetch_field', 'fbsql_fetch_lengths', 'fbsql_fetch_object', 'fbsql_fetch_row', 'fbsql_field_flags', 'fbsql_field_len', 'fbsql_field_name', 'fbsql_field_seek', 'fbsql_field_table', 'fbsql_field_type', 'fbsql_free_result', 'fbsql_get_autostart_info', 'fbsql_hostname', 'fbsql_insert_id', 'fbsql_list_dbs', 'fbsql_list_fields', 'fbsql_list_tables', 'fbsql_next_result', 'fbsql_num_fields', 'fbsql_num_rows', 'fbsql_password', 'fbsql_pconnect', 'fbsql_query', 'fbsql_read_blob', 'fbsql_read_clob', 'fbsql_result', 'fbsql_rollback', 'fbsql_rows_fetched', 'fbsql_select_db', 'fbsql_set_characterset', 'fbsql_set_lob_mode', 'fbsql_set_password', 'fbsql_set_transaction', 'fbsql_start_db', 'fbsql_stop_db', 'fbsql_table_name', 'fbsql_username', 'fclose', 'fdf_add_doc_javascript', 'fdf_add_template', 'fdf_close', 'fdf_create', 'fdf_enum_values', 'fdf_get_ap', 'fdf_get_attachment', 'fdf_get_encoding', 'fdf_get_file', 'fdf_get_flags', 'fdf_get_opt', 'fdf_get_status', 'fdf_get_value', 'fdf_get_version', 'fdf_next_field_name', 'fdf_open', 'fdf_open_string', 'fdf_remove_item', 'fdf_save', 'fdf_save_string', 'fdf_set_ap', 'fdf_set_encoding', 'fdf_set_file', 'fdf_set_flags', 'fdf_set_javascript_action', 'fdf_set_on_import_javascript', 'fdf_set_opt', 'fdf_set_status', 'fdf_set_submit_form_action', 'fdf_set_target_frame', 'fdf_set_value', 'fdf_set_version', 'feof', 'fflush', 'ffmpeg_frame::__construct', 'ffmpeg_frame::toGDImage', 'fgetc', 'fgetcsv', 'fgets', 'fgetss', 'file', 'file_get_contents', 'file_put_contents', 'finfo::buffer', 'finfo::file', 'finfo_buffer', 'finfo_close', 'finfo_file', 'finfo_open', 'finfo_set_flags', 'flock', 'fopen', 'fpassthru', 'fprintf', 'fputcsv', 'fputs', 'fread', 'fscanf', 'fseek', 'fstat', 'ftell', 'ftp_alloc', 'ftp_append', 'ftp_cdup', 'ftp_chdir', 'ftp_chmod', 'ftp_close', 'ftp_delete', 'ftp_exec', 'ftp_fget', 'ftp_fput', 'ftp_get', 'ftp_get_option', 'ftp_login', 'ftp_mdtm', 'ftp_mkdir', 'ftp_mlsd', 'ftp_nb_continue', 'ftp_nb_fget', 'ftp_nb_fput', 'ftp_nb_get', 'ftp_nb_put', 'ftp_nlist', 'ftp_pasv', 'ftp_put', 'ftp_pwd', 'ftp_quit', 'ftp_raw', 'ftp_rawlist', 'ftp_rename', 'ftp_rmdir', 'ftp_set_option', 'ftp_site', 'ftp_size', 'ftp_systype', 'ftruncate', 'fwrite', 'get_resource_type', 'gmp_div', 'gnupg::init', 'gnupg_adddecryptkey', 'gnupg_addencryptkey', 'gnupg_addsignkey', 'gnupg_cleardecryptkeys', 'gnupg_clearencryptkeys', 'gnupg_clearsignkeys', 'gnupg_decrypt', 'gnupg_decryptverify', 'gnupg_encrypt', 'gnupg_encryptsign', 'gnupg_export', 'gnupg_geterror', 'gnupg_getprotocol', 'gnupg_import', 'gnupg_init', 'gnupg_keyinfo', 'gnupg_setarmor', 'gnupg_seterrormode', 'gnupg_setsignmode', 'gnupg_sign', 'gnupg_verify', 'gupnp_context_get_host_ip', 'gupnp_context_get_port', 'gupnp_context_get_subscription_timeout', 'gupnp_context_host_path', 'gupnp_context_new', 'gupnp_context_set_subscription_timeout', 'gupnp_context_timeout_add', 'gupnp_context_unhost_path', 'gupnp_control_point_browse_start', 'gupnp_control_point_browse_stop', 'gupnp_control_point_callback_set', 'gupnp_control_point_new', 'gupnp_device_action_callback_set', 'gupnp_device_info_get', 'gupnp_device_info_get_service', 'gupnp_root_device_get_available', 'gupnp_root_device_get_relative_location', 'gupnp_root_device_new', 'gupnp_root_device_set_available', 'gupnp_root_device_start', 'gupnp_root_device_stop', 'gupnp_service_action_get', 'gupnp_service_action_return', 'gupnp_service_action_return_error', 'gupnp_service_action_set', 'gupnp_service_freeze_notify', 'gupnp_service_info_get', 'gupnp_service_info_get_introspection', 'gupnp_service_introspection_get_state_variable', 'gupnp_service_notify', 'gupnp_service_proxy_action_get', 'gupnp_service_proxy_action_set', 'gupnp_service_proxy_add_notify', 'gupnp_service_proxy_callback_set', 'gupnp_service_proxy_get_subscribed', 'gupnp_service_proxy_remove_notify', 'gupnp_service_proxy_send_action', 'gupnp_service_proxy_set_subscribed', 'gupnp_service_thaw_notify', 'gzclose', 'gzeof', 'gzgetc', 'gzgets', 'gzgetss', 'gzpassthru', 'gzputs', 'gzread', 'gzrewind', 'gzseek', 'gztell', 'gzwrite', 'hash_update_stream', 'http\\Env\\Response::send', 'http_get_request_body_stream', 'ibase_add_user', 'ibase_affected_rows', 'ibase_backup', 'ibase_blob_add', 'ibase_blob_cancel', 'ibase_blob_close', 'ibase_blob_create', 'ibase_blob_get', 'ibase_blob_open', 'ibase_close', 'ibase_commit', 'ibase_commit_ret', 'ibase_connect', 'ibase_db_info', 'ibase_delete_user', 'ibase_drop_db', 'ibase_execute', 'ibase_fetch_assoc', 'ibase_fetch_object', 'ibase_fetch_row', 'ibase_field_info', 'ibase_free_event_handler', 'ibase_free_query', 'ibase_free_result', 'ibase_gen_id', 'ibase_maintain_db', 'ibase_modify_user', 'ibase_name_result', 'ibase_num_fields', 'ibase_num_params', 'ibase_param_info', 'ibase_pconnect', 'ibase_prepare', 'ibase_query', 'ibase_restore', 'ibase_rollback', 'ibase_rollback_ret', 'ibase_server_info', 'ibase_service_attach', 'ibase_service_detach', 'ibase_set_event_handler', 'ibase_trans', 'ifx_affected_rows', 'ifx_close', 'ifx_connect', 'ifx_do', 'ifx_error', 'ifx_fetch_row', 'ifx_fieldproperties', 'ifx_fieldtypes', 'ifx_free_result', 'ifx_getsqlca', 'ifx_htmltbl_result', 'ifx_num_fields', 'ifx_num_rows', 'ifx_pconnect', 'ifx_prepare', 'ifx_query', 'image2wbmp', 'imageaffine', 'imagealphablending', 'imageantialias', 'imagearc', 'imagebmp', 'imagechar', 'imagecharup', 'imagecolorallocate', 'imagecolorallocatealpha', 'imagecolorat', 'imagecolorclosest', 'imagecolorclosestalpha', 'imagecolorclosesthwb', 'imagecolordeallocate', 'imagecolorexact', 'imagecolorexactalpha', 'imagecolormatch', 'imagecolorresolve', 'imagecolorresolvealpha', 'imagecolorset', 'imagecolorsforindex', 'imagecolorstotal', 'imagecolortransparent', 'imageconvolution', 'imagecopy', 'imagecopymerge', 'imagecopymergegray', 'imagecopyresampled', 'imagecopyresized', 'imagecrop', 'imagecropauto', 'imagedashedline', 'imagedestroy', 'imageellipse', 'imagefill', 'imagefilledarc', 'imagefilledellipse', 'imagefilledpolygon', 'imagefilledrectangle', 'imagefilltoborder', 'imagefilter', 'imageflip', 'imagefttext', 'imagegammacorrect', 'imagegd', 'imagegd2', 'imagegetclip', 'imagegif', 'imagegrabscreen', 'imagegrabwindow', 'imageinterlace', 'imageistruecolor', 'imagejpeg', 'imagelayereffect', 'imageline', 'imageopenpolygon', 'imagepalettecopy', 'imagepalettetotruecolor', 'imagepng', 'imagepolygon', 'imagepsencodefont', 'imagepsextendfont', 'imagepsfreefont', 'imagepsloadfont', 'imagepsslantfont', 'imagepstext', 'imagerectangle', 'imageresolution', 'imagerotate', 'imagesavealpha', 'imagescale', 'imagesetbrush', 'imagesetclip', 'imagesetinterpolation', 'imagesetpixel', 'imagesetstyle', 'imagesetthickness', 'imagesettile', 'imagestring', 'imagestringup', 'imagesx', 'imagesy', 'imagetruecolortopalette', 'imagettftext', 'imagewbmp', 'imagewebp', 'imagexbm', 'imap_append', 'imap_body', 'imap_bodystruct', 'imap_check', 'imap_clearflag_full', 'imap_close', 'imap_create', 'imap_createmailbox', 'imap_delete', 'imap_deletemailbox', 'imap_expunge', 'imap_fetch_overview', 'imap_fetchbody', 'imap_fetchheader', 'imap_fetchmime', 'imap_fetchstructure', 'imap_fetchtext', 'imap_gc', 'imap_get_quota', 'imap_get_quotaroot', 'imap_getacl', 'imap_getmailboxes', 'imap_getsubscribed', 'imap_header', 'imap_headerinfo', 'imap_headers', 'imap_list', 'imap_listmailbox', 'imap_listscan', 'imap_listsubscribed', 'imap_lsub', 'imap_mail_copy', 'imap_mail_move', 'imap_mailboxmsginfo', 'imap_msgno', 'imap_num_msg', 'imap_num_recent', 'imap_ping', 'imap_rename', 'imap_renamemailbox', 'imap_reopen', 'imap_savebody', 'imap_scan', 'imap_scanmailbox', 'imap_search', 'imap_set_quota', 'imap_setacl', 'imap_setflag_full', 'imap_sort', 'imap_status', 'imap_subscribe', 'imap_thread', 'imap_uid', 'imap_undelete', 'imap_unsubscribe', 'inflate_add', 'inflate_get_read_len', 'inflate_get_status', 'ingres_autocommit', 'ingres_autocommit_state', 'ingres_charset', 'ingres_close', 'ingres_commit', 'ingres_connect', 'ingres_cursor', 'ingres_errno', 'ingres_error', 'ingres_errsqlstate', 'ingres_escape_string', 'ingres_execute', 'ingres_fetch_array', 'ingres_fetch_assoc', 'ingres_fetch_object', 'ingres_fetch_proc_return', 'ingres_fetch_row', 'ingres_field_length', 'ingres_field_name', 'ingres_field_nullable', 'ingres_field_precision', 'ingres_field_scale', 'ingres_field_type', 'ingres_free_result', 'ingres_next_error', 'ingres_num_fields', 'ingres_num_rows', 'ingres_pconnect', 'ingres_prepare', 'ingres_query', 'ingres_result_seek', 'ingres_rollback', 'ingres_set_environment', 'ingres_unbuffered_query', 'inotify_add_watch', 'inotify_init', 'inotify_queue_len', 'inotify_read', 'inotify_rm_watch', 'kadm5_chpass_principal', 'kadm5_create_principal', 'kadm5_delete_principal', 'kadm5_destroy', 'kadm5_flush', 'kadm5_get_policies', 'kadm5_get_principal', 'kadm5_get_principals', 'kadm5_init_with_password', 'kadm5_modify_principal', 'ldap_add', 'ldap_bind', 'ldap_close', 'ldap_compare', 'ldap_control_paged_result', 'ldap_control_paged_result_response', 'ldap_count_entries', 'ldap_delete', 'ldap_errno', 'ldap_error', 'ldap_exop', 'ldap_exop_passwd', 'ldap_exop_refresh', 'ldap_exop_whoami', 'ldap_first_attribute', 'ldap_first_entry', 'ldap_first_reference', 'ldap_free_result', 'ldap_get_attributes', 'ldap_get_dn', 'ldap_get_entries', 'ldap_get_option', 'ldap_get_values', 'ldap_get_values_len', 'ldap_mod_add', 'ldap_mod_del', 'ldap_mod_replace', 'ldap_modify', 'ldap_modify_batch', 'ldap_next_attribute', 'ldap_next_entry', 'ldap_next_reference', 'ldap_parse_exop', 'ldap_parse_reference', 'ldap_parse_result', 'ldap_rename', 'ldap_sasl_bind', 'ldap_set_option', 'ldap_set_rebind_proc', 'ldap_sort', 'ldap_start_tls', 'ldap_unbind', 'libxml_set_streams_context', 'm_checkstatus', 'm_completeauthorizations', 'm_connect', 'm_connectionerror', 'm_deletetrans', 'm_destroyconn', 'm_getcell', 'm_getcellbynum', 'm_getcommadelimited', 'm_getheader', 'm_initconn', 'm_iscommadelimited', 'm_maxconntimeout', 'm_monitor', 'm_numcolumns', 'm_numrows', 'm_parsecommadelimited', 'm_responsekeys', 'm_responseparam', 'm_returnstatus', 'm_setblocking', 'm_setdropfile', 'm_setip', 'm_setssl', 'm_setssl_cafile', 'm_setssl_files', 'm_settimeout', 'm_transactionssent', 'm_transinqueue', 'm_transkeyval', 'm_transnew', 'm_transsend', 'm_validateidentifier', 'm_verifyconnection', 'm_verifysslcert', 'mailparse_determine_best_xfer_encoding', 'mailparse_msg_create', 'mailparse_msg_extract_part', 'mailparse_msg_extract_part_file', 'mailparse_msg_extract_whole_part_file', 'mailparse_msg_free', 'mailparse_msg_get_part', 'mailparse_msg_get_part_data', 'mailparse_msg_get_structure', 'mailparse_msg_parse', 'mailparse_msg_parse_file', 'mailparse_stream_encode', 'mailparse_uudecode_all', 'maxdb::use_result', 'maxdb_affected_rows', 'maxdb_connect', 'maxdb_disable_rpl_parse', 'maxdb_dump_debug_info', 'maxdb_embedded_connect', 'maxdb_enable_reads_from_master', 'maxdb_enable_rpl_parse', 'maxdb_errno', 'maxdb_error', 'maxdb_fetch_lengths', 'maxdb_field_tell', 'maxdb_get_host_info', 'maxdb_get_proto_info', 'maxdb_get_server_info', 'maxdb_get_server_version', 'maxdb_info', 'maxdb_init', 'maxdb_insert_id', 'maxdb_master_query', 'maxdb_more_results', 'maxdb_next_result', 'maxdb_num_fields', 'maxdb_num_rows', 'maxdb_rpl_parse_enabled', 'maxdb_rpl_probe', 'maxdb_select_db', 'maxdb_sqlstate', 'maxdb_stmt::result_metadata', 'maxdb_stmt_affected_rows', 'maxdb_stmt_errno', 'maxdb_stmt_error', 'maxdb_stmt_num_rows', 'maxdb_stmt_param_count', 'maxdb_stmt_result_metadata', 'maxdb_stmt_sqlstate', 'maxdb_thread_id', 'maxdb_use_result', 'maxdb_warning_count', 'mcrypt_enc_get_algorithms_name', 'mcrypt_enc_get_block_size', 'mcrypt_enc_get_iv_size', 'mcrypt_enc_get_key_size', 'mcrypt_enc_get_modes_name', 'mcrypt_enc_get_supported_key_sizes', 'mcrypt_enc_is_block_algorithm', 'mcrypt_enc_is_block_algorithm_mode', 'mcrypt_enc_is_block_mode', 'mcrypt_enc_self_test', 'mcrypt_generic', 'mcrypt_generic_deinit', 'mcrypt_generic_end', 'mcrypt_generic_init', 'mcrypt_module_close', 'mcrypt_module_open', 'mdecrypt_generic', 'mkdir', 'mqseries_back', 'mqseries_begin', 'mqseries_close', 'mqseries_cmit', 'mqseries_conn', 'mqseries_connx', 'mqseries_disc', 'mqseries_get', 'mqseries_inq', 'mqseries_open', 'mqseries_put', 'mqseries_put1', 'mqseries_set', 'msg_get_queue', 'msg_receive', 'msg_remove_queue', 'msg_send', 'msg_set_queue', 'msg_stat_queue', 'msql_affected_rows', 'msql_close', 'msql_connect', 'msql_create_db', 'msql_data_seek', 'msql_db_query', 'msql_drop_db', 'msql_fetch_array', 'msql_fetch_field', 'msql_fetch_object', 'msql_fetch_row', 'msql_field_flags', 'msql_field_len', 'msql_field_name', 'msql_field_seek', 'msql_field_table', 'msql_field_type', 'msql_free_result', 'msql_list_dbs', 'msql_list_fields', 'msql_list_tables', 'msql_num_fields', 'msql_num_rows', 'msql_pconnect', 'msql_query', 'msql_result', 'msql_select_db', 'mssql_bind', 'mssql_close', 'mssql_connect', 'mssql_data_seek', 'mssql_execute', 'mssql_fetch_array', 'mssql_fetch_assoc', 'mssql_fetch_batch', 'mssql_fetch_field', 'mssql_fetch_object', 'mssql_fetch_row', 'mssql_field_length', 'mssql_field_name', 'mssql_field_seek', 'mssql_field_type', 'mssql_free_result', 'mssql_free_statement', 'mssql_init', 'mssql_next_result', 'mssql_num_fields', 'mssql_num_rows', 'mssql_pconnect', 'mssql_query', 'mssql_result', 'mssql_rows_affected', 'mssql_select_db', 'mysql_affected_rows', 'mysql_client_encoding', 'mysql_close', 'mysql_connect', 'mysql_create_db', 'mysql_data_seek', 'mysql_db_name', 'mysql_db_query', 'mysql_drop_db', 'mysql_errno', 'mysql_error', 'mysql_fetch_array', 'mysql_fetch_assoc', 'mysql_fetch_field', 'mysql_fetch_lengths', 'mysql_fetch_object', 'mysql_fetch_row', 'mysql_field_flags', 'mysql_field_len', 'mysql_field_name', 'mysql_field_seek', 'mysql_field_table', 'mysql_field_type', 'mysql_free_result', 'mysql_get_host_info', 'mysql_get_proto_info', 'mysql_get_server_info', 'mysql_info', 'mysql_insert_id', 'mysql_list_dbs', 'mysql_list_fields', 'mysql_list_processes', 'mysql_list_tables', 'mysql_num_fields', 'mysql_num_rows', 'mysql_pconnect', 'mysql_ping', 'mysql_query', 'mysql_real_escape_string', 'mysql_result', 'mysql_select_db', 'mysql_set_charset', 'mysql_stat', 'mysql_tablename', 'mysql_thread_id', 'mysql_unbuffered_query', 'mysqlnd_uh_convert_to_mysqlnd', 'ncurses_bottom_panel', 'ncurses_del_panel', 'ncurses_delwin', 'ncurses_getmaxyx', 'ncurses_getyx', 'ncurses_hide_panel', 'ncurses_keypad', 'ncurses_meta', 'ncurses_move_panel', 'ncurses_mvwaddstr', 'ncurses_new_panel', 'ncurses_newpad', 'ncurses_newwin', 'ncurses_panel_above', 'ncurses_panel_below', 'ncurses_panel_window', 'ncurses_pnoutrefresh', 'ncurses_prefresh', 'ncurses_replace_panel', 'ncurses_show_panel', 'ncurses_top_panel', 'ncurses_waddch', 'ncurses_waddstr', 'ncurses_wattroff', 'ncurses_wattron', 'ncurses_wattrset', 'ncurses_wborder', 'ncurses_wclear', 'ncurses_wcolor_set', 'ncurses_werase', 'ncurses_wgetch', 'ncurses_whline', 'ncurses_wmouse_trafo', 'ncurses_wmove', 'ncurses_wnoutrefresh', 'ncurses_wrefresh', 'ncurses_wstandend', 'ncurses_wstandout', 'ncurses_wvline', 'newt_button', 'newt_button_bar', 'newt_checkbox', 'newt_checkbox_get_value', 'newt_checkbox_set_flags', 'newt_checkbox_set_value', 'newt_checkbox_tree', 'newt_checkbox_tree_add_item', 'newt_checkbox_tree_find_item', 'newt_checkbox_tree_get_current', 'newt_checkbox_tree_get_entry_value', 'newt_checkbox_tree_get_multi_selection', 'newt_checkbox_tree_get_selection', 'newt_checkbox_tree_multi', 'newt_checkbox_tree_set_current', 'newt_checkbox_tree_set_entry', 'newt_checkbox_tree_set_entry_value', 'newt_checkbox_tree_set_width', 'newt_compact_button', 'newt_component_add_callback', 'newt_component_takes_focus', 'newt_create_grid', 'newt_draw_form', 'newt_entry', 'newt_entry_get_value', 'newt_entry_set', 'newt_entry_set_filter', 'newt_entry_set_flags', 'newt_form', 'newt_form_add_component', 'newt_form_add_components', 'newt_form_add_hot_key', 'newt_form_destroy', 'newt_form_get_current', 'newt_form_run', 'newt_form_set_background', 'newt_form_set_height', 'newt_form_set_size', 'newt_form_set_timer', 'newt_form_set_width', 'newt_form_watch_fd', 'newt_grid_add_components_to_form', 'newt_grid_basic_window', 'newt_grid_free', 'newt_grid_get_size', 'newt_grid_h_close_stacked', 'newt_grid_h_stacked', 'newt_grid_place', 'newt_grid_set_field', 'newt_grid_simple_window', 'newt_grid_v_close_stacked', 'newt_grid_v_stacked', 'newt_grid_wrapped_window', 'newt_grid_wrapped_window_at', 'newt_label', 'newt_label_set_text', 'newt_listbox', 'newt_listbox_append_entry', 'newt_listbox_clear', 'newt_listbox_clear_selection', 'newt_listbox_delete_entry', 'newt_listbox_get_current', 'newt_listbox_get_selection', 'newt_listbox_insert_entry', 'newt_listbox_item_count', 'newt_listbox_select_item', 'newt_listbox_set_current', 'newt_listbox_set_current_by_key', 'newt_listbox_set_data', 'newt_listbox_set_entry', 'newt_listbox_set_width', 'newt_listitem', 'newt_listitem_get_data', 'newt_listitem_set', 'newt_radio_get_current', 'newt_radiobutton', 'newt_run_form', 'newt_scale', 'newt_scale_set', 'newt_scrollbar_set', 'newt_textbox', 'newt_textbox_get_num_lines', 'newt_textbox_reflowed', 'newt_textbox_set_height', 'newt_textbox_set_text', 'newt_vertical_scrollbar', 'oci_bind_array_by_name', 'oci_bind_by_name', 'oci_cancel', 'oci_close', 'oci_commit', 'oci_connect', 'oci_define_by_name', 'oci_error', 'oci_execute', 'oci_fetch', 'oci_fetch_all', 'oci_fetch_array', 'oci_fetch_assoc', 'oci_fetch_object', 'oci_fetch_row', 'oci_field_is_null', 'oci_field_name', 'oci_field_precision', 'oci_field_scale', 'oci_field_size', 'oci_field_type', 'oci_field_type_raw', 'oci_free_cursor', 'oci_free_statement', 'oci_get_implicit_resultset', 'oci_new_collection', 'oci_new_connect', 'oci_new_cursor', 'oci_new_descriptor', 'oci_num_fields', 'oci_num_rows', 'oci_parse', 'oci_pconnect', 'oci_register_taf_callback', 'oci_result', 'oci_rollback', 'oci_server_version', 'oci_set_action', 'oci_set_client_identifier', 'oci_set_client_info', 'oci_set_module_name', 'oci_set_prefetch', 'oci_statement_type', 'oci_unregister_taf_callback', 'odbc_autocommit', 'odbc_close', 'odbc_columnprivileges', 'odbc_columns', 'odbc_commit', 'odbc_connect', 'odbc_cursor', 'odbc_data_source', 'odbc_do', 'odbc_error', 'odbc_errormsg', 'odbc_exec', 'odbc_execute', 'odbc_fetch_array', 'odbc_fetch_into', 'odbc_fetch_row', 'odbc_field_len', 'odbc_field_name', 'odbc_field_num', 'odbc_field_precision', 'odbc_field_scale', 'odbc_field_type', 'odbc_foreignkeys', 'odbc_free_result', 'odbc_gettypeinfo', 'odbc_next_result', 'odbc_num_fields', 'odbc_num_rows', 'odbc_pconnect', 'odbc_prepare', 'odbc_primarykeys', 'odbc_procedurecolumns', 'odbc_procedures', 'odbc_result', 'odbc_result_all', 'odbc_rollback', 'odbc_setoption', 'odbc_specialcolumns', 'odbc_statistics', 'odbc_tableprivileges', 'odbc_tables', 'openal_buffer_create', 'openal_buffer_data', 'openal_buffer_destroy', 'openal_buffer_get', 'openal_buffer_loadwav', 'openal_context_create', 'openal_context_current', 'openal_context_destroy', 'openal_context_process', 'openal_context_suspend', 'openal_device_close', 'openal_device_open', 'openal_source_create', 'openal_source_destroy', 'openal_source_get', 'openal_source_pause', 'openal_source_play', 'openal_source_rewind', 'openal_source_set', 'openal_source_stop', 'openal_stream', 'opendir', 'openssl_csr_new', 'openssl_dh_compute_key', 'openssl_free_key', 'openssl_pkey_export', 'openssl_pkey_free', 'openssl_pkey_get_details', 'openssl_spki_new', 'openssl_x509_free', 'pclose', 'pfsockopen', 'pg_affected_rows', 'pg_cancel_query', 'pg_client_encoding', 'pg_close', 'pg_connect_poll', 'pg_connection_busy', 'pg_connection_reset', 'pg_connection_status', 'pg_consume_input', 'pg_convert', 'pg_copy_from', 'pg_copy_to', 'pg_dbname', 'pg_delete', 'pg_end_copy', 'pg_escape_bytea', 'pg_escape_identifier', 'pg_escape_literal', 'pg_escape_string', 'pg_execute', 'pg_fetch_all', 'pg_fetch_all_columns', 'pg_fetch_array', 'pg_fetch_assoc', 'pg_fetch_row', 'pg_field_name', 'pg_field_num', 'pg_field_size', 'pg_field_table', 'pg_field_type', 'pg_field_type_oid', 'pg_flush', 'pg_free_result', 'pg_get_notify', 'pg_get_pid', 'pg_get_result', 'pg_host', 'pg_insert', 'pg_last_error', 'pg_last_notice', 'pg_last_oid', 'pg_lo_close', 'pg_lo_create', 'pg_lo_export', 'pg_lo_import', 'pg_lo_open', 'pg_lo_read', 'pg_lo_read_all', 'pg_lo_seek', 'pg_lo_tell', 'pg_lo_truncate', 'pg_lo_unlink', 'pg_lo_write', 'pg_meta_data', 'pg_num_fields', 'pg_num_rows', 'pg_options', 'pg_parameter_status', 'pg_ping', 'pg_port', 'pg_prepare', 'pg_put_line', 'pg_query', 'pg_query_params', 'pg_result_error', 'pg_result_error_field', 'pg_result_seek', 'pg_result_status', 'pg_select', 'pg_send_execute', 'pg_send_prepare', 'pg_send_query', 'pg_send_query_params', 'pg_set_client_encoding', 'pg_set_error_verbosity', 'pg_socket', 'pg_trace', 'pg_transaction_status', 'pg_tty', 'pg_untrace', 'pg_update', 'pg_version', 'php_user_filter::filter', 'proc_close', 'proc_get_status', 'proc_terminate', 'ps_add_bookmark', 'ps_add_launchlink', 'ps_add_locallink', 'ps_add_note', 'ps_add_pdflink', 'ps_add_weblink', 'ps_arc', 'ps_arcn', 'ps_begin_page', 'ps_begin_pattern', 'ps_begin_template', 'ps_circle', 'ps_clip', 'ps_close', 'ps_close_image', 'ps_closepath', 'ps_closepath_stroke', 'ps_continue_text', 'ps_curveto', 'ps_delete', 'ps_end_page', 'ps_end_pattern', 'ps_end_template', 'ps_fill', 'ps_fill_stroke', 'ps_findfont', 'ps_get_buffer', 'ps_get_parameter', 'ps_get_value', 'ps_hyphenate', 'ps_include_file', 'ps_lineto', 'ps_makespotcolor', 'ps_moveto', 'ps_new', 'ps_open_file', 'ps_open_image', 'ps_open_image_file', 'ps_open_memory_image', 'ps_place_image', 'ps_rect', 'ps_restore', 'ps_rotate', 'ps_save', 'ps_scale', 'ps_set_border_color', 'ps_set_border_dash', 'ps_set_border_style', 'ps_set_info', 'ps_set_parameter', 'ps_set_text_pos', 'ps_set_value', 'ps_setcolor', 'ps_setdash', 'ps_setflat', 'ps_setfont', 'ps_setgray', 'ps_setlinecap', 'ps_setlinejoin', 'ps_setlinewidth', 'ps_setmiterlimit', 'ps_setoverprintmode', 'ps_setpolydash', 'ps_shading', 'ps_shading_pattern', 'ps_shfill', 'ps_show', 'ps_show2', 'ps_show_boxed', 'ps_show_xy', 'ps_show_xy2', 'ps_string_geometry', 'ps_stringwidth', 'ps_stroke', 'ps_symbol', 'ps_symbol_name', 'ps_symbol_width', 'ps_translate', 'px_close', 'px_create_fp', 'px_date2string', 'px_delete', 'px_delete_record', 'px_get_field', 'px_get_info', 'px_get_parameter', 'px_get_record', 'px_get_schema', 'px_get_value', 'px_insert_record', 'px_new', 'px_numfields', 'px_numrecords', 'px_open_fp', 'px_put_record', 'px_retrieve_record', 'px_set_blob_file', 'px_set_parameter', 'px_set_tablename', 'px_set_targetencoding', 'px_set_value', 'px_timestamp2string', 'px_update_record', 'radius_acct_open', 'radius_add_server', 'radius_auth_open', 'radius_close', 'radius_config', 'radius_create_request', 'radius_demangle', 'radius_demangle_mppe_key', 'radius_get_attr', 'radius_put_addr', 'radius_put_attr', 'radius_put_int', 'radius_put_string', 'radius_put_vendor_addr', 'radius_put_vendor_attr', 'radius_put_vendor_int', 'radius_put_vendor_string', 'radius_request_authenticator', 'radius_salt_encrypt_attr', 'radius_send_request', 'radius_server_secret', 'radius_strerror', 'readdir', 'readfile', 'recode_file', 'rename', 'rewind', 'rewinddir', 'rmdir', 'rpm_close', 'rpm_get_tag', 'rpm_open', 'sapi_windows_vt100_support', 'scandir', 'sem_acquire', 'sem_get', 'sem_release', 'sem_remove', 'set_file_buffer', 'shm_attach', 'shm_detach', 'shm_get_var', 'shm_has_var', 'shm_put_var', 'shm_remove', 'shm_remove_var', 'shmop_close', 'shmop_delete', 'shmop_open', 'shmop_read', 'shmop_size', 'shmop_write', 'socket_accept', 'socket_addrinfo_bind', 'socket_addrinfo_connect', 'socket_addrinfo_explain', 'socket_bind', 'socket_clear_error', 'socket_close', 'socket_connect', 'socket_export_stream', 'socket_get_option', 'socket_get_status', 'socket_getopt', 'socket_getpeername', 'socket_getsockname', 'socket_import_stream', 'socket_last_error', 'socket_listen', 'socket_read', 'socket_recv', 'socket_recvfrom', 'socket_recvmsg', 'socket_send', 'socket_sendmsg', 'socket_sendto', 'socket_set_block', 'socket_set_blocking', 'socket_set_nonblock', 'socket_set_option', 'socket_set_timeout', 'socket_shutdown', 'socket_write', 'sqlite_close', 'sqlite_fetch_string', 'sqlite_has_more', 'sqlite_open', 'sqlite_popen', 'sqlsrv_begin_transaction', 'sqlsrv_cancel', 'sqlsrv_client_info', 'sqlsrv_close', 'sqlsrv_commit', 'sqlsrv_connect', 'sqlsrv_execute', 'sqlsrv_fetch', 'sqlsrv_fetch_array', 'sqlsrv_fetch_object', 'sqlsrv_field_metadata', 'sqlsrv_free_stmt', 'sqlsrv_get_field', 'sqlsrv_has_rows', 'sqlsrv_next_result', 'sqlsrv_num_fields', 'sqlsrv_num_rows', 'sqlsrv_prepare', 'sqlsrv_query', 'sqlsrv_rollback', 'sqlsrv_rows_affected', 'sqlsrv_send_stream_data', 'sqlsrv_server_info', 'ssh2_auth_agent', 'ssh2_auth_hostbased_file', 'ssh2_auth_none', 'ssh2_auth_password', 'ssh2_auth_pubkey_file', 'ssh2_disconnect', 'ssh2_exec', 'ssh2_fetch_stream', 'ssh2_fingerprint', 'ssh2_methods_negotiated', 'ssh2_publickey_add', 'ssh2_publickey_init', 'ssh2_publickey_list', 'ssh2_publickey_remove', 'ssh2_scp_recv', 'ssh2_scp_send', 'ssh2_sftp', 'ssh2_sftp_chmod', 'ssh2_sftp_lstat', 'ssh2_sftp_mkdir', 'ssh2_sftp_readlink', 'ssh2_sftp_realpath', 'ssh2_sftp_rename', 'ssh2_sftp_rmdir', 'ssh2_sftp_stat', 'ssh2_sftp_symlink', 'ssh2_sftp_unlink', 'ssh2_shell', 'ssh2_tunnel', 'stomp_connect', 'streamWrapper::stream_cast', 'stream_bucket_append', 'stream_bucket_make_writeable', 'stream_bucket_new', 'stream_bucket_prepend', 'stream_context_create', 'stream_context_get_default', 'stream_context_get_options', 'stream_context_get_params', 'stream_context_set_default', 'stream_context_set_params', 'stream_copy_to_stream', 'stream_encoding', 'stream_filter_append', 'stream_filter_prepend', 'stream_filter_remove', 'stream_get_contents', 'stream_get_line', 'stream_get_meta_data', 'stream_isatty', 'stream_set_blocking', 'stream_set_chunk_size', 'stream_set_read_buffer', 'stream_set_timeout', 'stream_set_write_buffer', 'stream_socket_accept', 'stream_socket_client', 'stream_socket_enable_crypto', 'stream_socket_get_name', 'stream_socket_recvfrom', 'stream_socket_sendto', 'stream_socket_server', 'stream_socket_shutdown', 'stream_supports_lock', 'svn_fs_abort_txn', 'svn_fs_apply_text', 'svn_fs_begin_txn2', 'svn_fs_change_node_prop', 'svn_fs_check_path', 'svn_fs_contents_changed', 'svn_fs_copy', 'svn_fs_delete', 'svn_fs_dir_entries', 'svn_fs_file_contents', 'svn_fs_file_length', 'svn_fs_is_dir', 'svn_fs_is_file', 'svn_fs_make_dir', 'svn_fs_make_file', 'svn_fs_node_created_rev', 'svn_fs_node_prop', 'svn_fs_props_changed', 'svn_fs_revision_prop', 'svn_fs_revision_root', 'svn_fs_txn_root', 'svn_fs_youngest_rev', 'svn_repos_create', 'svn_repos_fs', 'svn_repos_fs_begin_txn_for_commit', 'svn_repos_fs_commit_txn', 'svn_repos_open', 'sybase_affected_rows', 'sybase_close', 'sybase_connect', 'sybase_data_seek', 'sybase_fetch_array', 'sybase_fetch_assoc', 'sybase_fetch_field', 'sybase_fetch_object', 'sybase_fetch_row', 'sybase_field_seek', 'sybase_free_result', 'sybase_num_fields', 'sybase_num_rows', 'sybase_pconnect', 'sybase_query', 'sybase_result', 'sybase_select_db', 'sybase_set_message_handler', 'sybase_unbuffered_query', 'tmpfile', 'udm_add_search_limit', 'udm_alloc_agent', 'udm_alloc_agent_array', 'udm_cat_list', 'udm_cat_path', 'udm_check_charset', 'udm_clear_search_limits', 'udm_crc32', 'udm_errno', 'udm_error', 'udm_find', 'udm_free_agent', 'udm_free_res', 'udm_get_doc_count', 'udm_get_res_field', 'udm_get_res_param', 'udm_hash32', 'udm_load_ispell_data', 'udm_set_agent_param', 'unlink', 'vfprintf', 'w32api_init_dtype', 'wddx_add_vars', 'wddx_packet_end', 'wddx_packet_start', 'xml_get_current_byte_index', 'xml_get_current_column_number', 'xml_get_current_line_number', 'xml_get_error_code', 'xml_parse', 'xml_parse_into_struct', 'xml_parser_create', 'xml_parser_create_ns', 'xml_parser_free', 'xml_parser_get_option', 'xml_parser_set_option', 'xml_set_character_data_handler', 'xml_set_default_handler', 'xml_set_element_handler', 'xml_set_end_namespace_decl_handler', 'xml_set_external_entity_ref_handler', 'xml_set_notation_decl_handler', 'xml_set_object', 'xml_set_processing_instruction_handler', 'xml_set_start_namespace_decl_handler', 'xml_set_unparsed_entity_decl_handler', 'xmlrpc_server_add_introspection_data', 'xmlrpc_server_call_method', 'xmlrpc_server_create', 'xmlrpc_server_destroy', 'xmlrpc_server_register_introspection_callback', 'xmlrpc_server_register_method', 'xmlwriter_end_attribute', 'xmlwriter_end_cdata', 'xmlwriter_end_comment', 'xmlwriter_end_document', 'xmlwriter_end_dtd', 'xmlwriter_end_dtd_attlist', 'xmlwriter_end_dtd_element', 'xmlwriter_end_dtd_entity', 'xmlwriter_end_element', 'xmlwriter_end_pi', 'xmlwriter_flush', 'xmlwriter_full_end_element', 'xmlwriter_open_memory', 'xmlwriter_open_uri', 'xmlwriter_output_memory', 'xmlwriter_set_indent', 'xmlwriter_set_indent_string', 'xmlwriter_start_attribute', 'xmlwriter_start_attribute_ns', 'xmlwriter_start_cdata', 'xmlwriter_start_comment', 'xmlwriter_start_document', 'xmlwriter_start_dtd', 'xmlwriter_start_dtd_attlist', 'xmlwriter_start_dtd_element', 'xmlwriter_start_dtd_entity', 'xmlwriter_start_element', 'xmlwriter_start_element_ns', 'xmlwriter_start_pi', 'xmlwriter_text', 'xmlwriter_write_attribute', 'xmlwriter_write_attribute_ns', 'xmlwriter_write_cdata', 'xmlwriter_write_comment', 'xmlwriter_write_dtd', 'xmlwriter_write_dtd_attlist', 'xmlwriter_write_dtd_element', 'xmlwriter_write_dtd_entity', 'xmlwriter_write_element', 'xmlwriter_write_element_ns', 'xmlwriter_write_pi', 'xmlwriter_write_raw', 'xslt_create', 'yaz_addinfo', 'yaz_ccl_conf', 'yaz_ccl_parse', 'yaz_close', 'yaz_database', 'yaz_element', 'yaz_errno', 'yaz_error', 'yaz_es', 'yaz_es_result', 'yaz_get_option', 'yaz_hits', 'yaz_itemorder', 'yaz_present', 'yaz_range', 'yaz_record', 'yaz_scan', 'yaz_scan_result', 'yaz_schema', 'yaz_search', 'yaz_sort', 'yaz_syntax', 'zip_close', 'zip_entry_close', 'zip_entry_compressedsize', 'zip_entry_compressionmethod', 'zip_entry_filesize', 'zip_entry_name', 'zip_entry_open', 'zip_entry_read', 'zip_open', 'zip_read'];
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function assert;
use function class_exists;
use function count;
use function explode;
use function function_exists;
use function is_array;
use function is_object;
use function is_string;
use function strpos;
use Closure;
use ReflectionClass;
use ReflectionException;
use ReflectionObject;
final class CallableType extends \PHPUnit\SebastianBergmann\Type\Type
{
    /**
     * @var bool
     */
    private $allowsNull;
    public function __construct(bool $nullable)
    {
        $this->allowsNull = $nullable;
    }
    /**
     * @throws RuntimeException
     */
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        if ($this->allowsNull && $other instanceof \PHPUnit\SebastianBergmann\Type\NullType) {
            return \true;
        }
        if ($other instanceof self) {
            return \true;
        }
        if ($other instanceof \PHPUnit\SebastianBergmann\Type\ObjectType) {
            if ($this->isClosure($other)) {
                return \true;
            }
            if ($this->hasInvokeMethod($other)) {
                return \true;
            }
        }
        if ($other instanceof \PHPUnit\SebastianBergmann\Type\SimpleType) {
            if ($this->isFunction($other)) {
                return \true;
            }
            if ($this->isClassCallback($other)) {
                return \true;
            }
            if ($this->isObjectCallback($other)) {
                return \true;
            }
        }
        return \false;
    }
    public function name() : string
    {
        return 'callable';
    }
    public function allowsNull() : bool
    {
        return $this->allowsNull;
    }
    private function isClosure(\PHPUnit\SebastianBergmann\Type\ObjectType $type) : bool
    {
        return !$type->className()->isNamespaced() && $type->className()->simpleName() === \Closure::class;
    }
    /**
     * @throws RuntimeException
     */
    private function hasInvokeMethod(\PHPUnit\SebastianBergmann\Type\ObjectType $type) : bool
    {
        $className = $type->className()->qualifiedName();
        \assert(\class_exists($className));
        try {
            $class = new \ReflectionClass($className);
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\Type\RuntimeException($e->getMessage(), (int) $e->getCode(), $e);
            // @codeCoverageIgnoreEnd
        }
        if ($class->hasMethod('__invoke')) {
            return \true;
        }
        return \false;
    }
    private function isFunction(\PHPUnit\SebastianBergmann\Type\SimpleType $type) : bool
    {
        if (!\is_string($type->value())) {
            return \false;
        }
        return \function_exists($type->value());
    }
    private function isObjectCallback(\PHPUnit\SebastianBergmann\Type\SimpleType $type) : bool
    {
        if (!\is_array($type->value())) {
            return \false;
        }
        if (\count($type->value()) !== 2) {
            return \false;
        }
        if (!\is_object($type->value()[0]) || !\is_string($type->value()[1])) {
            return \false;
        }
        [$object, $methodName] = $type->value();
        return (new \ReflectionObject($object))->hasMethod($methodName);
    }
    private function isClassCallback(\PHPUnit\SebastianBergmann\Type\SimpleType $type) : bool
    {
        if (!\is_string($type->value()) && !\is_array($type->value())) {
            return \false;
        }
        if (\is_string($type->value())) {
            if (\strpos($type->value(), '::') === \false) {
                return \false;
            }
            [$className, $methodName] = \explode('::', $type->value());
        }
        if (\is_array($type->value())) {
            if (\count($type->value()) !== 2) {
                return \false;
            }
            if (!\is_string($type->value()[0]) || !\is_string($type->value()[1])) {
                return \false;
            }
            [$className, $methodName] = $type->value();
        }
        \assert(isset($className) && \is_string($className) && \class_exists($className));
        \assert(isset($methodName) && \is_string($methodName));
        try {
            $class = new \ReflectionClass($className);
            if ($class->hasMethod($methodName)) {
                $method = $class->getMethod($methodName);
                return $method->isPublic() && $method->isStatic();
            }
            // @codeCoverageIgnoreStart
        } catch (\ReflectionException $e) {
            throw new \PHPUnit\SebastianBergmann\Type\RuntimeException($e->getMessage(), (int) $e->getCode(), $e);
            // @codeCoverageIgnoreEnd
        }
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

final class GenericObjectType extends \PHPUnit\SebastianBergmann\Type\Type
{
    /**
     * @var bool
     */
    private $allowsNull;
    public function __construct(bool $nullable)
    {
        $this->allowsNull = $nullable;
    }
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        if ($this->allowsNull && $other instanceof \PHPUnit\SebastianBergmann\Type\NullType) {
            return \true;
        }
        if (!$other instanceof \PHPUnit\SebastianBergmann\Type\ObjectType) {
            return \false;
        }
        return \true;
    }
    public function name() : string
    {
        return 'object';
    }
    public function allowsNull() : bool
    {
        return $this->allowsNull;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function assert;
use function class_exists;
use function is_iterable;
use ReflectionClass;
use ReflectionException;
final class IterableType extends \PHPUnit\SebastianBergmann\Type\Type
{
    /**
     * @var bool
     */
    private $allowsNull;
    public function __construct(bool $nullable)
    {
        $this->allowsNull = $nullable;
    }
    /**
     * @throws RuntimeException
     */
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        if ($this->allowsNull && $other instanceof \PHPUnit\SebastianBergmann\Type\NullType) {
            return \true;
        }
        if ($other instanceof self) {
            return \true;
        }
        if ($other instanceof \PHPUnit\SebastianBergmann\Type\SimpleType) {
            return \is_iterable($other->value());
        }
        if ($other instanceof \PHPUnit\SebastianBergmann\Type\ObjectType) {
            $className = $other->className()->qualifiedName();
            \assert(\class_exists($className));
            try {
                return (new \ReflectionClass($className))->isIterable();
                // @codeCoverageIgnoreStart
            } catch (\ReflectionException $e) {
                throw new \PHPUnit\SebastianBergmann\Type\RuntimeException($e->getMessage(), (int) $e->getCode(), $e);
                // @codeCoverageIgnoreEnd
            }
        }
        return \false;
    }
    public function name() : string
    {
        return 'iterable';
    }
    public function allowsNull() : bool
    {
        return $this->allowsNull;
    }
}
sebastian/type

Copyright (c) 2019-2020, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

final class MixedType extends \PHPUnit\SebastianBergmann\Type\Type
{
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        return !$other instanceof \PHPUnit\SebastianBergmann\Type\VoidType;
    }
    public function asString() : string
    {
        return 'mixed';
    }
    public function name() : string
    {
        return 'mixed';
    }
    public function allowsNull() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

final class NullType extends \PHPUnit\SebastianBergmann\Type\Type
{
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        return !$other instanceof \PHPUnit\SebastianBergmann\Type\VoidType;
    }
    public function name() : string
    {
        return 'null';
    }
    public function asString() : string
    {
        return 'null';
    }
    /**
     * @deprecated
     *
     * @codeCoverageIgnore
     */
    public function getReturnTypeDeclaration() : string
    {
        return '';
    }
    public function allowsNull() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function is_subclass_of;
use function strcasecmp;
final class ObjectType extends \PHPUnit\SebastianBergmann\Type\Type
{
    /**
     * @var TypeName
     */
    private $className;
    /**
     * @var bool
     */
    private $allowsNull;
    public function __construct(\PHPUnit\SebastianBergmann\Type\TypeName $className, bool $allowsNull)
    {
        $this->className = $className;
        $this->allowsNull = $allowsNull;
    }
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        if ($this->allowsNull && $other instanceof \PHPUnit\SebastianBergmann\Type\NullType) {
            return \true;
        }
        if ($other instanceof self) {
            if (0 === \strcasecmp($this->className->qualifiedName(), $other->className->qualifiedName())) {
                return \true;
            }
            if (\is_subclass_of($other->className->qualifiedName(), $this->className->qualifiedName(), \true)) {
                return \true;
            }
        }
        return \false;
    }
    public function name() : string
    {
        return $this->className->qualifiedName();
    }
    public function allowsNull() : bool
    {
        return $this->allowsNull;
    }
    public function className() : \PHPUnit\SebastianBergmann\Type\TypeName
    {
        return $this->className;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function assert;
use function sprintf;
use ReflectionMethod;
use ReflectionNamedType;
use ReflectionUnionType;
final class ReflectionMapper
{
    public function fromMethodReturnType(\ReflectionMethod $method) : \PHPUnit\SebastianBergmann\Type\Type
    {
        if (!$method->hasReturnType()) {
            return new \PHPUnit\SebastianBergmann\Type\UnknownType();
        }
        $returnType = $method->getReturnType();
        \assert($returnType instanceof \ReflectionNamedType || $returnType instanceof \ReflectionUnionType);
        if ($returnType instanceof \ReflectionNamedType) {
            if ($returnType->getName() === 'self') {
                return \PHPUnit\SebastianBergmann\Type\ObjectType::fromName($method->getDeclaringClass()->getName(), $returnType->allowsNull());
            }
            if ($returnType->getName() === 'static') {
                return new \PHPUnit\SebastianBergmann\Type\StaticType(\PHPUnit\SebastianBergmann\Type\TypeName::fromReflection($method->getDeclaringClass()), $returnType->allowsNull());
            }
            if ($returnType->getName() === 'mixed') {
                return new \PHPUnit\SebastianBergmann\Type\MixedType();
            }
            if ($returnType->getName() === 'parent') {
                $parentClass = $method->getDeclaringClass()->getParentClass();
                // @codeCoverageIgnoreStart
                if ($parentClass === \false) {
                    throw new \PHPUnit\SebastianBergmann\Type\RuntimeException(\sprintf('%s::%s() has a "parent" return type declaration but %s does not have a parent class', $method->getDeclaringClass()->getName(), $method->getName(), $method->getDeclaringClass()->getName()));
                }
                // @codeCoverageIgnoreEnd
                return \PHPUnit\SebastianBergmann\Type\ObjectType::fromName($parentClass->getName(), $returnType->allowsNull());
            }
            return \PHPUnit\SebastianBergmann\Type\Type::fromName($returnType->getName(), $returnType->allowsNull());
        }
        \assert($returnType instanceof \ReflectionUnionType);
        $types = [];
        foreach ($returnType->getTypes() as $type) {
            \assert($type instanceof \ReflectionNamedType);
            if ($type->getName() === 'self') {
                $types[] = \PHPUnit\SebastianBergmann\Type\ObjectType::fromName($method->getDeclaringClass()->getName(), \false);
            } else {
                $types[] = \PHPUnit\SebastianBergmann\Type\Type::fromName($type->getName(), \false);
            }
        }
        return new \PHPUnit\SebastianBergmann\Type\UnionType(...$types);
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function strtolower;
final class SimpleType extends \PHPUnit\SebastianBergmann\Type\Type
{
    /**
     * @var string
     */
    private $name;
    /**
     * @var bool
     */
    private $allowsNull;
    /**
     * @var mixed
     */
    private $value;
    public function __construct(string $name, bool $nullable, $value = null)
    {
        $this->name = $this->normalize($name);
        $this->allowsNull = $nullable;
        $this->value = $value;
    }
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        if ($this->allowsNull && $other instanceof \PHPUnit\SebastianBergmann\Type\NullType) {
            return \true;
        }
        if ($other instanceof self) {
            return $this->name === $other->name;
        }
        return \false;
    }
    public function name() : string
    {
        return $this->name;
    }
    public function allowsNull() : bool
    {
        return $this->allowsNull;
    }
    public function value()
    {
        return $this->value;
    }
    private function normalize(string $name) : string
    {
        $name = \strtolower($name);
        switch ($name) {
            case 'boolean':
                return 'bool';
            case 'real':
            case 'double':
                return 'float';
            case 'integer':
                return 'int';
            case '[]':
                return 'array';
            default:
                return $name;
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

final class StaticType extends \PHPUnit\SebastianBergmann\Type\Type
{
    /**
     * @var TypeName
     */
    private $className;
    /**
     * @var bool
     */
    private $allowsNull;
    public function __construct(\PHPUnit\SebastianBergmann\Type\TypeName $className, bool $allowsNull)
    {
        $this->className = $className;
        $this->allowsNull = $allowsNull;
    }
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        if ($this->allowsNull && $other instanceof \PHPUnit\SebastianBergmann\Type\NullType) {
            return \true;
        }
        if (!$other instanceof \PHPUnit\SebastianBergmann\Type\ObjectType) {
            return \false;
        }
        if (0 === \strcasecmp($this->className->qualifiedName(), $other->className()->qualifiedName())) {
            return \true;
        }
        if (\is_subclass_of($other->className()->qualifiedName(), $this->className->qualifiedName(), \true)) {
            return \true;
        }
        return \false;
    }
    public function name() : string
    {
        return 'static';
    }
    public function allowsNull() : bool
    {
        return $this->allowsNull;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function get_class;
use function gettype;
use function strtolower;
abstract class Type
{
    public static function fromValue($value, bool $allowsNull) : self
    {
        $typeName = \gettype($value);
        if ($typeName === 'object') {
            return new \PHPUnit\SebastianBergmann\Type\ObjectType(\PHPUnit\SebastianBergmann\Type\TypeName::fromQualifiedName(\get_class($value)), $allowsNull);
        }
        $type = self::fromName($typeName, $allowsNull);
        if ($type instanceof \PHPUnit\SebastianBergmann\Type\SimpleType) {
            $type = new \PHPUnit\SebastianBergmann\Type\SimpleType($typeName, $allowsNull, $value);
        }
        return $type;
    }
    public static function fromName(string $typeName, bool $allowsNull) : self
    {
        switch (\strtolower($typeName)) {
            case 'callable':
                return new \PHPUnit\SebastianBergmann\Type\CallableType($allowsNull);
            case 'iterable':
                return new \PHPUnit\SebastianBergmann\Type\IterableType($allowsNull);
            case 'null':
                return new \PHPUnit\SebastianBergmann\Type\NullType();
            case 'object':
                return new \PHPUnit\SebastianBergmann\Type\GenericObjectType($allowsNull);
            case 'unknown type':
                return new \PHPUnit\SebastianBergmann\Type\UnknownType();
            case 'void':
                return new \PHPUnit\SebastianBergmann\Type\VoidType();
            case 'array':
            case 'bool':
            case 'boolean':
            case 'double':
            case 'float':
            case 'int':
            case 'integer':
            case 'real':
            case 'resource':
            case 'resource (closed)':
            case 'string':
                return new \PHPUnit\SebastianBergmann\Type\SimpleType($typeName, $allowsNull);
            default:
                return new \PHPUnit\SebastianBergmann\Type\ObjectType(\PHPUnit\SebastianBergmann\Type\TypeName::fromQualifiedName($typeName), $allowsNull);
        }
    }
    public function asString() : string
    {
        return ($this->allowsNull() ? '?' : '') . $this->name();
    }
    /**
     * @deprecated
     *
     * @codeCoverageIgnore
     */
    public function getReturnTypeDeclaration() : string
    {
        return ': ' . $this->asString();
    }
    public abstract function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool;
    public abstract function name() : string;
    public abstract function allowsNull() : bool;
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function array_pop;
use function explode;
use function implode;
use function substr;
use ReflectionClass;
final class TypeName
{
    /**
     * @var ?string
     */
    private $namespaceName;
    /**
     * @var string
     */
    private $simpleName;
    public static function fromQualifiedName(string $fullClassName) : self
    {
        if ($fullClassName[0] === '\\') {
            $fullClassName = \substr($fullClassName, 1);
        }
        $classNameParts = \explode('\\', $fullClassName);
        $simpleName = \array_pop($classNameParts);
        $namespaceName = \implode('\\', $classNameParts);
        return new self($namespaceName, $simpleName);
    }
    public static function fromReflection(\ReflectionClass $type) : self
    {
        return new self($type->getNamespaceName(), $type->getShortName());
    }
    public function __construct(?string $namespaceName, string $simpleName)
    {
        if ($namespaceName === '') {
            $namespaceName = null;
        }
        $this->namespaceName = $namespaceName;
        $this->simpleName = $simpleName;
    }
    public function namespaceName() : ?string
    {
        return $this->namespaceName;
    }
    public function simpleName() : string
    {
        return $this->simpleName;
    }
    public function qualifiedName() : string
    {
        return $this->namespaceName === null ? $this->simpleName : $this->namespaceName . '\\' . $this->simpleName;
    }
    /**
     * @deprecated Use namespaceName() instead
     *
     * @codeCoverageIgnore
     */
    public function getNamespaceName() : ?string
    {
        return $this->namespaceName();
    }
    /**
     * @deprecated Use simpleName() instead
     *
     * @codeCoverageIgnore
     */
    public function getSimpleName() : string
    {
        return $this->simpleName();
    }
    /**
     * @deprecated Use qualifiedName() instead
     *
     * @codeCoverageIgnore
     */
    public function getQualifiedName() : string
    {
        return $this->qualifiedName();
    }
    public function isNamespaced() : bool
    {
        return $this->namespaceName !== null;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use function count;
use function implode;
use function sort;
final class UnionType extends \PHPUnit\SebastianBergmann\Type\Type
{
    /**
     * @psalm-var list<Type>
     */
    private $types;
    /**
     * @throws RuntimeException
     */
    public function __construct(\PHPUnit\SebastianBergmann\Type\Type ...$types)
    {
        $this->ensureMinimumOfTwoTypes(...$types);
        $this->ensureOnlyValidTypes(...$types);
        $this->types = $types;
    }
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        foreach ($this->types as $type) {
            if ($type->isAssignable($other)) {
                return \true;
            }
        }
        return \false;
    }
    public function asString() : string
    {
        return $this->name();
    }
    /**
     * @deprecated
     *
     * @codeCoverageIgnore
     */
    public function getReturnTypeDeclaration() : string
    {
        return ': ' . $this->name();
    }
    public function name() : string
    {
        $types = [];
        foreach ($this->types as $type) {
            $types[] = $type->name();
        }
        \sort($types);
        return \implode('|', $types);
    }
    public function allowsNull() : bool
    {
        foreach ($this->types as $type) {
            if ($type instanceof \PHPUnit\SebastianBergmann\Type\NullType) {
                return \true;
            }
        }
        return \false;
    }
    /**
     * @throws RuntimeException
     */
    private function ensureMinimumOfTwoTypes(\PHPUnit\SebastianBergmann\Type\Type ...$types) : void
    {
        if (\count($types) < 2) {
            throw new \PHPUnit\SebastianBergmann\Type\RuntimeException('A union type must be composed of at least two types');
        }
    }
    /**
     * @throws RuntimeException
     */
    private function ensureOnlyValidTypes(\PHPUnit\SebastianBergmann\Type\Type ...$types) : void
    {
        foreach ($types as $type) {
            if ($type instanceof \PHPUnit\SebastianBergmann\Type\UnknownType) {
                throw new \PHPUnit\SebastianBergmann\Type\RuntimeException('A union type must not be composed of an unknown type');
            }
            if ($type instanceof \PHPUnit\SebastianBergmann\Type\VoidType) {
                throw new \PHPUnit\SebastianBergmann\Type\RuntimeException('A union type must not be composed of a void type');
            }
        }
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

final class UnknownType extends \PHPUnit\SebastianBergmann\Type\Type
{
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        return \true;
    }
    public function name() : string
    {
        return 'unknown type';
    }
    public function asString() : string
    {
        return '';
    }
    /**
     * @deprecated
     *
     * @codeCoverageIgnore
     */
    public function getReturnTypeDeclaration() : string
    {
        return '';
    }
    public function allowsNull() : bool
    {
        return \true;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

final class VoidType extends \PHPUnit\SebastianBergmann\Type\Type
{
    public function isAssignable(\PHPUnit\SebastianBergmann\Type\Type $other) : bool
    {
        return $other instanceof self;
    }
    public function name() : string
    {
        return 'void';
    }
    public function allowsNull() : bool
    {
        return \false;
    }
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

use Throwable;
interface Exception extends \Throwable
{
}
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/type.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann\Type;

final class RuntimeException extends \RuntimeException implements \PHPUnit\SebastianBergmann\Type\Exception
{
}
Version

Copyright (c) 2013-2021, Sebastian Bergmann <sebastian@phpunit.de>.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

 * Neither the name of Sebastian Bergmann nor the names of his
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
/*
 * This file is part of sebastian/version.
 *
 * (c) Sebastian Bergmann <sebastian@phpunit.de>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
namespace PHPUnit\SebastianBergmann;

use function end;
use function explode;
use function fclose;
use function is_dir;
use function is_resource;
use function proc_close;
use function proc_open;
use function stream_get_contents;
use function substr_count;
use function trim;
final class Version
{
    private string $path;
    private string $release;
    private ?string $version = null;
    public function __construct(string $release, string $path)
    {
        $this->release = $release;
        $this->path = $path;
    }
    public function getVersion() : string
    {
        if ($this->version === null) {
            if (\substr_count($this->release, '.') + 1 === 3) {
                $this->version = $this->release;
            } else {
                $this->version = $this->release . '-dev';
            }
            $git = $this->getGitInformation($this->path);
            if ($git) {
                if (\substr_count($this->release, '.') + 1 === 3) {
                    $this->version = $git;
                } else {
                    $git = \explode('-', $git);
                    $this->version = $this->release . '-' . \end($git);
                }
            }
        }
        return $this->version;
    }
    /**
     * @return bool|string
     */
    private function getGitInformation(string $path)
    {
        if (!\is_dir($path . \DIRECTORY_SEPARATOR . '.git')) {
            return \false;
        }
        $process = \proc_open('git describe --tags', [1 => ['pipe', 'w'], 2 => ['pipe', 'w']], $pipes, $path);
        if (!\is_resource($process)) {
            return \false;
        }
        $result = \trim(\stream_get_contents($pipes[1]));
        \fclose($pipes[1]);
        \fclose($pipes[2]);
        $returnCode = \proc_close($process);
        if ($returnCode !== 0) {
            return \false;
        }
        return $result;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

class Exception extends \Exception
{
}
Tokenizer

Copyright (c) 2017 Arne Blankerts <arne@blankerts.de> and contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of Arne Blankerts nor the names of contributors
  may be used to endorse or promote products derived from this software
  without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  * NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

class NamespaceUri
{
    /** @var string */
    private $value;
    public function __construct(string $value)
    {
        $this->ensureValidUri($value);
        $this->value = $value;
    }
    public function asString() : string
    {
        return $this->value;
    }
    private function ensureValidUri($value) : void
    {
        if (\strpos($value, ':') === \false) {
            throw new \PHPUnit\TheSeer\Tokenizer\NamespaceUriException(\sprintf("Namespace URI '%s' must contain at least one colon", $value));
        }
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

class NamespaceUriException extends \PHPUnit\TheSeer\Tokenizer\Exception
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

class Token
{
    /** @var int */
    private $line;
    /** @var string */
    private $name;
    /** @var string */
    private $value;
    /**
     * Token constructor.
     */
    public function __construct(int $line, string $name, string $value)
    {
        $this->line = $line;
        $this->name = $name;
        $this->value = $value;
    }
    public function getLine() : int
    {
        return $this->line;
    }
    public function getName() : string
    {
        return $this->name;
    }
    public function getValue() : string
    {
        return $this->value;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

class TokenCollection implements \ArrayAccess, \Iterator, \Countable
{
    /** @var Token[] */
    private $tokens = [];
    /** @var int */
    private $pos;
    public function addToken(\PHPUnit\TheSeer\Tokenizer\Token $token) : void
    {
        $this->tokens[] = $token;
    }
    public function current() : \PHPUnit\TheSeer\Tokenizer\Token
    {
        return \current($this->tokens);
    }
    public function key() : int
    {
        return \key($this->tokens);
    }
    public function next() : void
    {
        \next($this->tokens);
        $this->pos++;
    }
    public function valid() : bool
    {
        return $this->count() > $this->pos;
    }
    public function rewind() : void
    {
        \reset($this->tokens);
        $this->pos = 0;
    }
    public function count() : int
    {
        return \count($this->tokens);
    }
    public function offsetExists($offset) : bool
    {
        return isset($this->tokens[$offset]);
    }
    /**
     * @throws TokenCollectionException
     */
    public function offsetGet($offset) : \PHPUnit\TheSeer\Tokenizer\Token
    {
        if (!$this->offsetExists($offset)) {
            throw new \PHPUnit\TheSeer\Tokenizer\TokenCollectionException(\sprintf('No Token at offest %s', $offset));
        }
        return $this->tokens[$offset];
    }
    /**
     * @param Token $value
     *
     * @throws TokenCollectionException
     */
    public function offsetSet($offset, $value) : void
    {
        if (!\is_int($offset)) {
            $type = \gettype($offset);
            throw new \PHPUnit\TheSeer\Tokenizer\TokenCollectionException(\sprintf('Offset must be of type integer, %s given', $type === 'object' ? \get_class($value) : $type));
        }
        if (!$value instanceof \PHPUnit\TheSeer\Tokenizer\Token) {
            $type = \gettype($value);
            throw new \PHPUnit\TheSeer\Tokenizer\TokenCollectionException(\sprintf('Value must be of type %s, %s given', \PHPUnit\TheSeer\Tokenizer\Token::class, $type === 'object' ? \get_class($value) : $type));
        }
        $this->tokens[$offset] = $value;
    }
    public function offsetUnset($offset) : void
    {
        unset($this->tokens[$offset]);
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

class TokenCollectionException extends \PHPUnit\TheSeer\Tokenizer\Exception
{
}
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

class Tokenizer
{
    /**
     * Token Map for "non-tokens"
     *
     * @var array
     */
    private $map = ['(' => 'T_OPEN_BRACKET', ')' => 'T_CLOSE_BRACKET', '[' => 'T_OPEN_SQUARE', ']' => 'T_CLOSE_SQUARE', '{' => 'T_OPEN_CURLY', '}' => 'T_CLOSE_CURLY', ';' => 'T_SEMICOLON', '.' => 'T_DOT', ',' => 'T_COMMA', '=' => 'T_EQUAL', '<' => 'T_LT', '>' => 'T_GT', '+' => 'T_PLUS', '-' => 'T_MINUS', '*' => 'T_MULT', '/' => 'T_DIV', '?' => 'T_QUESTION_MARK', '!' => 'T_EXCLAMATION_MARK', ':' => 'T_COLON', '"' => 'T_DOUBLE_QUOTES', '@' => 'T_AT', '&' => 'T_AMPERSAND', '%' => 'T_PERCENT', '|' => 'T_PIPE', '$' => 'T_DOLLAR', '^' => 'T_CARET', '~' => 'T_TILDE', '`' => 'T_BACKTICK'];
    public function parse(string $source) : \PHPUnit\TheSeer\Tokenizer\TokenCollection
    {
        $result = new \PHPUnit\TheSeer\Tokenizer\TokenCollection();
        if ($source === '') {
            return $result;
        }
        $tokens = \token_get_all($source);
        $lastToken = new \PHPUnit\TheSeer\Tokenizer\Token($tokens[0][2], 'Placeholder', '');
        foreach ($tokens as $pos => $tok) {
            if (\is_string($tok)) {
                $token = new \PHPUnit\TheSeer\Tokenizer\Token($lastToken->getLine(), $this->map[$tok], $tok);
                $result->addToken($token);
                $lastToken = $token;
                continue;
            }
            $line = $tok[2];
            $values = \preg_split('/\\R+/Uu', $tok[1]);
            foreach ($values as $v) {
                $token = new \PHPUnit\TheSeer\Tokenizer\Token($line, \token_name($tok[0]), $v);
                $lastToken = $token;
                $line++;
                if ($v === '') {
                    continue;
                }
                $result->addToken($token);
            }
        }
        return $this->fillBlanks($result, $lastToken->getLine());
    }
    private function fillBlanks(\PHPUnit\TheSeer\Tokenizer\TokenCollection $tokens, int $maxLine) : \PHPUnit\TheSeer\Tokenizer\TokenCollection
    {
        /** @var Token $prev */
        $prev = null;
        $final = new \PHPUnit\TheSeer\Tokenizer\TokenCollection();
        foreach ($tokens as $token) {
            if ($prev === null) {
                $final->addToken($token);
                $prev = $token;
                continue;
            }
            $gap = $token->getLine() - $prev->getLine();
            while ($gap > 1) {
                $linebreak = new \PHPUnit\TheSeer\Tokenizer\Token($prev->getLine() + 1, 'T_WHITESPACE', '');
                $final->addToken($linebreak);
                $prev = $linebreak;
                $gap--;
            }
            $final->addToken($token);
            $prev = $token;
        }
        $gap = $maxLine - $prev->getLine();
        while ($gap > 0) {
            $linebreak = new \PHPUnit\TheSeer\Tokenizer\Token($prev->getLine() + 1, 'T_WHITESPACE', '');
            $final->addToken($linebreak);
            $prev = $linebreak;
            $gap--;
        }
        return $final;
    }
}
<?php

declare (strict_types=1);
namespace PHPUnit\TheSeer\Tokenizer;

use DOMDocument;
class XMLSerializer
{
    /** @var \XMLWriter */
    private $writer;
    /** @var Token */
    private $previousToken;
    /** @var NamespaceUri */
    private $xmlns;
    /**
     * XMLSerializer constructor.
     *
     * @param NamespaceUri $xmlns
     */
    public function __construct(\PHPUnit\TheSeer\Tokenizer\NamespaceUri $xmlns = null)
    {
        if ($xmlns === null) {
            $xmlns = new \PHPUnit\TheSeer\Tokenizer\NamespaceUri('https://github.com/theseer/tokenizer');
        }
        $this->xmlns = $xmlns;
    }
    public function toDom(\PHPUnit\TheSeer\Tokenizer\TokenCollection $tokens) : \DOMDocument
    {
        $dom = new \DOMDocument();
        $dom->preserveWhiteSpace = \false;
        $dom->loadXML($this->toXML($tokens));
        return $dom;
    }
    public function toXML(\PHPUnit\TheSeer\Tokenizer\TokenCollection $tokens) : string
    {
        $this->writer = new \XMLWriter();
        $this->writer->openMemory();
        $this->writer->setIndent(\true);
        $this->writer->startDocument();
        $this->writer->startElement('source');
        $this->writer->writeAttribute('xmlns', $this->xmlns->asString());
        if (\count($tokens) > 0) {
            $this->writer->startElement('line');
            $this->writer->writeAttribute('no', '1');
            $this->previousToken = $tokens[0];
            foreach ($tokens as $token) {
                $this->addToken($token);
            }
        }
        $this->writer->endElement();
        $this->writer->endElement();
        $this->writer->endDocument();
        return $this->writer->outputMemory();
    }
    private function addToken(\PHPUnit\TheSeer\Tokenizer\Token $token) : void
    {
        if ($this->previousToken->getLine() < $token->getLine()) {
            $this->writer->endElement();
            $this->writer->startElement('line');
            $this->writer->writeAttribute('no', (string) $token->getLine());
            $this->previousToken = $token;
        }
        if ($token->getValue() !== '') {
            $this->writer->startElement('token');
            $this->writer->writeAttribute('name', $token->getName());
            $this->writer->writeRaw(\htmlspecialchars($token->getValue(), \ENT_NOQUOTES | \ENT_DISALLOWED | \ENT_XML1));
            $this->writer->endElement();
        }
    }
}
<?php
namespace PHPSTORM_META {

    override(
        \PHPUnit\Framework\TestCase::createMock(0),
        map([
            '@&\PHPUnit\Framework\MockObject\MockObject',
        ])
    );

    override(
        \PHPUnit\Framework\TestCase::createStub(0),
        map([
            '@&\PHPUnit\Framework\MockObject\Stub',
        ])
    );

    override(
        \PHPUnit\Framework\TestCase::createConfiguredMock(0),
        map([
            '@&\PHPUnit\Framework\MockObject\MockObject',
        ])
    );

    override(
        \PHPUnit\Framework\TestCase::createPartialMock(0),
        map([
            '@&\PHPUnit\Framework\MockObject\MockObject',
        ])
    );

    override(
        \PHPUnit\Framework\TestCase::createTestProxy(0),
        map([
            '@&\PHPUnit\Framework\MockObject\MockObject',
        ])
    );

    override(
        \PHPUnit\Framework\TestCase::getMockForAbstractClass(0),
        map([
            '@&\PHPUnit\Framework\MockObject\MockObject',
        ])
    );
}
?)DyE0^2sh7G   GBMB